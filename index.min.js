/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/views/HomeView.tag.html":
/*!*************************************!*\
  !*** ./src/views/HomeView.tag.html ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _models_HomeModel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/HomeModel.js */ "./src/models/HomeModel.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  'css': null,
  'exports': {
    isRunning: false,
    errorMessage: null,
    homeModel: new _models_HomeModel_js__WEBPACK_IMPORTED_MODULE_0__["default"](),
    onMounted: function onMounted() {
      if (!this.homeModel.isSupported) {
        this.errorMessage = "Speech recognition is not supported on this browser. Use Google Chrome 33+ or Edge 79+ please.";
        this.update();
      }
    },
    onToggleStartStopButton: function onToggleStartStopButton() {
      var _this = this;
      this.errorMessage = null;
      if (this.isRunning) {
        this.homeModel.stop();
        this.isRunning = false;
        this.update();
      } else {
        this.homeModel.start().then(function () {
          _this.isRunning = true;
          _this.update();
        })["catch"](function (err) {
          console.log(err);
          _this.errorMessage = err.error;
          _this.update();
        });
      }
    }
  },
  'template': function template(_template, expressionTypes, bindingTypes, getComponent) {
    return _template('<div class="container"><div class="jumbotron"><h1>OBS Transcript</h1><p>\n        Real-time subtitle generation by speech recognition for <a href="https://obsproject.com/">OBS Studio</a>.\n        <a href="https://github.com/sponsors/akabe"><img src="https://img.shields.io/static/v1?label=Sponsor&message=%E2%9D%A4&logo=GitHub&color=ff69b4&link=https://github.com/sponsors/srz-zumix" alt="Sponsor"/></a></p><section><div class="row"><div class="col-md-4"><div class="input-group"><span class="input-group-addon">Language</span><input expr0="expr0" type="text" class="form-control" placeholder="Language"/></div></div><div class="col-md-2"><input expr1="expr1" type="button"/></div></div></section></div><div class="row"><div class="col-md-12"><div expr2="expr2" class="alert alert-danger" role="alert"></div></div></div><section><h2>Setup</h2><section><h3>1. Enable OBS WebSocket</h3><div class="row"><div class="col-md-7"><p>\n              Install <a href="https://github.com/Palakis/obs-websocket/releases">obs-websocket</a> 4.8 or above, and\n              open "WebSocket Server Settings" dialog under "Tools" menu in OBS.\n              After activation of OBS WebSocket Server, copy the WebSocket settings into the following text boxes.\n            </p><p><label>Address</label><div class="input-group"><span class="input-group-addon">ws://</span><input expr3="expr3" type="text" class="form-control" placeholder="Host:Port"/></div></p><p><label>Password</label><input expr4="expr4" type="password" class="form-control" placeholder="Password"/></p></div><div class="col-md-5 right-image"><image src="images/obs-websocket-connection.png" width="350"></image></div></div></section><section><h3>2. Create a text source</h3><div class="row"><div class="col-md-7"><p>\n              Add "Text (GDI+)" on Windows, or "Text (FreeType 2)" on Mac OS X or Linux to "Sources" in OBS.\n            </p><p><div class="row"><div class="col-md-6"><label>Source name</label><input expr5="expr5" type="text" class="form-control" placeholder="Text source"/></div><div class="col-md-6"><label>Source type</label><select expr6="expr6" class="form-control"><option expr7="expr7" value="0">Text (GDI+) [Windows]</option><option expr8="expr8" value="1">Text (FreeType 2) [Mac/Linux]</option></select></div></div></p><p><div class="row"><div class="col-md-6"><label>The number of lines</label><input expr9="expr9" type="text" class="form-control"/></div><div class="col-md-6"><label>The number of characters per line</label><input expr10="expr10" type="text" class="form-control"/></div></div></p></div><div class="col-md-5 right-image"><image src="images/obs-create-text-source.png" width="350"></image></div></div></section></section><section><h2>Sponsorship</h2><p>\n        If you like this project, please support by becoming a sponsor via <a href="https://github.com/sponsors/akabe">GitHub Sponsors</a>.\n        I hope to make OBS Transcript much better.\n        Could you fund me for improvement of the project?\n        I will publish your (company) logo and a link to your homepage in the <a href="https://akabe.github.io/obs-transcript">project page</a> and <a href="https://github.com/akabe/obs-transcript/blob/main/README.md">README</a> if you support me. Please send me an e-mail including a logo file.\n      </p></section></div>', [{
      'redundantAttribute': 'expr0',
      'selector': '[expr0]',
      'expressions': [{
        'type': expressionTypes.VALUE,
        'evaluate': function evaluate(scope) {
          return scope.homeModel.lang;
        }
      }, {
        'type': expressionTypes.EVENT,
        'name': 'oninput',
        'evaluate': function evaluate(scope) {
          return function (e) {
            return scope.homeModel.lang = e.target.value;
          };
        }
      }, {
        'type': expressionTypes.ATTRIBUTE,
        'name': 'disabled',
        'evaluate': function evaluate(scope) {
          return scope.isRunning;
        }
      }]
    }, {
      'redundantAttribute': 'expr1',
      'selector': '[expr1]',
      'expressions': [{
        'type': expressionTypes.ATTRIBUTE,
        'name': 'class',
        'evaluate': function evaluate(scope) {
          return ['btn ', scope.isRunning ? 'btn-danger' : 'btn-success'].join('');
        }
      }, {
        'type': expressionTypes.VALUE,
        'evaluate': function evaluate(scope) {
          return scope.isRunning ? 'Stop' : 'Start';
        }
      }, {
        'type': expressionTypes.EVENT,
        'name': 'onclick',
        'evaluate': function evaluate(scope) {
          return scope.onToggleStartStopButton;
        }
      }, {
        'type': expressionTypes.ATTRIBUTE,
        'name': 'disabled',
        'evaluate': function evaluate(scope) {
          return !scope.homeModel.isSupported;
        }
      }]
    }, {
      'type': bindingTypes.IF,
      'evaluate': function evaluate(scope) {
        return scope.errorMessage;
      },
      'redundantAttribute': 'expr2',
      'selector': '[expr2]',
      'template': _template('<strong>Error</strong> ', [{
        'expressions': [{
          'type': expressionTypes.TEXT,
          'childNodeIndex': 1,
          'evaluate': function evaluate(scope) {
            return [': ', scope.errorMessage].join('');
          }
        }]
      }])
    }, {
      'redundantAttribute': 'expr3',
      'selector': '[expr3]',
      'expressions': [{
        'type': expressionTypes.VALUE,
        'evaluate': function evaluate(scope) {
          return scope.homeModel.websocketAddress;
        }
      }, {
        'type': expressionTypes.EVENT,
        'name': 'oninput',
        'evaluate': function evaluate(scope) {
          return function (e) {
            return scope.homeModel.websocketAddress = e.target.value;
          };
        }
      }, {
        'type': expressionTypes.ATTRIBUTE,
        'name': 'disabled',
        'evaluate': function evaluate(scope) {
          return scope.isRunning;
        }
      }]
    }, {
      'redundantAttribute': 'expr4',
      'selector': '[expr4]',
      'expressions': [{
        'type': expressionTypes.VALUE,
        'evaluate': function evaluate(scope) {
          return scope.homeModel.websocketPassword;
        }
      }, {
        'type': expressionTypes.EVENT,
        'name': 'oninput',
        'evaluate': function evaluate(scope) {
          return function (e) {
            return scope.homeModel.websocketPassword = e.target.value;
          };
        }
      }, {
        'type': expressionTypes.ATTRIBUTE,
        'name': 'disabled',
        'evaluate': function evaluate(scope) {
          return scope.isRunning;
        }
      }]
    }, {
      'redundantAttribute': 'expr5',
      'selector': '[expr5]',
      'expressions': [{
        'type': expressionTypes.VALUE,
        'evaluate': function evaluate(scope) {
          return scope.homeModel.sourceName;
        }
      }, {
        'type': expressionTypes.EVENT,
        'name': 'oninput',
        'evaluate': function evaluate(scope) {
          return function (e) {
            return scope.homeModel.sourceName = e.target.value;
          };
        }
      }, {
        'type': expressionTypes.ATTRIBUTE,
        'name': 'disabled',
        'evaluate': function evaluate(scope) {
          return scope.isRunning;
        }
      }]
    }, {
      'redundantAttribute': 'expr6',
      'selector': '[expr6]',
      'expressions': [{
        'type': expressionTypes.EVENT,
        'name': 'oninput',
        'evaluate': function evaluate(scope) {
          return function (e) {
            return scope.homeModel.sourceType = e.target.value;
          };
        }
      }, {
        'type': expressionTypes.ATTRIBUTE,
        'name': 'disabled',
        'evaluate': function evaluate(scope) {
          return scope.isRunning;
        }
      }]
    }, {
      'redundantAttribute': 'expr7',
      'selector': '[expr7]',
      'expressions': [{
        'type': expressionTypes.ATTRIBUTE,
        'name': 'selected',
        'evaluate': function evaluate(scope) {
          return scope.homeModel.sourceType == 0;
        }
      }]
    }, {
      'redundantAttribute': 'expr8',
      'selector': '[expr8]',
      'expressions': [{
        'type': expressionTypes.ATTRIBUTE,
        'name': 'selected',
        'evaluate': function evaluate(scope) {
          return scope.homeModel.sourceType == 1;
        }
      }]
    }, {
      'redundantAttribute': 'expr9',
      'selector': '[expr9]',
      'expressions': [{
        'type': expressionTypes.VALUE,
        'evaluate': function evaluate(scope) {
          return scope.homeModel.maxRows;
        }
      }, {
        'type': expressionTypes.EVENT,
        'name': 'oninput',
        'evaluate': function evaluate(scope) {
          return function (e) {
            return scope.homeModel.maxRows = e.target.value;
          };
        }
      }]
    }, {
      'redundantAttribute': 'expr10',
      'selector': '[expr10]',
      'expressions': [{
        'type': expressionTypes.VALUE,
        'evaluate': function evaluate(scope) {
          return scope.homeModel.maxCols;
        }
      }, {
        'type': expressionTypes.EVENT,
        'name': 'oninput',
        'evaluate': function evaluate(scope) {
          return function (e) {
            return scope.homeModel.maxCols = e.target.value;
          };
        }
      }]
    }]);
  },
  'name': 'homeview'
});
;
(function () {
  if (false) { var component, hotReload; }
})();

/***/ }),

/***/ "./src/models/FormatModel.js":
/*!***********************************!*\
  !*** ./src/models/FormatModel.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var _default = /*#__PURE__*/function () {
  function _default() {
    _classCallCheck(this, _default);
  }
  _createClass(_default, [{
    key: "format",
    value:
    /**
     * Formats a given string.
     */
    function format(strs, maxRows, maxCols) {
      var _this = this;
      var lines = strs.map(function (s) {
        return _this.splitlines(s, maxCols);
      }).flat();
      return lines.slice(Math.max(0, lines.length - maxRows)).join("\n");
    }

    /**
     * Splits a given string into lines of maximum length `maxCols`.
     */
  }, {
    key: "splitlines",
    value: function splitlines(str, maxCols) {
      var _this2 = this;
      var lines = [];
      var currLine = "";
      str.trim().split(/ /).forEach(function (wd) {
        if (currLine.length == 0) {
          lines = _this2.splitcharwise(lines, wd, maxCols);
          currLine = lines.pop();
        } else {
          var newLine = currLine + " " + wd;
          if (newLine.length <= maxCols) {
            currLine = newLine;
          } else if (wd.length <= maxCols) {
            lines.push(currLine);
            currLine = wd;
          } else {
            lines = _this2.splitcharwise(lines, newLine, maxCols);
            currLine = lines.pop();
          }
        }
      });
      if (currLine.length > 0) {
        lines.push(currLine);
      }
      return lines;
    }

    /**
     * Splits a given string into substrings of maximum length `maxCols`,
     * and appends the substrings into `lines`.
     */
  }, {
    key: "splitcharwise",
    value: function splitcharwise(lines, str, maxCols) {
      while (str.length > maxCols) {
        lines.push(str.substring(0, maxCols));
        str = str.substring(maxCols);
      }
      if (str.length > 0) {
        lines.push(str);
      }
      return lines;
    }
  }]);
  return _default;
}();


/***/ }),

/***/ "./src/models/HomeModel.js":
/*!*********************************!*\
  !*** ./src/models/HomeModel.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ua-parser-js */ "./node_modules/ua-parser-js/src/ua-parser.js");
/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ua_parser_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _repositories_OBSRepository_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../repositories/OBSRepository.js */ "./src/repositories/OBSRepository.js");
/* harmony import */ var _models_SpeechRecognitionModel_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models/SpeechRecognitionModel.js */ "./src/models/SpeechRecognitionModel.js");
/* harmony import */ var _models_FormatModel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../models/FormatModel.js */ "./src/models/FormatModel.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }




var _default = /*#__PURE__*/function () {
  function _default() {
    _classCallCheck(this, _default);
    this.obsRepository = new _repositories_OBSRepository_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
    this.uaParser = new (ua_parser_js__WEBPACK_IMPORTED_MODULE_0___default())();
    this.speechRecognitionModel = new _models_SpeechRecognitionModel_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
    this.formatModel = new _models_FormatModel_js__WEBPACK_IMPORTED_MODULE_3__["default"]();
    this.lang = this.getDefaultLanguage();
    this.websocketAddress = "localhost:4444";
    this.websocketPassword = null;
    this.sourceName = "my_transcript_src";
    this.sourceType = this.getDefaultSourceType();
    this.maxRows = 3;
    this.maxCols = 20;
    this.fixedTranscripts = [];
  }
  _createClass(_default, [{
    key: "isSupported",
    value: function isSupported() {
      return this.speechRecognitionModel.isSupported();
    }
  }, {
    key: "getDefaultLanguage",
    value: function getDefaultLanguage() {
      return window.navigator.languages && window.navigator.languages[0] || window.navigator.language || window.navigator.userLanguage || window.navigator.browserLanguage || "en";
    }
  }, {
    key: "getDefaultSourceType",
    value: function getDefaultSourceType() {
      var os = this.uaParser.getOS();
      return os.name === "Windows" ? 0 : 1;
    }
  }, {
    key: "start",
    value: function start() {
      var _this = this;
      return this.obsRepository.connect({
        address: this.websocketAddress,
        password: this.websocketPassword
      }).then(function () {
        return _this.obsRepository.setText(_this.sourceType, _this.sourceName, "") // Validates sourceType and sourceName
        .then(function () {
          return _this.speechRecognitionModel.start(_this.lang, function (event) {
            console.log(event);
            var transcripts;
            if (event.isFinal) {
              _this.fixedTranscripts.push(event.transcript);
              transcripts = _this.fixedTranscripts;
            } else {
              transcripts = [].concat(_toConsumableArray(_this.fixedTranscripts), [event.transcript]);
            }
            var text = _this.formatModel.format(transcripts, _this.maxRows, _this.maxCols);
            _this.obsRepository.setText(_this.sourceType, _this.sourceName, text);
          });
        })["catch"](function (err) {
          _this.stop(); // close connection if failed.
          throw err;
        });
      });
    }
  }, {
    key: "stop",
    value: function stop() {
      this.speechRecognitionModel.stop();
      this.obsRepository.disconnect();
    }
  }]);
  return _default;
}();


/***/ }),

/***/ "./src/models/SpeechRecognitionModel.js":
/*!**********************************************!*\
  !*** ./src/models/SpeechRecognitionModel.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var _default = /*#__PURE__*/function () {
  function _default() {
    _classCallCheck(this, _default);
  }
  _createClass(_default, [{
    key: "isSupported",
    value: function isSupported() {
      return !!(webkitSpeechRecognition || SpeechRecognition);
    }
  }, {
    key: "start",
    value: function start(lang, onresult) {
      var _this = this;
      return new Promise(function (resolve) {
        if (webkitSpeechRecognition) {
          _this.engine = new webkitSpeechRecognition();
        } else if (SpeechRecognition) {
          _this.engine = new SpeechRecognition();
        }
        _this.engine.lang = lang;
        _this.engine.continuous = true;
        _this.engine.interimResults = true;
        _this.engine.maxAlternatives = 1;
        var model = _this;
        _this.engine.onstart = function () {
          console.log("Speech recognition started.");
          resolve();
        };
        _this.engine.onend = function () {
          console.log("Speech recognition stopped.");
          if (model.engine) model.engine.start();
        };
        _this.engine.onerror = function (event) {
          console.log("Speech recognition stopped by error: ", event);
          if (model.engine) model.engine.start();
        };
        _this.engine.onresult = function (event) {
          for (var i = event.resultIndex; i < event.results.length; ++i) {
            onresult({
              "isFinal": event.results[i].isFinal,
              "transcript": event.results[i][0].transcript,
              "confidence": event.results[i][0].confidence
            });
          }
        };
        _this.engine.start();
      });
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this.engine) {
        this.engine.stop();
        this.engine = null;
      }
    }
  }]);
  return _default;
}();


/***/ }),

/***/ "./src/repositories/OBSRepository.js":
/*!*******************************************!*\
  !*** ./src/repositories/OBSRepository.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _default)
/* harmony export */ });
/* harmony import */ var obs_websocket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! obs-websocket-js */ "./node_modules/obs-websocket-js/lib/index.js");
/* harmony import */ var obs_websocket_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(obs_websocket_js__WEBPACK_IMPORTED_MODULE_0__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var _default = /*#__PURE__*/function () {
  function _default() {
    _classCallCheck(this, _default);
    this.websocket = new (obs_websocket_js__WEBPACK_IMPORTED_MODULE_0___default())();
  }
  _createClass(_default, [{
    key: "connect",
    value: function connect(connInfo) {
      return this.websocket.connect(connInfo);
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      return this.websocket.disconnect();
    }
  }, {
    key: "setText",
    value: function setText(sourceType, sourceName, text) {
      if (sourceType == 0) {
        return this.setTextGDIPlus(sourceName, text);
      } else {
        return this.setTextFreetype2(sourceName, text);
      }
    }
  }, {
    key: "setTextGDIPlus",
    value: function setTextGDIPlus(sourceName, text) {
      return this.websocket.send("SetTextGDIPlusProperties", {
        "source": sourceName,
        "text": text
      });
    }
  }, {
    key: "setTextFreetype2",
    value: function setTextFreetype2(sourceName, text) {
      return this.websocket.send("SetTextFreetype2Properties", {
        "source": sourceName,
        "text": text
      });
    }
  }]);
  return _default;
}();


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/bootstrap.native/dist/bootstrap-native.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/bootstrap.native/dist/bootstrap-native.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*!
  * Native JavaScript for Bootstrap v3.0.15 (https://thednp.github.io/bootstrap.native/)
  * Copyright 2015-2021 Â© dnp_theme
  * Licensed under MIT (https://github.com/thednp/bootstrap.native/blob/master/LICENSE)
  */
const transitionEndEvent = 'webkitTransition' in document.head.style ? 'webkitTransitionEnd' : 'transitionend';

const supportTransition = 'webkitTransition' in document.head.style || 'transition' in document.head.style;

const transitionDuration = 'webkitTransition' in document.head.style ? 'webkitTransitionDuration' : 'transitionDuration';

const transitionProperty = 'webkitTransition' in document.head.style ? 'webkitTransitionProperty' : 'transitionProperty';

function getElementTransitionDuration(element) {
  const computedStyle = getComputedStyle(element);
  const propertyValue = computedStyle[transitionProperty];
  const durationValue = computedStyle[transitionDuration];
  const durationScale = durationValue.includes('ms') ? 1 : 1000;
  const duration = supportTransition && propertyValue && propertyValue !== 'none'
    ? parseFloat(durationValue) * durationScale : 0;

  return !Number.isNaN(duration) ? duration : 0;
}

function emulateTransitionEnd(element, handler) {
  let called = 0;
  const endEvent = new Event(transitionEndEvent);
  const duration = getElementTransitionDuration(element);

  if (duration) {
    element.addEventListener(transitionEndEvent, function transitionEndWrapper(e) {
      if (e.target === element) {
        handler.apply(element, [e]);
        element.removeEventListener(transitionEndEvent, transitionEndWrapper);
        called = 1;
      }
    });
    setTimeout(() => {
      if (!called) element.dispatchEvent(endEvent);
    }, duration + 17);
  } else {
    handler.apply(element, [endEvent]);
  }
}

function queryElement(selector, parent) {
  const lookUp = parent && parent instanceof Element ? parent : document;
  return selector instanceof Element ? selector : lookUp.querySelector(selector);
}

function hasClass(element, classNAME) {
  return element.classList.contains(classNAME);
}

function removeClass(element, classNAME) {
  element.classList.remove(classNAME);
}

const addEventListener = 'addEventListener';

const removeEventListener = 'removeEventListener';

const fadeClass = 'fade';

const showClass = 'show';

const dataBsDismiss = 'data-bs-dismiss';

function bootstrapCustomEvent(namespacedEventType, eventProperties) {
  const OriginalCustomEvent = new CustomEvent(namespacedEventType, { cancelable: true });

  if (eventProperties instanceof Object) {
    Object.keys(eventProperties).forEach((key) => {
      Object.defineProperty(OriginalCustomEvent, key, {
        value: eventProperties[key],
      });
    });
  }
  return OriginalCustomEvent;
}

function normalizeValue(value) {
  if (value === 'true') {
    return true;
  }

  if (value === 'false') {
    return false;
  }

  if (!Number.isNaN(+value)) {
    return +value;
  }

  if (value === '' || value === 'null') {
    return null;
  }

  // string / function / Element / Object
  return value;
}

function normalizeOptions(element, defaultOps, inputOps, ns) {
  const normalOps = {};
  const dataOps = {};
  const data = { ...element.dataset };

  Object.keys(data)
    .forEach((k) => {
      const key = k.includes(ns)
        ? k.replace(ns, '').replace(/[A-Z]/, (match) => match.toLowerCase())
        : k;

      dataOps[key] = normalizeValue(data[k]);
    });

  Object.keys(inputOps)
    .forEach((k) => {
      inputOps[k] = normalizeValue(inputOps[k]);
    });

  Object.keys(defaultOps)
    .forEach((k) => {
      if (k in inputOps) {
        normalOps[k] = inputOps[k];
      } else if (k in dataOps) {
        normalOps[k] = dataOps[k];
      } else {
        normalOps[k] = defaultOps[k];
      }
    });

  return normalOps;
}

/* Native JavaScript for Bootstrap 5 | Base Component
----------------------------------------------------- */

class BaseComponent {
  constructor(name, target, defaults, config) {
    const self = this;
    const element = queryElement(target);

    if (element[name]) element[name].dispose();
    self.element = element;

    if (defaults && Object.keys(defaults).length) {
      self.options = normalizeOptions(element, defaults, (config || {}), 'bs');
    }
    element[name] = self;
  }

  dispose(name) {
    const self = this;
    self.element[name] = null;
    Object.keys(self).forEach((prop) => { self[prop] = null; });
  }
}

/* Native JavaScript for Bootstrap 5 | Alert
-------------------------------------------- */

// ALERT PRIVATE GC
// ================
const alertString = 'alert';
const alertComponent = 'Alert';
const alertSelector = `.${alertString}`;
const alertDismissSelector = `[${dataBsDismiss}="${alertString}"]`;

// ALERT CUSTOM EVENTS
// ===================
const closeAlertEvent = bootstrapCustomEvent(`close.bs.${alertString}`);
const closedAlertEvent = bootstrapCustomEvent(`closed.bs.${alertString}`);

// ALERT EVENT HANDLERS
// ====================
function alertTransitionEnd(self) {
  const { element, relatedTarget } = self;
  toggleAlertHandler(self);

  if (relatedTarget) closedAlertEvent.relatedTarget = relatedTarget;
  element.dispatchEvent(closedAlertEvent);

  self.dispose();
  element.parentNode.removeChild(element);
}

// ALERT PRIVATE METHOD
// ====================
function toggleAlertHandler(self, add) {
  const action = add ? addEventListener : removeEventListener;
  if (self.dismiss) self.dismiss[action]('click', self.close);
}

// ALERT DEFINITION
// ================
class Alert extends BaseComponent {
  constructor(target) {
    super(alertComponent, target);
    // bind
    const self = this;

    // initialization element
    const { element } = self;

    // the dismiss button
    self.dismiss = queryElement(alertDismissSelector, element);
    self.relatedTarget = null;

    // add event listener
    toggleAlertHandler(self, 1);
  }

  // ALERT PUBLIC METHODS
  // ====================
  close(e) {
    const target = e ? e.target : null;
    const self = e
      ? e.target.closest(alertSelector)[alertComponent]
      : this;
    const { element } = self;

    if (self && element && hasClass(element, showClass)) {
      if (target) {
        closeAlertEvent.relatedTarget = target;
        self.relatedTarget = target;
      }
      element.dispatchEvent(closeAlertEvent);
      if (closeAlertEvent.defaultPrevented) return;

      removeClass(element, showClass);

      if (hasClass(element, fadeClass)) {
        emulateTransitionEnd(element, () => alertTransitionEnd(self));
      } else alertTransitionEnd(self);
    }
  }

  dispose() {
    toggleAlertHandler(this);
    super.dispose(alertComponent);
  }
}

Alert.init = {
  component: alertComponent,
  selector: alertSelector,
  constructor: Alert,
};

function addClass(element, classNAME) {
  element.classList.add(classNAME);
}

const activeClass = 'active';

const dataBsToggle = 'data-bs-toggle';

/* Native JavaScript for Bootstrap 5 | Button
---------------------------------------------*/

// BUTTON PRIVATE GC
// =================
const buttonString = 'button';
const buttonComponent = 'Button';
const buttonSelector = `[${dataBsToggle}="${buttonString}"]`;
const ariaPressed = 'aria-pressed';

// BUTTON PRIVATE METHOD
// =====================
function toggleButtonHandler(self, add) {
  const action = add ? addEventListener : removeEventListener;
  self.element[action]('click', self.toggle);
}

// BUTTON DEFINITION
// =================
class Button extends BaseComponent {
  constructor(target) {
    super(buttonComponent, target);
    const self = this;

    // initialization element
    const { element } = self;

    // set initial state
    self.isActive = hasClass(element, activeClass);
    element.setAttribute(ariaPressed, !!self.isActive);

    // add event listener
    toggleButtonHandler(self, 1);
  }

  // BUTTON PUBLIC METHODS
  // =====================
  toggle(e) {
    if (e) e.preventDefault();
    const self = e ? this[buttonComponent] : this;
    const { element } = self;

    if (hasClass(element, 'disabled')) return;

    self.isActive = hasClass(element, activeClass);
    const { isActive } = self;

    const action = isActive ? removeClass : addClass;
    const ariaValue = isActive ? 'false' : 'true';

    action(element, activeClass);
    element.setAttribute(ariaPressed, ariaValue);
  }

  dispose() {
    toggleButtonHandler(this);
    super.dispose(buttonComponent);
  }
}

Button.init = {
  component: buttonComponent,
  selector: buttonSelector,
  constructor: Button,
};

const supportPassive = (() => {
  let result = false;
  try {
    const opts = Object.defineProperty({}, 'passive', {
      get() {
        result = true;
        return result;
      },
    });
    document[addEventListener]('DOMContentLoaded', function wrap() {
      document[removeEventListener]('DOMContentLoaded', wrap, opts);
    }, opts);
  } catch (e) {
    throw Error('Passive events are not supported');
  }

  return result;
})();

// general event options

var passiveHandler = supportPassive ? { passive: true } : false;

function reflow(element) {
  return element.offsetHeight;
}

function isElementInScrollRange(element) {
  const bcr = element.getBoundingClientRect();
  const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
  return bcr.top <= viewportHeight && bcr.bottom >= 0; // bottom && top
}

/* Native JavaScript for Bootstrap 5 | Carousel
----------------------------------------------- */

// CAROUSEL PRIVATE GC
// ===================
const carouselString = 'carousel';
const carouselComponent = 'Carousel';
const carouselSelector = `[data-bs-ride="${carouselString}"]`;
const carouselControl = `${carouselString}-control`;
const carouselItem = `${carouselString}-item`;
const dataBsSlideTo = 'data-bs-slide-to';
const pausedClass = 'paused';
const defaultCarouselOptions = {
  pause: 'hover', // 'boolean|string'
  keyboard: false, // 'boolean'
  touch: true, // 'boolean'
  interval: 5000, // 'boolean|number'
};
let startX = 0;
let currentX = 0;
let endX = 0;

// CAROUSEL CUSTOM EVENTS
// ======================
const carouselSlideEvent = bootstrapCustomEvent(`slide.bs.${carouselString}`);
const carouselSlidEvent = bootstrapCustomEvent(`slid.bs.${carouselString}`);

// CAROUSEL EVENT HANDLERS
// =======================
function carouselTransitionEndHandler(self) {
  const {
    index, direction, element, slides, options, isAnimating,
  } = self;

  // discontinue disposed instances
  if (isAnimating && element[carouselComponent]) {
    const activeItem = getActiveIndex(self);
    const orientation = direction === 'left' ? 'next' : 'prev';
    const directionClass = direction === 'left' ? 'start' : 'end';
    self.isAnimating = false;

    addClass(slides[index], activeClass);
    removeClass(slides[activeItem], activeClass);

    removeClass(slides[index], `${carouselItem}-${orientation}`);
    removeClass(slides[index], `${carouselItem}-${directionClass}`);
    removeClass(slides[activeItem], `${carouselItem}-${directionClass}`);

    element.dispatchEvent(carouselSlidEvent);

    // check for element, might have been disposed
    if (!document.hidden && options.interval
      && !hasClass(element, pausedClass)) {
      self.cycle();
    }
  }
}

function carouselPauseHandler(e) {
  const eventTarget = e.target;
  const self = eventTarget.closest(carouselSelector)[carouselComponent];
  const { element, isAnimating } = self;

  if (!hasClass(element, pausedClass)) {
    addClass(element, pausedClass);
    if (!isAnimating) {
      clearInterval(self.timer);
      self.timer = null;
    }
  }
}

function carouselResumeHandler(e) {
  const eventTarget = e.target;
  const self = eventTarget.closest(carouselSelector)[carouselComponent];
  const { isPaused, isAnimating, element } = self;

  if (!isPaused && hasClass(element, pausedClass)) {
    removeClass(element, pausedClass);

    if (!isAnimating) {
      clearInterval(self.timer);
      self.timer = null;
      self.cycle();
    }
  }
}

function carouselIndicatorHandler(e) {
  e.preventDefault();
  const { target } = e;
  const self = target.closest(carouselSelector)[carouselComponent];

  if (self.isAnimating) return;

  const newIndex = target.getAttribute(dataBsSlideTo);

  if (target && !hasClass(target, activeClass) // event target is not active
    && newIndex) { // AND has the specific attribute
    self.to(+newIndex); // do the slide
  }
}

function carouselControlsHandler(e) {
  e.preventDefault();
  const that = this;
  const self = that.closest(carouselSelector)[carouselComponent];
  const { controls } = self;

  if (controls[1] && that === controls[1]) {
    self.next();
  } else if (controls[1] && that === controls[0]) {
    self.prev();
  }
}

function carouselKeyHandler({ which }) {
  const [element] = Array.from(document.querySelectorAll(carouselSelector))
    .filter((x) => isElementInScrollRange(x));

  if (!element) return;
  const self = element[carouselComponent];

  switch (which) {
    case 39:
      self.next();
      break;
    case 37:
      self.prev();
      break;
  }
}

// CAROUSEL TOUCH HANDLERS
// =======================
function carouselTouchDownHandler(e) {
  const element = this;
  const self = element[carouselComponent];

  if (!self || self.isTouch) { return; }

  startX = e.changedTouches[0].pageX;

  if (element.contains(e.target)) {
    self.isTouch = true;
    toggleCarouselTouchHandlers(self, 1);
  }
}

function carouselTouchMoveHandler(e) {
  const { changedTouches, type } = e;
  const self = this[carouselComponent];

  if (!self || !self.isTouch) { return; }

  currentX = changedTouches[0].pageX;

  // cancel touch if more than one changedTouches detected
  if (type === 'touchmove' && changedTouches.length > 1) {
    e.preventDefault();
  }
}

function carouselTouchEndHandler(e) {
  const element = this;
  const self = element[carouselComponent];

  if (!self || !self.isTouch) { return; }

  endX = currentX || e.changedTouches[0].pageX;

  if (self.isTouch) {
    // the event target is outside the carousel OR carousel doens't include the related target
    if ((!element.contains(e.target) || !element.contains(e.relatedTarget))
      && Math.abs(startX - endX) < 75) { // AND swipe distance is less than 75px
      // when the above conditions are satisfied, no need to continue
      return;
    } // OR determine next index to slide to
    if (currentX < startX) {
      self.index += 1;
    } else if (currentX > startX) {
      self.index -= 1;
    }

    self.isTouch = false;
    self.to(self.index); // do the slide

    toggleCarouselTouchHandlers(self); // remove touch events handlers
  }
}

// CAROUSEL PRIVATE METHODS
// ========================
function activateCarouselIndicator(self, pageIndex) { // indicators
  const { indicators } = self;
  Array.from(indicators).forEach((x) => removeClass(x, activeClass));
  if (self.indicators[pageIndex]) addClass(indicators[pageIndex], activeClass);
}

function toggleCarouselTouchHandlers(self, add) {
  const { element } = self;
  const action = add ? addEventListener : removeEventListener;
  element[action]('touchmove', carouselTouchMoveHandler, passiveHandler);
  element[action]('touchend', carouselTouchEndHandler, passiveHandler);
}

function toggleCarouselHandlers(self, add) {
  const {
    element, options, slides, controls, indicator,
  } = self;
  const {
    touch, pause, interval, keyboard,
  } = options;
  const action = add ? addEventListener : removeEventListener;

  if (pause && interval) {
    element[action]('mouseenter', carouselPauseHandler);
    element[action]('mouseleave', carouselResumeHandler);
    element[action]('touchstart', carouselPauseHandler, passiveHandler);
    element[action]('touchend', carouselResumeHandler, passiveHandler);
  }

  if (touch && slides.length > 1) {
    element[action]('touchstart', carouselTouchDownHandler, passiveHandler);
  }

  controls.forEach((arrow) => {
    if (arrow) arrow[action]('click', carouselControlsHandler);
  });

  if (indicator) indicator[action]('click', carouselIndicatorHandler);
  if (keyboard) window[action]('keydown', carouselKeyHandler);
}

function getActiveIndex(self) {
  const { slides, element } = self;
  return Array.from(slides)
    .indexOf(element.getElementsByClassName(`${carouselItem} ${activeClass}`)[0]) || 0;
}

// CAROUSEL DEFINITION
// ===================
class Carousel extends BaseComponent {
  constructor(target, config) {
    super(carouselComponent, target, defaultCarouselOptions, config);
    // bind
    const self = this;

    // additional properties
    self.timer = null;
    self.direction = 'left';
    self.isPaused = false;
    self.isAnimating = false;
    self.index = 0;
    self.timer = null;
    self.isTouch = false;

    // initialization element
    const { element } = self;
    // carousel elements
    // a LIVE collection is prefferable
    self.slides = element.getElementsByClassName(carouselItem);
    const { slides } = self;

    // invalidate when not enough items
    // no need to go further
    if (slides.length < 2) { return; }

    self.controls = [
      queryElement(`.${carouselControl}-prev`, element),
      queryElement(`.${carouselControl}-next`, element),
    ];

    // a LIVE collection is prefferable
    self.indicator = queryElement('.carousel-indicators', element);
    self.indicators = (self.indicator && self.indicator.querySelectorAll(`[${dataBsSlideTo}]`)) || [];

    // set JavaScript and DATA API options
    const { options } = self;

    // don't use TRUE as interval, it's actually 0, use the default 5000ms better
    self.options.interval = options.interval === true
      ? defaultCarouselOptions.interval
      : options.interval;

    // set first slide active if none
    if (getActiveIndex(self) < 0) {
      if (slides.length) addClass(slides[0], activeClass);
      if (self.indicators.length) activateCarouselIndicator(self, 0);
    }

    // attach event handlers
    toggleCarouselHandlers(self, 1);

    // start to cycle if interval is set
    if (options.interval) self.cycle();
  }

  // CAROUSEL PUBLIC METHODS
  // =======================
  cycle() {
    const self = this;
    const { isPaused, element, options } = self;
    if (self.timer) {
      clearInterval(self.timer);
      self.timer = null;
    }

    if (isPaused) {
      removeClass(element, pausedClass);
      self.isPaused = !isPaused;
    }

    self.timer = setInterval(() => {
      if (isElementInScrollRange(element)) {
        self.index += 1;
        self.to(self.index);
      }
    }, options.interval);
  }

  pause() {
    const self = this;
    const { element, options, isPaused } = self;
    if (options.interval && !isPaused) {
      clearInterval(self.timer);
      self.timer = null;
      addClass(element, pausedClass);
      self.isPaused = !isPaused;
    }
  }

  next() {
    const self = this;
    if (!self.isAnimating) { self.index += 1; self.to(self.index); }
  }

  prev() {
    const self = this;
    if (!self.isAnimating) { self.index -= 1; self.to(self.index); }
  }

  to(idx) {
    const self = this;
    const {
      element, isAnimating, slides, options,
    } = self;
    const activeItem = getActiveIndex(self);
    let next = idx;

    // when controled via methods, make sure to check again
    // first return if we're on the same item #227
    if (isAnimating || activeItem === next) return;

    // determine transition direction
    if ((activeItem < next) || (activeItem === 0 && next === slides.length - 1)) {
      self.direction = 'left'; // next
    } else if ((activeItem > next) || (activeItem === slides.length - 1 && next === 0)) {
      self.direction = 'right'; // prev
    }
    const { direction } = self;

    // find the right next index
    if (next < 0) { next = slides.length - 1; } else if (next >= slides.length) { next = 0; }

    // orientation, class name, eventProperties
    const orientation = direction === 'left' ? 'next' : 'prev';
    const directionClass = direction === 'left' ? 'start' : 'end';
    const eventProperties = {
      relatedTarget: slides[next], direction, from: activeItem, to: next,
    };

    // update event properties
    Object.keys(eventProperties).forEach((k) => {
      carouselSlideEvent[k] = eventProperties[k];
      carouselSlidEvent[k] = eventProperties[k];
    });

    // discontinue when prevented
    element.dispatchEvent(carouselSlideEvent);
    if (carouselSlideEvent.defaultPrevented) return;

    // update index
    self.index = next;

    clearInterval(self.timer);
    self.timer = null;

    self.isAnimating = true;
    activateCarouselIndicator(self, next);

    if (getElementTransitionDuration(slides[next]) && hasClass(element, 'slide')) {
      addClass(slides[next], `${carouselItem}-${orientation}`);
      reflow(slides[next]);
      addClass(slides[next], `${carouselItem}-${directionClass}`);
      addClass(slides[activeItem], `${carouselItem}-${directionClass}`);

      emulateTransitionEnd(slides[next], () => carouselTransitionEndHandler(self));
    } else {
      addClass(slides[next], activeClass);
      removeClass(slides[activeItem], activeClass);

      setTimeout(() => {
        self.isAnimating = false;

        // check for element, might have been disposed
        if (element && options.interval && !hasClass(element, pausedClass)) {
          self.cycle();
        }

        element.dispatchEvent(carouselSlidEvent);
      }, 100);
    }
  }

  dispose() {
    const self = this;
    const { slides } = self;
    const itemClasses = ['start', 'end', 'prev', 'next'];

    Array.from(slides).forEach((slide, idx) => {
      if (hasClass(slide, activeClass)) activateCarouselIndicator(self, idx);
      itemClasses.forEach((c) => removeClass(slide, `${carouselItem}-${c}`));
    });

    toggleCarouselHandlers(self);
    clearInterval(self.timer);
    super.dispose(carouselComponent);
  }
}

Carousel.init = {
  component: carouselComponent,
  selector: carouselSelector,
  constructor: Carousel,
};

const ariaExpanded = 'aria-expanded';

// collapse / tab
const collapsingClass = 'collapsing';

const dataBsTarget = 'data-bs-target';

const dataBsParent = 'data-bs-parent';

const dataBsContainer = 'data-bs-container';

function getTargetElement(element) {
  return queryElement(element.getAttribute(dataBsTarget) || element.getAttribute('href'))
        || element.closest(element.getAttribute(dataBsParent))
        || queryElement(element.getAttribute(dataBsContainer));
}

/* Native JavaScript for Bootstrap 5 | Collapse
----------------------------------------------- */

// COLLAPSE GC
// ===========
const collapseString = 'collapse';
const collapseComponent = 'Collapse';
const collapseSelector = `.${collapseString}`;
const collapseToggleSelector = `[${dataBsToggle}="${collapseString}"]`;

// COLLAPSE CUSTOM EVENTS
// ======================
const showCollapseEvent = bootstrapCustomEvent(`show.bs.${collapseString}`);
const shownCollapseEvent = bootstrapCustomEvent(`shown.bs.${collapseString}`);
const hideCollapseEvent = bootstrapCustomEvent(`hide.bs.${collapseString}`);
const hiddenCollapseEvent = bootstrapCustomEvent(`hidden.bs.${collapseString}`);

// COLLAPSE PRIVATE METHODS
// ========================
function expandCollapse(self) {
  const {
    element, parent, triggers,
  } = self;

  element.dispatchEvent(showCollapseEvent);
  if (showCollapseEvent.defaultPrevented) return;

  self.isAnimating = true;
  if (parent) parent.isAnimating = true;

  addClass(element, collapsingClass);
  removeClass(element, collapseString);

  element.style.height = `${element.scrollHeight}px`;

  emulateTransitionEnd(element, () => {
    self.isAnimating = false;
    if (parent) parent.isAnimating = false;

    triggers.forEach((btn) => btn.setAttribute(ariaExpanded, 'true'));

    removeClass(element, collapsingClass);
    addClass(element, collapseString);
    addClass(element, showClass);

    element.style.height = '';

    element.dispatchEvent(shownCollapseEvent);
  });
}

function collapseContent(self) {
  const {
    element, parent, triggers,
  } = self;

  element.dispatchEvent(hideCollapseEvent);

  if (hideCollapseEvent.defaultPrevented) return;

  self.isAnimating = true;
  if (parent) parent.isAnimating = true;

  element.style.height = `${element.scrollHeight}px`;

  removeClass(element, collapseString);
  removeClass(element, showClass);
  addClass(element, collapsingClass);

  reflow(element);
  element.style.height = '0px';

  emulateTransitionEnd(element, () => {
    self.isAnimating = false;
    if (parent) parent.isAnimating = false;

    triggers.forEach((btn) => btn.setAttribute(ariaExpanded, 'false'));

    removeClass(element, collapsingClass);
    addClass(element, collapseString);

    element.style.height = '';

    element.dispatchEvent(hiddenCollapseEvent);
  });
}

function toggleCollapseHandler(self, add) {
  const action = add ? addEventListener : removeEventListener;
  const { triggers } = self;

  if (triggers.length) {
    triggers.forEach((btn) => btn[action]('click', collapseClickHandler));
  }
}

// COLLAPSE EVENT HANDLER
// ======================
function collapseClickHandler(e) {
  const { target } = e;
  const trigger = target.closest(collapseToggleSelector);
  const element = getTargetElement(trigger);
  const self = element && element[collapseComponent];
  if (self) self.toggle(target);

  // event target is anchor link #398
  if (trigger && trigger.tagName === 'A') e.preventDefault();
}

// COLLAPSE DEFINITION
// ===================
class Collapse extends BaseComponent {
  constructor(target, config) {
    super(collapseComponent, target, { parent: null }, config);
    // bind
    const self = this;

    // initialization element
    const { element } = self;

    // set triggering elements
    self.triggers = Array.from(document.querySelectorAll(collapseToggleSelector))
      .filter((btn) => getTargetElement(btn) === element);

    // set parent accordion
    self.parent = queryElement(self.options.parent);
    const { parent } = self;

    // set initial state
    self.isAnimating = false;
    if (parent) parent.isAnimating = false;

    // add event listeners
    toggleCollapseHandler(self, 1);
  }

  // COLLAPSE PUBLIC METHODS
  // =======================
  toggle(related) {
    const self = this;
    if (!hasClass(self.element, showClass)) self.show(related);
    else self.hide(related);
  }

  hide() {
    const self = this;
    const { triggers, isAnimating } = self;
    if (isAnimating) return;

    collapseContent(self);
    if (triggers.length) {
      triggers.forEach((btn) => addClass(btn, `${collapseString}d`));
    }
  }

  show() {
    const self = this;
    const {
      element, parent, triggers, isAnimating,
    } = self;
    let activeCollapse;
    let activeCollapseInstance;

    if (parent) {
      activeCollapse = Array.from(parent.querySelectorAll(`.${collapseString}.${showClass}`))
        .find((i) => i[collapseComponent]);
      activeCollapseInstance = activeCollapse && activeCollapse[collapseComponent];
    }

    if ((!parent || (parent && !parent.isAnimating)) && !isAnimating) {
      if (activeCollapseInstance && activeCollapse !== element) {
        collapseContent(activeCollapseInstance);
        activeCollapseInstance.triggers.forEach((btn) => {
          addClass(btn, `${collapseString}d`);
        });
      }

      expandCollapse(self);
      if (triggers.length) {
        triggers.forEach((btn) => removeClass(btn, `${collapseString}d`));
      }
    }
  }

  dispose() {
    const self = this;
    const { parent } = self;
    toggleCollapseHandler(self);

    if (parent) delete parent.isAnimating;
    super.dispose(collapseComponent);
  }
}

Collapse.init = {
  component: collapseComponent,
  selector: collapseSelector,
  constructor: Collapse,
};

const dropdownMenuClasses = ['dropdown', 'dropup', 'dropstart', 'dropend'];

const dropdownMenuClass = 'dropdown-menu';

function isEmptyAnchor(elem) {
  const parentAnchor = elem.closest('A');
  // anchor href starts with #
  return elem && ((elem.href && elem.href.slice(-1) === '#')
    // OR a child of an anchor with href starts with #
    || (parentAnchor && parentAnchor.href && parentAnchor.href.slice(-1) === '#'));
}

function setFocus(element) {
  element.focus();
}

/* Native JavaScript for Bootstrap 5 | Dropdown
----------------------------------------------- */

// DROPDOWN PRIVATE GC
// ===================
const [dropdownString] = dropdownMenuClasses;
const dropdownComponent = 'Dropdown';
const dropdownSelector = `[${dataBsToggle}="${dropdownString}"]`;

// DROPDOWN PRIVATE GC
// ===================
const dropupString = dropdownMenuClasses[1];
const dropstartString = dropdownMenuClasses[2];
const dropendString = dropdownMenuClasses[3];
const dropdownMenuEndClass = `${dropdownMenuClass}-end`;
const hideMenuClass = ['d-block', 'invisible'];
const verticalClass = [dropdownString, dropupString];
const horizontalClass = [dropstartString, dropendString];
const defaultDropdownOptions = {
  offset: 5, // [number] 5(px)
  display: 'dynamic', // [dynamic|static]
};

// DROPDOWN CUSTOM EVENTS
// ========================
const showDropdownEvent = bootstrapCustomEvent(`show.bs.${dropdownString}`);
const shownDropdownEvent = bootstrapCustomEvent(`shown.bs.${dropdownString}`);
const hideDropdownEvent = bootstrapCustomEvent(`hide.bs.${dropdownString}`);
const hiddenDropdownEvent = bootstrapCustomEvent(`hidden.bs.${dropdownString}`);

// DROPDOWN PRIVATE METHODS
// ========================
function styleDropdown(self, show) {
  const {
    element, menu, originalClass, menuEnd, options,
  } = self;
  const parent = element.parentElement;

  // reset menu offset and position
  const resetProps = ['margin', 'top', 'bottom', 'left', 'right'];
  resetProps.forEach((p) => { menu.style[p] = ''; });
  removeClass(parent, 'position-static');

  if (!show) {
    parent.className = originalClass.join(' ');
    const menuAction = menuEnd && !hasClass(menu, dropdownMenuEndClass) ? addClass : removeClass;
    menuAction(menu, dropdownMenuEndClass);
    return;
  }

  const { offset } = options;
  let positionClass = dropdownMenuClasses.find((c) => originalClass.includes(c));

  let dropdownMargin = {
    dropdown: [offset, 0, 0],
    dropup: [0, 0, offset],
    dropstart: [-1, offset, 0],
    dropend: [-1, 0, 0, offset],
  };

  const dropdownPosition = {
    dropdown: { top: '100%' },
    dropup: { top: 'auto', bottom: '100%' },
    dropstart: { left: 'auto', right: '100%' },
    dropend: { left: '100%', right: 'auto' },
    menuEnd: { right: 0, left: 'auto' },
  };

  // force showing the menu to calculate its size
  hideMenuClass.forEach((c) => addClass(menu, c));

  const dropdownRegex = new RegExp(`\\b(${dropdownString}|${dropupString}|${dropstartString}|${dropendString})+`);
  const elementDimensions = { w: element.offsetWidth, h: element.offsetHeight };
  const menuDimensions = { w: menu.offsetWidth, h: menu.offsetHeight };
  const HTML = document.documentElement;
  const BD = document.body;
  const windowWidth = (HTML.clientWidth || BD.clientWidth);
  const windowHeight = (HTML.clientHeight || BD.clientHeight);
  const targetBCR = element.getBoundingClientRect();
  // dropdownMenuEnd && [ dropdown | dropup ]
  const leftExceed = targetBCR.left + elementDimensions.w - menuDimensions.w < 0;
  // dropstart
  const leftFullExceed = targetBCR.left - menuDimensions.w < 0;
  // !dropdownMenuEnd && [ dropdown | dropup ]
  const rightExceed = targetBCR.left + menuDimensions.w >= windowWidth;
  // dropend
  const rightFullExceed = targetBCR.left + menuDimensions.w + elementDimensions.w >= windowWidth;
  // dropstart | dropend
  const bottomExceed = targetBCR.top + menuDimensions.h >= windowHeight;
  // dropdown
  const bottomFullExceed = targetBCR.top + menuDimensions.h + elementDimensions.h >= windowHeight;
  // dropup
  const topExceed = targetBCR.top - menuDimensions.h < 0;

  const btnGroup = parent.parentNode.closest('.btn-group,.btn-group-vertical');

  // recompute position
  if (horizontalClass.includes(positionClass) && leftFullExceed && rightFullExceed) {
    positionClass = dropdownString;
  }
  if (horizontalClass.includes(positionClass) && bottomExceed) {
    positionClass = dropupString;
  }
  if (positionClass === dropstartString && leftFullExceed && !bottomExceed) {
    positionClass = dropendString;
  }
  if (positionClass === dropendString && rightFullExceed && !bottomExceed) {
    positionClass = dropstartString;
  }
  if (positionClass === dropupString && topExceed && !bottomFullExceed) {
    positionClass = dropdownString;
  }
  if (positionClass === dropdownString && bottomFullExceed && !topExceed) {
    positionClass = dropupString;
  }

  // set spacing
  dropdownMargin = dropdownMargin[positionClass];
  menu.style.margin = `${dropdownMargin.map((x) => (x ? `${x}px` : x)).join(' ')}`;
  Object.keys(dropdownPosition[positionClass]).forEach((position) => {
    menu.style[position] = dropdownPosition[positionClass][position];
  });

  // update dropdown position class
  if (!hasClass(parent, positionClass)) {
    parent.className = parent.className.replace(dropdownRegex, positionClass);
  }

  // update dropdown / dropup to handle parent btn-group element
  // as well as the dropdown-menu-end utility class
  if (verticalClass.includes(positionClass)) {
    const menuEndAction = rightExceed ? addClass : removeClass;

    if (!btnGroup) menuEndAction(menu, dropdownMenuEndClass);
    else if (leftExceed) addClass(parent, 'position-static');

    if (hasClass(menu, dropdownMenuEndClass)) {
      Object.keys(dropdownPosition.menuEnd).forEach((p) => {
        menu.style[p] = dropdownPosition.menuEnd[p];
      });
    }
  }

  // remove util classes from the menu, we have its size
  hideMenuClass.forEach((c) => removeClass(menu, c));
}

function toggleDropdownDismiss(self) {
  const action = self.open ? addEventListener : removeEventListener;

  document[action]('click', dropdownDismissHandler);
  document[action]('focus', dropdownDismissHandler);
  document[action]('keydown', dropdownPreventScroll);
  document[action]('keyup', dropdownKeyHandler);
  if (self.options.display === 'dynamic') {
    window[action]('scroll', dropdownLayoutHandler, passiveHandler);
    window[action]('resize', dropdownLayoutHandler, passiveHandler);
  }
}

function toggleDropdownHandler(self, add) {
  const action = add ? addEventListener : removeEventListener;
  self.element[action]('click', dropdownClickHandler);
}

function getCurrentOpenDropdown() {
  const currentParent = dropdownMenuClasses
    .map((c) => document.getElementsByClassName(`${c} ${showClass}`))
    .find((x) => x.length);

  if (currentParent && currentParent.length) {
    return Array.from(currentParent[0].children).find((x) => x.hasAttribute(dataBsToggle));
  }
  return null;
}

// DROPDOWN EVENT HANDLERS
// =======================
function dropdownDismissHandler(e) {
  const { target, type } = e;
  if (!target.closest) return; // some weird FF bug #409

  const element = getCurrentOpenDropdown();
  const parent = element && element.parentNode;
  const self = element && element[dropdownComponent];
  const menu = self && self.menu;

  const hasData = target.closest(dropdownSelector) !== null;
  const isForm = parent && parent.contains(target)
    && (target.tagName === 'form' || target.closest('form') !== null);

  if (type === 'click' && isEmptyAnchor(target)) {
    e.preventDefault();
  }
  if (type === 'focus'
    && (target === element || target === menu || menu.contains(target))) {
    return;
  }

  if (isForm || hasData) ; else if (self) {
    self.hide(element);
  }
}

function dropdownClickHandler(e) {
  const element = this;
  const self = element[dropdownComponent];
  self.toggle(element);

  if (isEmptyAnchor(e.target)) e.preventDefault();
}

function dropdownPreventScroll(e) {
  if (e.which === 38 || e.which === 40) e.preventDefault();
}

function dropdownKeyHandler({ which }) {
  const element = getCurrentOpenDropdown();
  const self = element[dropdownComponent];
  const { menu, menuItems, open } = self;
  const activeItem = document.activeElement;
  const isSameElement = activeItem === element;
  const isInsideMenu = menu.contains(activeItem);
  const isMenuItem = activeItem.parentNode === menu || activeItem.parentNode.parentNode === menu;

  let idx = menuItems.indexOf(activeItem);

  if (isMenuItem) { // navigate up | down
    if (isSameElement) {
      idx = 0;
    } else if (which === 38) {
      idx = idx > 1 ? idx - 1 : 0;
    } else if (which === 40) {
      idx = idx < menuItems.length - 1 ? idx + 1 : idx;
    }

    if (menuItems[idx]) setFocus(menuItems[idx]);
  }

  if (((menuItems.length && isMenuItem) // menu has items
      || (!menuItems.length && (isInsideMenu || isSameElement)) // menu might be a form
      || !isInsideMenu) // or the focused element is not in the menu at all
      && open && which === 27 // menu must be open
  ) {
    self.toggle();
  }
}

function dropdownLayoutHandler() {
  const element = getCurrentOpenDropdown();
  const self = element && element[dropdownComponent];

  if (self && self.open) styleDropdown(self, 1);
}

// DROPDOWN DEFINITION
// ===================
class Dropdown extends BaseComponent {
  constructor(target, config) {
    super(dropdownComponent, target, defaultDropdownOptions, config);
    // bind
    const self = this;

    // initialization element
    const { element } = self;

    // set targets
    const parent = element.parentElement;
    self.menu = queryElement(`.${dropdownMenuClass}`, parent);
    const { menu } = self;

    self.originalClass = Array.from(parent.classList);

    // set original position
    self.menuEnd = hasClass(menu, dropdownMenuEndClass);

    self.menuItems = [];

    Array.from(menu.children).forEach((child) => {
      if (child.children.length && (child.children[0].tagName === 'A')) self.menuItems.push(child.children[0]);
      if (child.tagName === 'A') self.menuItems.push(child);
    });

    // set initial state to closed
    self.open = false;

    // add event listener
    toggleDropdownHandler(self, 1);
  }

  // DROPDOWN PUBLIC METHODS
  // =======================
  toggle(related) {
    const self = this;
    const { open } = self;

    if (open) self.hide(related);
    else self.show(related);
  }

  show(related) {
    const self = this;
    const currentParent = queryElement(dropdownMenuClasses.map((c) => `.${c}.${showClass}`).join(','));
    const currentElement = currentParent && queryElement(dropdownSelector, currentParent);

    if (currentElement) currentElement[dropdownComponent].hide();

    const { element, menu, open } = self;
    const parent = element.parentNode;

    // update relatedTarget and dispatch
    showDropdownEvent.relatedTarget = related || null;
    parent.dispatchEvent(showDropdownEvent);
    if (showDropdownEvent.defaultPrevented) return;

    // change menu position
    styleDropdown(self, 1);

    addClass(menu, showClass);
    addClass(parent, showClass);

    element.setAttribute(ariaExpanded, true);
    self.open = !open;

    setTimeout(() => {
      setFocus(menu.getElementsByTagName('INPUT')[0] || element); // focus the first input item | element
      toggleDropdownDismiss(self);

      shownDropdownEvent.relatedTarget = related || null;
      parent.dispatchEvent(shownDropdownEvent);
    }, 1);
  }

  hide(related) {
    const self = this;
    const { element, menu, open } = self;
    const parent = element.parentNode;
    hideDropdownEvent.relatedTarget = related || null;
    parent.dispatchEvent(hideDropdownEvent);
    if (hideDropdownEvent.defaultPrevented) return;

    removeClass(menu, showClass);
    removeClass(parent, showClass);

    // revert to original position
    styleDropdown(self);

    element.setAttribute(ariaExpanded, false);
    self.open = !open;

    setFocus(element);

    // only re-attach handler if the instance is not disposed
    setTimeout(() => toggleDropdownDismiss(self), 1);

    // update relatedTarget and dispatch
    hiddenDropdownEvent.relatedTarget = related || null;
    parent.dispatchEvent(hiddenDropdownEvent);
  }

  dispose() {
    const self = this;
    const { element } = self;

    if (hasClass(element.parentNode, showClass) && self.open) self.hide();

    toggleDropdownHandler(self);

    super.dispose(dropdownComponent);
  }
}

Dropdown.init = {
  component: dropdownComponent,
  selector: dropdownSelector,
  constructor: Dropdown,
};

const ariaHidden = 'aria-hidden';

const ariaModal = 'aria-modal';

const fixedTopClass = 'fixed-top';

const fixedBottomClass = 'fixed-bottom';

const stickyTopClass = 'sticky-top';

const fixedItems = Array.from(document.getElementsByClassName(fixedTopClass))
  .concat(Array.from(document.getElementsByClassName(fixedBottomClass)))
  .concat(Array.from(document.getElementsByClassName(stickyTopClass)))
  .concat(Array.from(document.getElementsByClassName('is-fixed')));

function resetScrollbar() {
  const bd = document.body;
  bd.style.paddingRight = '';
  bd.style.overflow = '';

  if (fixedItems.length) {
    fixedItems.forEach((fixed) => {
      fixed.style.paddingRight = '';
      fixed.style.marginRight = '';
    });
  }
}

function measureScrollbar() {
  const windowWidth = document.documentElement.clientWidth;
  return Math.abs(window.innerWidth - windowWidth);
}

function setScrollbar(scrollbarWidth, overflow, isOpen) {
  const bd = document.body;
  const bodyPad = parseInt(getComputedStyle(bd).paddingRight, 10);
  const sbWidth = isOpen && bodyPad ? 0 : scrollbarWidth;

  if (overflow) {
    bd.style.paddingRight = `${bodyPad + sbWidth}px`;

    if (fixedItems.length) {
      fixedItems.forEach((fixed) => {
        const isSticky = hasClass(fixed, stickyTopClass);
        const itemPadValue = getComputedStyle(fixed).paddingRight;
        fixed.style.paddingRight = `${parseInt(itemPadValue, 10) + sbWidth}px`;
        if (isSticky) {
          const itemMValue = getComputedStyle(fixed).marginRight;
          fixed.style.marginRight = `${parseInt(itemMValue, 10) - sbWidth}px`;
        }
      });
    }
  }
}

const modalOpenClass = 'modal-open';
const modalBackdropClass = 'modal-backdrop';
const modalActiveSelector = `.modal.${showClass}`;
const offcanvasActiveSelector = `.offcanvas.${showClass}`;

const overlay = document.createElement('div');
overlay.setAttribute('class', `${modalBackdropClass}`);

function getCurrentOpen() {
  return queryElement(`${modalActiveSelector},${offcanvasActiveSelector}`);
}

function appendOverlay(hasFade) {
  document.body.appendChild(overlay);
  if (hasFade) addClass(overlay, fadeClass);
}

function showOverlay() {
  addClass(overlay, showClass);
  reflow(overlay);
}

function hideOverlay() {
  removeClass(overlay, showClass);
}

function removeOverlay() {
  const bd = document.body;
  const currentOpen = getCurrentOpen();

  if (!currentOpen) {
    removeClass(overlay, fadeClass);
    removeClass(bd, modalOpenClass);
    bd.removeChild(overlay);
    resetScrollbar();
  }
}

function isVisible(element) {
  return getComputedStyle(element).visibility !== 'hidden'
    && element.offsetParent !== null;
}

/* Native JavaScript for Bootstrap 5 | Modal
-------------------------------------------- */

// MODAL PRIVATE GC
// ================
const modalString = 'modal';
const modalComponent = 'Modal';
const modalSelector = `.${modalString}`;
// const modalActiveSelector = `.${modalString}.${showClass}`;
const modalToggleSelector = `[${dataBsToggle}="${modalString}"]`;
const modalDismissSelector = `[${dataBsDismiss}="${modalString}"]`;
const modalStaticClass = `${modalString}-static`;
const modalDefaultOptions = {
  backdrop: true, // boolean|string
  keyboard: true, // boolean
};

// MODAL CUSTOM EVENTS
// ===================
const showModalEvent = bootstrapCustomEvent(`show.bs.${modalString}`);
const shownModalEvent = bootstrapCustomEvent(`shown.bs.${modalString}`);
const hideModalEvent = bootstrapCustomEvent(`hide.bs.${modalString}`);
const hiddenModalEvent = bootstrapCustomEvent(`hidden.bs.${modalString}`);

// MODAL PRIVATE METHODS
// =====================
function setModalScrollbar(self) {
  const { element, scrollbarWidth } = self;
  const bd = document.body;
  const html = document.documentElement;
  const openModal = hasClass(bd, modalOpenClass);
  const bodyOverflow = html.clientHeight !== html.scrollHeight
                    || bd.clientHeight !== bd.scrollHeight;
  const modalOverflow = element.clientHeight !== element.scrollHeight;

  if (!modalOverflow && scrollbarWidth) {
    element.style.paddingRight = `${scrollbarWidth}px`;
  }
  setScrollbar(scrollbarWidth, (modalOverflow || bodyOverflow), openModal);
}

function toggleModalDismiss(self, add) {
  const action = add ? addEventListener : removeEventListener;
  window[action]('resize', self.update, passiveHandler);
  self.element[action]('click', modalDismissHandler);
  document[action]('keydown', modalKeyHandler);
}

function toggleModalHandler(self, add) {
  const action = add ? addEventListener : removeEventListener;
  const { triggers } = self;

  if (triggers.length) {
    triggers.forEach((btn) => btn[action]('click', modalClickHandler));
  }
}

function afterModalHide(self) {
  const { triggers } = self;
  removeOverlay();
  self.element.style.paddingRight = '';
  self.isAnimating = false;

  if (triggers.length) {
    const visibleTrigger = triggers.find((x) => isVisible(x));
    if (visibleTrigger) setFocus(visibleTrigger);
  }
}

function afterModalShow(self) {
  const { element, relatedTarget } = self;
  setFocus(element);
  self.isAnimating = false;

  toggleModalDismiss(self, 1);

  shownModalEvent.relatedTarget = relatedTarget;
  element.dispatchEvent(shownModalEvent);
}

function beforeModalShow(self) {
  const { element, hasFade } = self;
  element.style.display = 'block';

  setModalScrollbar(self);
  if (!queryElement(modalActiveSelector)) {
    addClass(document.body, modalOpenClass);
  }

  addClass(element, showClass);
  element.removeAttribute(ariaHidden);
  element.setAttribute(ariaModal, true);

  if (hasFade) emulateTransitionEnd(element, () => afterModalShow(self));
  else afterModalShow(self);
}

function beforeModalHide(self, force) {
  const {
    element, relatedTarget, hasFade,
  } = self;
  const currentOpen = getCurrentOpen();

  element.style.display = '';

  // force can also be the transitionEvent object, we wanna make sure it's not
  // call is not forced and overlay is visible
  if (!force && hasFade && hasClass(overlay, showClass)
    && !currentOpen) { // AND no modal is visible
    hideOverlay();
    emulateTransitionEnd(overlay, () => afterModalHide(self));
  } else {
    afterModalHide(self);
  }

  toggleModalDismiss(self);

  hiddenModalEvent.relatedTarget = relatedTarget;
  element.dispatchEvent(hiddenModalEvent);
}

// MODAL EVENT HANDLERS
// ====================
function modalClickHandler(e) {
  const { target } = e;
  const trigger = target.closest(modalToggleSelector);
  const element = getTargetElement(trigger);
  const self = element && element[modalComponent];

  if (trigger.tagName === 'A') e.preventDefault();

  if (self.isAnimating) return;

  self.relatedTarget = trigger;

  self.toggle();
}

function modalKeyHandler({ which }) {
  const element = queryElement(modalActiveSelector);
  const self = element[modalComponent];
  const { options, isAnimating } = self;
  if (!isAnimating // modal has no animations running
    && options.keyboard && which === 27 // the keyboard option is enabled and the key is 27
    && hasClass(element, showClass)) { // the modal is not visible
    self.relatedTarget = null;
    self.hide();
  }
}

function modalDismissHandler(e) {
  const element = this;
  const self = element[modalComponent];

  if (self.isAnimating) return;

  const { isStatic, modalDialog } = self;
  const { target } = e;
  const selectedText = document.getSelection().toString().length;
  const targetInsideDialog = modalDialog.contains(target);
  const dismiss = target.closest(modalDismissSelector);

  if (isStatic && !targetInsideDialog) {
    addClass(element, modalStaticClass);
    self.isAnimating = true;
    emulateTransitionEnd(modalDialog, () => staticTransitionEnd(self));
  } else if (dismiss || (!selectedText && !isStatic && !targetInsideDialog)) {
    self.relatedTarget = dismiss || null;
    self.hide();
    e.preventDefault();
  }
}

function staticTransitionEnd(self) {
  const duration = getElementTransitionDuration(self.modalDialog) + 17;
  removeClass(self.element, modalStaticClass);
  // user must wait for zoom out transition
  setTimeout(() => { self.isAnimating = false; }, duration);
}

// MODAL DEFINITION
// ================
class Modal extends BaseComponent {
  constructor(target, config) {
    super(modalComponent, target, modalDefaultOptions, config);

    // bind
    const self = this;

    // the modal
    const { element } = self;

    // the modal-dialog
    self.modalDialog = queryElement(`.${modalString}-dialog`, element);

    // modal can have multiple triggering elements
    self.triggers = Array.from(document.querySelectorAll(modalToggleSelector))
      .filter((btn) => getTargetElement(btn) === element);

    // additional internals
    self.isStatic = self.options.backdrop === 'static';
    self.hasFade = hasClass(element, fadeClass);
    self.isAnimating = false;
    self.scrollbarWidth = measureScrollbar();
    self.relatedTarget = null;

    // attach event listeners
    toggleModalHandler(self, 1);

    // bind
    self.update = self.update.bind(self);
  }

  // MODAL PUBLIC METHODS
  // ====================
  toggle() {
    const self = this;
    if (hasClass(self.element, showClass)) self.hide();
    else self.show();
  }

  show() {
    const self = this;
    const {
      element, isAnimating, hasFade, relatedTarget,
    } = self;
    let overlayDelay = 0;

    if (hasClass(element, showClass) && !isAnimating) return;

    showModalEvent.relatedTarget = relatedTarget || null;
    element.dispatchEvent(showModalEvent);
    if (showModalEvent.defaultPrevented) return;

    self.isAnimating = true;

    // we elegantly hide any opened modal/offcanvas
    const currentOpen = getCurrentOpen();
    if (currentOpen && currentOpen !== element) {
      const that = currentOpen[modalComponent]
        ? currentOpen[modalComponent]
        : currentOpen.Offcanvas;
      that.hide();
    }

    if (!queryElement(`.${modalBackdropClass}`)) {
      appendOverlay(hasFade);
    }
    overlayDelay = getElementTransitionDuration(overlay);

    if (!hasClass(overlay, showClass)) {
      showOverlay();
    }

    if (!currentOpen) {
      setTimeout(() => beforeModalShow(self), overlayDelay);
    } else beforeModalShow(self);
  }

  hide(force) {
    const self = this;
    const {
      element, isAnimating, hasFade, relatedTarget,
    } = self;
    if (!hasClass(element, showClass) && !isAnimating) return;

    hideModalEvent.relatedTarget = relatedTarget || null;
    element.dispatchEvent(hideModalEvent);
    if (hideModalEvent.defaultPrevented) return;

    self.isAnimating = true;
    removeClass(element, showClass);
    element.setAttribute(ariaHidden, true);
    element.removeAttribute(ariaModal);

    if (hasFade && force !== 1) {
      emulateTransitionEnd(element, () => beforeModalHide(self));
    } else {
      beforeModalHide(self, force);
    }
  }

  update() {
    const self = this;

    if (hasClass(self.element, showClass)) setModalScrollbar(self);
  }

  dispose() {
    const self = this;
    self.hide(1); // forced call

    toggleModalHandler(self);

    super.dispose(modalComponent);
  }
}

Modal.init = {
  component: modalComponent,
  selector: modalSelector,
  constructor: Modal,
};

/* Native JavaScript for Bootstrap 5 | OffCanvas
------------------------------------------------ */

// OFFCANVAS PRIVATE GC
// ====================
const offcanvasString = 'offcanvas';
const offcanvasComponent = 'Offcanvas';
const OffcanvasSelector = `.${offcanvasString}`;
const offcanvasToggleSelector = `[${dataBsToggle}="${offcanvasString}"]`;
const offcanvasDismissSelector = `[${dataBsDismiss}="${offcanvasString}"]`;
const offcanvasTogglingClass = `${offcanvasString}-toggling`;
const offcanvasDefaultOptions = {
  backdrop: true, // boolean
  keyboard: true, // boolean
  scroll: false, // boolean
};

// OFFCANVAS CUSTOM EVENTS
// =======================
const showOffcanvasEvent = bootstrapCustomEvent(`show.bs.${offcanvasString}`);
const shownOffcanvasEvent = bootstrapCustomEvent(`shown.bs.${offcanvasString}`);
const hideOffcanvasEvent = bootstrapCustomEvent(`hide.bs.${offcanvasString}`);
const hiddenOffcanvasEvent = bootstrapCustomEvent(`hidden.bs.${offcanvasString}`);

// OFFCANVAS PRIVATE METHODS
// =========================
function setOffCanvasScrollbar(self) {
  const bd = document.body;
  const html = document.documentElement;
  const openOffCanvas = hasClass(bd, modalOpenClass);
  const bodyOverflow = html.clientHeight !== html.scrollHeight
                    || bd.clientHeight !== bd.scrollHeight;
  setScrollbar(self.scrollbarWidth, bodyOverflow, openOffCanvas);
}

function toggleOffcanvasEvents(self, add) {
  const action = add ? addEventListener : removeEventListener;
  self.triggers.forEach((btn) => btn[action]('click', offcanvasTriggerHandler));
}

function toggleOffCanvasDismiss(add) {
  const action = add ? addEventListener : removeEventListener;
  document[action]('keydown', offcanvasKeyDismissHandler);
  document[action]('click', offcanvasDismissHandler);
}

function beforeOffcanvasShow(self) {
  const { element, options } = self;

  if (!options.scroll) {
    addClass(document.body, modalOpenClass);
    setOffCanvasScrollbar(self);
  }

  addClass(element, offcanvasTogglingClass);
  addClass(element, showClass);
  element.style.visibility = 'visible';

  emulateTransitionEnd(element, () => showOffcanvasComplete(self));
}

function beforeOffcanvasHide(self) {
  const { element, options } = self;
  const currentOpen = getCurrentOpen();

  element.blur();

  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {
    hideOverlay();
    emulateTransitionEnd(overlay, () => hideOffcanvasComplete(self));
  } else hideOffcanvasComplete(self);
}

// OFFCANVAS EVENT HANDLERS
// ========================
function offcanvasTriggerHandler(e) {
  const trigger = this.closest(offcanvasToggleSelector);
  const element = getTargetElement(trigger);
  const self = element && element[offcanvasComponent];

  if (trigger.tagName === 'A') e.preventDefault();
  if (self) {
    self.relatedTarget = trigger;
    self.toggle();
  }
}

function offcanvasDismissHandler(e) {
  const element = queryElement(offcanvasActiveSelector);
  if (!element) return;

  const offCanvasDismiss = queryElement(offcanvasDismissSelector, element);
  const self = element[offcanvasComponent];
  if (!self) return;

  const { options, open, triggers } = self;
  const { target } = e;
  const trigger = target.closest(offcanvasToggleSelector);

  if (trigger && trigger.tagName === 'A') e.preventDefault();

  if (open && ((!element.contains(target) && options.backdrop
    && (!trigger || (trigger && !triggers.includes(trigger))))
    || offCanvasDismiss.contains(target))) {
    self.relatedTarget = target === offCanvasDismiss ? offCanvasDismiss : null;
    self.hide();
  }
}

function offcanvasKeyDismissHandler({ which }) {
  const element = queryElement(offcanvasActiveSelector);
  if (!element) return;

  const self = element[offcanvasComponent];

  if (self && self.options.keyboard && which === 27) {
    self.relatedTarget = null;
    self.hide();
  }
}

function showOffcanvasComplete(self) {
  const { element, triggers, relatedTarget } = self;
  removeClass(element, offcanvasTogglingClass);

  element.removeAttribute(ariaHidden);
  element.setAttribute(ariaModal, true);
  element.setAttribute('role', 'dialog');
  self.isAnimating = false;

  if (triggers.length) {
    triggers.forEach((btn) => btn.setAttribute(ariaExpanded, true));
  }

  shownOffcanvasEvent.relatedTarget = relatedTarget || null;
  element.dispatchEvent(shownOffcanvasEvent);

  toggleOffCanvasDismiss(1);
  setFocus(element);
}

function hideOffcanvasComplete(self) {
  const {
    element, options, relatedTarget, triggers,
  } = self;
  const currentOpen = getCurrentOpen();

  element.setAttribute(ariaHidden, true);
  element.removeAttribute(ariaModal);
  element.removeAttribute('role');
  element.style.visibility = '';
  self.open = false;
  self.isAnimating = false;

  if (triggers.length) {
    triggers.forEach((btn) => btn.setAttribute(ariaExpanded, false));
    const visibleTrigger = triggers.find((x) => isVisible(x));
    if (visibleTrigger) setFocus(visibleTrigger);
  }

  // handle new offcanvas showing up
  if (!currentOpen) {
    if (options.backdrop) removeOverlay();
    if (!options.scroll) {
      resetScrollbar();
      removeClass(document.body, modalOpenClass);
    }
  }

  hiddenOffcanvasEvent.relatedTarget = relatedTarget || null;
  element.dispatchEvent(hiddenOffcanvasEvent);
  removeClass(element, offcanvasTogglingClass);

  toggleOffCanvasDismiss();
}

// OFFCANVAS DEFINITION
// ====================
class Offcanvas extends BaseComponent {
  constructor(target, config) {
    super(offcanvasComponent, target, offcanvasDefaultOptions, config);
    const self = this;

    // instance element
    const { element } = self;

    // all the triggering buttons
    self.triggers = Array.from(document.querySelectorAll(offcanvasToggleSelector))
      .filter((btn) => getTargetElement(btn) === element);

    // additional instance property
    self.open = false;
    self.isAnimating = false;
    self.scrollbarWidth = measureScrollbar();

    // attach event listeners
    toggleOffcanvasEvents(self, 1);
  }

  // OFFCANVAS PUBLIC METHODS
  // ========================
  toggle() {
    const self = this;
    return self.open ? self.hide() : self.show();
  }

  show() {
    const self = this[offcanvasComponent] ? this[offcanvasComponent] : this;
    const {
      element, options, isAnimating, relatedTarget,
    } = self;
    let overlayDelay = 0;

    if (self.open || isAnimating) return;

    showOffcanvasEvent.relatedTarget = relatedTarget || null;
    element.dispatchEvent(showOffcanvasEvent);

    if (showOffcanvasEvent.defaultPrevented) return;

    // we elegantly hide any opened modal/offcanvas
    const currentOpen = getCurrentOpen();
    if (currentOpen && currentOpen !== element) {
      const that = currentOpen[offcanvasComponent]
        ? currentOpen[offcanvasComponent]
        : currentOpen.Modal;
      that.hide();
    }

    self.open = true;
    self.isAnimating = true;

    if (options.backdrop) {
      if (!queryElement(`.${modalBackdropClass}`)) {
        appendOverlay(1);
      }

      overlayDelay = getElementTransitionDuration(overlay);

      if (!hasClass(overlay, showClass)) showOverlay();

      setTimeout(() => beforeOffcanvasShow(self), overlayDelay);
    } else beforeOffcanvasShow(self);
  }

  hide(force) {
    const self = this;
    const { element, isAnimating, relatedTarget } = self;

    if (!self.open || isAnimating) return;

    hideOffcanvasEvent.relatedTarget = relatedTarget || null;
    element.dispatchEvent(hideOffcanvasEvent);
    if (hideOffcanvasEvent.defaultPrevented) return;

    self.isAnimating = true;
    addClass(element, offcanvasTogglingClass);
    removeClass(element, showClass);

    if (!force) {
      emulateTransitionEnd(element, () => beforeOffcanvasHide(self));
    } else beforeOffcanvasHide(self);
  }

  dispose() {
    const self = this;
    self.hide(1);
    toggleOffcanvasEvents(self);
    super.dispose(offcanvasComponent);
  }
}

Offcanvas.init = {
  component: offcanvasComponent,
  selector: OffcanvasSelector,
  constructor: Offcanvas,
};

const ariaDescribedBy = 'aria-describedby';

var tipClassPositions = {
  top: 'top', bottom: 'bottom', left: 'start', right: 'end',
};

function isVisibleTip(tip, container) {
  return container.contains(tip);
}

function isMedia(element) {
  return [SVGElement, HTMLImageElement, HTMLVideoElement]
    .some((mediaType) => element instanceof mediaType);
}

function closestRelative(element) {
  let retval = null;
  let el = element;
  while (el !== document.body) {
    el = el.parentElement;
    if (getComputedStyle(el).position === 'relative') {
      retval = el;
      break;
    }
  }
  return retval;
}

// both popovers and tooltips (this, event)
function styleTip(self, e) {
  const tipClasses = /\b(top|bottom|start|end)+/;
  const tip = self.tooltip || self.popover;
  // reset tip style
  tip.style.top = '';
  tip.style.left = '';
  tip.style.right = '';
  // continue with metrics
  const isPopover = !!self.popover;
  let tipDimensions = { w: tip.offsetWidth, h: tip.offsetHeight };
  const windowWidth = (document.documentElement.clientWidth || document.body.clientWidth);
  const windowHeight = (document.documentElement.clientHeight || document.body.clientHeight);
  const { element, options, arrow } = self;
  let { container, placement } = options;
  let parentIsBody = container === document.body;
  const targetPosition = getComputedStyle(element).position;
  const parentPosition = getComputedStyle(container).position;
  const staticParent = !parentIsBody && parentPosition === 'static';
  let relativeParent = !parentIsBody && parentPosition === 'relative';
  const relContainer = staticParent && closestRelative(container);
  // static containers should refer to another relative container or the body
  container = relContainer || container;
  relativeParent = staticParent && relContainer ? 1 : relativeParent;
  parentIsBody = container === document.body;
  const parentRect = container.getBoundingClientRect();
  const leftBoundry = relativeParent ? parentRect.left : 0;
  const rightBoundry = relativeParent ? parentRect.right : windowWidth;
  // this case should not be possible
  // absoluteParent = !parentIsBody && parentPosition === 'absolute',
  // this case requires a container with placement: relative
  const absoluteTarget = targetPosition === 'absolute';
  const targetRect = element.getBoundingClientRect();
  const scroll = parentIsBody
    ? { x: window.pageXOffset, y: window.pageYOffset }
    : { x: container.scrollLeft, y: container.scrollTop };
  const elemDimensions = { w: element.offsetWidth, h: element.offsetHeight };
  const top = relativeParent ? element.offsetTop : targetRect.top;
  const left = relativeParent ? element.offsetLeft : targetRect.left;
  // reset arrow style
  arrow.style.top = '';
  arrow.style.left = '';
  arrow.style.right = '';
  let topPosition;
  let leftPosition;
  let rightPosition;
  let arrowTop;
  let arrowLeft;
  let arrowRight;

  // check placement
  let topExceed = targetRect.top - tipDimensions.h < 0;
  let bottomExceed = targetRect.top + tipDimensions.h + elemDimensions.h >= windowHeight;
  let leftExceed = targetRect.left - tipDimensions.w < leftBoundry;
  let rightExceed = targetRect.left + tipDimensions.w + elemDimensions.w >= rightBoundry;

  topExceed = ['left', 'right'].includes(placement)
    ? targetRect.top + elemDimensions.h / 2 - tipDimensions.h / 2 < 0
    : topExceed;
  bottomExceed = ['left', 'right'].includes(placement)
    ? targetRect.top + tipDimensions.h / 2 + elemDimensions.h / 2 >= windowHeight
    : bottomExceed;
  leftExceed = ['top', 'bottom'].includes(placement)
    ? targetRect.left + elemDimensions.w / 2 - tipDimensions.w / 2 < leftBoundry
    : leftExceed;
  rightExceed = ['top', 'bottom'].includes(placement)
    ? targetRect.left + tipDimensions.w / 2 + elemDimensions.w / 2 >= rightBoundry
    : rightExceed;

  // recompute placement
  // first, when both left and right limits are exceeded, we fall back to top|bottom
  placement = (['left', 'right'].includes(placement)) && leftExceed && rightExceed ? 'top' : placement;
  placement = placement === 'top' && topExceed ? 'bottom' : placement;
  placement = placement === 'bottom' && bottomExceed ? 'top' : placement;
  placement = placement === 'left' && leftExceed ? 'right' : placement;
  placement = placement === 'right' && rightExceed ? 'left' : placement;

  // update tooltip/popover class
  if (!tip.className.includes(placement)) {
    tip.className = tip.className.replace(tipClasses, tipClassPositions[placement]);
  }
  // if position has changed, update tip dimensions
  tipDimensions = { w: tip.offsetWidth, h: tip.offsetHeight };

  // we check the computed width & height and update here
  const arrowWidth = arrow.offsetWidth || 0;
  const arrowHeight = arrow.offsetHeight || 0;
  const arrowAdjust = arrowWidth / 2;

  // compute tooltip / popover coordinates
  if (['left', 'right'].includes(placement)) { // secondary|side positions
    if (placement === 'left') { // LEFT
      leftPosition = left + scroll.x - tipDimensions.w - (isPopover ? arrowWidth : 0);
    } else { // RIGHT
      leftPosition = left + scroll.x + elemDimensions.w + (isPopover ? arrowWidth : 0);
    }

    // adjust top and arrow
    if (topExceed) {
      topPosition = top + scroll.y;
      arrowTop = elemDimensions.h / 2 - arrowWidth;
    } else if (bottomExceed) {
      topPosition = top + scroll.y - tipDimensions.h + elemDimensions.h;
      arrowTop = tipDimensions.h - elemDimensions.h / 2 - arrowWidth;
    } else {
      topPosition = top + scroll.y - tipDimensions.h / 2 + elemDimensions.h / 2;
      arrowTop = tipDimensions.h / 2 - arrowHeight / 2;
    }
  } else if (['top', 'bottom'].includes(placement)) {
    if (e && isMedia(element)) {
      const eX = !relativeParent ? e.pageX : e.layerX + (absoluteTarget ? element.offsetLeft : 0);
      const eY = !relativeParent ? e.pageY : e.layerY + (absoluteTarget ? element.offsetTop : 0);

      if (placement === 'top') {
        topPosition = eY - tipDimensions.h - (isPopover ? arrowWidth : arrowHeight);
      } else {
        topPosition = eY + arrowHeight;
      }

      // adjust left | right and also the arrow
      if (e.clientX - tipDimensions.w / 2 < leftBoundry) { // when exceeds left
        leftPosition = 0;
        arrowLeft = eX - arrowAdjust;
      } else if (e.clientX + tipDimensions.w * 0.51 >= rightBoundry) { // when exceeds right
        leftPosition = 'auto';
        rightPosition = 0;
        arrowLeft = tipDimensions.w - (rightBoundry - eX) - arrowAdjust;
      } else { // normal top/bottom
        leftPosition = eX - tipDimensions.w / 2;
        arrowLeft = tipDimensions.w / 2 - arrowAdjust;
      }
    } else {
      if (placement === 'top') {
        topPosition = top + scroll.y - tipDimensions.h - (isPopover ? arrowHeight : 0);
      } else { // BOTTOM
        topPosition = top + scroll.y + elemDimensions.h + (isPopover ? arrowHeight : 0);
      }

      // adjust left | right and also the arrow
      if (leftExceed) {
        leftPosition = 0;
        arrowLeft = left + elemDimensions.w / 2 - arrowAdjust;
      } else if (rightExceed) {
        leftPosition = 'auto';
        rightPosition = 0;
        arrowRight = elemDimensions.w / 2 + (parentRect.right - targetRect.right) - arrowAdjust;
      } else {
        leftPosition = left + scroll.x - tipDimensions.w / 2 + elemDimensions.w / 2;
        arrowLeft = tipDimensions.w / 2 - arrowAdjust;
      }
    }
  }

  // apply style to tooltip/popover and its arrow
  tip.style.top = `${topPosition}px`;
  tip.style.left = leftPosition === 'auto' ? leftPosition : `${leftPosition}px`;
  tip.style.right = rightPosition !== undefined ? `${rightPosition}px` : '';
  // update arrow placement or clear side
  if (arrowTop !== undefined) {
    arrow.style.top = `${arrowTop}px`;
  }

  if (arrowLeft !== undefined) {
    arrow.style.left = `${arrowLeft}px`;
  } else if (arrowRight !== undefined) {
    arrow.style.right = `${arrowRight}px`;
  }
}

let bsnUID = 1;

// popover, tooltip, scrollspy need a unique id
function getUID(element, key) {
  bsnUID += 1;
  return element[key] || bsnUID;
}

function getTipContainer(element) {
  // maybe the element is inside a modal
  const modal = element.closest('.modal');

  // OR maybe the element is inside a fixed navbar
  const navbarFixed = element.closest(`.${fixedTopClass},.${fixedBottomClass}`);

  // set default container option appropriate for the context
  return modal || navbarFixed || document.body;
}

/* Native JavaScript for Bootstrap 5 | Popover
---------------------------------------------- */

// POPOVER PRIVATE GC
// ==================
const popoverString = 'popover';
const popoverComponent = 'Popover';
const popoverSelector = `[${dataBsToggle}="${popoverString}"],[data-tip="${popoverString}"]`;
const popoverDefaultOptions = {
  template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', // string
  title: null, // string
  content: null, // string
  sanitizeFn: null, // function
  customClass: null, // string
  dismissible: false, // boolean
  animation: true, // boolean
  trigger: 'hover', // string
  placement: 'top', // string
  delay: 200, // number
};

// POPOVER PRIVATE GC
// ==================
const isIphone = /(iPhone|iPod|iPad)/.test(navigator.userAgent);
// popoverArrowClass = `${popoverString}-arrow`,
const popoverHeaderClass = `${popoverString}-header`;
const popoverBodyClass = `${popoverString}-body`;
// close btn for dissmissible popover
let popoverCloseButton = '<button type="button" class="btn-close"></button>';

// POPOVER CUSTOM EVENTS
// =====================
const showPopoverEvent = bootstrapCustomEvent(`show.bs.${popoverString}`);
const shownPopoverEvent = bootstrapCustomEvent(`shown.bs.${popoverString}`);
const hidePopoverEvent = bootstrapCustomEvent(`hide.bs.${popoverString}`);
const hiddenPopoverEvent = bootstrapCustomEvent(`hidden.bs.${popoverString}`);

// POPOVER EVENT HANDLERS
// ======================
function popoverForceFocus() {
  setFocus(this);
}

function popoverTouchHandler({ target }) {
  const self = this;
  const { popover, element } = self;

  if ((popover && popover.contains(target)) // popover includes touch target
    || target === element // OR touch target is element
    || element.contains(target)) ; else {
    self.hide();
  }
}

// POPOVER PRIVATE METHODS
// =======================
function createPopover(self) {
  const { id, options } = self;
  const {
    animation, customClass, sanitizeFn, placement, dismissible,
  } = options;
  let { title, content, template } = options;

  // set initial popover class
  const placementClass = `bs-${popoverString}-${tipClassPositions[placement]}`;

  // fixing #233
  title = title ? title.trim() : null;
  content = content ? content.trim() : null;

  // sanitize title && content
  if (sanitizeFn) {
    title = title ? sanitizeFn(title) : null;
    content = content ? sanitizeFn(content) : null;
    template = template ? sanitizeFn(template) : null;
    popoverCloseButton = sanitizeFn(popoverCloseButton);
  }

  self.popover = document.createElement('div');
  const { popover } = self;

  // set id and aria-describedby
  popover.setAttribute('id', id);
  popover.setAttribute('role', 'tooltip');

  // load template
  const popoverTemplate = document.createElement('div');
  popoverTemplate.innerHTML = template.trim();
  popover.className = popoverTemplate.firstChild.className;
  popover.innerHTML = popoverTemplate.firstChild.innerHTML;

  const popoverHeader = queryElement(`.${popoverHeaderClass}`, popover);
  const popoverBody = queryElement(`.${popoverBodyClass}`, popover);

  // set arrow
  self.arrow = queryElement(`.${popoverString}-arrow`, popover);

  // set dismissible button
  if (dismissible) {
    title = title ? title + popoverCloseButton : title;
    content = title === null ? +popoverCloseButton : content;
  }

  // fill the template with content from data attributes
  if (title && popoverHeader) popoverHeader.innerHTML = title.trim();
  if (content && popoverBody) popoverBody.innerHTML = content.trim();

  // set popover animation and placement
  if (!hasClass(popover, popoverString)) addClass(popover, popoverString);
  if (animation && !hasClass(popover, fadeClass)) addClass(popover, fadeClass);
  if (customClass && !hasClass(popover, customClass)) {
    addClass(popover, customClass);
  }
  if (!hasClass(popover, placementClass)) addClass(popover, placementClass);
}

function removePopover(self) {
  const { element, popover, options } = self;
  element.removeAttribute(ariaDescribedBy);
  options.container.removeChild(popover);
  self.timer = null;
}

function togglePopoverHandlers(self, add) {
  const action = add ? addEventListener : removeEventListener;
  const { element, options } = self;
  const { trigger, dismissible } = options;
  self.enabled = !!add;

  if (trigger === 'hover') {
    element[action]('mousedown', self.show);
    element[action]('mouseenter', self.show);
    if (isMedia(element)) element[action]('mousemove', self.update, passiveHandler);
    if (!dismissible) element[action]('mouseleave', self.hide);
  } else if (trigger === 'click') {
    element[action](trigger, self.toggle);
  } else if (trigger === 'focus') {
    if (isIphone) element[action]('click', popoverForceFocus);
    element[action]('focusin', self.show);
  }
}

function dismissHandlerToggle(self, add) {
  const action = add ? addEventListener : removeEventListener;
  const { options, element, popover } = self;
  const { trigger, dismissible } = options;

  if (dismissible) {
    const [btnClose] = popover.getElementsByClassName('btn-close');
    if (btnClose) btnClose[action]('click', self.hide);
  } else {
    if (trigger === 'focus') element[action]('focusout', self.hide);
    if (trigger === 'hover') document[action]('touchstart', popoverTouchHandler, passiveHandler);
  }

  if (!isMedia(element)) {
    window[action]('scroll', self.update, passiveHandler);
    window[action]('resize', self.update, passiveHandler);
  }
}

function popoverShowTrigger(self) {
  dismissHandlerToggle(self, 1);
  self.element.dispatchEvent(shownPopoverEvent);
}

function popoverHideTrigger(self) {
  dismissHandlerToggle(self);
  removePopover(self);
  self.element.dispatchEvent(hiddenPopoverEvent);
}

// POPOVER DEFINITION
// ==================
class Popover extends BaseComponent {
  constructor(target, config) {
    popoverDefaultOptions.container = getTipContainer(queryElement(target));
    super(popoverComponent, target, popoverDefaultOptions, config);

    // bind
    const self = this;

    // initialization element
    const { element } = self;
    // additional instance properties
    self.timer = null;
    self.popover = null;
    self.arrow = null;
    self.enabled = false;
    // set unique ID for aria-describedby
    self.id = `${popoverString}-${getUID(element)}`;

    // set instance options
    const { options } = self;

    // media elements only work with body as a container
    self.options.container = isMedia(element)
      ? popoverDefaultOptions.container
      : queryElement(options.container);

    // reset default container
    popoverDefaultOptions.container = null;

    // invalidate when no content is set
    if (!options.content) return;

    // crate popover
    createPopover(self);

    // bind
    self.update = self.update.bind(self);

    // attach event listeners
    togglePopoverHandlers(self, 1);
  }

  update(e) {
    styleTip(this, e);
  }

  // POPOVER PUBLIC METHODS
  // ======================
  toggle(e) {
    const self = e ? this[popoverComponent] : this;
    const { popover, options } = self;
    if (!isVisibleTip(popover, options.container)) self.show();
    else self.hide();
  }

  show(e) {
    const self = e ? this[popoverComponent] : this;
    const {
      element, popover, options, id,
    } = self;
    const { container } = options;

    clearTimeout(self.timer);

    self.timer = setTimeout(() => {
      if (!isVisibleTip(popover, container)) {
        element.dispatchEvent(showPopoverEvent);
        if (showPopoverEvent.defaultPrevented) return;

        // append to the container
        container.appendChild(popover);
        element.setAttribute(ariaDescribedBy, id);

        self.update(e);
        if (!hasClass(popover, showClass)) addClass(popover, showClass);

        if (options.animation) emulateTransitionEnd(popover, () => popoverShowTrigger(self));
        else popoverShowTrigger(self);
      }
    }, 17);
  }

  hide(e) {
    let self;
    if (e && this[popoverComponent]) {
      self = this[popoverComponent];
    } else if (e) { // dismissible popover
      const dPopover = this.closest(`.${popoverString}`);
      const dEl = dPopover && queryElement(`[${ariaDescribedBy}="${dPopover.id}"]`);
      self = dEl[popoverComponent];
    } else {
      self = this;
    }
    const { element, popover, options } = self;

    clearTimeout(self.timer);

    self.timer = setTimeout(() => {
      if (isVisibleTip(popover, options.container)) {
        element.dispatchEvent(hidePopoverEvent);
        if (hidePopoverEvent.defaultPrevented) return;

        removeClass(popover, showClass);

        if (options.animation) emulateTransitionEnd(popover, () => popoverHideTrigger(self));
        else popoverHideTrigger(self);
      }
    }, options.delay + 17);
  }

  enable() {
    const self = this;
    const { enabled } = self;
    if (!enabled) {
      togglePopoverHandlers(self, 1);
      self.enabled = !enabled;
    }
  }

  disable() {
    const self = this;
    const { enabled, popover, options } = self;
    if (enabled) {
      if (isVisibleTip(popover, options.container) && options.animation) {
        self.hide();

        setTimeout(
          () => togglePopoverHandlers(self),
          getElementTransitionDuration(popover) + options.delay + 17,
        );
      } else {
        togglePopoverHandlers(self);
      }
      self.enabled = !enabled;
    }
  }

  toggleEnabled() {
    const self = this;
    if (!self.enabled) self.enable();
    else self.disable();
  }

  dispose() {
    const self = this;
    const { popover, options } = self;
    const { container, animation } = options;
    if (animation && isVisibleTip(popover, container)) {
      options.delay = 0; // reset delay
      self.hide();
      emulateTransitionEnd(popover, () => togglePopoverHandlers(self));
    } else {
      togglePopoverHandlers(self);
    }
    super.dispose(popoverComponent);
  }
}

Popover.init = {
  component: popoverComponent,
  selector: popoverSelector,
  constructor: Popover,
};

/* Native JavaScript for Bootstrap 5 | ScrollSpy
------------------------------------------------ */

// SCROLLSPY PRIVATE GC
// ====================
const scrollspyString = 'scrollspy';
const scrollspyComponent = 'ScrollSpy';
const scrollspySelector = '[data-bs-spy="scroll"]';
const scrollSpyDefaultOptions = {
  offset: 10,
  target: null,
};

// SCROLLSPY CUSTOM EVENT
// ======================
const activateScrollSpy = bootstrapCustomEvent(`activate.bs.${scrollspyString}`);

// SCROLLSPY PRIVATE METHODS
// =========================
function updateSpyTargets(self) {
  const {
    target, scrollTarget, isWindow, options, itemsLength, scrollHeight,
  } = self;
  const { offset } = options;
  const links = target.getElementsByTagName('A');

  self.scrollTop = isWindow
    ? scrollTarget.pageYOffset
    : scrollTarget.scrollTop;

  // only update items/offsets once or with each mutation
  if (itemsLength !== links.length || getScrollHeight(scrollTarget) !== scrollHeight) {
    let href;
    let targetItem;
    let rect;

    // reset arrays & update
    self.items = [];
    self.offsets = [];
    self.scrollHeight = getScrollHeight(scrollTarget);
    self.maxScroll = self.scrollHeight - getOffsetHeight(self);

    Array.from(links).forEach((link) => {
      href = link.getAttribute('href');
      targetItem = href && href.charAt(0) === '#' && href.slice(-1) !== '#' && queryElement(href);

      if (targetItem) {
        self.items.push(link);
        rect = targetItem.getBoundingClientRect();
        self.offsets.push((isWindow ? rect.top + self.scrollTop : targetItem.offsetTop) - offset);
      }
    });
    self.itemsLength = self.items.length;
  }
}

function getScrollHeight(scrollTarget) {
  return scrollTarget.scrollHeight || Math.max(
    document.body.scrollHeight,
    document.documentElement.scrollHeight,
  );
}

function getOffsetHeight({ element, isWindow }) {
  if (!isWindow) return element.getBoundingClientRect().height;
  return window.innerHeight;
}

function clear(target) {
  Array.from(target.getElementsByTagName('A')).forEach((item) => {
    if (hasClass(item, activeClass)) removeClass(item, activeClass);
  });
}

function activate(self, item) {
  const { target, element } = self;
  clear(target);
  self.activeItem = item;
  addClass(item, activeClass);

  // activate all parents
  const parents = [];
  let parentItem = item;
  while (parentItem !== document.body) {
    parentItem = parentItem.parentNode;
    if (hasClass(parentItem, 'nav') || hasClass(parentItem, 'dropdown-menu')) parents.push(parentItem);
  }

  parents.forEach((menuItem) => {
    const parentLink = menuItem.previousElementSibling;

    if (parentLink && !hasClass(parentLink, activeClass)) {
      addClass(parentLink, activeClass);
    }
  });

  // update relatedTarget and dispatch
  activateScrollSpy.relatedTarget = item;
  element.dispatchEvent(activateScrollSpy);
}

function toggleSpyHandlers(self, add) {
  const action = add ? addEventListener : removeEventListener;
  self.scrollTarget[action]('scroll', self.refresh, passiveHandler);
}

// SCROLLSPY DEFINITION
// ====================
class ScrollSpy extends BaseComponent {
  constructor(target, config) {
    super(scrollspyComponent, target, scrollSpyDefaultOptions, config);
    // bind
    const self = this;

    // initialization element & options
    const { element, options } = self;

    // additional properties
    self.target = queryElement(options.target);

    // invalidate
    if (!self.target) return;

    // set initial state
    self.scrollTarget = element.clientHeight < element.scrollHeight ? element : window;
    self.isWindow = self.scrollTarget === window;
    self.scrollTop = 0;
    self.maxScroll = 0;
    self.scrollHeight = 0;
    self.activeItem = null;
    self.items = [];
    self.offsets = [];

    // bind events
    self.refresh = self.refresh.bind(self);

    // add event handlers
    toggleSpyHandlers(self, 1);

    self.refresh();
  }

  // SCROLLSPY PUBLIC METHODS
  // ========================
  refresh() {
    const self = this;
    const { target } = self;

    // check if target is visible and invalidate
    if (target.offsetHeight === 0) return;

    updateSpyTargets(self);

    const {
      scrollTop, maxScroll, itemsLength, items, activeItem,
    } = self;

    if (scrollTop >= maxScroll) {
      const newActiveItem = items[itemsLength - 1];

      if (activeItem !== newActiveItem) {
        activate(self, newActiveItem);
      }
      return;
    }

    const { offsets } = self;

    if (activeItem && scrollTop < offsets[0] && offsets[0] > 0) {
      self.activeItem = null;
      clear(target);
      return;
    }

    items.forEach((item, i) => {
      if (activeItem !== item && scrollTop >= offsets[i]
        && (typeof offsets[i + 1] === 'undefined' || scrollTop < offsets[i + 1])) {
        activate(self, item);
      }
    });
  }

  dispose() {
    toggleSpyHandlers(this);
    super.dispose(scrollspyComponent);
  }
}

ScrollSpy.init = {
  component: scrollspyComponent,
  selector: scrollspySelector,
  constructor: ScrollSpy,
};

const ariaSelected = 'aria-selected';

/* Native JavaScript for Bootstrap 5 | Tab
------------------------------------------ */

// TAB PRIVATE GC
// ================
const tabString = 'tab';
const tabComponent = 'Tab';
const tabSelector = `[${dataBsToggle}="${tabString}"]`;

// TAB CUSTOM EVENTS
// =================
const showTabEvent = bootstrapCustomEvent(`show.bs.${tabString}`);
const shownTabEvent = bootstrapCustomEvent(`shown.bs.${tabString}`);
const hideTabEvent = bootstrapCustomEvent(`hide.bs.${tabString}`);
const hiddenTabEvent = bootstrapCustomEvent(`hidden.bs.${tabString}`);

let nextTab;
let nextTabContent;
let nextTabHeight;
let activeTab;
let activeTabContent;
let tabContainerHeight;
let tabEqualContents;

// TAB PRIVATE METHODS
// ===================
function triggerTabEnd(self) {
  const { tabContent, nav } = self;
  tabContent.style.height = '';
  removeClass(tabContent, collapsingClass);
  nav.isAnimating = false;
}

function triggerTabShow(self) {
  const { tabContent, nav } = self;

  if (tabContent) { // height animation
    if (tabEqualContents) {
      triggerTabEnd(self);
    } else {
      setTimeout(() => { // enables height animation
        tabContent.style.height = `${nextTabHeight}px`; // height animation
        reflow(tabContent);
        emulateTransitionEnd(tabContent, () => triggerTabEnd(self));
      }, 50);
    }
  } else {
    nav.isAnimating = false;
  }
  shownTabEvent.relatedTarget = activeTab;
  nextTab.dispatchEvent(shownTabEvent);
}

function triggerTabHide(self) {
  const { tabContent } = self;
  if (tabContent) {
    activeTabContent.style.float = 'left';
    nextTabContent.style.float = 'left';
    tabContainerHeight = activeTabContent.scrollHeight;
  }

  // update relatedTarget and dispatch event
  showTabEvent.relatedTarget = activeTab;
  hiddenTabEvent.relatedTarget = nextTab;
  nextTab.dispatchEvent(showTabEvent);
  if (showTabEvent.defaultPrevented) return;

  addClass(nextTabContent, activeClass);
  removeClass(activeTabContent, activeClass);

  if (tabContent) {
    nextTabHeight = nextTabContent.scrollHeight;
    tabEqualContents = nextTabHeight === tabContainerHeight;
    addClass(tabContent, collapsingClass);
    tabContent.style.height = `${tabContainerHeight}px`; // height animation
    reflow(tabContent);
    activeTabContent.style.float = '';
    nextTabContent.style.float = '';
  }

  if (hasClass(nextTabContent, fadeClass)) {
    setTimeout(() => {
      addClass(nextTabContent, showClass);
      emulateTransitionEnd(nextTabContent, () => {
        triggerTabShow(self);
      });
    }, 20);
  } else { triggerTabShow(self); }

  activeTab.dispatchEvent(hiddenTabEvent);
}

function getActiveTab({ nav }) {
  const activeTabs = nav.getElementsByClassName(activeClass);

  if (activeTabs.length === 1
    && !dropdownMenuClasses.some((c) => hasClass(activeTabs[0].parentNode, c))) {
    [activeTab] = activeTabs;
  } else if (activeTabs.length > 1) {
    activeTab = activeTabs[activeTabs.length - 1];
  }
  return activeTab;
}

function getActiveTabContent(self) {
  return queryElement(getActiveTab(self).getAttribute('href'));
}

function toggleTabHandler(self, add) {
  const action = add ? addEventListener : removeEventListener;
  self.element[action]('click', tabClickHandler);
}

// TAB EVENT HANDLER
// =================
function tabClickHandler(e) {
  const self = this[tabComponent];
  e.preventDefault();
  if (!self.nav.isAnimating) self.show();
}

// TAB DEFINITION
// ==============
class Tab extends BaseComponent {
  constructor(target) {
    super(tabComponent, target);
    // bind
    const self = this;

    // initialization element
    const { element } = self;

    // event targets
    self.nav = element.closest('.nav');
    const { nav } = self;
    self.dropdown = nav && queryElement(`.${dropdownMenuClasses[0]}-toggle`, nav);
    activeTabContent = getActiveTabContent(self);
    self.tabContent = supportTransition && activeTabContent.closest('.tab-content');
    tabContainerHeight = activeTabContent.scrollHeight;

    // set default animation state
    nav.isAnimating = false;

    // add event listener
    toggleTabHandler(self, 1);
  }

  // TAB PUBLIC METHODS
  // ==================
  show() { // the tab we clicked is now the nextTab tab
    const self = this;
    const { element, nav, dropdown } = self;
    nextTab = element;
    if (!hasClass(nextTab, activeClass)) {
      // this is the actual object, the nextTab tab content to activate
      nextTabContent = queryElement(nextTab.getAttribute('href'));
      activeTab = getActiveTab({ nav });
      activeTabContent = getActiveTabContent({ nav });

      // update relatedTarget and dispatch
      hideTabEvent.relatedTarget = nextTab;
      activeTab.dispatchEvent(hideTabEvent);
      if (hideTabEvent.defaultPrevented) return;

      nav.isAnimating = true;
      removeClass(activeTab, activeClass);
      activeTab.setAttribute(ariaSelected, 'false');
      addClass(nextTab, activeClass);
      nextTab.setAttribute(ariaSelected, 'true');

      if (dropdown) {
        if (!hasClass(element.parentNode, dropdownMenuClass)) {
          if (hasClass(dropdown, activeClass)) removeClass(dropdown, activeClass);
        } else if (!hasClass(dropdown, activeClass)) addClass(dropdown, activeClass);
      }

      if (hasClass(activeTabContent, fadeClass)) {
        removeClass(activeTabContent, showClass);
        emulateTransitionEnd(activeTabContent, () => triggerTabHide(self));
      } else {
        triggerTabHide(self);
      }
    }
  }

  dispose() {
    toggleTabHandler(this);
    super.dispose(tabComponent);
  }
}

Tab.init = {
  component: tabComponent,
  selector: tabSelector,
  constructor: Tab,
};

/* Native JavaScript for Bootstrap 5 | Toast
-------------------------------------------- */

// TOAST PRIVATE GC
// ================
const toastString = 'toast';
const toastComponent = 'Toast';
const toastSelector = `.${toastString}`;
const toastDismissSelector = `[${dataBsDismiss}="${toastString}"]`;
const showingClass = 'showing';
const hideClass = 'hide';
const toastDefaultOptions = {
  animation: true,
  autohide: true,
  delay: 500,
};

// TOAST CUSTOM EVENTS
// ===================
const showToastEvent = bootstrapCustomEvent(`show.bs.${toastString}`);
const hideToastEvent = bootstrapCustomEvent(`hide.bs.${toastString}`);
const shownToastEvent = bootstrapCustomEvent(`shown.bs.${toastString}`);
const hiddenToastEvent = bootstrapCustomEvent(`hidden.bs.${toastString}`);

// TOAST PRIVATE METHODS
// =====================
function showToastComplete(self) {
  const { element, options } = self;
  if (!options.animation) {
    removeClass(element, showingClass);
    addClass(element, showClass);
  }

  element.dispatchEvent(shownToastEvent);
  if (options.autohide) self.hide();
}

function hideToastComplete(self) {
  const { element } = self;
  addClass(element, hideClass);
  element.dispatchEvent(hiddenToastEvent);
}

function closeToast(self) {
  const { element, options } = self;
  removeClass(element, showClass);

  if (options.animation) {
    reflow(element);
    emulateTransitionEnd(element, () => hideToastComplete(self));
  } else {
    hideToastComplete(self);
  }
}

function openToast(self) {
  const { element, options } = self;
  removeClass(element, hideClass);

  if (options.animation) {
    reflow(element);
    addClass(element, showingClass);
    addClass(element, showClass);

    emulateTransitionEnd(element, () => showToastComplete(self));
  } else {
    showToastComplete(self);
  }
}

function toggleToastHandler(self, add) {
  const action = add ? addEventListener : removeEventListener;
  if (self.dismiss) {
    self.dismiss[action]('click', self.hide);
  }
}

// TOAST EVENT HANDLERS
// ====================
function completeDisposeToast(self) {
  clearTimeout(self.timer);
  toggleToastHandler(self);
}

// TOAST DEFINITION
// ================
class Toast extends BaseComponent {
  constructor(target, config) {
    super(toastComponent, target, toastDefaultOptions, config);
    // bind
    const self = this;

    // dismiss button
    self.dismiss = queryElement(toastDismissSelector, self.element);

    // bind
    self.show = self.show.bind(self);
    self.hide = self.hide.bind(self);

    // add event listener
    toggleToastHandler(self, 1);
  }

  // TOAST PUBLIC METHODS
  // ====================
  show() {
    const self = this;
    const { element } = self;
    if (element && hasClass(element, hideClass)) {
      element.dispatchEvent(showToastEvent);
      if (showToastEvent.defaultPrevented) return;

      addClass(element, fadeClass);
      clearTimeout(self.timer);
      self.timer = setTimeout(() => openToast(self), 10);
    }
  }

  hide(noTimer) {
    const self = this;
    const { element, options } = self;

    if (element && hasClass(element, showClass)) {
      element.dispatchEvent(hideToastEvent);
      if (hideToastEvent.defaultPrevented) return;

      clearTimeout(self.timer);
      self.timer = setTimeout(
        closeToast(self),
        noTimer ? 10 : options.delay,
      );
    }
  }

  dispose() {
    const self = this;
    const { element, options } = self;
    self.hide();

    if (options.animation) emulateTransitionEnd(element, () => completeDisposeToast(self));
    else completeDisposeToast(self);

    super.dispose(toastComponent);
  }
}

Toast.init = {
  component: toastComponent,
  selector: toastSelector,
  constructor: Toast,
};

const dataOriginalTitle = 'data-original-title';

/* Native JavaScript for Bootstrap 5 | Tooltip
---------------------------------------------- */

// TOOLTIP PRIVATE GC
// ==================
const tooltipString = 'tooltip';
const tooltipComponent = 'Tooltip';
const tooltipSelector = `[${dataBsToggle}="${tooltipString}"],[data-tip="${tooltipString}"]`;

const titleAttr = 'title';
const tooltipInnerClass = `${tooltipString}-inner`;
const tooltipDefaultOptions = {
  title: null,
  template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
  placement: 'top',
  animation: true,
  customClass: null,
  delay: 200,
  sanitizeFn: null,
};

// TOOLTIP CUSTOM EVENTS
// =====================
const showTooltipEvent = bootstrapCustomEvent(`show.bs.${tooltipString}`);
const shownTooltipEvent = bootstrapCustomEvent(`shown.bs.${tooltipString}`);
const hideTooltipEvent = bootstrapCustomEvent(`hide.bs.${tooltipString}`);
const hiddenTooltipEvent = bootstrapCustomEvent(`hidden.bs.${tooltipString}`);

// TOOLTIP PRIVATE METHODS
// =======================
function createTooltip(self) {
  const { options, id } = self;
  const placementClass = `bs-${tooltipString}-${tipClassPositions[options.placement]}`;
  let titleString = options.title.trim();

  // sanitize stuff
  if (options.sanitizeFn) {
    titleString = options.sanitizeFn(titleString);
    options.template = options.sanitizeFn(options.template);
  }

  if (!titleString) return;

  // create tooltip
  self.tooltip = document.createElement('div');
  const { tooltip } = self;

  // set aria
  tooltip.setAttribute('id', id);

  // set markup
  const tooltipMarkup = document.createElement('div');
  tooltipMarkup.innerHTML = options.template.trim();

  tooltip.className = tooltipMarkup.firstChild.className;
  tooltip.innerHTML = tooltipMarkup.firstChild.innerHTML;

  queryElement(`.${tooltipInnerClass}`, tooltip).innerHTML = titleString;

  // set arrow
  self.arrow = queryElement(`.${tooltipString}-arrow`, tooltip);

  // set class and role attribute
  tooltip.setAttribute('role', tooltipString);
  // set classes
  if (!hasClass(tooltip, tooltipString)) addClass(tooltip, tooltipString);
  if (options.animation && !hasClass(tooltip, fadeClass)) addClass(tooltip, fadeClass);
  if (options.customClass && !hasClass(tooltip, options.customClass)) {
    addClass(tooltip, options.customClass);
  }
  if (!hasClass(tooltip, placementClass)) addClass(tooltip, placementClass);
}

function removeTooltip(self) {
  const { element, options, tooltip } = self;
  element.removeAttribute(ariaDescribedBy);
  options.container.removeChild(tooltip);
  self.timer = null;
}

function disposeTooltipComplete(self) {
  const { element } = self;
  toggleTooltipHandlers(self);
  if (element.hasAttribute(dataOriginalTitle)) toggleTooltipTitle(self);
}
function toggleTooltipAction(self, add) {
  const action = add ? addEventListener : removeEventListener;

  document[action]('touchstart', tooltipTouchHandler, passiveHandler);

  if (!isMedia(self.element)) {
    window[action]('scroll', self.update, passiveHandler);
    window[action]('resize', self.update, passiveHandler);
  }
}
function tooltipShownAction(self) {
  toggleTooltipAction(self, 1);
  self.element.dispatchEvent(shownTooltipEvent);
}
function tooltipHiddenAction(self) {
  toggleTooltipAction(self);
  removeTooltip(self);
  self.element.dispatchEvent(hiddenTooltipEvent);
}
function toggleTooltipHandlers(self, add) {
  const action = add ? addEventListener : removeEventListener;
  const { element } = self;

  if (isMedia(element)) element[action]('mousemove', self.update, passiveHandler);
  element[action]('mousedown', self.show);
  element[action]('mouseenter', self.show);
  element[action]('mouseleave', self.hide);
}

function toggleTooltipTitle(self, content) {
  // [0 - add, 1 - remove] | [0 - remove, 1 - add]
  const titleAtt = [dataOriginalTitle, titleAttr];
  const { element } = self;

  element.setAttribute(titleAtt[content ? 0 : 1],
    (content || element.getAttribute(titleAtt[0])));
  element.removeAttribute(titleAtt[content ? 1 : 0]);
}

// TOOLTIP EVENT HANDLERS
// ======================
function tooltipTouchHandler({ target }) {
  const { tooltip, element } = this;
  if (tooltip.contains(target) || target === element || element.contains(target)) ; else {
    this.hide();
  }
}

// TOOLTIP DEFINITION
// ==================
class Tooltip extends BaseComponent {
  constructor(target, config) {
    // initialization element
    const element = queryElement(target);
    tooltipDefaultOptions.title = element.getAttribute(titleAttr);
    tooltipDefaultOptions.container = getTipContainer(element);
    super(tooltipComponent, element, tooltipDefaultOptions, config);

    // bind
    const self = this;

    // additional properties
    self.tooltip = null;
    self.arrow = null;
    self.timer = null;
    self.enabled = false;

    // instance options
    const { options } = self;

    // media elements only work with body as a container
    self.options.container = isMedia(element)
      ? tooltipDefaultOptions.container
      : queryElement(options.container);

    // reset default options
    tooltipDefaultOptions.container = null;
    tooltipDefaultOptions[titleAttr] = null;

    // invalidate
    if (!options.title) return;

    // all functions bind
    tooltipTouchHandler.bind(self);
    self.update = self.update.bind(self);

    // set title attributes and add event listeners
    if (element.hasAttribute(titleAttr)) toggleTooltipTitle(self, options.title);

    // create tooltip here
    self.id = `${tooltipString}-${getUID(element)}`;
    createTooltip(self);

    // attach events
    toggleTooltipHandlers(self, 1);
  }

  // TOOLTIP PUBLIC METHODS
  // ======================
  show(e) {
    const self = e ? this[tooltipComponent] : this;
    const {
      options, tooltip, element, id,
    } = self;
    clearTimeout(self.timer);
    self.timer = setTimeout(() => {
      if (!isVisibleTip(tooltip, options.container)) {
        element.dispatchEvent(showTooltipEvent);
        if (showTooltipEvent.defaultPrevented) return;

        // append to container
        options.container.appendChild(tooltip);
        element.setAttribute(ariaDescribedBy, id);

        self.update(e);
        if (!hasClass(tooltip, showClass)) addClass(tooltip, showClass);
        if (options.animation) emulateTransitionEnd(tooltip, () => tooltipShownAction(self));
        else tooltipShownAction(self);
      }
    }, 20);
  }

  hide(e) {
    const self = e ? this[tooltipComponent] : this;
    const { options, tooltip, element } = self;

    clearTimeout(self.timer);
    self.timer = setTimeout(() => {
      if (isVisibleTip(tooltip, options.container)) {
        element.dispatchEvent(hideTooltipEvent);
        if (hideTooltipEvent.defaultPrevented) return;

        removeClass(tooltip, showClass);
        if (options.animation) emulateTransitionEnd(tooltip, () => tooltipHiddenAction(self));
        else tooltipHiddenAction(self);
      }
    }, options.delay);
  }

  update(e) {
    styleTip(this, e);
  }

  toggle() {
    const self = this;
    const { tooltip, options } = self;
    if (!isVisibleTip(tooltip, options.container)) self.show();
    else self.hide();
  }

  enable() {
    const self = this;
    const { enabled } = self;
    if (!enabled) {
      toggleTooltipHandlers(self, 1);
      self.enabled = !enabled;
    }
  }

  disable() {
    const self = this;
    const { tooltip, options, enabled } = self;
    if (enabled) {
      if (!isVisibleTip(tooltip, options.container) && options.animation) {
        self.hide();

        setTimeout(
          () => toggleTooltipHandlers(self),
          getElementTransitionDuration(tooltip) + options.delay + 17,
        );
      } else {
        toggleTooltipHandlers(self);
      }
      self.enabled = !enabled;
    }
  }

  toggleEnabled() {
    const self = this;
    if (!self.enabled) self.enable();
    else self.disable();
  }

  dispose() {
    const self = this;
    const { tooltip, options } = self;

    if (options.animation && isVisibleTip(tooltip, options.container)) {
      options.delay = 0; // reset delay
      self.hide();
      emulateTransitionEnd(tooltip, () => disposeTooltipComplete(self));
    } else {
      disposeTooltipComplete(self);
    }
    super.dispose(tooltipComponent);
  }
}

Tooltip.init = {
  component: tooltipComponent,
  selector: tooltipSelector,
  constructor: Tooltip,
};

var version = "3.0.15";

// import { alertInit } from '../components/alert-native.js';
// import { buttonInit } from '../components/button-native.js';
// import { carouselInit } from '../components/carousel-native.js';
// import { collapseInit } from '../components/collapse-native.js';
// import { dropdownInit } from '../components/dropdown-native.js';
// import { modalInit } from '../components/modal-native.js';
// import { offcanvasInit } from '../components/offcanvas-native.js';
// import { popoverInit } from '../components/popover-native.js';
// import { scrollSpyInit } from '../components/scrollspy-native.js';
// import { tabInit } from '../components/tab-native.js';
// import { toastInit } from '../components/toast-native.js';
// import { tooltipInit } from '../components/tooltip-native.js';

const componentsInit = {
  Alert: Alert.init,
  Button: Button.init,
  Carousel: Carousel.init,
  Collapse: Collapse.init,
  Dropdown: Dropdown.init,
  Modal: Modal.init,
  Offcanvas: Offcanvas.init,
  Popover: Popover.init,
  ScrollSpy: ScrollSpy.init,
  Tab: Tab.init,
  Toast: Toast.init,
  Tooltip: Tooltip.init,
};

function initializeDataAPI(Konstructor, collection) {
  Array.from(collection).forEach((x) => new Konstructor(x));
}

function initCallback(context) {
  const lookUp = context instanceof Element ? context : document;

  Object.keys(componentsInit).forEach((comp) => {
    const { constructor, selector } = componentsInit[comp];
    initializeDataAPI(constructor, lookUp.querySelectorAll(selector));
  });
}

// bulk initialize all components
if (document.body) initCallback();
else {
  document.addEventListener('DOMContentLoaded', () => initCallback(), { once: true });
}

var index = {
  Alert,
  Button,
  Carousel,
  Collapse,
  Dropdown,
  Modal,
  Offcanvas,
  Popover,
  ScrollSpy,
  Tab,
  Toast,
  Tooltip,

  initCallback,
  Version: version,
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
const ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./src/assets/images/obs-create-text-source.png":
/*!******************************************************!*\
  !*** ./src/assets/images/obs-create-text-source.png ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "images/obs-create-text-source.png");

/***/ }),

/***/ "./src/assets/images/obs-websocket-connection.png":
/*!********************************************************!*\
  !*** ./src/assets/images/obs-websocket-connection.png ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "images/obs-websocket-connection.png");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/isomorphic-ws/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/isomorphic-ws/browser.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js

var ws = null

if (typeof WebSocket !== 'undefined') {
  ws = WebSocket
} else if (typeof MozWebSocket !== 'undefined') {
  ws = MozWebSocket
} else if (typeof __webpack_require__.g !== 'undefined') {
  ws = __webpack_require__.g.WebSocket || __webpack_require__.g.MozWebSocket
} else if (typeof window !== 'undefined') {
  ws = window.WebSocket || window.MozWebSocket
} else if (typeof self !== 'undefined') {
  ws = self.WebSocket || self.MozWebSocket
}

module.exports = ws


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/obs-websocket-js/lib/OBSWebSocket.js":
/*!***********************************************************!*\
  !*** ./node_modules/obs-websocket-js/lib/OBSWebSocket.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Socket = __webpack_require__(/*! ./Socket */ "./node_modules/obs-websocket-js/lib/Socket.js");
const Status = __webpack_require__(/*! ./Status */ "./node_modules/obs-websocket-js/lib/Status.js");
const debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('obs-websocket-js:Core');

let requestCounter = 0;

function generateMessageId() {
  return String(requestCounter++);
}

class OBSWebSocket extends Socket {
  /**
   * Generic Socket request method. Returns a promise.
   * Generates a messageId internally and will override any passed in the args.
   * Note that the requestType here is pre-marshaling and currently must match exactly what the websocket plugin is expecting.
   *
   * @param  {String}   requestType obs-websocket plugin expected request type.
   * @param  {Object}   [args={}]   request arguments.
   * @return {Promise}              Promise, passes the plugin response object.
   */
  send(requestType, args = {}) {
    args = args || {};

    return new Promise((resolve, reject) => {
      const messageId = generateMessageId();
      let rejectReason;

      if (!requestType) {
        rejectReason = Status.REQUEST_TYPE_NOT_SPECIFIED;
      }

      if (args && (typeof args !== 'object' || args === null || Array.isArray(args))) {
        rejectReason = Status.ARGS_NOT_OBJECT;
      }

      if (!this._connected) {
        rejectReason = Status.NOT_CONNECTED;
      }

      // Assign a temporary event listener for this particular messageId to uniquely identify the response.
      this.once(`obs:internal:message:id-${messageId}`, (err, data) => {
        if (err) {
          debug('[send:reject] %o', err);
          reject(err);
        } else {
          debug('[send:resolve] %o', data);
          resolve(data);
        }
      });

      // If we don't have a reason to fail fast, send the request to the socket.
      if (!rejectReason) {
        args['request-type'] = requestType;
        args['message-id'] = messageId;

        // Submit the request to the websocket.
        debug('[send] %s %s %o', messageId, requestType, args);
        try {
          this._socket.send(JSON.stringify(args));
        } catch (_) {
          // TODO: Consider inspecting the exception thrown to gleam some relevant info and pass that on.
          rejectReason = Status.SOCKET_EXCEPTION;
        }
      }

      // If the socket call was unsuccessful or bypassed, simulate its resolution.
      if (rejectReason) {
        this.emit(`obs:internal:message:id-${messageId}`, rejectReason);
      }
    });
  }

  /**
   * Generic Socket request method. Handles callbacks.
   * Internally calls `send` (which is promise-based). See `send`'s docs for more details.
   *
   * @param  {String}   requestType obs-websocket plugin expected request type.
   * @param  {Object}   [args={}]   request arguments.
   * @param  {Function} callback    Optional. callback(err, data)
   */
  sendCallback(requestType, args = {}, callback) { // eslint-disable-line default-param-last
    // Allow the `args` argument to be omitted.
    if (callback === undefined && typeof args === 'function') {
      callback = args;
      args = {};
    }

    // Perform the actual request, using `send`.
    this.send(requestType, args).then((...response) => {
      callback(null, ...response);
    }).catch(error => {
      callback(error);
    });
  }
}

module.exports = OBSWebSocket;


/***/ }),

/***/ "./node_modules/obs-websocket-js/lib/Socket.js":
/*!*****************************************************!*\
  !*** ./node_modules/obs-websocket-js/lib/Socket.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const WebSocket = __webpack_require__(/*! isomorphic-ws */ "./node_modules/isomorphic-ws/browser.js");
const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const hash = __webpack_require__(/*! ./util/authenticationHashing */ "./node_modules/obs-websocket-js/lib/util/authenticationHashing.js");
const Status = __webpack_require__(/*! ./Status */ "./node_modules/obs-websocket-js/lib/Status.js");
const debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('obs-websocket-js:Socket');
const logAmbiguousError = __webpack_require__(/*! ./util/logAmbiguousError */ "./node_modules/obs-websocket-js/lib/util/logAmbiguousError.js");
const camelCaseKeys = __webpack_require__(/*! ./util/camelCaseKeys */ "./node_modules/obs-websocket-js/lib/util/camelCaseKeys.js");

class Socket extends EventEmitter {
  constructor() {
    super();
    this._connected = false;
    this._socket = undefined;

    const originalEmit = this.emit;
    this.emit = function (...args) {
      debug('[emit] %s err: %o data: %o', ...args);
      originalEmit.apply(this, args);
    };
  }

  async connect(args = {}) {
    args = args || {};
    const address = args.address || 'localhost:4444';

    if (this._socket) {
      try {
        // Blindly try to close the socket.
        // Don't care if its already closed.
        // We just don't want any sockets to leak.
        this._socket.close();
      } catch (error) {
        // These errors are probably safe to ignore, but debug log them just in case.
        debug('Failed to close previous WebSocket:', error.message);
      }
    }

    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      try {
        await this._connect(address, Boolean(args.secure));
        await this._authenticate(args.password);
        resolve();
      } catch (err) {
        this._socket.close();
        this._connected = false;
        logAmbiguousError(debug, 'Connection failed:', err);
        reject(err);
      }
    });
  }

  /**
   * Opens a WebSocket connection to an obs-websocket server, but does not attempt any authentication.
   *
   * @param {String} address url without ws:// or wss:// prefix.
   * @param {Boolean} secure whether to us ws:// or wss://
   * @returns {Promise}
   * @private
   * @return {Promise} on attempted creation of WebSocket connection.
   */
  async _connect(address, secure) {
    return new Promise((resolve, reject) => {
      let settled = false;

      debug('Attempting to connect to: %s (secure: %s)', address, secure);
      this._socket = new WebSocket((secure ? 'wss://' : 'ws://') + address);

      // We only handle the initial connection error.
      // Beyond that, the consumer is responsible for adding their own generic `error` event listener.
      // FIXME: Unsure how best to expose additional information about the WebSocket error.
      this._socket.onerror = err => {
        if (settled) {
          logAmbiguousError(debug, 'Unknown Socket Error', err);
          this.emit('error', err);
          return;
        }

        settled = true;
        logAmbiguousError(debug, 'Websocket Connection failed:', err);
        reject(Status.CONNECTION_ERROR);
      };

      this._socket.onopen = () => {
        if (settled) {
          return;
        }

        this._connected = true;
        settled = true;

        debug('Connection opened: %s', address);
        this.emit('ConnectionOpened');
        resolve();
      };

      // Looks like this should be bound. We don't technically cancel the connection when the authentication fails.
      this._socket.onclose = () => {
        this._connected = false;
        debug('Connection closed: %s', address);
        this.emit('ConnectionClosed');
      };

      // This handler must be present before we can call _authenticate.
      this._socket.onmessage = msg => {
        debug('[OnMessage]: %o', msg);
        const message = camelCaseKeys(JSON.parse(msg.data));
        let err;
        let data;

        if (message.status === 'error') {
          err = message;
        } else {
          data = message;
        }

        // Emit the message with ID if available, otherwise try to find a non-messageId driven event.
        if (message.messageId) {
          this.emit(`obs:internal:message:id-${message.messageId}`, err, data);
        } else if (message.updateType) {
          this.emit(message.updateType, data);
        } else {
          logAmbiguousError(debug, 'Unrecognized Socket Message:', message);
          this.emit('message', message);
        }
      };
    });
  }

  /**
   * Authenticates to an obs-websocket server. Must already have an active connection before calling this method.
   *
   * @param {String} [password=''] authentication string.
   * @private
   * @return {Promise} on resolution of authentication call.
   */
  async _authenticate(password = '') {
    if (!this._connected) {
      throw Status.NOT_CONNECTED;
    }

    const auth = await this.send('GetAuthRequired');

    if (!auth.authRequired) {
      debug('Authentication not Required');
      this.emit('AuthenticationSuccess');
      return Status.AUTH_NOT_REQUIRED;
    }

    try {
      await this.send('Authenticate', {
        auth: hash(auth.salt, auth.challenge, password)
      });
    } catch (e) {
      debug('Authentication Failure %o', e);
      this.emit('AuthenticationFailure');
      throw e;
    }

    debug('Authentication Success');
    this.emit('AuthenticationSuccess');
  }

  /**
   * Close and disconnect the WebSocket connection.
   * FIXME: this should support a callback and return a Promise to match the connect method.
   *
   * @function
   * @category request
   */
  disconnect() {
    debug('Disconnect requested.');
    if (this._socket) {
      this._socket.close();
    }
  }
}

module.exports = Socket;


/***/ }),

/***/ "./node_modules/obs-websocket-js/lib/Status.js":
/*!*****************************************************!*\
  !*** ./node_modules/obs-websocket-js/lib/Status.js ***!
  \*****************************************************/
/***/ ((module) => {

module.exports = {
  NOT_CONNECTED: {
    status: 'error',
    description: 'There is no Socket connection available.'
  },
  CONNECTION_ERROR: {
    status: 'error',
    description: 'Connection error.'
  },
  SOCKET_EXCEPTION: {
    status: 'error',
    description: 'An exception occurred from the underlying WebSocket.'
  },
  AUTH_NOT_REQUIRED: {
    status: 'ok',
    description: 'Authentication is not required.'
  },
  REQUEST_TYPE_NOT_SPECIFIED: {
    status: 'error',
    description: 'A Request Type was not specified.'
  },
  ARGS_NOT_OBJECT: {
    status: 'error',
    description: 'The supplied argments parameter is not an object.'
  },

  init() {
    for (const key in this) {
      if ({}.hasOwnProperty.call(this, key)) {
        // Assign a value to 'code' identified by the status' key.
        this[key].code = key;

        // Assign a value to 'error' if one is not already defined.
        if (this[key].status === 'error' && !this[key].error) {
          this[key].error = this[key].description;
        }
      }
    }

    delete this.init;
    return this;
  }
}.init();


/***/ }),

/***/ "./node_modules/obs-websocket-js/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/obs-websocket-js/lib/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./OBSWebSocket.js */ "./node_modules/obs-websocket-js/lib/OBSWebSocket.js");


/***/ }),

/***/ "./node_modules/obs-websocket-js/lib/util/authenticationHashing.js":
/*!*************************************************************************!*\
  !*** ./node_modules/obs-websocket-js/lib/util/authenticationHashing.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SHA256 = __webpack_require__(/*! sha.js/sha256 */ "./node_modules/sha.js/sha256.js");

/**
 * SHA256 Hashing.
 *
 * @param  {String} [salt=''] salt.
 * @param  {String} [challenge=''] challenge.
 * @param  {String} msg Message to encode.
 * @return {String} sha256 encoded string.
 */
// eslint-disable-next-line default-param-last
module.exports = function (salt = '', challenge = '', msg) {
  const hash = new SHA256()
    .update(msg)
    .update(salt)
    .digest('base64');

  const resp = new SHA256()
    .update(hash)
    .update(challenge)
    .digest('base64');

  return resp;
};


/***/ }),

/***/ "./node_modules/obs-websocket-js/lib/util/camelCaseKeys.js":
/*!*****************************************************************!*\
  !*** ./node_modules/obs-websocket-js/lib/util/camelCaseKeys.js ***!
  \*****************************************************************/
/***/ ((module) => {

/**
 * Converts kebab-case to camelCase.
 * Retains the original kebab-case entries.
 *
 * @param {Object} [obj={}] Keyed object.
 * @return {Object} Keyed object with added camelCased keys.
 */
module.exports = function (obj) {
  obj = obj || {};
  for (const key in obj) {
    if (!{}.hasOwnProperty.call(obj, key)) {
      continue;
    }

    const camelCasedKey = key.replace(/-([a-z])/gi, ($0, $1) => {
      return $1.toUpperCase();
    });
    obj[camelCasedKey] = obj[key];
  }

  return obj;
};


/***/ }),

/***/ "./node_modules/obs-websocket-js/lib/util/logAmbiguousError.js":
/*!*********************************************************************!*\
  !*** ./node_modules/obs-websocket-js/lib/util/logAmbiguousError.js ***!
  \*********************************************************************/
/***/ ((module) => {

/**
 * Disambiguates an "error" and formats it nicely for `debug` output.
 * Particularly useful when dealing with error response objects from obs-websocket,
 * which are not actual Error-type errors, but simply Objects.
 *
 * @param {Object} debug A `debug` instance.
 * @param {String} prefix A string to print in front of the formatted error.
 * @param {Object|Error} error An error of ambiguous type that you wish to log to `debug`. Can be an Error, Object, or String.
 */
module.exports = function (debug, prefix, error) {
  if (error && error.stack) {
    debug(`${prefix}\n %O`, error.stack);
  } else if (typeof error === 'object') {
    debug(`${prefix} %o`, error);
  } else {
    debug(`${prefix} %s`, error);
  }
};


/***/ }),

/***/ "./node_modules/riot/riot.esm.js":
/*!***************************************!*\
  !*** ./node_modules/riot/riot.esm.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__": () => (/* binding */ __),
/* harmony export */   "component": () => (/* binding */ component),
/* harmony export */   "install": () => (/* binding */ install),
/* harmony export */   "mount": () => (/* binding */ mount),
/* harmony export */   "pure": () => (/* binding */ pure),
/* harmony export */   "register": () => (/* binding */ register),
/* harmony export */   "uninstall": () => (/* binding */ uninstall),
/* harmony export */   "unmount": () => (/* binding */ unmount),
/* harmony export */   "unregister": () => (/* binding */ unregister),
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
/* Riot v5.4.5, @license MIT */
/**
 * Convert a string from camel case to dash-case
 * @param   {string} string - probably a component tag name
 * @returns {string} component name normalized
 */
function camelToDashCase(string) {
  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
/**
 * Convert a string containing dashes to camel case
 * @param   {string} string - input string
 * @returns {string} my-string -> myString
 */

function dashToCamelCase(string) {
  return string.replace(/-(\w)/g, (_, c) => c.toUpperCase());
}

/**
 * Get all the element attributes as object
 * @param   {HTMLElement} element - DOM node we want to parse
 * @returns {Object} all the attributes found as a key value pairs
 */

function DOMattributesToObject(element) {
  return Array.from(element.attributes).reduce((acc, attribute) => {
    acc[dashToCamelCase(attribute.name)] = attribute.value;
    return acc;
  }, {});
}
/**
 * Move all the child nodes from a source tag to another
 * @param   {HTMLElement} source - source node
 * @param   {HTMLElement} target - target node
 * @returns {undefined} it's a void method Â¯\_(ã)_/Â¯
 */
// Ignore this helper because it's needed only for svg tags

function moveChildren(source, target) {
  if (source.firstChild) {
    target.appendChild(source.firstChild);
    moveChildren(source, target);
  }
}
/**
 * Remove the child nodes from any DOM node
 * @param   {HTMLElement} node - target node
 * @returns {undefined}
 */

function cleanNode(node) {
  clearChildren(node.childNodes);
}
/**
 * Clear multiple children in a node
 * @param   {HTMLElement[]} children - direct children nodes
 * @returns {undefined}
 */

function clearChildren(children) {
  Array.from(children).forEach(removeChild);
}
/**
 * Remove a node
 * @param {HTMLElement}node - node to remove
 * @returns {undefined}
 */

const removeChild = node => node && node.parentNode && node.parentNode.removeChild(node);
/**
 * Insert before a node
 * @param {HTMLElement} newNode - node to insert
 * @param {HTMLElement} refNode - ref child
 * @returns {undefined}
 */

const insertBefore = (newNode, refNode) => refNode && refNode.parentNode && refNode.parentNode.insertBefore(newNode, refNode);
/**
 * Replace a node
 * @param {HTMLElement} newNode - new node to add to the DOM
 * @param {HTMLElement} replaced - node to replace
 * @returns {undefined}
 */

const replaceChild = (newNode, replaced) => replaced && replaced.parentNode && replaced.parentNode.replaceChild(newNode, replaced);

// Riot.js constants that can be used accross more modules
const COMPONENTS_IMPLEMENTATION_MAP$1 = new Map(),
      DOM_COMPONENT_INSTANCE_PROPERTY$1 = Symbol('riot-component'),
      PLUGINS_SET$1 = new Set(),
      IS_DIRECTIVE = 'is',
      VALUE_ATTRIBUTE = 'value',
      MOUNT_METHOD_KEY = 'mount',
      UPDATE_METHOD_KEY = 'update',
      UNMOUNT_METHOD_KEY = 'unmount',
      SHOULD_UPDATE_KEY = 'shouldUpdate',
      ON_BEFORE_MOUNT_KEY = 'onBeforeMount',
      ON_MOUNTED_KEY = 'onMounted',
      ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',
      ON_UPDATED_KEY = 'onUpdated',
      ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',
      ON_UNMOUNTED_KEY = 'onUnmounted',
      PROPS_KEY = 'props',
      STATE_KEY = 'state',
      SLOTS_KEY = 'slots',
      ROOT_KEY = 'root',
      IS_PURE_SYMBOL = Symbol('pure'),
      IS_COMPONENT_UPDATING = Symbol('is_updating'),
      PARENT_KEY_SYMBOL = Symbol('parent'),
      ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),
      TEMPLATE_KEY_SYMBOL = Symbol('template');

var globals = /*#__PURE__*/Object.freeze({
  __proto__: null,
  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,
  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,
  PLUGINS_SET: PLUGINS_SET$1,
  IS_DIRECTIVE: IS_DIRECTIVE,
  VALUE_ATTRIBUTE: VALUE_ATTRIBUTE,
  MOUNT_METHOD_KEY: MOUNT_METHOD_KEY,
  UPDATE_METHOD_KEY: UPDATE_METHOD_KEY,
  UNMOUNT_METHOD_KEY: UNMOUNT_METHOD_KEY,
  SHOULD_UPDATE_KEY: SHOULD_UPDATE_KEY,
  ON_BEFORE_MOUNT_KEY: ON_BEFORE_MOUNT_KEY,
  ON_MOUNTED_KEY: ON_MOUNTED_KEY,
  ON_BEFORE_UPDATE_KEY: ON_BEFORE_UPDATE_KEY,
  ON_UPDATED_KEY: ON_UPDATED_KEY,
  ON_BEFORE_UNMOUNT_KEY: ON_BEFORE_UNMOUNT_KEY,
  ON_UNMOUNTED_KEY: ON_UNMOUNTED_KEY,
  PROPS_KEY: PROPS_KEY,
  STATE_KEY: STATE_KEY,
  SLOTS_KEY: SLOTS_KEY,
  ROOT_KEY: ROOT_KEY,
  IS_PURE_SYMBOL: IS_PURE_SYMBOL,
  IS_COMPONENT_UPDATING: IS_COMPONENT_UPDATING,
  PARENT_KEY_SYMBOL: PARENT_KEY_SYMBOL,
  ATTRIBUTES_KEY_SYMBOL: ATTRIBUTES_KEY_SYMBOL,
  TEMPLATE_KEY_SYMBOL: TEMPLATE_KEY_SYMBOL
});

const EACH = 0;
const IF = 1;
const SIMPLE = 2;
const TAG = 3;
const SLOT = 4;
var bindingTypes = {
  EACH,
  IF,
  SIMPLE,
  TAG,
  SLOT
};

const ATTRIBUTE = 0;
const EVENT = 1;
const TEXT = 2;
const VALUE = 3;
var expressionTypes = {
  ATTRIBUTE,
  EVENT,
  TEXT,
  VALUE
};

const HEAD_SYMBOL = Symbol('head');
const TAIL_SYMBOL = Symbol('tail');

/**
 * Create the <template> fragments text nodes
 * @return {Object} {{head: TextNode, tail: TextNode}}
 */

function createHeadTailPlaceholders() {
  const head = document.createTextNode('');
  const tail = document.createTextNode('');
  head[HEAD_SYMBOL] = true;
  tail[TAIL_SYMBOL] = true;
  return {
    head,
    tail
  };
}

/**
 * Create the template meta object in case of <template> fragments
 * @param   {TemplateChunk} componentTemplate - template chunk object
 * @returns {Object} the meta property that will be passed to the mount function of the TemplateChunk
 */

function createTemplateMeta(componentTemplate) {
  const fragment = componentTemplate.dom.cloneNode(true);
  const {
    head,
    tail
  } = createHeadTailPlaceholders();
  return {
    avoidDOMInjection: true,
    fragment,
    head,
    tail,
    children: [head, ...Array.from(fragment.childNodes), tail]
  };
}

/**
 * Get the current <template> fragment children located in between the head and tail comments
 * @param {Comment} head - head comment node
 * @param {Comment} tail - tail comment node
 * @return {Array[]} children list of the nodes found in this template fragment
 */

function getFragmentChildren(_ref) {
  let {
    head,
    tail
  } = _ref;
  const nodes = walkNodes([head], head.nextSibling, n => n === tail, false);
  nodes.push(tail);
  return nodes;
}
/**
 * Recursive function to walk all the <template> children nodes
 * @param {Array[]} children - children nodes collection
 * @param {ChildNode} node - current node
 * @param {Function} check - exit function check
 * @param {boolean} isFilterActive - filter flag to skip nodes managed by other bindings
 * @returns {Array[]} children list of the nodes found in this template fragment
 */

function walkNodes(children, node, check, isFilterActive) {
  const {
    nextSibling
  } = node; // filter tail and head nodes together with all the nodes in between
  // this is needed only to fix a really ugly edge case https://github.com/riot/riot/issues/2892

  if (!isFilterActive && !node[HEAD_SYMBOL] && !node[TAIL_SYMBOL]) {
    children.push(node);
  }

  if (!nextSibling || check(node)) return children;
  return walkNodes(children, nextSibling, check, // activate the filters to skip nodes between <template> fragments that will be managed by other bindings
  isFilterActive && !node[TAIL_SYMBOL] || nextSibling[HEAD_SYMBOL]);
}

/**
 * Quick type checking
 * @param   {*} element - anything
 * @param   {string} type - type definition
 * @returns {boolean} true if the type corresponds
 */
function checkType(element, type) {
  return typeof element === type;
}
/**
 * Check if an element is part of an svg
 * @param   {HTMLElement}  el - element to check
 * @returns {boolean} true if we are in an svg context
 */

function isSvg(el) {
  const owner = el.ownerSVGElement;
  return !!owner || owner === null;
}
/**
 * Check if an element is a template tag
 * @param   {HTMLElement}  el - element to check
 * @returns {boolean} true if it's a <template>
 */

function isTemplate(el) {
  return el.tagName.toLowerCase() === 'template';
}
/**
 * Check that will be passed if its argument is a function
 * @param   {*} value - value to check
 * @returns {boolean} - true if the value is a function
 */

function isFunction(value) {
  return checkType(value, 'function');
}
/**
 * Check if a value is a Boolean
 * @param   {*}  value - anything
 * @returns {boolean} true only for the value is a boolean
 */

function isBoolean(value) {
  return checkType(value, 'boolean');
}
/**
 * Check if a value is an Object
 * @param   {*}  value - anything
 * @returns {boolean} true only for the value is an object
 */

function isObject(value) {
  return !isNil(value) && value.constructor === Object;
}
/**
 * Check if a value is null or undefined
 * @param   {*}  value - anything
 * @returns {boolean} true only for the 'undefined' and 'null' types
 */

function isNil(value) {
  return value === null || value === undefined;
}

/**
 * ISC License
 *
 * Copyright (c) 2020, Andrea Giammarchi, @WebReflection
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
// fork of https://github.com/WebReflection/udomdiff version 1.1.0
// due to https://github.com/WebReflection/udomdiff/pull/2

/* eslint-disable */

/**
 * @param {Node[]} a The list of current/live children
 * @param {Node[]} b The list of future children
 * @param {(entry: Node, action: number) => Node} get
 * The callback invoked per each entry related DOM operation.
 * @param {Node} [before] The optional node used as anchor to insert before.
 * @returns {Node[]} The same list of future children.
 */

var udomdiff = ((a, b, get, before) => {
  const bLength = b.length;
  let aEnd = a.length;
  let bEnd = bLength;
  let aStart = 0;
  let bStart = 0;
  let map = null;

  while (aStart < aEnd || bStart < bEnd) {
    // append head, tail, or nodes in between: fast path
    if (aEnd === aStart) {
      // we could be in a situation where the rest of nodes that
      // need to be added are not at the end, and in such case
      // the node to `insertBefore`, if the index is more than 0
      // must be retrieved, otherwise it's gonna be the first item.
      const node = bEnd < bLength ? bStart ? get(b[bStart - 1], -0).nextSibling : get(b[bEnd - bStart], 0) : before;

      while (bStart < bEnd) insertBefore(get(b[bStart++], 1), node);
    } // remove head or tail: fast path
    else if (bEnd === bStart) {
        while (aStart < aEnd) {
          // remove the node only if it's unknown or not live
          if (!map || !map.has(a[aStart])) removeChild(get(a[aStart], -1));
          aStart++;
        }
      } // same node: fast path
      else if (a[aStart] === b[bStart]) {
          aStart++;
          bStart++;
        } // same tail: fast path
        else if (a[aEnd - 1] === b[bEnd - 1]) {
            aEnd--;
            bEnd--;
          } // The once here single last swap "fast path" has been removed in v1.1.0
          // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85
          // reverse swap: also fast path
          else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
              // this is a "shrink" operation that could happen in these cases:
              // [1, 2, 3, 4, 5]
              // [1, 4, 3, 2, 5]
              // or asymmetric too
              // [1, 2, 3, 4, 5]
              // [1, 2, 3, 5, 6, 4]
              const node = get(a[--aEnd], -1).nextSibling;
              insertBefore(get(b[bStart++], 1), get(a[aStart++], -1).nextSibling);
              insertBefore(get(b[--bEnd], 1), node); // mark the future index as identical (yeah, it's dirty, but cheap ð)
              // The main reason to do this, is that when a[aEnd] will be reached,
              // the loop will likely be on the fast path, as identical to b[bEnd].
              // In the best case scenario, the next loop will skip the tail,
              // but in the worst one, this node will be considered as already
              // processed, bailing out pretty quickly from the map index check

              a[aEnd] = b[bEnd];
            } // map based fallback, "slow" path
            else {
                // the map requires an O(bEnd - bStart) operation once
                // to store all future nodes indexes for later purposes.
                // In the worst case scenario, this is a full O(N) cost,
                // and such scenario happens at least when all nodes are different,
                // but also if both first and last items of the lists are different
                if (!map) {
                  map = new Map();
                  let i = bStart;

                  while (i < bEnd) map.set(b[i], i++);
                } // if it's a future node, hence it needs some handling


                if (map.has(a[aStart])) {
                  // grab the index of such node, 'cause it might have been processed
                  const index = map.get(a[aStart]); // if it's not already processed, look on demand for the next LCS

                  if (bStart < index && index < bEnd) {
                    let i = aStart; // counts the amount of nodes that are the same in the future

                    let sequence = 1;

                    while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence) sequence++; // effort decision here: if the sequence is longer than replaces
                    // needed to reach such sequence, which would brings again this loop
                    // to the fast path, prepend the difference before a sequence,
                    // and move only the future list index forward, so that aStart
                    // and bStart will be aligned again, hence on the fast path.
                    // An example considering aStart and bStart are both 0:
                    // a: [1, 2, 3, 4]
                    // b: [7, 1, 2, 3, 6]
                    // this would place 7 before 1 and, from that time on, 1, 2, and 3
                    // will be processed at zero cost


                    if (sequence > index - bStart) {
                      const node = get(a[aStart], 0);

                      while (bStart < index) insertBefore(get(b[bStart++], 1), node);
                    } // if the effort wasn't good enough, fallback to a replace,
                    // moving both source and target indexes forward, hoping that some
                    // similar node will be found later on, to go back to the fast path
                    else {
                        replaceChild(get(b[bStart++], 1), get(a[aStart++], -1));
                      }
                  } // otherwise move the source forward, 'cause there's nothing to do
                  else aStart++;
                } // this node has no meaning in the future list, so it's more than safe
                // to remove it, and check the next live node out instead, meaning
                // that only the live list index should be forwarded
                else removeChild(get(a[aStart++], -1));
              }
  }

  return b;
});

const UNMOUNT_SCOPE = Symbol('unmount');
const EachBinding = {
  // dynamic binding properties
  // childrenMap: null,
  // node: null,
  // root: null,
  // condition: null,
  // evaluate: null,
  // template: null,
  // isTemplateTag: false,
  nodes: [],

  // getKey: null,
  // indexName: null,
  // itemName: null,
  // afterPlaceholder: null,
  // placeholder: null,
  // API methods
  mount(scope, parentScope) {
    return this.update(scope, parentScope);
  },

  update(scope, parentScope) {
    const {
      placeholder,
      nodes,
      childrenMap
    } = this;
    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);
    const items = collection ? Array.from(collection) : []; // prepare the diffing

    const {
      newChildrenMap,
      batches,
      futureNodes
    } = createPatch(items, scope, parentScope, this); // patch the DOM only if there are new nodes

    udomdiff(nodes, futureNodes, patch(Array.from(childrenMap.values()), parentScope), placeholder); // trigger the mounts and the updates

    batches.forEach(fn => fn()); // update the children map

    this.childrenMap = newChildrenMap;
    this.nodes = futureNodes; // make sure that the loop edge nodes are marked

    markEdgeNodes(this.nodes);
    return this;
  },

  unmount(scope, parentScope) {
    this.update(UNMOUNT_SCOPE, parentScope);
    return this;
  }

};
/**
 * Patch the DOM while diffing
 * @param   {any[]} redundant - list of all the children (template, nodes, context) added via each
 * @param   {*} parentScope - scope of the parent template
 * @returns {Function} patch function used by domdiff
 */

function patch(redundant, parentScope) {
  return (item, info) => {
    if (info < 0) {
      // get the last element added to the childrenMap saved previously
      const element = redundant[redundant.length - 1];

      if (element) {
        // get the nodes and the template in stored in the last child of the childrenMap
        const {
          template,
          nodes,
          context
        } = element; // remove the last node (notice <template> tags might have more children nodes)

        nodes.pop(); // notice that we pass null as last argument because
        // the root node and its children will be removed by domdiff

        if (nodes.length === 0) {
          // we have cleared all the children nodes and we can unmount this template
          redundant.pop();
          template.unmount(context, parentScope, null);
        }
      }
    }

    return item;
  };
}
/**
 * Check whether a template must be filtered from a loop
 * @param   {Function} condition - filter function
 * @param   {Object} context - argument passed to the filter function
 * @returns {boolean} true if this item should be skipped
 */


function mustFilterItem(condition, context) {
  return condition ? Boolean(condition(context)) === false : false;
}
/**
 * Extend the scope of the looped template
 * @param   {Object} scope - current template scope
 * @param   {string} options.itemName - key to identify the looped item in the new context
 * @param   {string} options.indexName - key to identify the index of the looped item
 * @param   {number} options.index - current index
 * @param   {*} options.item - collection item looped
 * @returns {Object} enhanced scope object
 */


function extendScope(scope, _ref) {
  let {
    itemName,
    indexName,
    index,
    item
  } = _ref;
  scope[itemName] = item;
  if (indexName) scope[indexName] = index;
  return scope;
}
/**
 * Mark the first and last nodes in order to ignore them in case we need to retrieve the <template> fragment nodes
 * @param {Array[]} nodes - each binding nodes list
 * @returns {undefined} void function
 */


function markEdgeNodes(nodes) {
  const first = nodes[0];
  const last = nodes[nodes.length - 1];
  if (first) first[HEAD_SYMBOL] = true;
  if (last) last[TAIL_SYMBOL] = true;
}
/**
 * Loop the current template items
 * @param   {Array} items - expression collection value
 * @param   {*} scope - template scope
 * @param   {*} parentScope - scope of the parent template
 * @param   {EeachBinding} binding - each binding object instance
 * @returns {Object} data
 * @returns {Map} data.newChildrenMap - a Map containing the new children template structure
 * @returns {Array} data.batches - array containing the template lifecycle functions to trigger
 * @returns {Array} data.futureNodes - array containing the nodes we need to diff
 */


function createPatch(items, scope, parentScope, binding) {
  const {
    condition,
    template,
    childrenMap,
    itemName,
    getKey,
    indexName,
    root,
    isTemplateTag
  } = binding;
  const newChildrenMap = new Map();
  const batches = [];
  const futureNodes = [];
  items.forEach((item, index) => {
    const context = extendScope(Object.create(scope), {
      itemName,
      indexName,
      index,
      item
    });
    const key = getKey ? getKey(context) : index;
    const oldItem = childrenMap.get(key);
    const nodes = [];

    if (mustFilterItem(condition, context)) {
      return;
    }

    const mustMount = !oldItem;
    const componentTemplate = oldItem ? oldItem.template : template.clone();
    const el = componentTemplate.el || root.cloneNode();
    const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : componentTemplate.meta;

    if (mustMount) {
      batches.push(() => componentTemplate.mount(el, context, parentScope, meta));
    } else {
      batches.push(() => componentTemplate.update(context, parentScope));
    } // create the collection of nodes to update or to add
    // in case of template tags we need to add all its children nodes


    if (isTemplateTag) {
      nodes.push(...(mustMount ? meta.children : getFragmentChildren(meta)));
    } else {
      nodes.push(el);
    } // delete the old item from the children map


    childrenMap.delete(key);
    futureNodes.push(...nodes); // update the children map

    newChildrenMap.set(key, {
      nodes,
      template: componentTemplate,
      context,
      index
    });
  });
  return {
    newChildrenMap,
    batches,
    futureNodes
  };
}

function create$6(node, _ref2) {
  let {
    evaluate,
    condition,
    itemName,
    indexName,
    getKey,
    template
  } = _ref2;
  const placeholder = document.createTextNode('');
  const root = node.cloneNode();
  insertBefore(placeholder, node);
  removeChild(node);
  return Object.assign({}, EachBinding, {
    childrenMap: new Map(),
    node,
    root,
    condition,
    evaluate,
    isTemplateTag: isTemplate(root),
    template: template.createDOM(node),
    getKey,
    indexName,
    itemName,
    placeholder
  });
}

/**
 * Binding responsible for the `if` directive
 */

const IfBinding = {
  // dynamic binding properties
  // node: null,
  // evaluate: null,
  // isTemplateTag: false,
  // placeholder: null,
  // template: null,
  // API methods
  mount(scope, parentScope) {
    return this.update(scope, parentScope);
  },

  update(scope, parentScope) {
    const value = !!this.evaluate(scope);
    const mustMount = !this.value && value;
    const mustUnmount = this.value && !value;

    const mount = () => {
      const pristine = this.node.cloneNode();
      insertBefore(pristine, this.placeholder);
      this.template = this.template.clone();
      this.template.mount(pristine, scope, parentScope);
    };

    switch (true) {
      case mustMount:
        mount();
        break;

      case mustUnmount:
        this.unmount(scope);
        break;

      default:
        if (value) this.template.update(scope, parentScope);
    }

    this.value = value;
    return this;
  },

  unmount(scope, parentScope) {
    this.template.unmount(scope, parentScope, true);
    return this;
  }

};
function create$5(node, _ref) {
  let {
    evaluate,
    template
  } = _ref;
  const placeholder = document.createTextNode('');
  insertBefore(placeholder, node);
  removeChild(node);
  return Object.assign({}, IfBinding, {
    node,
    evaluate,
    placeholder,
    template: template.createDOM(node)
  });
}

/**
 * Throw an error with a descriptive message
 * @param   { string } message - error message
 * @returns { undefined } hoppla.. at this point the program should stop working
 */

function panic(message) {
  throw new Error(message);
}
/**
 * Returns the memoized (cached) function.
 * // borrowed from https://www.30secondsofcode.org/js/s/memoize
 * @param {Function} fn - function to memoize
 * @returns {Function} memoize function
 */

function memoize(fn) {
  const cache = new Map();

  const cached = val => {
    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);
  };

  cached.cache = cache;
  return cached;
}
/**
 * Evaluate a list of attribute expressions
 * @param   {Array} attributes - attribute expressions generated by the riot compiler
 * @returns {Object} key value pairs with the result of the computation
 */

function evaluateAttributeExpressions(attributes) {
  return attributes.reduce((acc, attribute) => {
    const {
      value,
      type
    } = attribute;

    switch (true) {
      // spread attribute
      case !attribute.name && type === ATTRIBUTE:
        return Object.assign({}, acc, value);
      // value attribute

      case type === VALUE:
        acc.value = attribute.value;
        break;
      // normal attributes

      default:
        acc[dashToCamelCase(attribute.name)] = attribute.value;
    }

    return acc;
  }, {});
}

const ElementProto = typeof Element === 'undefined' ? {} : Element.prototype;
const isNativeHtmlProperty = memoize(name => ElementProto.hasOwnProperty(name)); // eslint-disable-line

/**
 * Add all the attributes provided
 * @param   {HTMLElement} node - target node
 * @param   {Object} attributes - object containing the attributes names and values
 * @returns {undefined} sorry it's a void function :(
 */

function setAllAttributes(node, attributes) {
  Object.entries(attributes).forEach(_ref => {
    let [name, value] = _ref;
    return attributeExpression(node, {
      name
    }, value);
  });
}
/**
 * Remove all the attributes provided
 * @param   {HTMLElement} node - target node
 * @param   {Object} newAttributes - object containing all the new attribute names
 * @param   {Object} oldAttributes - object containing all the old attribute names
 * @returns {undefined} sorry it's a void function :(
 */


function removeAllAttributes(node, newAttributes, oldAttributes) {
  const newKeys = newAttributes ? Object.keys(newAttributes) : [];
  Object.keys(oldAttributes).filter(name => !newKeys.includes(name)).forEach(attribute => node.removeAttribute(attribute));
}
/**
 * Check whether the attribute value can be rendered
 * @param {*} value - expression value
 * @returns {boolean} true if we can render this attribute value
 */


function canRenderAttribute(value) {
  return value === true || ['string', 'number'].includes(typeof value);
}
/**
 * Check whether the attribute should be removed
 * @param {*} value - expression value
 * @returns {boolean} boolean - true if the attribute can be removed}
 */


function shouldRemoveAttribute(value) {
  return isNil(value) || value === false || value === '';
}
/**
 * This methods handles the DOM attributes updates
 * @param   {HTMLElement} node - target node
 * @param   {Object} expression - expression object
 * @param   {string} expression.name - attribute name
 * @param   {*} value - new expression value
 * @param   {*} oldValue - the old expression cached value
 * @returns {undefined}
 */


function attributeExpression(node, _ref2, value, oldValue) {
  let {
    name
  } = _ref2;

  // is it a spread operator? {...attributes}
  if (!name) {
    if (oldValue) {
      // remove all the old attributes
      removeAllAttributes(node, value, oldValue);
    } // is the value still truthy?


    if (value) {
      setAllAttributes(node, value);
    }

    return;
  } // handle boolean attributes


  if (!isNativeHtmlProperty(name) && (isBoolean(value) || isObject(value) || isFunction(value))) {
    node[name] = value;
  }

  if (shouldRemoveAttribute(value)) {
    node.removeAttribute(name);
  } else if (canRenderAttribute(value)) {
    node.setAttribute(name, normalizeValue(name, value));
  }
}
/**
 * Get the value as string
 * @param   {string} name - attribute name
 * @param   {*} value - user input value
 * @returns {string} input value as string
 */

function normalizeValue(name, value) {
  // be sure that expressions like selected={ true } will be always rendered as selected='selected'
  if (value === true) return name;
  return value;
}

const RE_EVENTS_PREFIX = /^on/;

const getCallbackAndOptions = value => Array.isArray(value) ? value : [value, false]; // see also https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38


const EventListener = {
  handleEvent(event) {
    this[event.type](event);
  }

};
const ListenersWeakMap = new WeakMap();

const createListener = node => {
  const listener = Object.create(EventListener);
  ListenersWeakMap.set(node, listener);
  return listener;
};
/**
 * Set a new event listener
 * @param   {HTMLElement} node - target node
 * @param   {Object} expression - expression object
 * @param   {string} expression.name - event name
 * @param   {*} value - new expression value
 * @returns {value} the callback just received
 */


function eventExpression(node, _ref, value) {
  let {
    name
  } = _ref;
  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, '');
  const eventListener = ListenersWeakMap.get(node) || createListener(node);
  const [callback, options] = getCallbackAndOptions(value);
  const handler = eventListener[normalizedEventName];
  const mustRemoveEvent = handler && !callback;
  const mustAddEvent = callback && !handler;

  if (mustRemoveEvent) {
    node.removeEventListener(normalizedEventName, eventListener);
  }

  if (mustAddEvent) {
    node.addEventListener(normalizedEventName, eventListener, options);
  }

  eventListener[normalizedEventName] = callback;
}

/**
 * Normalize the user value in order to render a empty string in case of falsy values
 * @param   {*} value - user input value
 * @returns {string} hopefully a string
 */

function normalizeStringValue(value) {
  return isNil(value) ? '' : value;
}

/**
 * Get the the target text node to update or create one from of a comment node
 * @param   {HTMLElement} node - any html element containing childNodes
 * @param   {number} childNodeIndex - index of the text node in the childNodes list
 * @returns {HTMLTextNode} the text node to update
 */

const getTextNode = (node, childNodeIndex) => {
  const target = node.childNodes[childNodeIndex];

  if (target.nodeType === Node.COMMENT_NODE) {
    const textNode = document.createTextNode('');
    node.replaceChild(textNode, target);
    return textNode;
  }

  return target;
};
/**
 * This methods handles a simple text expression update
 * @param   {HTMLElement} node - target node
 * @param   {Object} data - expression object
 * @param   {*} value - new expression value
 * @returns {undefined}
 */

function textExpression(node, data, value) {
  node.data = normalizeStringValue(value);
}

/**
 * This methods handles the input fileds value updates
 * @param   {HTMLElement} node - target node
 * @param   {Object} expression - expression object
 * @param   {*} value - new expression value
 * @returns {undefined}
 */

function valueExpression(node, expression, value) {
  node.value = normalizeStringValue(value);
}

var expressions = {
  [ATTRIBUTE]: attributeExpression,
  [EVENT]: eventExpression,
  [TEXT]: textExpression,
  [VALUE]: valueExpression
};

const Expression = {
  // Static props
  // node: null,
  // value: null,
  // API methods

  /**
   * Mount the expression evaluating its initial value
   * @param   {*} scope - argument passed to the expression to evaluate its current values
   * @returns {Expression} self
   */
  mount(scope) {
    // hopefully a pure function
    this.value = this.evaluate(scope); // IO() DOM updates

    apply(this, this.value);
    return this;
  },

  /**
   * Update the expression if its value changed
   * @param   {*} scope - argument passed to the expression to evaluate its current values
   * @returns {Expression} self
   */
  update(scope) {
    // pure function
    const value = this.evaluate(scope);

    if (this.value !== value) {
      // IO() DOM updates
      apply(this, value);
      this.value = value;
    }

    return this;
  },

  /**
   * Expression teardown method
   * @returns {Expression} self
   */
  unmount() {
    // unmount only the event handling expressions
    if (this.type === EVENT) apply(this, null);
    return this;
  }

};
/**
 * IO() function to handle the DOM updates
 * @param {Expression} expression - expression object
 * @param {*} value - current expression value
 * @returns {undefined}
 */

function apply(expression, value) {
  return expressions[expression.type](expression.node, expression, value, expression.value);
}

function create$4(node, data) {
  return Object.assign({}, Expression, data, {
    node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node
  });
}

/**
 * Create a flat object having as keys a list of methods that if dispatched will propagate
 * on the whole collection
 * @param   {Array} collection - collection to iterate
 * @param   {Array<string>} methods - methods to execute on each item of the collection
 * @param   {*} context - context returned by the new methods created
 * @returns {Object} a new object to simplify the the nested methods dispatching
 */
function flattenCollectionMethods(collection, methods, context) {
  return methods.reduce((acc, method) => {
    return Object.assign({}, acc, {
      [method]: scope => {
        return collection.map(item => item[method](scope)) && context;
      }
    });
  }, {});
}

function create$3(node, _ref) {
  let {
    expressions
  } = _ref;
  return Object.assign({}, flattenCollectionMethods(expressions.map(expression => create$4(node, expression)), ['mount', 'update', 'unmount']));
}

function extendParentScope(attributes, scope, parentScope) {
  if (!attributes || !attributes.length) return parentScope;
  const expressions = attributes.map(attr => Object.assign({}, attr, {
    value: attr.evaluate(scope)
  }));
  return Object.assign(Object.create(parentScope || null), evaluateAttributeExpressions(expressions));
} // this function is only meant to fix an edge case
// https://github.com/riot/riot/issues/2842


const getRealParent = (scope, parentScope) => scope[PARENT_KEY_SYMBOL] || parentScope;

const SlotBinding = {
  // dynamic binding properties
  // node: null,
  // name: null,
  attributes: [],

  // template: null,
  getTemplateScope(scope, parentScope) {
    return extendParentScope(this.attributes, scope, parentScope);
  },

  // API methods
  mount(scope, parentScope) {
    const templateData = scope.slots ? scope.slots.find(_ref => {
      let {
        id
      } = _ref;
      return id === this.name;
    }) : false;
    const {
      parentNode
    } = this.node;
    const realParent = getRealParent(scope, parentScope);
    this.template = templateData && create(templateData.html, templateData.bindings).createDOM(parentNode);

    if (this.template) {
      this.template.mount(this.node, this.getTemplateScope(scope, realParent), realParent);
      this.template.children = Array.from(this.node.childNodes);
      moveSlotInnerContent(this.node);
    }

    removeChild(this.node);
    return this;
  },

  update(scope, parentScope) {
    if (this.template) {
      const realParent = getRealParent(scope, parentScope);
      this.template.update(this.getTemplateScope(scope, realParent), realParent);
    }

    return this;
  },

  unmount(scope, parentScope, mustRemoveRoot) {
    if (this.template) {
      this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot);
    }

    return this;
  }

};
/**
 * Move the inner content of the slots outside of them
 * @param   {HTMLElement} slot - slot node
 * @returns {undefined} it's a void method Â¯\_(ã)_/Â¯
 */

function moveSlotInnerContent(slot) {
  const child = slot && slot.firstChild;
  if (!child) return;
  insertBefore(child, slot);
  moveSlotInnerContent(slot);
}
/**
 * Create a single slot binding
 * @param   {HTMLElement} node - slot node
 * @param   {string} options.name - slot id
 * @returns {Object} Slot binding object
 */


function createSlot(node, _ref2) {
  let {
    name,
    attributes
  } = _ref2;
  return Object.assign({}, SlotBinding, {
    attributes,
    node,
    name
  });
}

/**
 * Create a new tag object if it was registered before, otherwise fallback to the simple
 * template chunk
 * @param   {Function} component - component factory function
 * @param   {Array<Object>} slots - array containing the slots markup
 * @param   {Array} attributes - dynamic attributes that will be received by the tag element
 * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback
 */

function getTag(component, slots, attributes) {
  if (slots === void 0) {
    slots = [];
  }

  if (attributes === void 0) {
    attributes = [];
  }

  // if this tag was registered before we will return its implementation
  if (component) {
    return component({
      slots,
      attributes
    });
  } // otherwise we return a template chunk


  return create(slotsToMarkup(slots), [...slotBindings(slots), {
    // the attributes should be registered as binding
    // if we fallback to a normal template chunk
    expressions: attributes.map(attr => {
      return Object.assign({
        type: ATTRIBUTE
      }, attr);
    })
  }]);
}
/**
 * Merge all the slots bindings into a single array
 * @param   {Array<Object>} slots - slots collection
 * @returns {Array<Bindings>} flatten bindings array
 */


function slotBindings(slots) {
  return slots.reduce((acc, _ref) => {
    let {
      bindings
    } = _ref;
    return acc.concat(bindings);
  }, []);
}
/**
 * Merge all the slots together in a single markup string
 * @param   {Array<Object>} slots - slots collection
 * @returns {string} markup of all the slots in a single string
 */


function slotsToMarkup(slots) {
  return slots.reduce((acc, slot) => {
    return acc + slot.html;
  }, '');
}

const TagBinding = {
  // dynamic binding properties
  // node: null,
  // evaluate: null,
  // name: null,
  // slots: null,
  // tag: null,
  // attributes: null,
  // getComponent: null,
  mount(scope) {
    return this.update(scope);
  },

  update(scope, parentScope) {
    const name = this.evaluate(scope); // simple update

    if (name && name === this.name) {
      this.tag.update(scope);
    } else {
      // unmount the old tag if it exists
      this.unmount(scope, parentScope, true); // mount the new tag

      this.name = name;
      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);
      this.tag.mount(this.node, scope);
    }

    return this;
  },

  unmount(scope, parentScope, keepRootTag) {
    if (this.tag) {
      // keep the root tag
      this.tag.unmount(keepRootTag);
    }

    return this;
  }

};
function create$2(node, _ref2) {
  let {
    evaluate,
    getComponent,
    slots,
    attributes
  } = _ref2;
  return Object.assign({}, TagBinding, {
    node,
    evaluate,
    slots,
    attributes,
    getComponent
  });
}

var bindings = {
  [IF]: create$5,
  [SIMPLE]: create$3,
  [EACH]: create$6,
  [TAG]: create$2,
  [SLOT]: createSlot
};

/**
 * Text expressions in a template tag will get childNodeIndex value normalized
 * depending on the position of the <template> tag offset
 * @param   {Expression[]} expressions - riot expressions array
 * @param   {number} textExpressionsOffset - offset of the <template> tag
 * @returns {Expression[]} expressions containing the text expressions normalized
 */

function fixTextExpressionsOffset(expressions, textExpressionsOffset) {
  return expressions.map(e => e.type === TEXT ? Object.assign({}, e, {
    childNodeIndex: e.childNodeIndex + textExpressionsOffset
  }) : e);
}
/**
 * Bind a new expression object to a DOM node
 * @param   {HTMLElement} root - DOM node where to bind the expression
 * @param   {Object} binding - binding data
 * @param   {number|null} templateTagOffset - if it's defined we need to fix the text expressions childNodeIndex offset
 * @returns {Binding} Binding object
 */


function create$1(root, binding, templateTagOffset) {
  const {
    selector,
    type,
    redundantAttribute,
    expressions
  } = binding; // find the node to apply the bindings

  const node = selector ? root.querySelector(selector) : root; // remove eventually additional attributes created only to select this node

  if (redundantAttribute) node.removeAttribute(redundantAttribute);
  const bindingExpressions = expressions || []; // init the binding

  return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {
    expressions: templateTagOffset && !selector ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset) : bindingExpressions
  }));
}

function createHTMLTree(html, root) {
  const template = isTemplate(root) ? root : document.createElement('template');
  template.innerHTML = html;
  return template.content;
} // for svg nodes we need a bit more work


function createSVGTree(html, container) {
  // create the SVGNode
  const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${html}</svg>`, 'application/xml').documentElement, true);
  return svgNode;
}
/**
 * Create the DOM that will be injected
 * @param {Object} root - DOM node to find out the context where the fragment will be created
 * @param   {string} html - DOM to create as string
 * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment
 */


function createDOMTree(root, html) {
  if (isSvg(root)) return createSVGTree(html, root);
  return createHTMLTree(html, root);
}

/**
 * Inject the DOM tree into a target node
 * @param   {HTMLElement} el - target element
 * @param   {HTMLFragment|SVGElement} dom - dom tree to inject
 * @returns {undefined}
 */

function injectDOM(el, dom) {
  switch (true) {
    case isSvg(el):
      moveChildren(dom, el);
      break;

    case isTemplate(el):
      el.parentNode.replaceChild(dom, el);
      break;

    default:
      el.appendChild(dom);
  }
}

/**
 * Create the Template DOM skeleton
 * @param   {HTMLElement} el - root node where the DOM will be injected
 * @param   {string} html - markup that will be injected into the root node
 * @returns {HTMLFragment} fragment that will be injected into the root node
 */

function createTemplateDOM(el, html) {
  return html && (typeof html === 'string' ? createDOMTree(el, html) : html);
}
/**
 * Get the offset of the <template> tag
 * @param {HTMLElement} parentNode - template tag parent node
 * @param {HTMLElement} el - the template tag we want to render
 * @param   {Object} meta - meta properties needed to handle the <template> tags in loops
 * @returns {number} offset of the <template> tag calculated from its siblings DOM nodes
 */


function getTemplateTagOffset(parentNode, el, meta) {
  const siblings = Array.from(parentNode.childNodes);
  return Math.max(siblings.indexOf(el), siblings.indexOf(meta.head) + 1, 0);
}
/**
 * Template Chunk model
 * @type {Object}
 */


const TemplateChunk = Object.freeze({
  // Static props
  // bindings: null,
  // bindingsData: null,
  // html: null,
  // isTemplateTag: false,
  // fragment: null,
  // children: null,
  // dom: null,
  // el: null,

  /**
   * Create the template DOM structure that will be cloned on each mount
   * @param   {HTMLElement} el - the root node
   * @returns {TemplateChunk} self
   */
  createDOM(el) {
    // make sure that the DOM gets created before cloning the template
    this.dom = this.dom || createTemplateDOM(el, this.html) || document.createDocumentFragment();
    return this;
  },

  // API methods

  /**
   * Attach the template to a DOM node
   * @param   {HTMLElement} el - target DOM node
   * @param   {*} scope - template data
   * @param   {*} parentScope - scope of the parent template tag
   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops
   * @returns {TemplateChunk} self
   */
  mount(el, scope, parentScope, meta) {
    if (meta === void 0) {
      meta = {};
    }

    if (!el) throw new Error('Please provide DOM node to mount properly your template');
    if (this.el) this.unmount(scope); // <template> tags require a bit more work
    // the template fragment might be already created via meta outside of this call

    const {
      fragment,
      children,
      avoidDOMInjection
    } = meta; // <template> bindings of course can not have a root element
    // so we check the parent node to set the query selector bindings

    const {
      parentNode
    } = children ? children[0] : el;
    const isTemplateTag = isTemplate(el);
    const templateTagOffset = isTemplateTag ? getTemplateTagOffset(parentNode, el, meta) : null; // create the DOM if it wasn't created before

    this.createDOM(el); // create the DOM of this template cloning the original DOM structure stored in this instance
    // notice that if a documentFragment was passed (via meta) we will use it instead

    const cloneNode = fragment || this.dom.cloneNode(true); // store root node
    // notice that for template tags the root note will be the parent tag

    this.el = isTemplateTag ? parentNode : el; // create the children array only for the <template> fragments

    this.children = isTemplateTag ? children || Array.from(cloneNode.childNodes) : null; // inject the DOM into the el only if a fragment is available

    if (!avoidDOMInjection && cloneNode) injectDOM(el, cloneNode); // create the bindings

    this.bindings = this.bindingsData.map(binding => create$1(this.el, binding, templateTagOffset));
    this.bindings.forEach(b => b.mount(scope, parentScope)); // store the template meta properties

    this.meta = meta;
    return this;
  },

  /**
   * Update the template with fresh data
   * @param   {*} scope - template data
   * @param   {*} parentScope - scope of the parent template tag
   * @returns {TemplateChunk} self
   */
  update(scope, parentScope) {
    this.bindings.forEach(b => b.update(scope, parentScope));
    return this;
  },

  /**
   * Remove the template from the node where it was initially mounted
   * @param   {*} scope - template data
   * @param   {*} parentScope - scope of the parent template tag
   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,
   * if false or undefined clean the root tag content, if null don't touch the DOM
   * @returns {TemplateChunk} self
   */
  unmount(scope, parentScope, mustRemoveRoot) {
    if (this.el) {
      this.bindings.forEach(b => b.unmount(scope, parentScope, mustRemoveRoot));

      switch (true) {
        // pure components should handle the DOM unmount updates by themselves
        case this.el[IS_PURE_SYMBOL]:
          break;
        // <template> tags should be treated a bit differently
        // we need to clear their children only if it's explicitly required by the caller
        // via mustRemoveRoot !== null

        case this.children && mustRemoveRoot !== null:
          clearChildren(this.children);
          break;
        // remove the root node only if the mustRemoveRoot === true

        case mustRemoveRoot === true:
          removeChild(this.el);
          break;
        // otherwise we clean the node children

        case mustRemoveRoot !== null:
          cleanNode(this.el);
          break;
      }

      this.el = null;
    }

    return this;
  },

  /**
   * Clone the template chunk
   * @returns {TemplateChunk} a clone of this object resetting the this.el property
   */
  clone() {
    return Object.assign({}, this, {
      meta: {},
      el: null
    });
  }

});
/**
 * Create a template chunk wiring also the bindings
 * @param   {string|HTMLElement} html - template string
 * @param   {Array} bindings - bindings collection
 * @returns {TemplateChunk} a new TemplateChunk copy
 */

function create(html, bindings) {
  if (bindings === void 0) {
    bindings = [];
  }

  return Object.assign({}, TemplateChunk, {
    html,
    bindingsData: bindings
  });
}

/**
 * Method used to bind expressions to a DOM node
 * @param   {string|HTMLElement} html - your static template html structure
 * @param   {Array} bindings - list of the expressions to bind to update the markup
 * @returns {TemplateChunk} a new TemplateChunk object having the `update`,`mount`, `unmount` and `clone` methods
 *
 * @example
 *
 * riotDOMBindings
 *  .template(
 *   `<div expr0><!----></div><div><p expr1><!----><section expr2></section></p>`,
 *   [
 *     {
 *       selector: '[expr0]',
 *       redundantAttribute: 'expr0',
 *       expressions: [
 *         {
 *           type: expressionTypes.TEXT,
 *           childNodeIndex: 0,
 *           evaluate(scope) {
 *             return scope.time;
 *           },
 *         },
 *       ],
 *     },
 *     {
 *       selector: '[expr1]',
 *       redundantAttribute: 'expr1',
 *       expressions: [
 *         {
 *           type: expressionTypes.TEXT,
 *           childNodeIndex: 0,
 *           evaluate(scope) {
 *             return scope.name;
 *           },
 *         },
 *         {
 *           type: 'attribute',
 *           name: 'style',
 *           evaluate(scope) {
 *             return scope.style;
 *           },
 *         },
 *       ],
 *     },
 *     {
 *       selector: '[expr2]',
 *       redundantAttribute: 'expr2',
 *       type: bindingTypes.IF,
 *       evaluate(scope) {
 *         return scope.isVisible;
 *       },
 *       template: riotDOMBindings.template('hello there'),
 *     },
 *   ]
 * )
 */

var DOMBindings = /*#__PURE__*/Object.freeze({
  __proto__: null,
  template: create,
  createBinding: create$1,
  createExpression: create$4,
  bindingTypes: bindingTypes,
  expressionTypes: expressionTypes
});

function noop() {
  return this;
}
/**
 * Autobind the methods of a source object to itself
 * @param   {Object} source - probably a riot tag instance
 * @param   {Array<string>} methods - list of the methods to autobind
 * @returns {Object} the original object received
 */

function autobindMethods(source, methods) {
  methods.forEach(method => {
    source[method] = source[method].bind(source);
  });
  return source;
}
/**
 * Call the first argument received only if it's a function otherwise return it as it is
 * @param   {*} source - anything
 * @returns {*} anything
 */

function callOrAssign(source) {
  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;
}

/**
 * Helper function to set an immutable property
 * @param   {Object} source - object where the new property will be set
 * @param   {string} key - object key where the new property will be stored
 * @param   {*} value - value of the new property
 * @param   {Object} options - set the propery overriding the default options
 * @returns {Object} - the original object modified
 */
function defineProperty(source, key, value, options) {
  if (options === void 0) {
    options = {};
  }

  /* eslint-disable fp/no-mutating-methods */
  Object.defineProperty(source, key, Object.assign({
    value,
    enumerable: false,
    writable: false,
    configurable: true
  }, options));
  /* eslint-enable fp/no-mutating-methods */

  return source;
}
/**
 * Define multiple properties on a target object
 * @param   {Object} source - object where the new properties will be set
 * @param   {Object} properties - object containing as key pair the key + value properties
 * @param   {Object} options - set the propery overriding the default options
 * @returns {Object} the original object modified
 */

function defineProperties(source, properties, options) {
  Object.entries(properties).forEach(_ref => {
    let [key, value] = _ref;
    defineProperty(source, key, value, options);
  });
  return source;
}
/**
 * Define default properties if they don't exist on the source object
 * @param   {Object} source - object that will receive the default properties
 * @param   {Object} defaults - object containing additional optional keys
 * @returns {Object} the original object received enhanced
 */

function defineDefaults(source, defaults) {
  Object.entries(defaults).forEach(_ref2 => {
    let [key, value] = _ref2;
    if (!source[key]) source[key] = value;
  });
  return source;
}

/**
 * Converts any DOM node/s to a loopable array
 * @param   { HTMLElement|NodeList } els - single html element or a node list
 * @returns { Array } always a loopable object
 */
function domToArray(els) {
  // can this object be already looped?
  if (!Array.isArray(els)) {
    // is it a node list?
    if (/^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else // if it's a single node
      // it will be returned as "array" with one single entry
      return [els];
  } // this object could be looped out of the box


  return els;
}

/**
 * Simple helper to find DOM nodes returning them as array like loopable object
 * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify
 * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes
 * @returns { Array } DOM nodes found as array
 */

function $(selector, ctx) {
  return domToArray(typeof selector === 'string' ? (ctx || document).querySelectorAll(selector) : selector);
}

/**
 * Normalize the return values, in case of a single value we avoid to return an array
 * @param   { Array } values - list of values we want to return
 * @returns { Array|string|boolean } either the whole list of values or the single one found
 * @private
 */

const normalize = values => values.length === 1 ? values[0] : values;
/**
 * Parse all the nodes received to get/remove/check their attributes
 * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse
 * @param   { string|Array }               name   - name or list of attributes
 * @param   { string }                     method - method that will be used to parse the attributes
 * @returns { Array|string } result of the parsing in a list or a single value
 * @private
 */


function parseNodes(els, name, method) {
  const names = typeof name === 'string' ? [name] : name;
  return normalize(domToArray(els).map(el => {
    return normalize(names.map(n => el[method](n)));
  }));
}
/**
 * Set any attribute on a single or a list of DOM nodes
 * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse
 * @param   { string|Object }              name  - either the name of the attribute to set
 *                                                 or a list of properties as object key - value
 * @param   { string }                     value - the new value of the attribute (optional)
 * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function
 *
 * @example
 *
 * import { set } from 'bianco.attr'
 *
 * const img = document.createElement('img')
 *
 * set(img, 'width', 100)
 *
 * // or also
 * set(img, {
 *   width: 300,
 *   height: 300
 * })
 *
 */


function set(els, name, value) {
  const attrs = typeof name === 'object' ? name : {
    [name]: value
  };
  const props = Object.keys(attrs);
  domToArray(els).forEach(el => {
    props.forEach(prop => el.setAttribute(prop, attrs[prop]));
  });
  return els;
}
/**
 * Get any attribute from a single or a list of DOM nodes
 * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse
 * @param   { string|Array }               name  - name or list of attributes to get
 * @returns { Array|string } list of the attributes found
 *
 * @example
 *
 * import { get } from 'bianco.attr'
 *
 * const img = document.createElement('img')
 *
 * get(img, 'width') // => '200'
 *
 * // or also
 * get(img, ['width', 'height']) // => ['200', '300']
 *
 * // or also
 * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]
 */

function get(els, name) {
  return parseNodes(els, name, 'getAttribute');
}

const CSS_BY_NAME = new Map();
const STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function

const getStyleNode = (style => {
  return () => {
    // lazy evaluation:
    // if this function was already called before
    // we return its cached result
    if (style) return style; // create a new style element or use an existing one
    // and cache it internally

    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');
    set(style, 'type', 'text/css');
    /* istanbul ignore next */

    if (!style.parentNode) document.head.appendChild(style);
    return style;
  };
})();
/**
 * Object that will be used to inject and manage the css of every tag instance
 */


var cssManager = {
  CSS_BY_NAME,

  /**
   * Save a tag style to be later injected into DOM
   * @param { string } name - if it's passed we will map the css to a tagname
   * @param { string } css - css string
   * @returns {Object} self
   */
  add(name, css) {
    if (!CSS_BY_NAME.has(name)) {
      CSS_BY_NAME.set(name, css);
      this.inject();
    }

    return this;
  },

  /**
   * Inject all previously saved tag styles into DOM
   * innerHTML seems slow: http://jsperf.com/riot-insert-style
   * @returns {Object} self
   */
  inject() {
    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\n');
    return this;
  },

  /**
   * Remove a tag style from the DOM
   * @param {string} name a registered tagname
   * @returns {Object} self
   */
  remove(name) {
    if (CSS_BY_NAME.has(name)) {
      CSS_BY_NAME.delete(name);
      this.inject();
    }

    return this;
  }

};

/**
 * Function to curry any javascript method
 * @param   {Function}  fn - the target function we want to curry
 * @param   {...[args]} acc - initial arguments
 * @returns {Function|*} it will return a function until the target function
 *                       will receive all of its arguments
 */
function curry(fn) {
  for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    acc[_key - 1] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args = [...acc, ...args];
    return args.length < fn.length ? curry(fn, ...args) : fn(...args);
  };
}

/**
 * Get the tag name of any DOM node
 * @param   {HTMLElement} element - DOM node we want to inspect
 * @returns {string} name to identify this dom node in riot
 */

function getName(element) {
  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();
}

const COMPONENT_CORE_HELPERS = Object.freeze({
  // component helpers
  $(selector) {
    return $(selector, this.root)[0];
  },

  $$(selector) {
    return $(selector, this.root);
  }

});
const PURE_COMPONENT_API = Object.freeze({
  [MOUNT_METHOD_KEY]: noop,
  [UPDATE_METHOD_KEY]: noop,
  [UNMOUNT_METHOD_KEY]: noop
});
const COMPONENT_LIFECYCLE_METHODS = Object.freeze({
  [SHOULD_UPDATE_KEY]: noop,
  [ON_BEFORE_MOUNT_KEY]: noop,
  [ON_MOUNTED_KEY]: noop,
  [ON_BEFORE_UPDATE_KEY]: noop,
  [ON_UPDATED_KEY]: noop,
  [ON_BEFORE_UNMOUNT_KEY]: noop,
  [ON_UNMOUNTED_KEY]: noop
});
const MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {
  clone: noop,
  createDOM: noop
});
/**
 * Performance optimization for the recursive components
 * @param  {RiotComponentShell} componentShell - riot compiler generated object
 * @returns {Object} component like interface
 */

const memoizedCreateComponent = memoize(createComponent);
/**
 * Evaluate the component properties either from its real attributes or from its initial user properties
 * @param   {HTMLElement} element - component root
 * @param   {Object}  initialProps - initial props
 * @returns {Object} component props key value pairs
 */

function evaluateInitialProps(element, initialProps) {
  if (initialProps === void 0) {
    initialProps = {};
  }

  return Object.assign({}, DOMattributesToObject(element), callOrAssign(initialProps));
}
/**
 * Bind a DOM node to its component object
 * @param   {HTMLElement} node - html node mounted
 * @param   {Object} component - Riot.js component object
 * @returns {Object} the component object received as second argument
 */


const bindDOMNodeToComponentObject = (node, component) => node[DOM_COMPONENT_INSTANCE_PROPERTY$1] = component;
/**
 * Wrap the Riot.js core API methods using a mapping function
 * @param   {Function} mapFunction - lifting function
 * @returns {Object} an object having the { mount, update, unmount } functions
 */


function createCoreAPIMethods(mapFunction) {
  return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {
    acc[method] = mapFunction(method);
    return acc;
  }, {});
}
/**
 * Factory function to create the component templates only once
 * @param   {Function} template - component template creation function
 * @param   {RiotComponentShell} componentShell - riot compiler generated object
 * @returns {TemplateChunk} template chunk object
 */


function componentTemplateFactory(template, componentShell) {
  const components = createSubcomponents(componentShell.exports ? componentShell.exports.components : {});
  return template(create, expressionTypes, bindingTypes, name => {
    // improve support for recursive components
    if (name === componentShell.name) return memoizedCreateComponent(componentShell); // return the registered components

    return components[name] || COMPONENTS_IMPLEMENTATION_MAP$1.get(name);
  });
}
/**
 * Create a pure component
 * @param   {Function} pureFactoryFunction - pure component factory function
 * @param   {Array} options.slots - component slots
 * @param   {Array} options.attributes - component attributes
 * @param   {Array} options.template - template factory function
 * @param   {Array} options.template - template factory function
 * @param   {any} options.props - initial component properties
 * @returns {Object} pure component object
 */


function createPureComponent(pureFactoryFunction, _ref) {
  let {
    slots,
    attributes,
    props,
    css,
    template
  } = _ref;
  if (template) panic('Pure components can not have html');
  if (css) panic('Pure components do not have css');
  const component = defineDefaults(pureFactoryFunction({
    slots,
    attributes,
    props
  }), PURE_COMPONENT_API);
  return createCoreAPIMethods(method => function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // intercept the mount calls to bind the DOM node to the pure object created
    // see also https://github.com/riot/riot/issues/2806
    if (method === MOUNT_METHOD_KEY) {
      const [el] = args; // mark this node as pure element

      el[IS_PURE_SYMBOL] = true;
      bindDOMNodeToComponentObject(el, component);
    }

    component[method](...args);
    return component;
  });
}
/**
 * Create the component interface needed for the @riotjs/dom-bindings tag bindings
 * @param   {RiotComponentShell} componentShell - riot compiler generated object
 * @param   {string} componentShell.css - component css
 * @param   {Function} componentShell.template - function that will return the dom-bindings template function
 * @param   {Object} componentShell.exports - component interface
 * @param   {string} componentShell.name - component name
 * @returns {Object} component like interface
 */


function createComponent(componentShell) {
  const {
    css,
    template,
    exports,
    name
  } = componentShell;
  const templateFn = template ? componentTemplateFactory(template, componentShell) : MOCKED_TEMPLATE_INTERFACE;
  return _ref2 => {
    let {
      slots,
      attributes,
      props
    } = _ref2;
    // pure components rendering will be managed by the end user
    if (exports && exports[IS_PURE_SYMBOL]) return createPureComponent(exports, {
      slots,
      attributes,
      props,
      css,
      template
    });
    const componentAPI = callOrAssign(exports) || {};
    const component = defineComponent({
      css,
      template: templateFn,
      componentAPI,
      name
    })({
      slots,
      attributes,
      props
    }); // notice that for the components create via tag binding
    // we need to invert the mount (state/parentScope) arguments
    // the template bindings will only forward the parentScope updates
    // and never deal with the component state

    return {
      mount(element, parentScope, state) {
        return component.mount(element, state, parentScope);
      },

      update(parentScope, state) {
        return component.update(state, parentScope);
      },

      unmount(preserveRoot) {
        return component.unmount(preserveRoot);
      }

    };
  };
}
/**
 * Component definition function
 * @param   {Object} implementation - the componen implementation will be generated via compiler
 * @param   {Object} component - the component initial properties
 * @returns {Object} a new component implementation object
 */

function defineComponent(_ref3) {
  let {
    css,
    template,
    componentAPI,
    name
  } = _ref3;
  // add the component css into the DOM
  if (css && name) cssManager.add(name, css);
  return curry(enhanceComponentAPI)(defineProperties( // set the component defaults without overriding the original component API
  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {
    [PROPS_KEY]: {},
    [STATE_KEY]: {}
  })), Object.assign({
    // defined during the component creation
    [SLOTS_KEY]: null,
    [ROOT_KEY]: null
  }, COMPONENT_CORE_HELPERS, {
    name,
    css,
    template
  })));
}
/**
 * Create the bindings to update the component attributes
 * @param   {HTMLElement} node - node where we will bind the expressions
 * @param   {Array} attributes - list of attribute bindings
 * @returns {TemplateChunk} - template bindings object
 */

function createAttributeBindings(node, attributes) {
  if (attributes === void 0) {
    attributes = [];
  }

  const expressions = attributes.map(a => create$4(node, a));
  const binding = {};
  return Object.assign(binding, Object.assign({
    expressions
  }, createCoreAPIMethods(method => scope => {
    expressions.forEach(e => e[method](scope));
    return binding;
  })));
}
/**
 * Create the subcomponents that can be included inside a tag in runtime
 * @param   {Object} components - components imported in runtime
 * @returns {Object} all the components transformed into Riot.Component factory functions
 */


function createSubcomponents(components) {
  if (components === void 0) {
    components = {};
  }

  return Object.entries(callOrAssign(components)).reduce((acc, _ref4) => {
    let [key, value] = _ref4;
    acc[camelToDashCase(key)] = createComponent(value);
    return acc;
  }, {});
}
/**
 * Run the component instance through all the plugins set by the user
 * @param   {Object} component - component instance
 * @returns {Object} the component enhanced by the plugins
 */


function runPlugins(component) {
  return [...PLUGINS_SET$1].reduce((c, fn) => fn(c) || c, component);
}
/**
 * Compute the component current state merging it with its previous state
 * @param   {Object} oldState - previous state object
 * @param   {Object} newState - new state givent to the `update` call
 * @returns {Object} new object state
 */


function computeState(oldState, newState) {
  return Object.assign({}, oldState, callOrAssign(newState));
}
/**
 * Add eventually the "is" attribute to link this DOM node to its css
 * @param {HTMLElement} element - target root node
 * @param {string} name - name of the component mounted
 * @returns {undefined} it's a void function
 */


function addCssHook(element, name) {
  if (getName(element) !== name) {
    set(element, IS_DIRECTIVE, name);
  }
}
/**
 * Component creation factory function that will enhance the user provided API
 * @param   {Object} component - a component implementation previously defined
 * @param   {Array} options.slots - component slots generated via riot compiler
 * @param   {Array} options.attributes - attribute expressions generated via riot compiler
 * @returns {Riot.Component} a riot component instance
 */


function enhanceComponentAPI(component, _ref5) {
  let {
    slots,
    attributes,
    props
  } = _ref5;
  return autobindMethods(runPlugins(defineProperties(isObject(component) ? Object.create(component) : component, {
    mount(element, state, parentScope) {
      if (state === void 0) {
        state = {};
      }

      this[PARENT_KEY_SYMBOL] = parentScope;
      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);
      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, evaluateInitialProps(element, props), evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions))));
      this[STATE_KEY] = computeState(this[STATE_KEY], state);
      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone(); // link this object to the DOM node

      bindDOMNodeToComponentObject(element, this); // add eventually the 'is' attribute

      component.name && addCssHook(element, component.name); // define the root element

      defineProperty(this, ROOT_KEY, element); // define the slots array

      defineProperty(this, SLOTS_KEY, slots); // before mount lifecycle event

      this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]); // mount the template

      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);
      this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);
      return this;
    },

    update(state, parentScope) {
      if (state === void 0) {
        state = {};
      }

      if (parentScope) {
        this[PARENT_KEY_SYMBOL] = parentScope;
        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);
      }

      const newProps = evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions);
      if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false) return;
      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, this[PROPS_KEY], newProps)));
      this[STATE_KEY] = computeState(this[STATE_KEY], state);
      this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]); // avoiding recursive updates
      // see also https://github.com/riot/riot/issues/2895

      if (!this[IS_COMPONENT_UPDATING]) {
        this[IS_COMPONENT_UPDATING] = true;
        this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);
      }

      this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);
      this[IS_COMPONENT_UPDATING] = false;
      return this;
    },

    unmount(preserveRoot) {
      this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);
      this[ATTRIBUTES_KEY_SYMBOL].unmount(); // if the preserveRoot is null the template html will be left untouched
      // in that case the DOM cleanup will happen differently from a parent node

      this[TEMPLATE_KEY_SYMBOL].unmount(this, this[PARENT_KEY_SYMBOL], preserveRoot === null ? null : !preserveRoot);
      this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);
      return this;
    }

  })), Object.keys(component).filter(prop => isFunction(component[prop])));
}
/**
 * Component initialization function starting from a DOM node
 * @param   {HTMLElement} element - element to upgrade
 * @param   {Object} initialProps - initial component properties
 * @param   {string} componentName - component id
 * @returns {Object} a new component instance bound to a DOM node
 */

function mountComponent(element, initialProps, componentName) {
  const name = componentName || getName(element);
  if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component named "${name}" was never registered`);
  const component = COMPONENTS_IMPLEMENTATION_MAP$1.get(name)({
    props: initialProps
  });
  return component.mount(element);
}

/**
 * Similar to compose but performs from left-to-right function composition.<br/>
 * {@link https://30secondsofcode.org/function#composeright see also}
 * @param   {...[function]} fns) - list of unary function
 * @returns {*} result of the computation
 */
/**
 * Performs right-to-left function composition.<br/>
 * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>
 * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>
 * {@link https://30secondsofcode.org/function#compose original source code}
 * @param   {...[function]} fns) - list of unary function
 * @returns {*} result of the computation
 */

function compose() {
  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    fns[_key2] = arguments[_key2];
  }

  return fns.reduce((f, g) => function () {
    return f(g(...arguments));
  });
}

const {
  DOM_COMPONENT_INSTANCE_PROPERTY,
  COMPONENTS_IMPLEMENTATION_MAP,
  PLUGINS_SET
} = globals;
/**
 * Riot public api
 */

/**
 * Register a custom tag by name
 * @param   {string} name - component name
 * @param   {Object} implementation - tag implementation
 * @returns {Map} map containing all the components implementations
 */

function register(name, _ref) {
  let {
    css,
    template,
    exports
  } = _ref;
  if (COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component "${name}" was already registered`);
  COMPONENTS_IMPLEMENTATION_MAP.set(name, createComponent({
    name,
    css,
    template,
    exports
  }));
  return COMPONENTS_IMPLEMENTATION_MAP;
}
/**
 * Unregister a riot web component
 * @param   {string} name - component name
 * @returns {Map} map containing all the components implementations
 */

function unregister(name) {
  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component "${name}" was never registered`);
  COMPONENTS_IMPLEMENTATION_MAP.delete(name);
  cssManager.remove(name);
  return COMPONENTS_IMPLEMENTATION_MAP;
}
/**
 * Mounting function that will work only for the components that were globally registered
 * @param   {string|HTMLElement} selector - query for the selection or a DOM element
 * @param   {Object} initialProps - the initial component properties
 * @param   {string} name - optional component name
 * @returns {Array} list of riot components
 */

function mount(selector, initialProps, name) {
  return $(selector).map(element => mountComponent(element, initialProps, name));
}
/**
 * Sweet unmounting helper function for the DOM node mounted manually by the user
 * @param   {string|HTMLElement} selector - query for the selection or a DOM element
 * @param   {boolean|null} keepRootElement - if true keep the root element
 * @returns {Array} list of nodes unmounted
 */

function unmount(selector, keepRootElement) {
  return $(selector).map(element => {
    if (element[DOM_COMPONENT_INSTANCE_PROPERTY]) {
      element[DOM_COMPONENT_INSTANCE_PROPERTY].unmount(keepRootElement);
    }

    return element;
  });
}
/**
 * Define a riot plugin
 * @param   {Function} plugin - function that will receive all the components created
 * @returns {Set} the set containing all the plugins installed
 */

function install(plugin) {
  if (!isFunction(plugin)) panic('Plugins must be of type function');
  if (PLUGINS_SET.has(plugin)) panic('This plugin was already installed');
  PLUGINS_SET.add(plugin);
  return PLUGINS_SET;
}
/**
 * Uninstall a riot plugin
 * @param   {Function} plugin - plugin previously installed
 * @returns {Set} the set containing all the plugins installed
 */

function uninstall(plugin) {
  if (!PLUGINS_SET.has(plugin)) panic('This plugin was never installed');
  PLUGINS_SET.delete(plugin);
  return PLUGINS_SET;
}
/**
 * Helper method to create component without relying on the registered ones
 * @param   {Object} implementation - component implementation
 * @returns {Function} function that will allow you to mount a riot component on a DOM node
 */

function component(implementation) {
  return function (el, props, _temp) {
    let {
      slots,
      attributes,
      parentScope
    } = _temp === void 0 ? {} : _temp;
    return compose(c => c.mount(el, parentScope), c => c({
      props,
      slots,
      attributes
    }), createComponent)(implementation);
  };
}
/**
 * Lift a riot component Interface into a pure riot object
 * @param   {Function} func - RiotPureComponent factory function
 * @returns {Function} the lifted original function received as argument
 */

function pure(func) {
  if (!isFunction(func)) panic('riot.pure accepts only arguments of type "function"');
  func[IS_PURE_SYMBOL] = true;
  return func;
}
/** @type {string} current riot version */

const version = 'v5.4.5'; // expose some internal stuff that might be used from external tools

const __ = {
  cssManager,
  DOMBindings,
  createComponent,
  defineComponent,
  globals
};




/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/sha.js/hash.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/hash.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer)

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),

/***/ "./node_modules/sha.js/sha256.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha256.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer)

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256


/***/ }),

/***/ "./node_modules/ua-parser-js/src/ua-parser.js":
/*!****************************************************!*\
  !*** ./node_modules/ua-parser-js/src/ua-parser.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/////////////////////////////////////////////////////////////////////////////////
/* UAParser.js v0.7.32
   Copyright Â© 2012-2021 Faisal Salman <f@faisalman.com>
   MIT License *//*
   Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.
   Supports browser & node.js environment. 
   Demo   : https://faisalman.github.io/ua-parser-js
   Source : https://github.com/faisalman/ua-parser-js */
/////////////////////////////////////////////////////////////////////////////////

(function (window, undefined) {

    'use strict';

    //////////////
    // Constants
    /////////////


    var LIBVERSION  = '0.7.32',
        EMPTY       = '',
        UNKNOWN     = '?',
        FUNC_TYPE   = 'function',
        UNDEF_TYPE  = 'undefined',
        OBJ_TYPE    = 'object',
        STR_TYPE    = 'string',
        MAJOR       = 'major',
        MODEL       = 'model',
        NAME        = 'name',
        TYPE        = 'type',
        VENDOR      = 'vendor',
        VERSION     = 'version',
        ARCHITECTURE= 'architecture',
        CONSOLE     = 'console',
        MOBILE      = 'mobile',
        TABLET      = 'tablet',
        SMARTTV     = 'smarttv',
        WEARABLE    = 'wearable',
        EMBEDDED    = 'embedded',
        UA_MAX_LENGTH = 350;

    var AMAZON  = 'Amazon',
        APPLE   = 'Apple',
        ASUS    = 'ASUS',
        BLACKBERRY = 'BlackBerry',
        BROWSER = 'Browser',
        CHROME  = 'Chrome',
        EDGE    = 'Edge',
        FIREFOX = 'Firefox',
        GOOGLE  = 'Google',
        HUAWEI  = 'Huawei',
        LG      = 'LG',
        MICROSOFT = 'Microsoft',
        MOTOROLA  = 'Motorola',
        OPERA   = 'Opera',
        SAMSUNG = 'Samsung',
        SHARP   = 'Sharp',
        SONY    = 'Sony',
        XIAOMI  = 'Xiaomi',
        ZEBRA   = 'Zebra',
        FACEBOOK   = 'Facebook';

    ///////////
    // Helper
    //////////

    var extend = function (regexes, extensions) {
            var mergedRegexes = {};
            for (var i in regexes) {
                if (extensions[i] && extensions[i].length % 2 === 0) {
                    mergedRegexes[i] = extensions[i].concat(regexes[i]);
                } else {
                    mergedRegexes[i] = regexes[i];
                }
            }
            return mergedRegexes;
        },
        enumerize = function (arr) {
            var enums = {};
            for (var i=0; i<arr.length; i++) {
                enums[arr[i].toUpperCase()] = arr[i];
            }
            return enums;
        },
        has = function (str1, str2) {
            return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
        },
        lowerize = function (str) {
            return str.toLowerCase();
        },
        majorize = function (version) {
            return typeof(version) === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split('.')[0] : undefined;
        },
        trim = function (str, len) {
            if (typeof(str) === STR_TYPE) {
                str = str.replace(/^\s\s*/, EMPTY).replace(/\s\s*$/, EMPTY);
                return typeof(len) === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
            }
    };

    ///////////////
    // Map helper
    //////////////

    var rgxMapper = function (ua, arrays) {

            var i = 0, j, k, p, q, matches, match;

            // loop through all regexes maps
            while (i < arrays.length && !matches) {

                var regex = arrays[i],       // even sequence (0,2,4,..)
                    props = arrays[i + 1];   // odd sequence (1,3,5,..)
                j = k = 0;

                // try matching uastring with regexes
                while (j < regex.length && !matches) {

                    matches = regex[j++].exec(ua);

                    if (!!matches) {
                        for (p = 0; p < props.length; p++) {
                            match = matches[++k];
                            q = props[p];
                            // check if given property is actually array
                            if (typeof q === OBJ_TYPE && q.length > 0) {
                                if (q.length === 2) {
                                    if (typeof q[1] == FUNC_TYPE) {
                                        // assign modified match
                                        this[q[0]] = q[1].call(this, match);
                                    } else {
                                        // assign given value, ignore regex match
                                        this[q[0]] = q[1];
                                    }
                                } else if (q.length === 3) {
                                    // check whether function or regex
                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                        // call function (usually string mapper)
                                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                                    } else {
                                        // sanitize match using given regex
                                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                                    }
                                } else if (q.length === 4) {
                                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                                }
                            } else {
                                this[q] = match ? match : undefined;
                            }
                        }
                    }
                }
                i += 2;
            }
        },

        strMapper = function (str, map) {

            for (var i in map) {
                // check if current value is array
                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                    for (var j = 0; j < map[i].length; j++) {
                        if (has(map[i][j], str)) {
                            return (i === UNKNOWN) ? undefined : i;
                        }
                    }
                } else if (has(map[i], str)) {
                    return (i === UNKNOWN) ? undefined : i;
                }
            }
            return str;
    };

    ///////////////
    // String map
    //////////////

    // Safari < 3.0
    var oldSafariMap = {
            '1.0'   : '/8',
            '1.2'   : '/1',
            '1.3'   : '/3',
            '2.0'   : '/412',
            '2.0.2' : '/416',
            '2.0.3' : '/417',
            '2.0.4' : '/419',
            '?'     : '/'
        },
        windowsVersionMap = {
            'ME'        : '4.90',
            'NT 3.11'   : 'NT3.51',
            'NT 4.0'    : 'NT4.0',
            '2000'      : 'NT 5.0',
            'XP'        : ['NT 5.1', 'NT 5.2'],
            'Vista'     : 'NT 6.0',
            '7'         : 'NT 6.1',
            '8'         : 'NT 6.2',
            '8.1'       : 'NT 6.3',
            '10'        : ['NT 6.4', 'NT 10.0'],
            'RT'        : 'ARM'
    };

    //////////////
    // Regex map
    /////////////

    var regexes = {

        browser : [[

            /\b(?:crmo|crios)\/([\w\.]+)/i                                      // Chrome for Android/iOS
            ], [VERSION, [NAME, 'Chrome']], [
            /edg(?:e|ios|a)?\/([\w\.]+)/i                                       // Microsoft Edge
            ], [VERSION, [NAME, 'Edge']], [

            // Presto based
            /(opera mini)\/([-\w\.]+)/i,                                        // Opera Mini
            /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,                 // Opera Mobi/Tablet
            /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i                           // Opera
            ], [NAME, VERSION], [
            /opios[\/ ]+([\w\.]+)/i                                             // Opera mini on iphone >= 8.0
            ], [VERSION, [NAME, OPERA+' Mini']], [
            /\bopr\/([\w\.]+)/i                                                 // Opera Webkit
            ], [VERSION, [NAME, OPERA]], [

            // Mixed
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,      // Lunascape/Maxthon/Netfront/Jasmine/Blazer
            // Trident based
            /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,               // Avant/IEMobile/SlimBrowser
            /(ba?idubrowser)[\/ ]?([\w\.]+)/i,                                  // Baidu Browser
            /(?:ms|\()(ie) ([\w\.]+)/i,                                         // Internet Explorer

            // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
                                                                                // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
            /(weibo)__([\d\.]+)/i                                               // Weibo
            ], [NAME, VERSION], [
            /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i                 // UCBrowser
            ], [VERSION, [NAME, 'UC'+BROWSER]], [
            /microm.+\bqbcore\/([\w\.]+)/i,                                     // WeChat Desktop for Windows Built-in Browser
            /\bqbcore\/([\w\.]+).+microm/i
            ], [VERSION, [NAME, 'WeChat(Win) Desktop']], [
            /micromessenger\/([\w\.]+)/i                                        // WeChat
            ], [VERSION, [NAME, 'WeChat']], [
            /konqueror\/([\w\.]+)/i                                             // Konqueror
            ], [VERSION, [NAME, 'Konqueror']], [
            /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i                       // IE11
            ], [VERSION, [NAME, 'IE']], [
            /yabrowser\/([\w\.]+)/i                                             // Yandex
            ], [VERSION, [NAME, 'Yandex']], [
            /(avast|avg)\/([\w\.]+)/i                                           // Avast/AVG Secure Browser
            ], [[NAME, /(.+)/, '$1 Secure '+BROWSER], VERSION], [
            /\bfocus\/([\w\.]+)/i                                               // Firefox Focus
            ], [VERSION, [NAME, FIREFOX+' Focus']], [
            /\bopt\/([\w\.]+)/i                                                 // Opera Touch
            ], [VERSION, [NAME, OPERA+' Touch']], [
            /coc_coc\w+\/([\w\.]+)/i                                            // Coc Coc Browser
            ], [VERSION, [NAME, 'Coc Coc']], [
            /dolfin\/([\w\.]+)/i                                                // Dolphin
            ], [VERSION, [NAME, 'Dolphin']], [
            /coast\/([\w\.]+)/i                                                 // Opera Coast
            ], [VERSION, [NAME, OPERA+' Coast']], [
            /miuibrowser\/([\w\.]+)/i                                           // MIUI Browser
            ], [VERSION, [NAME, 'MIUI '+BROWSER]], [
            /fxios\/([-\w\.]+)/i                                                // Firefox for iOS
            ], [VERSION, [NAME, FIREFOX]], [
            /\bqihu|(qi?ho?o?|360)browser/i                                     // 360
            ], [[NAME, '360 '+BROWSER]], [
            /(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i
            ], [[NAME, /(.+)/, '$1 '+BROWSER], VERSION], [                      // Oculus/Samsung/Sailfish/Huawei Browser
            /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
            ], [[NAME, /_/g, ' '], VERSION], [
            /(electron)\/([\w\.]+) safari/i,                                    // Electron-based App
            /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,                   // Tesla
            /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i            // QQBrowser/Baidu App/2345 Browser
            ], [NAME, VERSION], [
            /(metasr)[\/ ]?([\w\.]+)/i,                                         // SouGouBrowser
            /(lbbrowser)/i,                                                     // LieBao Browser
            /\[(linkedin)app\]/i                                                // LinkedIn App for iOS & Android
            ], [NAME], [

            // WebView
            /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i       // Facebook App for iOS & Android
            ], [[NAME, FACEBOOK], VERSION], [
            /safari (line)\/([\w\.]+)/i,                                        // Line App for iOS
            /\b(line)\/([\w\.]+)\/iab/i,                                        // Line App for Android
            /(chromium|instagram)[\/ ]([-\w\.]+)/i                              // Chromium/Instagram
            ], [NAME, VERSION], [
            /\bgsa\/([\w\.]+) .*safari\//i                                      // Google Search Appliance on iOS
            ], [VERSION, [NAME, 'GSA']], [

            /headlesschrome(?:\/([\w\.]+)| )/i                                  // Chrome Headless
            ], [VERSION, [NAME, CHROME+' Headless']], [

            / wv\).+(chrome)\/([\w\.]+)/i                                       // Chrome WebView
            ], [[NAME, CHROME+' WebView'], VERSION], [

            /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i           // Android Browser
            ], [VERSION, [NAME, 'Android '+BROWSER]], [

            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i       // Chrome/OmniWeb/Arora/Tizen/Nokia
            ], [NAME, VERSION], [

            /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i                      // Mobile Safari
            ], [VERSION, [NAME, 'Mobile Safari']], [
            /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i                // Safari & Safari Mobile
            ], [VERSION, NAME], [
            /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i                      // Safari < 3.0
            ], [NAME, [VERSION, strMapper, oldSafariMap]], [

            /(webkit|khtml)\/([\w\.]+)/i
            ], [NAME, VERSION], [

            // Gecko based
            /(navigator|netscape\d?)\/([-\w\.]+)/i                              // Netscape
            ], [[NAME, 'Netscape'], VERSION], [
            /mobile vr; rv:([\w\.]+)\).+firefox/i                               // Firefox Reality
            ], [VERSION, [NAME, FIREFOX+' Reality']], [
            /ekiohf.+(flow)\/([\w\.]+)/i,                                       // Flow
            /(swiftfox)/i,                                                      // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(firefox)\/([\w\.]+)/i,                                            // Other Firefox-based
            /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,                         // Mozilla

            // Other
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
            /(links) \(([\w\.]+)/i                                              // Links
            ], [NAME, VERSION]
        ],

        cpu : [[

            /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i                     // AMD64 (x64)
            ], [[ARCHITECTURE, 'amd64']], [

            /(ia32(?=;))/i                                                      // IA32 (quicktime)
            ], [[ARCHITECTURE, lowerize]], [

            /((?:i[346]|x)86)[;\)]/i                                            // IA32 (x86)
            ], [[ARCHITECTURE, 'ia32']], [

            /\b(aarch64|arm(v?8e?l?|_?64))\b/i                                 // ARM64
            ], [[ARCHITECTURE, 'arm64']], [

            /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i                                   // ARMHF
            ], [[ARCHITECTURE, 'armhf']], [

            // PocketPC mistakenly identified as PowerPC
            /windows (ce|mobile); ppc;/i
            ], [[ARCHITECTURE, 'arm']], [

            /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i                            // PowerPC
            ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [

            /(sun4\w)[;\)]/i                                                    // SPARC
            ], [[ARCHITECTURE, 'sparc']], [

            /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
            ], [[ARCHITECTURE, lowerize]]
        ],

        device : [[

            //////////////////////////
            // MOBILES & TABLETS
            // Ordered by popularity
            /////////////////////////

            // Samsung
            /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [
            /\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i,
            /samsung[- ]([-\w]+)/i,
            /sec-(sgh\w+)/i
            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [

            // Apple
            /\((ip(?:hone|od)[\w ]*);/i                                         // iPod/iPhone
            ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [
            /\((ipad);[-\w\),; ]+apple/i,                                       // iPad
            /applecoremedia\/[\w\.]+ \((ipad)/i,
            /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
            ], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [

            // Huawei
            /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
            ], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [
            /(?:huawei|honor)([-\w ]+)[;\)]/i,
            /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
            ], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [

            // Xiaomi
            /\b(poco[\w ]+)(?: bui|\))/i,                                       // Xiaomi POCO
            /\b; (\w+) build\/hm\1/i,                                           // Xiaomi Hongmi 'numeric' models
            /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,                             // Xiaomi Hongmi
            /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,                   // Xiaomi Redmi
            /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i // Xiaomi Mi
            ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, MOBILE]], [
            /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i                        // Mi Pad tablets
            ],[[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, TABLET]], [

            // OPPO
            /; (\w+) bui.+ oppo/i,
            /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
            ], [MODEL, [VENDOR, 'OPPO'], [TYPE, MOBILE]], [

            // Vivo
            /vivo (\w+)(?: bui|\))/i,
            /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
            ], [MODEL, [VENDOR, 'Vivo'], [TYPE, MOBILE]], [

            // Realme
            /\b(rmx[12]\d{3})(?: bui|;|\))/i
            ], [MODEL, [VENDOR, 'Realme'], [TYPE, MOBILE]], [

            // Motorola
            /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
            /\bmot(?:orola)?[- ](\w*)/i,
            /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [
            /\b(mz60\d|xoom[2 ]{0,2}) build\//i
            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [

            // LG
            /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
            ], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [
            /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
            /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
            /\blg-?([\d\w]+) bui/i
            ], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [

            // Lenovo
            /(ideatab[-\w ]+)/i,
            /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [

            // Nokia
            /(?:maemo|nokia).*(n900|lumia \d+)/i,
            /nokia[-_ ]?([-\w\.]*)/i
            ], [[MODEL, /_/g, ' '], [VENDOR, 'Nokia'], [TYPE, MOBILE]], [

            // Google
            /(pixel c)\b/i                                                      // Google Pixel C
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [
            /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i                         // Google Pixel
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [

            // Sony
            /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
            ], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [
            /sony tablet [ps]/i,
            /\b(?:sony)?sgp\w+(?: bui|\))/i
            ], [[MODEL, 'Xperia Tablet'], [VENDOR, SONY], [TYPE, TABLET]], [

            // OnePlus
            / (kb2005|in20[12]5|be20[12][59])\b/i,
            /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
            ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [

            // Amazon
            /(alexa)webm/i,
            /(kf[a-z]{2}wi)( bui|\))/i,                                         // Kindle Fire without Silk
            /(kf[a-z]+)( bui|\)).+silk\//i                                      // Kindle Fire HD
            ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [
            /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i                     // Fire Phone
            ], [[MODEL, /(.+)/g, 'Fire Phone $1'], [VENDOR, AMAZON], [TYPE, MOBILE]], [

            // BlackBerry
            /(playbook);[-\w\),; ]+(rim)/i                                      // BlackBerry PlayBook
            ], [MODEL, VENDOR, [TYPE, TABLET]], [
            /\b((?:bb[a-f]|st[hv])100-\d)/i,
            /\(bb10; (\w+)/i                                                    // BlackBerry 10
            ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [

            // Asus
            /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
            ], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [
            / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
            ], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [

            // HTC
            /(nexus 9)/i                                                        // HTC Nexus 9
            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [
            /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,                         // HTC

            // ZTE
            /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
            /(alcatel|geeksphone|nexian|panasonic|sony(?!-bra))[-_ ]?([-\w]*)/i         // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

            // Acer
            /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [

            // Meizu
            /droid.+; (m[1-5] note) bui/i,
            /\bmz-([-\w]{2,})/i
            ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [

            // Sharp
            /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
            ], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [

            // MIXED
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
                                                                                // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
            /(hp) ([\w ]+\w)/i,                                                 // HP iPAQ
            /(asus)-?(\w+)/i,                                                   // Asus
            /(microsoft); (lumia[\w ]+)/i,                                      // Microsoft Lumia
            /(lenovo)[-_ ]?([-\w]+)/i,                                          // Lenovo
            /(jolla)/i,                                                         // Jolla
            /(oppo) ?([\w ]+) bui/i                                             // OPPO
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /(archos) (gamepad2?)/i,                                            // Archos
            /(hp).+(touchpad(?!.+tablet)|tablet)/i,                             // HP TouchPad
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /(nook)[\w ]+build\/(\w+)/i,                                        // Nook
            /(dell) (strea[kpr\d ]*[\dko])/i,                                   // Dell Streak
            /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,                                  // Le Pan Tablets
            /(trinity)[- ]*(t\d{3}) bui/i,                                      // Trinity Tablets
            /(gigaset)[- ]+(q\w{1,9}) bui/i,                                    // Gigaset Tablets
            /(vodafone) ([\w ]+)(?:\)| bui)/i                                   // Vodafone
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /(surface duo)/i                                                    // Surface Duo
            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [
            /droid [\d\.]+; (fp\du?)(?: b|\))/i                                 // Fairphone
            ], [MODEL, [VENDOR, 'Fairphone'], [TYPE, MOBILE]], [
            /(u304aa)/i                                                         // AT&T
            ], [MODEL, [VENDOR, 'AT&T'], [TYPE, MOBILE]], [
            /\bsie-(\w*)/i                                                      // Siemens
            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [
            /\b(rct\w+) b/i                                                     // RCA Tablets
            ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [
            /\b(venue[\d ]{2,7}) b/i                                            // Dell Venue Tablets
            ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [
            /\b(q(?:mv|ta)\w+) b/i                                              // Verizon Tablet
            ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [
            /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i                       // Barnes & Noble Tablet
            ], [MODEL, [VENDOR, 'Barnes & Noble'], [TYPE, TABLET]], [
            /\b(tm\d{3}\w+) b/i
            ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [
            /\b(k88) b/i                                                        // ZTE K Series Tablet
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [
            /\b(nx\d{3}j) b/i                                                   // ZTE Nubia
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [
            /\b(gen\d{3}) b.+49h/i                                              // Swiss GEN Mobile
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [
            /\b(zur\d{3}) b/i                                                   // Swiss ZUR Tablet
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [
            /\b((zeki)?tb.*\b) b/i                                              // Zeki Tablets
            ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [
            /\b([yr]\d{2}) b/i,
            /\b(dragon[- ]+touch |dt)(\w{5}) b/i                                // Dragon Touch Tablet
            ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [
            /\b(ns-?\w{0,9}) b/i                                                // Insignia Tablets
            ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [
            /\b((nxa|next)-?\w{0,9}) b/i                                        // NextBook Tablets
            ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [
            /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i                  // Voice Xtreme Phones
            ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [
            /\b(lvtel\-)?(v1[12]) b/i                                           // LvTel Phones
            ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [
            /\b(ph-1) /i                                                        // Essential PH-1
            ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [
            /\b(v(100md|700na|7011|917g).*\b) b/i                               // Envizen Tablets
            ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [
            /\b(trio[-\w\. ]+) b/i                                              // MachSpeed Tablets
            ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [
            /\btu_(1491) b/i                                                    // Rotor Tablets
            ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [
            /(shield[\w ]+) b/i                                                 // Nvidia Shield Tablets
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, TABLET]], [
            /(sprint) (\w+)/i                                                   // Sprint Phones
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /(kin\.[onetw]{3})/i                                                // Microsoft Kin
            ], [[MODEL, /\./g, ' '], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [
            /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i             // Zebra
            ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [
            /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
            ], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [

            ///////////////////
            // CONSOLES
            ///////////////////

            /(ouya)/i,                                                          // Ouya
            /(nintendo) ([wids3utch]+)/i                                        // Nintendo
            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [
            /droid.+; (shield) bui/i                                            // Nvidia
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [
            /(playstation [345portablevi]+)/i                                   // Playstation
            ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [
            /\b(xbox(?: one)?(?!; xbox))[\); ]/i                                // Microsoft Xbox
            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [

            ///////////////////
            // SMARTTVS
            ///////////////////

            /smart-tv.+(samsung)/i                                              // Samsung
            ], [VENDOR, [TYPE, SMARTTV]], [
            /hbbtv.+maple;(\d+)/i
            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [
            /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i        // LG SmartTV
            ], [[VENDOR, LG], [TYPE, SMARTTV]], [
            /(apple) ?tv/i                                                      // Apple TV
            ], [VENDOR, [MODEL, APPLE+' TV'], [TYPE, SMARTTV]], [
            /crkey/i                                                            // Google Chromecast
            ], [[MODEL, CHROME+'cast'], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [
            /droid.+aft(\w)( bui|\))/i                                          // Fire TV
            ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [
            /\(dtv[\);].+(aquos)/i,
            /(aquos-tv[\w ]+)\)/i                                               // Sharp
            ], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],[
            /(bravia[\w ]+)( bui|\))/i                                              // Sony
            ], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [
            /(mitv-\w{5}) bui/i                                                 // Xiaomi
            ], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [
            /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,                          // Roku
            /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i               // HbbTV devices
            ], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [
            /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i                   // SmartTV from Unidentified Vendors
            ], [[TYPE, SMARTTV]], [

            ///////////////////
            // WEARABLES
            ///////////////////

            /((pebble))app/i                                                    // Pebble
            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [
            /droid.+; (glass) \d/i                                              // Google Glass
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [
            /droid.+; (wt63?0{2,3})\)/i
            ], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [
            /(quest( 2)?)/i                                                     // Oculus Quest
            ], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [

            ///////////////////
            // EMBEDDED
            ///////////////////

            /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i                              // Tesla
            ], [VENDOR, [TYPE, EMBEDDED]], [

            ////////////////////
            // MIXED (GENERIC)
            ///////////////////

            /droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i           // Android Phones from Unidentified Vendors
            ], [MODEL, [TYPE, MOBILE]], [
            /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i       // Android Tablets from Unidentified Vendors
            ], [MODEL, [TYPE, TABLET]], [
            /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i                      // Unidentifiable Tablet
            ], [[TYPE, TABLET]], [
            /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i    // Unidentifiable Mobile
            ], [[TYPE, MOBILE]], [
            /(android[-\w\. ]{0,9});.+buil/i                                    // Generic Android Device
            ], [MODEL, [VENDOR, 'Generic']]
        ],

        engine : [[

            /windows.+ edge\/([\w\.]+)/i                                       // EdgeHTML
            ], [VERSION, [NAME, EDGE+'HTML']], [

            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i                         // Blink
            ], [VERSION, [NAME, 'Blink']], [

            /(presto)\/([\w\.]+)/i,                                             // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
            /ekioh(flow)\/([\w\.]+)/i,                                          // Flow
            /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,                           // KHTML/Tasman/Links
            /(icab)[\/ ]([23]\.[\d\.]+)/i                                       // iCab
            ], [NAME, VERSION], [

            /rv\:([\w\.]{1,9})\b.+(gecko)/i                                     // Gecko
            ], [VERSION, NAME]
        ],

        os : [[

            // Windows
            /microsoft (windows) (vista|xp)/i                                   // Windows (iTunes)
            ], [NAME, VERSION], [
            /(windows) nt 6\.2; (arm)/i,                                        // Windows RT
            /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,            // Windows Phone
            /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i
            ], [NAME, [VERSION, strMapper, windowsVersionMap]], [
            /(win(?=3|9|n)|win 9x )([nt\d\.]+)/i
            ], [[NAME, 'Windows'], [VERSION, strMapper, windowsVersionMap]], [

            // iOS/macOS
            /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,              // iOS
            /cfnetwork\/.+darwin/i
            ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [
            /(mac os x) ?([\w\. ]*)/i,
            /(macintosh|mac_powerpc\b)(?!.+haiku)/i                             // Mac OS
            ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [

            // Mobile OSes
            /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i                    // Android-x86/HarmonyOS
            ], [VERSION, NAME], [                                               // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
            /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
            /(blackberry)\w*\/([\w\.]*)/i,                                      // Blackberry
            /(tizen|kaios)[\/ ]([\w\.]+)/i,                                     // Tizen/KaiOS
            /\((series40);/i                                                    // Series 40
            ], [NAME, VERSION], [
            /\(bb(10);/i                                                        // BlackBerry 10
            ], [VERSION, [NAME, BLACKBERRY]], [
            /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i         // Symbian
            ], [VERSION, [NAME, 'Symbian']], [
            /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i // Firefox OS
            ], [VERSION, [NAME, FIREFOX+' OS']], [
            /web0s;.+rt(tv)/i,
            /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i                              // WebOS
            ], [VERSION, [NAME, 'webOS']], [

            // Google Chromecast
            /crkey\/([\d\.]+)/i                                                 // Google Chromecast
            ], [VERSION, [NAME, CHROME+'cast']], [
            /(cros) [\w]+ ([\w\.]+\w)/i                                         // Chromium OS
            ], [[NAME, 'Chromium OS'], VERSION],[

            // Console
            /(nintendo|playstation) ([wids345portablevuch]+)/i,                 // Nintendo/Playstation
            /(xbox); +xbox ([^\);]+)/i,                                         // Microsoft Xbox (360, One, X, S, Series X, Series S)

            // Other
            /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,                            // Joli/Palm
            /(mint)[\/\(\) ]?(\w*)/i,                                           // Mint
            /(mageia|vectorlinux)[; ]/i,                                        // Mageia/VectorLinux
            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                                                                                // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
            /(hurd|linux) ?([\w\.]*)/i,                                         // Hurd/Linux
            /(gnu) ?([\w\.]*)/i,                                                // GNU
            /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
            /(haiku) (\w+)/i                                                    // Haiku
            ], [NAME, VERSION], [
            /(sunos) ?([\w\.\d]*)/i                                             // Solaris
            ], [[NAME, 'Solaris'], VERSION], [
            /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,                              // Solaris
            /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,                                  // AIX
            /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i,            // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX
            /(unix) ?([\w\.]*)/i                                                // UNIX
            ], [NAME, VERSION]
        ]
    };

    /////////////////
    // Constructor
    ////////////////

    var UAParser = function (ua, extensions) {

        if (typeof ua === OBJ_TYPE) {
            extensions = ua;
            ua = undefined;
        }

        if (!(this instanceof UAParser)) {
            return new UAParser(ua, extensions).getResult();
        }

        var _ua = ua || ((typeof window !== UNDEF_TYPE && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);
        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;

        this.getBrowser = function () {
            var _browser = {};
            _browser[NAME] = undefined;
            _browser[VERSION] = undefined;
            rgxMapper.call(_browser, _ua, _rgxmap.browser);
            _browser.major = majorize(_browser.version);
            return _browser;
        };
        this.getCPU = function () {
            var _cpu = {};
            _cpu[ARCHITECTURE] = undefined;
            rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
            return _cpu;
        };
        this.getDevice = function () {
            var _device = {};
            _device[VENDOR] = undefined;
            _device[MODEL] = undefined;
            _device[TYPE] = undefined;
            rgxMapper.call(_device, _ua, _rgxmap.device);
            return _device;
        };
        this.getEngine = function () {
            var _engine = {};
            _engine[NAME] = undefined;
            _engine[VERSION] = undefined;
            rgxMapper.call(_engine, _ua, _rgxmap.engine);
            return _engine;
        };
        this.getOS = function () {
            var _os = {};
            _os[NAME] = undefined;
            _os[VERSION] = undefined;
            rgxMapper.call(_os, _ua, _rgxmap.os);
            return _os;
        };
        this.getResult = function () {
            return {
                ua      : this.getUA(),
                browser : this.getBrowser(),
                engine  : this.getEngine(),
                os      : this.getOS(),
                device  : this.getDevice(),
                cpu     : this.getCPU()
            };
        };
        this.getUA = function () {
            return _ua;
        };
        this.setUA = function (ua) {
            _ua = (typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH) ? trim(ua, UA_MAX_LENGTH) : ua;
            return this;
        };
        this.setUA(_ua);
        return this;
    };

    UAParser.VERSION = LIBVERSION;
    UAParser.BROWSER =  enumerize([NAME, VERSION, MAJOR]);
    UAParser.CPU = enumerize([ARCHITECTURE]);
    UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
    UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);

    ///////////
    // Export
    //////////

    // check js environment
    if (typeof(exports) !== UNDEF_TYPE) {
        // nodejs env
        if ("object" !== UNDEF_TYPE && module.exports) {
            exports = module.exports = UAParser;
        }
        exports.UAParser = UAParser;
    } else {
        // requirejs env (optional)
        if ("function" === FUNC_TYPE && __webpack_require__.amdO) {
            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
                return UAParser;
            }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else if (typeof window !== UNDEF_TYPE) {
            // browser env
            window.UAParser = UAParser;
        }
    }

    // jQuery/Zepto specific (optional)
    // Note:
    //   In AMD env the global scope should be kept clean, but jQuery is an exception.
    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
    //   and we should catch that.
    var $ = typeof window !== UNDEF_TYPE && (window.jQuery || window.Zepto);
    if ($ && !$.ua) {
        var parser = new UAParser();
        $.ua = parser.getResult();
        $.ua.get = function () {
            return parser.getUA();
        };
        $.ua.set = function (ua) {
            parser.setUA(ua);
            var result = parser.getResult();
            for (var prop in result) {
                $.ua[prop] = result[prop];
            }
        };
    }

})(typeof window === 'object' ? window : this);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _assets_images_obs_create_text_source_png__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assets/images/obs-create-text-source.png */ "./src/assets/images/obs-create-text-source.png");
/* harmony import */ var _assets_images_obs_websocket_connection_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assets/images/obs-websocket-connection.png */ "./src/assets/images/obs-websocket-connection.png");
/* harmony import */ var bootstrap_native__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bootstrap.native */ "./node_modules/bootstrap.native/dist/bootstrap-native.esm.js");
/* harmony import */ var riot__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! riot */ "./node_modules/riot/riot.esm.js");
/* harmony import */ var _views_HomeView_tag_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./views/HomeView.tag.html */ "./src/views/HomeView.tag.html");
// Assets


 // eslint-disable-line no-unused-vars


riot__WEBPACK_IMPORTED_MODULE_4__.register("homeview", _views_HomeView_tag_html__WEBPACK_IMPORTED_MODULE_3__["default"]);
riot__WEBPACK_IMPORTED_MODULE_4__.mount("homeview");
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFVBQVU7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxZQUFZLHNDQUFzQzs7QUFFbEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFVBQVUsMEJBQTBCO0FBQ3BDLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFFBQVE7QUFDUiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixZQUFZLFNBQVM7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsV0FBVztBQUN0QixXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFFBQVE7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixhQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LG1CQUFPLENBQUMsNkRBQVU7QUFDakMsV0FBVyxtQkFBTyxDQUFDLDZDQUFRO0FBQzNCLGFBQWEsc0ZBQTZCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTtBQUMxQixTQUFTLFFBQVE7O0FBRWpCLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZkE7QUFDb0Q7QUFDRTtBQUViLENBQUM7QUFDYjtBQUNvQjtBQUVqRDJCLDBDQUFhLENBQUMsVUFBVSxFQUFFQyxnRUFBUSxDQUFDO0FBQ25DRCx1Q0FBVSxDQUFDLFVBQVUsQ0FBQyxDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9zcmMvdmlld3MvSG9tZVZpZXcudGFnLmh0bWwiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9zcmMvbW9kZWxzL0Zvcm1hdE1vZGVsLmpzIiwid2VicGFjazovL29icy10cmFuc2NyaXB0Ly4vc3JjL21vZGVscy9Ib21lTW9kZWwuanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9zcmMvbW9kZWxzL1NwZWVjaFJlY29nbml0aW9uTW9kZWwuanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9zcmMvcmVwb3NpdG9yaWVzL09CU1JlcG9zaXRvcnkuanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovL29icy10cmFuc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC5uYXRpdmUvZGlzdC9ib290c3RyYXAtbmF0aXZlLmVzbS5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovL29icy10cmFuc2NyaXB0Ly4vc3JjL2Fzc2V0cy9pbWFnZXMvb2JzLWNyZWF0ZS10ZXh0LXNvdXJjZS5wbmciLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9zcmMvYXNzZXRzL2ltYWdlcy9vYnMtd2Vic29ja2V0LWNvbm5lY3Rpb24ucG5nIiwid2VicGFjazovL29icy10cmFuc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL25vZGVfbW9kdWxlcy9pc29tb3JwaGljLXdzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvb2JzLXdlYnNvY2tldC1qcy9saWIvT0JTV2ViU29ja2V0LmpzIiwid2VicGFjazovL29icy10cmFuc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL29icy13ZWJzb2NrZXQtanMvbGliL1NvY2tldC5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL25vZGVfbW9kdWxlcy9vYnMtd2Vic29ja2V0LWpzL2xpYi9TdGF0dXMuanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvb2JzLXdlYnNvY2tldC1qcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvb2JzLXdlYnNvY2tldC1qcy9saWIvdXRpbC9hdXRoZW50aWNhdGlvbkhhc2hpbmcuanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvb2JzLXdlYnNvY2tldC1qcy9saWIvdXRpbC9jYW1lbENhc2VLZXlzLmpzIiwid2VicGFjazovL29icy10cmFuc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL29icy13ZWJzb2NrZXQtanMvbGliL3V0aWwvbG9nQW1iaWd1b3VzRXJyb3IuanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvcmlvdC9yaW90LmVzbS5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL25vZGVfbW9kdWxlcy9zaGEuanMvaGFzaC5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjU2LmpzIiwid2VicGFjazovL29icy10cmFuc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3VhLXBhcnNlci1qcy9zcmMvdWEtcGFyc2VyLmpzIiwid2VicGFjazovL29icy10cmFuc2NyaXB0L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL29icy10cmFuc2NyaXB0L3dlYnBhY2svcnVudGltZS9hbWQgb3B0aW9ucyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL29icy10cmFuc2NyaXB0L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiPEhvbWVWaWV3PlxuICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gICAgPGRpdiBjbGFzcz1cImp1bWJvdHJvblwiPlxuICAgICAgPGgxPk9CUyBUcmFuc2NyaXB0PC9oMT5cbiAgICAgIDxwPlxuICAgICAgICBSZWFsLXRpbWUgc3VidGl0bGUgZ2VuZXJhdGlvbiBieSBzcGVlY2ggcmVjb2duaXRpb24gZm9yIDxhIGhyZWY9XCJodHRwczovL29ic3Byb2plY3QuY29tL1wiPk9CUyBTdHVkaW88L2E+LlxuICAgICAgICA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL3Nwb25zb3JzL2FrYWJlXCI+PGltZyBzcmM9XCJodHRwczovL2ltZy5zaGllbGRzLmlvL3N0YXRpYy92MT9sYWJlbD1TcG9uc29yJm1lc3NhZ2U9JUUyJTlEJUE0JmxvZ289R2l0SHViJmNvbG9yPWZmNjliNCZsaW5rPWh0dHBzOi8vZ2l0aHViLmNvbS9zcG9uc29ycy9zcnotenVtaXhcIiBhbHQ9XCJTcG9uc29yXCIgLz48L2E+XG4gICAgICA8L3A+XG4gICAgICA8c2VjdGlvbj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwXCI+XG5cdCAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIj5MYW5ndWFnZTwvc3Bhbj5cbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiTGFuZ3VhZ2VcIlxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJ7IGhvbWVNb2RlbC5sYW5nIH1cIlxuICAgICAgICAgICAgICAgICAgICAgb25pbnB1dD1cInsgZSA9PiBob21lTW9kZWwubGFuZyA9IGUudGFyZ2V0LnZhbHVlIH1cIlxuICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9XCJ7IGlzUnVubmluZyB9XCIgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtMlwiPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYnRuIHsgaXNSdW5uaW5nID8gJ2J0bi1kYW5nZXInIDogJ2J0bi1zdWNjZXNzJyB9XCJcbiAgICAgICAgICAgICAgICAgICB2YWx1ZT1cInsgaXNSdW5uaW5nID8gJ1N0b3AnIDogJ1N0YXJ0JyB9XCJcbiAgICAgICAgICAgICAgICAgICBvbmNsaWNrPVwieyBvblRvZ2dsZVN0YXJ0U3RvcEJ1dHRvbiB9XCJcbiAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD1cInsgIWhvbWVNb2RlbC5pc1N1cHBvcnRlZCB9XCIgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L3NlY3Rpb24+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTEyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC1kYW5nZXJcIiByb2xlPVwiYWxlcnRcIiBpZj1cInsgZXJyb3JNZXNzYWdlIH1cIj5cbiAgICAgICAgICA8c3Ryb25nPkVycm9yPC9zdHJvbmc+OiB7IGVycm9yTWVzc2FnZSB9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8c2VjdGlvbj5cbiAgICAgIDxoMj5TZXR1cDwvaDI+XG5cbiAgICAgIDxzZWN0aW9uPlxuICAgICAgICA8aDM+MS4gRW5hYmxlIE9CUyBXZWJTb2NrZXQ8L2gzPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC03XCI+XG4gICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgSW5zdGFsbCA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL1BhbGFraXMvb2JzLXdlYnNvY2tldC9yZWxlYXNlc1wiPm9icy13ZWJzb2NrZXQ8L2E+IDQuOCBvciBhYm92ZSwgYW5kXG4gICAgICAgICAgICAgIG9wZW4gXCJXZWJTb2NrZXQgU2VydmVyIFNldHRpbmdzXCIgZGlhbG9nIHVuZGVyIFwiVG9vbHNcIiBtZW51IGluIE9CUy5cbiAgICAgICAgICAgICAgQWZ0ZXIgYWN0aXZhdGlvbiBvZiBPQlMgV2ViU29ja2V0IFNlcnZlciwgY29weSB0aGUgV2ViU29ja2V0IHNldHRpbmdzIGludG8gdGhlIGZvbGxvd2luZyB0ZXh0IGJveGVzLlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgIDxsYWJlbD5BZGRyZXNzPC9sYWJlbD5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwXCI+XG5cdCAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvblwiPndzOi8vPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJIb3N0OlBvcnRcIlxuICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cInsgaG9tZU1vZGVsLndlYnNvY2tldEFkZHJlc3MgfVwiXG4gICAgICAgICAgICAgICAgICAgICAgIG9uaW5wdXQ9XCJ7IGUgPT4gaG9tZU1vZGVsLndlYnNvY2tldEFkZHJlc3MgPSBlLnRhcmdldC52YWx1ZSB9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9XCJ7IGlzUnVubmluZyB9XCIgLz5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgPGxhYmVsPlBhc3N3b3JkPC9sYWJlbD5cbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiXG4gICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImZvcm0tY29udHJvbFwiXG4gICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlBhc3N3b3JkXCJcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlPVwieyBob21lTW9kZWwud2Vic29ja2V0UGFzc3dvcmQgfVwiXG4gICAgICAgICAgICAgICAgICAgICBvbmlucHV0PVwieyBlID0+IGhvbWVNb2RlbC53ZWJzb2NrZXRQYXNzd29yZCA9IGUudGFyZ2V0LnZhbHVlIH1cIlxuICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9XCJ7IGlzUnVubmluZyB9XCIgLz5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTUgcmlnaHQtaW1hZ2VcIj5cbiAgICAgICAgICAgIDxpbWFnZSBzcmM9XCJpbWFnZXMvb2JzLXdlYnNvY2tldC1jb25uZWN0aW9uLnBuZ1wiIHdpZHRoPVwiMzUwXCIgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L3NlY3Rpb24+XG5cbiAgICAgIDxzZWN0aW9uPlxuICAgICAgICA8aDM+Mi4gQ3JlYXRlIGEgdGV4dCBzb3VyY2U8L2gzPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC03XCI+XG4gICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgQWRkIFwiVGV4dCAoR0RJKylcIiBvbiBXaW5kb3dzLCBvciBcIlRleHQgKEZyZWVUeXBlIDIpXCIgb24gTWFjIE9TIFggb3IgTGludXggdG8gXCJTb3VyY2VzXCIgaW4gT0JTLlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cbiAgICAgICAgICAgICAgICAgIDxsYWJlbD5Tb3VyY2UgbmFtZTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlRleHQgc291cmNlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cInsgaG9tZU1vZGVsLnNvdXJjZU5hbWUgfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgb25pbnB1dD1cInsgZSA9PiBob21lTW9kZWwuc291cmNlTmFtZSA9IGUudGFyZ2V0LnZhbHVlIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPVwieyBpc1J1bm5pbmcgfVwiIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC02XCI+XG4gICAgICAgICAgICAgICAgICA8bGFiZWw+U291cmNlIHR5cGU8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uaW5wdXQ9XCJ7IGUgPT4gaG9tZU1vZGVsLnNvdXJjZVR5cGUgPSBlLnRhcmdldC52YWx1ZSB9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9XCJ7IGlzUnVubmluZyB9XCI+XG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIwXCIgc2VsZWN0ZWQ9XCJ7IGhvbWVNb2RlbC5zb3VyY2VUeXBlID09IDAgfVwiPlRleHQgKEdESSspIFtXaW5kb3dzXTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMVwiIHNlbGVjdGVkPVwieyBob21lTW9kZWwuc291cmNlVHlwZSA9PSAxIH1cIj5UZXh0IChGcmVlVHlwZSAyKSBbTWFjL0xpbnV4XTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cbiAgICAgICAgICAgICAgICAgIDxsYWJlbD5UaGUgbnVtYmVyIG9mIGxpbmVzPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgdmFsdWU9XCJ7IGhvbWVNb2RlbC5tYXhSb3dzIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgIG9uaW5wdXQ9XCJ7IGUgPT4gaG9tZU1vZGVsLm1heFJvd3MgPSBlLnRhcmdldC52YWx1ZSB9XCIgLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cbiAgICAgICAgICAgICAgICAgIDxsYWJlbD5UaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgcGVyIGxpbmU8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiB2YWx1ZT1cInsgaG9tZU1vZGVsLm1heENvbHMgfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgb25pbnB1dD1cInsgZSA9PiBob21lTW9kZWwubWF4Q29scyA9IGUudGFyZ2V0LnZhbHVlIH1cIiAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTUgcmlnaHQtaW1hZ2VcIj5cbiAgICAgICAgICAgIDxpbWFnZSBzcmM9XCJpbWFnZXMvb2JzLWNyZWF0ZS10ZXh0LXNvdXJjZS5wbmdcIiB3aWR0aD1cIjM1MFwiIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9zZWN0aW9uPlxuICAgIDwvc2VjdGlvbj5cblxuICAgIDxzZWN0aW9uPlxuICAgICAgPGgyPlNwb25zb3JzaGlwPC9oMj5cbiAgICAgIDxwPlxuICAgICAgICBJZiB5b3UgbGlrZSB0aGlzIHByb2plY3QsIHBsZWFzZSBzdXBwb3J0IGJ5IGJlY29taW5nIGEgc3BvbnNvciB2aWEgPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9zcG9uc29ycy9ha2FiZVwiPkdpdEh1YiBTcG9uc29yczwvYT4uXG4gICAgICAgIEkgaG9wZSB0byBtYWtlIE9CUyBUcmFuc2NyaXB0IG11Y2ggYmV0dGVyLlxuICAgICAgICBDb3VsZCB5b3UgZnVuZCBtZSBmb3IgaW1wcm92ZW1lbnQgb2YgdGhlIHByb2plY3Q/XG4gICAgICAgIEkgd2lsbCBwdWJsaXNoIHlvdXIgKGNvbXBhbnkpIGxvZ28gYW5kIGEgbGluayB0byB5b3VyIGhvbWVwYWdlIGluIHRoZSA8YSBocmVmPVwiaHR0cHM6Ly9ha2FiZS5naXRodWIuaW8vb2JzLXRyYW5zY3JpcHRcIj5wcm9qZWN0IHBhZ2U8L2E+IGFuZCA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL2FrYWJlL29icy10cmFuc2NyaXB0L2Jsb2IvbWFpbi9SRUFETUUubWRcIj5SRUFETUU8L2E+IGlmIHlvdSBzdXBwb3J0IG1lLiBQbGVhc2Ugc2VuZCBtZSBhbiBlLW1haWwgaW5jbHVkaW5nIGEgbG9nbyBmaWxlLlxuICAgICAgPC9wPlxuICAgIDwvc2VjdGlvbj5cbiAgPC9kaXY+XG5cbiAgPHNjcmlwdD5cbiAgIGltcG9ydCBIb21lTW9kZWwgZnJvbSBcIi4uL21vZGVscy9Ib21lTW9kZWwuanNcIjtcblxuICAgZXhwb3J0IGRlZmF1bHQge1xuICAgICBpc1J1bm5pbmc6IGZhbHNlLFxuICAgICBlcnJvck1lc3NhZ2U6IG51bGwsXG4gICAgIGhvbWVNb2RlbDogbmV3IEhvbWVNb2RlbCgpLFxuICAgICBvbk1vdW50ZWQoKSB7XG4gICAgICAgaWYgKCF0aGlzLmhvbWVNb2RlbC5pc1N1cHBvcnRlZCkge1xuICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UgPSBcIlNwZWVjaCByZWNvZ25pdGlvbiBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci4gVXNlIEdvb2dsZSBDaHJvbWUgMzMrIG9yIEVkZ2UgNzkrIHBsZWFzZS5cIjtcbiAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgfVxuICAgICB9LFxuICAgICBvblRvZ2dsZVN0YXJ0U3RvcEJ1dHRvbigpIHtcbiAgICAgICB0aGlzLmVycm9yTWVzc2FnZSA9IG51bGw7XG5cbiAgICAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgICAgIHRoaXMuaG9tZU1vZGVsLnN0b3AoKTtcbiAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICB0aGlzLmhvbWVNb2RlbFxuICAgICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gZXJyLmVycm9yO1xuICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH1cbiAgIH07XG4gIDwvc2NyaXB0PlxuPC9Ib21lVmlldz5cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcblxuICAvKipcbiAgICogRm9ybWF0cyBhIGdpdmVuIHN0cmluZy5cbiAgICovXG4gIGZvcm1hdChzdHJzLCBtYXhSb3dzLCBtYXhDb2xzKSB7XG4gICAgY29uc3QgbGluZXMgPSBzdHJzLm1hcChzID0+IHRoaXMuc3BsaXRsaW5lcyhzLCBtYXhDb2xzKSkuZmxhdCgpO1xuICAgIHJldHVybiBsaW5lcy5zbGljZShNYXRoLm1heCgwLCBsaW5lcy5sZW5ndGggLSBtYXhSb3dzKSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYSBnaXZlbiBzdHJpbmcgaW50byBsaW5lcyBvZiBtYXhpbXVtIGxlbmd0aCBgbWF4Q29sc2AuXG4gICAqL1xuICBzcGxpdGxpbmVzKHN0ciwgbWF4Q29scykge1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxldCBjdXJyTGluZSA9IFwiXCI7XG5cbiAgICBzdHIudHJpbSgpLnNwbGl0KC8gLykuZm9yRWFjaCh3ZCA9PiB7XG4gICAgICBpZiAoY3VyckxpbmUubGVuZ3RoID09IDApIHtcbiAgICAgICAgbGluZXMgPSB0aGlzLnNwbGl0Y2hhcndpc2UobGluZXMsIHdkLCBtYXhDb2xzKTtcbiAgICAgICAgY3VyckxpbmUgPSBsaW5lcy5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5ld0xpbmUgPSBjdXJyTGluZSArIFwiIFwiICsgd2Q7XG5cbiAgICAgICAgaWYgKG5ld0xpbmUubGVuZ3RoIDw9IG1heENvbHMpIHtcbiAgICAgICAgICBjdXJyTGluZSA9IG5ld0xpbmU7XG4gICAgICAgIH0gZWxzZSBpZiAod2QubGVuZ3RoIDw9IG1heENvbHMpIHtcbiAgICAgICAgICBsaW5lcy5wdXNoKGN1cnJMaW5lKTtcbiAgICAgICAgICBjdXJyTGluZSA9IHdkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVzID0gdGhpcy5zcGxpdGNoYXJ3aXNlKGxpbmVzLCBuZXdMaW5lLCBtYXhDb2xzKTtcbiAgICAgICAgICBjdXJyTGluZSA9IGxpbmVzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoY3VyckxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgbGluZXMucHVzaChjdXJyTGluZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhIGdpdmVuIHN0cmluZyBpbnRvIHN1YnN0cmluZ3Mgb2YgbWF4aW11bSBsZW5ndGggYG1heENvbHNgLFxuICAgKiBhbmQgYXBwZW5kcyB0aGUgc3Vic3RyaW5ncyBpbnRvIGBsaW5lc2AuXG4gICAqL1xuICBzcGxpdGNoYXJ3aXNlKGxpbmVzLCBzdHIsIG1heENvbHMpIHtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA+IG1heENvbHMpIHtcbiAgICAgIGxpbmVzLnB1c2goc3RyLnN1YnN0cmluZygwLCBtYXhDb2xzKSk7XG4gICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKG1heENvbHMpO1xuICAgIH1cblxuICAgIGlmIChzdHIubGVuZ3RoID4gMCkge1xuICAgICAgbGluZXMucHVzaChzdHIpO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5lcztcbiAgfVxufVxuIiwiaW1wb3J0IFVBUGFyc2VyIGZyb20gXCJ1YS1wYXJzZXItanNcIjtcbmltcG9ydCBPQlNSZXBvc2l0b3J5IGZyb20gXCIuLi9yZXBvc2l0b3JpZXMvT0JTUmVwb3NpdG9yeS5qc1wiO1xuaW1wb3J0IFNwZWVjaFJlY29nbml0aW9uTW9kZWwgZnJvbSBcIi4uL21vZGVscy9TcGVlY2hSZWNvZ25pdGlvbk1vZGVsLmpzXCI7XG5pbXBvcnQgRm9ybWF0TW9kZWwgZnJvbSBcIi4uL21vZGVscy9Gb3JtYXRNb2RlbC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMub2JzUmVwb3NpdG9yeSA9IG5ldyBPQlNSZXBvc2l0b3J5KCk7XG4gICAgdGhpcy51YVBhcnNlciA9IG5ldyBVQVBhcnNlcigpO1xuICAgIHRoaXMuc3BlZWNoUmVjb2duaXRpb25Nb2RlbCA9IG5ldyBTcGVlY2hSZWNvZ25pdGlvbk1vZGVsKCk7XG4gICAgdGhpcy5mb3JtYXRNb2RlbCA9IG5ldyBGb3JtYXRNb2RlbCgpO1xuXG4gICAgdGhpcy5sYW5nID0gdGhpcy5nZXREZWZhdWx0TGFuZ3VhZ2UoKTtcbiAgICB0aGlzLndlYnNvY2tldEFkZHJlc3MgPSBcImxvY2FsaG9zdDo0NDQ0XCI7XG4gICAgdGhpcy53ZWJzb2NrZXRQYXNzd29yZCA9IG51bGw7XG4gICAgdGhpcy5zb3VyY2VOYW1lID0gXCJteV90cmFuc2NyaXB0X3NyY1wiO1xuICAgIHRoaXMuc291cmNlVHlwZSA9IHRoaXMuZ2V0RGVmYXVsdFNvdXJjZVR5cGUoKTtcbiAgICB0aGlzLm1heFJvd3MgPSAzO1xuICAgIHRoaXMubWF4Q29scyA9IDIwO1xuICAgIHRoaXMuZml4ZWRUcmFuc2NyaXB0cyA9IFtdO1xuICB9XG5cbiAgaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BlZWNoUmVjb2duaXRpb25Nb2RlbC5pc1N1cHBvcnRlZCgpO1xuICB9XG5cbiAgZ2V0RGVmYXVsdExhbmd1YWdlKCkge1xuICAgIHJldHVybiAod2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZXMgJiYgd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZXNbMF0pIHx8XG4gICAgICB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlIHx8XG4gICAgICB3aW5kb3cubmF2aWdhdG9yLnVzZXJMYW5ndWFnZSB8fFxuICAgICAgd2luZG93Lm5hdmlnYXRvci5icm93c2VyTGFuZ3VhZ2UgfHwgXCJlblwiO1xuICB9XG5cbiAgZ2V0RGVmYXVsdFNvdXJjZVR5cGUoKSB7XG4gICAgY29uc3Qgb3MgPSB0aGlzLnVhUGFyc2VyLmdldE9TKCk7XG4gICAgcmV0dXJuIG9zLm5hbWUgPT09IFwiV2luZG93c1wiID8gMCA6IDE7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5vYnNSZXBvc2l0b3J5XG4gICAgICAuY29ubmVjdCh7XG4gICAgICAgIGFkZHJlc3M6IHRoaXMud2Vic29ja2V0QWRkcmVzcyxcbiAgICAgICAgcGFzc3dvcmQ6IHRoaXMud2Vic29ja2V0UGFzc3dvcmRcbiAgICAgIH0pLnRoZW4oKCkgPT5cbiAgICAgICAgdGhpcy5vYnNSZXBvc2l0b3J5XG4gICAgICAgICAgLnNldFRleHQodGhpcy5zb3VyY2VUeXBlLCB0aGlzLnNvdXJjZU5hbWUsIFwiXCIpIC8vIFZhbGlkYXRlcyBzb3VyY2VUeXBlIGFuZCBzb3VyY2VOYW1lXG4gICAgICAgICAgLnRoZW4oKCkgPT5cbiAgICAgICAgICAgIHRoaXMuc3BlZWNoUmVjb2duaXRpb25Nb2RlbC5zdGFydCh0aGlzLmxhbmcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhldmVudCk7XG5cbiAgICAgICAgICAgICAgbGV0IHRyYW5zY3JpcHRzO1xuICAgICAgICAgICAgICBpZiAoZXZlbnQuaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZml4ZWRUcmFuc2NyaXB0cy5wdXNoKGV2ZW50LnRyYW5zY3JpcHQpO1xuICAgICAgICAgICAgICAgIHRyYW5zY3JpcHRzID0gdGhpcy5maXhlZFRyYW5zY3JpcHRzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zY3JpcHRzID0gWy4uLnRoaXMuZml4ZWRUcmFuc2NyaXB0cywgZXZlbnQudHJhbnNjcmlwdF07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5mb3JtYXRNb2RlbC5mb3JtYXQodHJhbnNjcmlwdHMsIHRoaXMubWF4Um93cywgdGhpcy5tYXhDb2xzKTtcbiAgICAgICAgICAgICAgdGhpcy5vYnNSZXBvc2l0b3J5LnNldFRleHQodGhpcy5zb3VyY2VUeXBlLCB0aGlzLnNvdXJjZU5hbWUsIHRleHQpO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTsgLy8gY2xvc2UgY29ubmVjdGlvbiBpZiBmYWlsZWQuXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfSkpO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnNwZWVjaFJlY29nbml0aW9uTW9kZWwuc3RvcCgpO1xuICAgIHRoaXMub2JzUmVwb3NpdG9yeS5kaXNjb25uZWN0KCk7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gIH1cblxuICBpc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gISEod2Via2l0U3BlZWNoUmVjb2duaXRpb24gfHwgU3BlZWNoUmVjb2duaXRpb24pO1xuICB9XG5cbiAgc3RhcnQobGFuZywgb25yZXN1bHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmICh3ZWJraXRTcGVlY2hSZWNvZ25pdGlvbikge1xuICAgICAgICB0aGlzLmVuZ2luZSA9IG5ldyB3ZWJraXRTcGVlY2hSZWNvZ25pdGlvbigpO1xuICAgICAgfSBlbHNlIGlmIChTcGVlY2hSZWNvZ25pdGlvbikge1xuICAgICAgICB0aGlzLmVuZ2luZSA9IG5ldyBTcGVlY2hSZWNvZ25pdGlvbigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVuZ2luZS5sYW5nID0gbGFuZztcbiAgICAgIHRoaXMuZW5naW5lLmNvbnRpbnVvdXMgPSB0cnVlO1xuICAgICAgdGhpcy5lbmdpbmUuaW50ZXJpbVJlc3VsdHMgPSB0cnVlO1xuICAgICAgdGhpcy5lbmdpbmUubWF4QWx0ZXJuYXRpdmVzID0gMTtcblxuICAgICAgY29uc3QgbW9kZWwgPSB0aGlzO1xuXG4gICAgICB0aGlzLmVuZ2luZS5vbnN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNwZWVjaCByZWNvZ25pdGlvbiBzdGFydGVkLlwiKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuZW5naW5lLm9uZW5kID0gKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNwZWVjaCByZWNvZ25pdGlvbiBzdG9wcGVkLlwiKTtcbiAgICAgICAgaWYgKG1vZGVsLmVuZ2luZSkgbW9kZWwuZW5naW5lLnN0YXJ0KCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5lbmdpbmUub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNwZWVjaCByZWNvZ25pdGlvbiBzdG9wcGVkIGJ5IGVycm9yOiBcIiwgZXZlbnQpO1xuICAgICAgICBpZiAobW9kZWwuZW5naW5lKSBtb2RlbC5lbmdpbmUuc3RhcnQoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmVuZ2luZS5vbnJlc3VsdCA9IChldmVudCkgPT4ge1xuICAgICAgICBmb3IgKHZhciBpID0gZXZlbnQucmVzdWx0SW5kZXg7IGkgPCBldmVudC5yZXN1bHRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgb25yZXN1bHQoe1xuICAgICAgICAgICAgXCJpc0ZpbmFsXCI6IGV2ZW50LnJlc3VsdHNbaV0uaXNGaW5hbCxcbiAgICAgICAgICAgIFwidHJhbnNjcmlwdFwiOiBldmVudC5yZXN1bHRzW2ldWzBdLnRyYW5zY3JpcHQsXG4gICAgICAgICAgICBcImNvbmZpZGVuY2VcIjogZXZlbnQucmVzdWx0c1tpXVswXS5jb25maWRlbmNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmVuZ2luZS5zdGFydCgpO1xuICAgIH0pO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5lbmdpbmUpIHtcbiAgICAgIHRoaXMuZW5naW5lLnN0b3AoKTtcbiAgICAgIHRoaXMuZW5naW5lID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBPQlNXZWJTb2NrZXQgZnJvbSBcIm9icy13ZWJzb2NrZXQtanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLndlYnNvY2tldCA9IG5ldyBPQlNXZWJTb2NrZXQoKTtcbiAgfVxuXG4gIGNvbm5lY3QoY29ubkluZm8pIHtcbiAgICByZXR1cm4gdGhpcy53ZWJzb2NrZXQuY29ubmVjdChjb25uSW5mbyk7XG4gIH1cblxuICBkaXNjb25uZWN0KCkge1xuICAgIHJldHVybiB0aGlzLndlYnNvY2tldC5kaXNjb25uZWN0KCk7XG4gIH1cblxuICBzZXRUZXh0KHNvdXJjZVR5cGUsIHNvdXJjZU5hbWUsIHRleHQpIHtcbiAgICBpZiAoc291cmNlVHlwZSA9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRUZXh0R0RJUGx1cyhzb3VyY2VOYW1lLCB0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0VGV4dEZyZWV0eXBlMihzb3VyY2VOYW1lLCB0ZXh0KTtcbiAgICB9XG4gIH1cblxuICBzZXRUZXh0R0RJUGx1cyhzb3VyY2VOYW1lLCB0ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMud2Vic29ja2V0LnNlbmQoXCJTZXRUZXh0R0RJUGx1c1Byb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgfVxuXG4gIHNldFRleHRGcmVldHlwZTIoc291cmNlTmFtZSwgdGV4dCkge1xuICAgIHJldHVybiB0aGlzLndlYnNvY2tldC5zZW5kKFwiU2V0VGV4dEZyZWV0eXBlMlByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAgKiBOYXRpdmUgSmF2YVNjcmlwdCBmb3IgQm9vdHN0cmFwIHYzLjAuMTUgKGh0dHBzOi8vdGhlZG5wLmdpdGh1Yi5pby9ib290c3RyYXAubmF0aXZlLylcbiAgKiBDb3B5cmlnaHQgMjAxNS0yMDIxIMKpIGRucF90aGVtZVxuICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3RoZWRucC9ib290c3RyYXAubmF0aXZlL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gICovXG5jb25zdCB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbicgaW4gZG9jdW1lbnQuaGVhZC5zdHlsZSA/ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcblxuY29uc3Qgc3VwcG9ydFRyYW5zaXRpb24gPSAnd2Via2l0VHJhbnNpdGlvbicgaW4gZG9jdW1lbnQuaGVhZC5zdHlsZSB8fCAndHJhbnNpdGlvbicgaW4gZG9jdW1lbnQuaGVhZC5zdHlsZTtcblxuY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gJ3dlYmtpdFRyYW5zaXRpb24nIGluIGRvY3VtZW50LmhlYWQuc3R5bGUgPyAnd2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uJyA6ICd0cmFuc2l0aW9uRHVyYXRpb24nO1xuXG5jb25zdCB0cmFuc2l0aW9uUHJvcGVydHkgPSAnd2Via2l0VHJhbnNpdGlvbicgaW4gZG9jdW1lbnQuaGVhZC5zdHlsZSA/ICd3ZWJraXRUcmFuc2l0aW9uUHJvcGVydHknIDogJ3RyYW5zaXRpb25Qcm9wZXJ0eSc7XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRUcmFuc2l0aW9uRHVyYXRpb24oZWxlbWVudCkge1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgY29uc3QgcHJvcGVydHlWYWx1ZSA9IGNvbXB1dGVkU3R5bGVbdHJhbnNpdGlvblByb3BlcnR5XTtcbiAgY29uc3QgZHVyYXRpb25WYWx1ZSA9IGNvbXB1dGVkU3R5bGVbdHJhbnNpdGlvbkR1cmF0aW9uXTtcbiAgY29uc3QgZHVyYXRpb25TY2FsZSA9IGR1cmF0aW9uVmFsdWUuaW5jbHVkZXMoJ21zJykgPyAxIDogMTAwMDtcbiAgY29uc3QgZHVyYXRpb24gPSBzdXBwb3J0VHJhbnNpdGlvbiAmJiBwcm9wZXJ0eVZhbHVlICYmIHByb3BlcnR5VmFsdWUgIT09ICdub25lJ1xuICAgID8gcGFyc2VGbG9hdChkdXJhdGlvblZhbHVlKSAqIGR1cmF0aW9uU2NhbGUgOiAwO1xuXG4gIHJldHVybiAhTnVtYmVyLmlzTmFOKGR1cmF0aW9uKSA/IGR1cmF0aW9uIDogMDtcbn1cblxuZnVuY3Rpb24gZW11bGF0ZVRyYW5zaXRpb25FbmQoZWxlbWVudCwgaGFuZGxlcikge1xuICBsZXQgY2FsbGVkID0gMDtcbiAgY29uc3QgZW5kRXZlbnQgPSBuZXcgRXZlbnQodHJhbnNpdGlvbkVuZEV2ZW50KTtcbiAgY29uc3QgZHVyYXRpb24gPSBnZXRFbGVtZW50VHJhbnNpdGlvbkR1cmF0aW9uKGVsZW1lbnQpO1xuXG4gIGlmIChkdXJhdGlvbikge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGZ1bmN0aW9uIHRyYW5zaXRpb25FbmRXcmFwcGVyKGUpIHtcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gZWxlbWVudCkge1xuICAgICAgICBoYW5kbGVyLmFwcGx5KGVsZW1lbnQsIFtlXSk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIHRyYW5zaXRpb25FbmRXcmFwcGVyKTtcbiAgICAgICAgY2FsbGVkID0gMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghY2FsbGVkKSBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZW5kRXZlbnQpO1xuICAgIH0sIGR1cmF0aW9uICsgMTcpO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZXIuYXBwbHkoZWxlbWVudCwgW2VuZEV2ZW50XSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVlcnlFbGVtZW50KHNlbGVjdG9yLCBwYXJlbnQpIHtcbiAgY29uc3QgbG9va1VwID0gcGFyZW50ICYmIHBhcmVudCBpbnN0YW5jZW9mIEVsZW1lbnQgPyBwYXJlbnQgOiBkb2N1bWVudDtcbiAgcmV0dXJuIHNlbGVjdG9yIGluc3RhbmNlb2YgRWxlbWVudCA/IHNlbGVjdG9yIDogbG9va1VwLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBjbGFzc05BTUUpIHtcbiAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTkFNRSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTkFNRSkge1xuICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOQU1FKTtcbn1cblxuY29uc3QgYWRkRXZlbnRMaXN0ZW5lciA9ICdhZGRFdmVudExpc3RlbmVyJztcblxuY29uc3QgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9ICdyZW1vdmVFdmVudExpc3RlbmVyJztcblxuY29uc3QgZmFkZUNsYXNzID0gJ2ZhZGUnO1xuXG5jb25zdCBzaG93Q2xhc3MgPSAnc2hvdyc7XG5cbmNvbnN0IGRhdGFCc0Rpc21pc3MgPSAnZGF0YS1icy1kaXNtaXNzJztcblxuZnVuY3Rpb24gYm9vdHN0cmFwQ3VzdG9tRXZlbnQobmFtZXNwYWNlZEV2ZW50VHlwZSwgZXZlbnRQcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IE9yaWdpbmFsQ3VzdG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQobmFtZXNwYWNlZEV2ZW50VHlwZSwgeyBjYW5jZWxhYmxlOiB0cnVlIH0pO1xuXG4gIGlmIChldmVudFByb3BlcnRpZXMgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICBPYmplY3Qua2V5cyhldmVudFByb3BlcnRpZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9yaWdpbmFsQ3VzdG9tRXZlbnQsIGtleSwge1xuICAgICAgICB2YWx1ZTogZXZlbnRQcm9wZXJ0aWVzW2tleV0sXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gT3JpZ2luYWxDdXN0b21FdmVudDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghTnVtYmVyLmlzTmFOKCt2YWx1ZSkpIHtcbiAgICByZXR1cm4gK3ZhbHVlO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gJ251bGwnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBzdHJpbmcgLyBmdW5jdGlvbiAvIEVsZW1lbnQgLyBPYmplY3RcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPcHRpb25zKGVsZW1lbnQsIGRlZmF1bHRPcHMsIGlucHV0T3BzLCBucykge1xuICBjb25zdCBub3JtYWxPcHMgPSB7fTtcbiAgY29uc3QgZGF0YU9wcyA9IHt9O1xuICBjb25zdCBkYXRhID0geyAuLi5lbGVtZW50LmRhdGFzZXQgfTtcblxuICBPYmplY3Qua2V5cyhkYXRhKVxuICAgIC5mb3JFYWNoKChrKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBrLmluY2x1ZGVzKG5zKVxuICAgICAgICA/IGsucmVwbGFjZShucywgJycpLnJlcGxhY2UoL1tBLVpdLywgKG1hdGNoKSA9PiBtYXRjaC50b0xvd2VyQ2FzZSgpKVxuICAgICAgICA6IGs7XG5cbiAgICAgIGRhdGFPcHNba2V5XSA9IG5vcm1hbGl6ZVZhbHVlKGRhdGFba10pO1xuICAgIH0pO1xuXG4gIE9iamVjdC5rZXlzKGlucHV0T3BzKVxuICAgIC5mb3JFYWNoKChrKSA9PiB7XG4gICAgICBpbnB1dE9wc1trXSA9IG5vcm1hbGl6ZVZhbHVlKGlucHV0T3BzW2tdKTtcbiAgICB9KTtcblxuICBPYmplY3Qua2V5cyhkZWZhdWx0T3BzKVxuICAgIC5mb3JFYWNoKChrKSA9PiB7XG4gICAgICBpZiAoayBpbiBpbnB1dE9wcykge1xuICAgICAgICBub3JtYWxPcHNba10gPSBpbnB1dE9wc1trXTtcbiAgICAgIH0gZWxzZSBpZiAoayBpbiBkYXRhT3BzKSB7XG4gICAgICAgIG5vcm1hbE9wc1trXSA9IGRhdGFPcHNba107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxPcHNba10gPSBkZWZhdWx0T3BzW2tdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIHJldHVybiBub3JtYWxPcHM7XG59XG5cbi8qIE5hdGl2ZSBKYXZhU2NyaXB0IGZvciBCb290c3RyYXAgNSB8IEJhc2UgQ29tcG9uZW50XG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5jbGFzcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IobmFtZSwgdGFyZ2V0LCBkZWZhdWx0cywgY29uZmlnKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudCh0YXJnZXQpO1xuXG4gICAgaWYgKGVsZW1lbnRbbmFtZV0pIGVsZW1lbnRbbmFtZV0uZGlzcG9zZSgpO1xuICAgIHNlbGYuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICBpZiAoZGVmYXVsdHMgJiYgT2JqZWN0LmtleXMoZGVmYXVsdHMpLmxlbmd0aCkge1xuICAgICAgc2VsZi5vcHRpb25zID0gbm9ybWFsaXplT3B0aW9ucyhlbGVtZW50LCBkZWZhdWx0cywgKGNvbmZpZyB8fCB7fSksICdicycpO1xuICAgIH1cbiAgICBlbGVtZW50W25hbWVdID0gc2VsZjtcbiAgfVxuXG4gIGRpc3Bvc2UobmFtZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuZWxlbWVudFtuYW1lXSA9IG51bGw7XG4gICAgT2JqZWN0LmtleXMoc2VsZikuZm9yRWFjaCgocHJvcCkgPT4geyBzZWxmW3Byb3BdID0gbnVsbDsgfSk7XG4gIH1cbn1cblxuLyogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCA1IHwgQWxlcnRcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8vIEFMRVJUIFBSSVZBVEUgR0Ncbi8vID09PT09PT09PT09PT09PT1cbmNvbnN0IGFsZXJ0U3RyaW5nID0gJ2FsZXJ0JztcbmNvbnN0IGFsZXJ0Q29tcG9uZW50ID0gJ0FsZXJ0JztcbmNvbnN0IGFsZXJ0U2VsZWN0b3IgPSBgLiR7YWxlcnRTdHJpbmd9YDtcbmNvbnN0IGFsZXJ0RGlzbWlzc1NlbGVjdG9yID0gYFske2RhdGFCc0Rpc21pc3N9PVwiJHthbGVydFN0cmluZ31cIl1gO1xuXG4vLyBBTEVSVCBDVVNUT00gRVZFTlRTXG4vLyA9PT09PT09PT09PT09PT09PT09XG5jb25zdCBjbG9zZUFsZXJ0RXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudChgY2xvc2UuYnMuJHthbGVydFN0cmluZ31gKTtcbmNvbnN0IGNsb3NlZEFsZXJ0RXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudChgY2xvc2VkLmJzLiR7YWxlcnRTdHJpbmd9YCk7XG5cbi8vIEFMRVJUIEVWRU5UIEhBTkRMRVJTXG4vLyA9PT09PT09PT09PT09PT09PT09PVxuZnVuY3Rpb24gYWxlcnRUcmFuc2l0aW9uRW5kKHNlbGYpIHtcbiAgY29uc3QgeyBlbGVtZW50LCByZWxhdGVkVGFyZ2V0IH0gPSBzZWxmO1xuICB0b2dnbGVBbGVydEhhbmRsZXIoc2VsZik7XG5cbiAgaWYgKHJlbGF0ZWRUYXJnZXQpIGNsb3NlZEFsZXJ0RXZlbnQucmVsYXRlZFRhcmdldCA9IHJlbGF0ZWRUYXJnZXQ7XG4gIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChjbG9zZWRBbGVydEV2ZW50KTtcblxuICBzZWxmLmRpc3Bvc2UoKTtcbiAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xufVxuXG4vLyBBTEVSVCBQUklWQVRFIE1FVEhPRFxuLy8gPT09PT09PT09PT09PT09PT09PT1cbmZ1bmN0aW9uIHRvZ2dsZUFsZXJ0SGFuZGxlcihzZWxmLCBhZGQpIHtcbiAgY29uc3QgYWN0aW9uID0gYWRkID8gYWRkRXZlbnRMaXN0ZW5lciA6IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gIGlmIChzZWxmLmRpc21pc3MpIHNlbGYuZGlzbWlzc1thY3Rpb25dKCdjbGljaycsIHNlbGYuY2xvc2UpO1xufVxuXG4vLyBBTEVSVCBERUZJTklUSU9OXG4vLyA9PT09PT09PT09PT09PT09XG5jbGFzcyBBbGVydCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICBzdXBlcihhbGVydENvbXBvbmVudCwgdGFyZ2V0KTtcbiAgICAvLyBiaW5kXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgY29uc3QgeyBlbGVtZW50IH0gPSBzZWxmO1xuXG4gICAgLy8gdGhlIGRpc21pc3MgYnV0dG9uXG4gICAgc2VsZi5kaXNtaXNzID0gcXVlcnlFbGVtZW50KGFsZXJ0RGlzbWlzc1NlbGVjdG9yLCBlbGVtZW50KTtcbiAgICBzZWxmLnJlbGF0ZWRUYXJnZXQgPSBudWxsO1xuXG4gICAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyXG4gICAgdG9nZ2xlQWxlcnRIYW5kbGVyKHNlbGYsIDEpO1xuICB9XG5cbiAgLy8gQUxFUlQgUFVCTElDIE1FVEhPRFNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cbiAgY2xvc2UoZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IGUgPyBlLnRhcmdldCA6IG51bGw7XG4gICAgY29uc3Qgc2VsZiA9IGVcbiAgICAgID8gZS50YXJnZXQuY2xvc2VzdChhbGVydFNlbGVjdG9yKVthbGVydENvbXBvbmVudF1cbiAgICAgIDogdGhpcztcbiAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHNlbGY7XG5cbiAgICBpZiAoc2VsZiAmJiBlbGVtZW50ICYmIGhhc0NsYXNzKGVsZW1lbnQsIHNob3dDbGFzcykpIHtcbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgY2xvc2VBbGVydEV2ZW50LnJlbGF0ZWRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHNlbGYucmVsYXRlZFRhcmdldCA9IHRhcmdldDtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChjbG9zZUFsZXJ0RXZlbnQpO1xuICAgICAgaWYgKGNsb3NlQWxlcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIHNob3dDbGFzcyk7XG5cbiAgICAgIGlmIChoYXNDbGFzcyhlbGVtZW50LCBmYWRlQ2xhc3MpKSB7XG4gICAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKGVsZW1lbnQsICgpID0+IGFsZXJ0VHJhbnNpdGlvbkVuZChzZWxmKSk7XG4gICAgICB9IGVsc2UgYWxlcnRUcmFuc2l0aW9uRW5kKHNlbGYpO1xuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdG9nZ2xlQWxlcnRIYW5kbGVyKHRoaXMpO1xuICAgIHN1cGVyLmRpc3Bvc2UoYWxlcnRDb21wb25lbnQpO1xuICB9XG59XG5cbkFsZXJ0LmluaXQgPSB7XG4gIGNvbXBvbmVudDogYWxlcnRDb21wb25lbnQsXG4gIHNlbGVjdG9yOiBhbGVydFNlbGVjdG9yLFxuICBjb25zdHJ1Y3RvcjogQWxlcnQsXG59O1xuXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05BTUUpIHtcbiAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTkFNRSk7XG59XG5cbmNvbnN0IGFjdGl2ZUNsYXNzID0gJ2FjdGl2ZSc7XG5cbmNvbnN0IGRhdGFCc1RvZ2dsZSA9ICdkYXRhLWJzLXRvZ2dsZSc7XG5cbi8qIE5hdGl2ZSBKYXZhU2NyaXB0IGZvciBCb290c3RyYXAgNSB8IEJ1dHRvblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLy8gQlVUVE9OIFBSSVZBVEUgR0Ncbi8vID09PT09PT09PT09PT09PT09XG5jb25zdCBidXR0b25TdHJpbmcgPSAnYnV0dG9uJztcbmNvbnN0IGJ1dHRvbkNvbXBvbmVudCA9ICdCdXR0b24nO1xuY29uc3QgYnV0dG9uU2VsZWN0b3IgPSBgWyR7ZGF0YUJzVG9nZ2xlfT1cIiR7YnV0dG9uU3RyaW5nfVwiXWA7XG5jb25zdCBhcmlhUHJlc3NlZCA9ICdhcmlhLXByZXNzZWQnO1xuXG4vLyBCVVRUT04gUFJJVkFURSBNRVRIT0Rcbi8vID09PT09PT09PT09PT09PT09PT09PVxuZnVuY3Rpb24gdG9nZ2xlQnV0dG9uSGFuZGxlcihzZWxmLCBhZGQpIHtcbiAgY29uc3QgYWN0aW9uID0gYWRkID8gYWRkRXZlbnRMaXN0ZW5lciA6IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gIHNlbGYuZWxlbWVudFthY3Rpb25dKCdjbGljaycsIHNlbGYudG9nZ2xlKTtcbn1cblxuLy8gQlVUVE9OIERFRklOSVRJT05cbi8vID09PT09PT09PT09PT09PT09XG5jbGFzcyBCdXR0b24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgc3VwZXIoYnV0dG9uQ29tcG9uZW50LCB0YXJnZXQpO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gc2VsZjtcblxuICAgIC8vIHNldCBpbml0aWFsIHN0YXRlXG4gICAgc2VsZi5pc0FjdGl2ZSA9IGhhc0NsYXNzKGVsZW1lbnQsIGFjdGl2ZUNsYXNzKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhcmlhUHJlc3NlZCwgISFzZWxmLmlzQWN0aXZlKTtcblxuICAgIC8vIGFkZCBldmVudCBsaXN0ZW5lclxuICAgIHRvZ2dsZUJ1dHRvbkhhbmRsZXIoc2VsZiwgMSk7XG4gIH1cblxuICAvLyBCVVRUT04gUFVCTElDIE1FVEhPRFNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09XG4gIHRvZ2dsZShlKSB7XG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBzZWxmID0gZSA/IHRoaXNbYnV0dG9uQ29tcG9uZW50XSA6IHRoaXM7XG4gICAgY29uc3QgeyBlbGVtZW50IH0gPSBzZWxmO1xuXG4gICAgaWYgKGhhc0NsYXNzKGVsZW1lbnQsICdkaXNhYmxlZCcpKSByZXR1cm47XG5cbiAgICBzZWxmLmlzQWN0aXZlID0gaGFzQ2xhc3MoZWxlbWVudCwgYWN0aXZlQ2xhc3MpO1xuICAgIGNvbnN0IHsgaXNBY3RpdmUgfSA9IHNlbGY7XG5cbiAgICBjb25zdCBhY3Rpb24gPSBpc0FjdGl2ZSA/IHJlbW92ZUNsYXNzIDogYWRkQ2xhc3M7XG4gICAgY29uc3QgYXJpYVZhbHVlID0gaXNBY3RpdmUgPyAnZmFsc2UnIDogJ3RydWUnO1xuXG4gICAgYWN0aW9uKGVsZW1lbnQsIGFjdGl2ZUNsYXNzKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhcmlhUHJlc3NlZCwgYXJpYVZhbHVlKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdG9nZ2xlQnV0dG9uSGFuZGxlcih0aGlzKTtcbiAgICBzdXBlci5kaXNwb3NlKGJ1dHRvbkNvbXBvbmVudCk7XG4gIH1cbn1cblxuQnV0dG9uLmluaXQgPSB7XG4gIGNvbXBvbmVudDogYnV0dG9uQ29tcG9uZW50LFxuICBzZWxlY3RvcjogYnV0dG9uU2VsZWN0b3IsXG4gIGNvbnN0cnVjdG9yOiBCdXR0b24sXG59O1xuXG5jb25zdCBzdXBwb3J0UGFzc2l2ZSA9ICgoKSA9PiB7XG4gIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgZG9jdW1lbnRbYWRkRXZlbnRMaXN0ZW5lcl0oJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiB3cmFwKCkge1xuICAgICAgZG9jdW1lbnRbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oJ0RPTUNvbnRlbnRMb2FkZWQnLCB3cmFwLCBvcHRzKTtcbiAgICB9LCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IEVycm9yKCdQYXNzaXZlIGV2ZW50cyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0pKCk7XG5cbi8vIGdlbmVyYWwgZXZlbnQgb3B0aW9uc1xuXG52YXIgcGFzc2l2ZUhhbmRsZXIgPSBzdXBwb3J0UGFzc2l2ZSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogZmFsc2U7XG5cbmZ1bmN0aW9uIHJlZmxvdyhlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50Lm9mZnNldEhlaWdodDtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50SW5TY3JvbGxSYW5nZShlbGVtZW50KSB7XG4gIGNvbnN0IGJjciA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJldHVybiBiY3IudG9wIDw9IHZpZXdwb3J0SGVpZ2h0ICYmIGJjci5ib3R0b20gPj0gMDsgLy8gYm90dG9tICYmIHRvcFxufVxuXG4vKiBOYXRpdmUgSmF2YVNjcmlwdCBmb3IgQm9vdHN0cmFwIDUgfCBDYXJvdXNlbFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLy8gQ0FST1VTRUwgUFJJVkFURSBHQ1xuLy8gPT09PT09PT09PT09PT09PT09PVxuY29uc3QgY2Fyb3VzZWxTdHJpbmcgPSAnY2Fyb3VzZWwnO1xuY29uc3QgY2Fyb3VzZWxDb21wb25lbnQgPSAnQ2Fyb3VzZWwnO1xuY29uc3QgY2Fyb3VzZWxTZWxlY3RvciA9IGBbZGF0YS1icy1yaWRlPVwiJHtjYXJvdXNlbFN0cmluZ31cIl1gO1xuY29uc3QgY2Fyb3VzZWxDb250cm9sID0gYCR7Y2Fyb3VzZWxTdHJpbmd9LWNvbnRyb2xgO1xuY29uc3QgY2Fyb3VzZWxJdGVtID0gYCR7Y2Fyb3VzZWxTdHJpbmd9LWl0ZW1gO1xuY29uc3QgZGF0YUJzU2xpZGVUbyA9ICdkYXRhLWJzLXNsaWRlLXRvJztcbmNvbnN0IHBhdXNlZENsYXNzID0gJ3BhdXNlZCc7XG5jb25zdCBkZWZhdWx0Q2Fyb3VzZWxPcHRpb25zID0ge1xuICBwYXVzZTogJ2hvdmVyJywgLy8gJ2Jvb2xlYW58c3RyaW5nJ1xuICBrZXlib2FyZDogZmFsc2UsIC8vICdib29sZWFuJ1xuICB0b3VjaDogdHJ1ZSwgLy8gJ2Jvb2xlYW4nXG4gIGludGVydmFsOiA1MDAwLCAvLyAnYm9vbGVhbnxudW1iZXInXG59O1xubGV0IHN0YXJ0WCA9IDA7XG5sZXQgY3VycmVudFggPSAwO1xubGV0IGVuZFggPSAwO1xuXG4vLyBDQVJPVVNFTCBDVVNUT00gRVZFTlRTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBjYXJvdXNlbFNsaWRlRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudChgc2xpZGUuYnMuJHtjYXJvdXNlbFN0cmluZ31gKTtcbmNvbnN0IGNhcm91c2VsU2xpZEV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoYHNsaWQuYnMuJHtjYXJvdXNlbFN0cmluZ31gKTtcblxuLy8gQ0FST1VTRUwgRVZFTlQgSEFORExFUlNcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5mdW5jdGlvbiBjYXJvdXNlbFRyYW5zaXRpb25FbmRIYW5kbGVyKHNlbGYpIHtcbiAgY29uc3Qge1xuICAgIGluZGV4LCBkaXJlY3Rpb24sIGVsZW1lbnQsIHNsaWRlcywgb3B0aW9ucywgaXNBbmltYXRpbmcsXG4gIH0gPSBzZWxmO1xuXG4gIC8vIGRpc2NvbnRpbnVlIGRpc3Bvc2VkIGluc3RhbmNlc1xuICBpZiAoaXNBbmltYXRpbmcgJiYgZWxlbWVudFtjYXJvdXNlbENvbXBvbmVudF0pIHtcbiAgICBjb25zdCBhY3RpdmVJdGVtID0gZ2V0QWN0aXZlSW5kZXgoc2VsZik7XG4gICAgY29uc3Qgb3JpZW50YXRpb24gPSBkaXJlY3Rpb24gPT09ICdsZWZ0JyA/ICduZXh0JyA6ICdwcmV2JztcbiAgICBjb25zdCBkaXJlY3Rpb25DbGFzcyA9IGRpcmVjdGlvbiA9PT0gJ2xlZnQnID8gJ3N0YXJ0JyA6ICdlbmQnO1xuICAgIHNlbGYuaXNBbmltYXRpbmcgPSBmYWxzZTtcblxuICAgIGFkZENsYXNzKHNsaWRlc1tpbmRleF0sIGFjdGl2ZUNsYXNzKTtcbiAgICByZW1vdmVDbGFzcyhzbGlkZXNbYWN0aXZlSXRlbV0sIGFjdGl2ZUNsYXNzKTtcblxuICAgIHJlbW92ZUNsYXNzKHNsaWRlc1tpbmRleF0sIGAke2Nhcm91c2VsSXRlbX0tJHtvcmllbnRhdGlvbn1gKTtcbiAgICByZW1vdmVDbGFzcyhzbGlkZXNbaW5kZXhdLCBgJHtjYXJvdXNlbEl0ZW19LSR7ZGlyZWN0aW9uQ2xhc3N9YCk7XG4gICAgcmVtb3ZlQ2xhc3Moc2xpZGVzW2FjdGl2ZUl0ZW1dLCBgJHtjYXJvdXNlbEl0ZW19LSR7ZGlyZWN0aW9uQ2xhc3N9YCk7XG5cbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoY2Fyb3VzZWxTbGlkRXZlbnQpO1xuXG4gICAgLy8gY2hlY2sgZm9yIGVsZW1lbnQsIG1pZ2h0IGhhdmUgYmVlbiBkaXNwb3NlZFxuICAgIGlmICghZG9jdW1lbnQuaGlkZGVuICYmIG9wdGlvbnMuaW50ZXJ2YWxcbiAgICAgICYmICFoYXNDbGFzcyhlbGVtZW50LCBwYXVzZWRDbGFzcykpIHtcbiAgICAgIHNlbGYuY3ljbGUoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2Fyb3VzZWxQYXVzZUhhbmRsZXIoZSkge1xuICBjb25zdCBldmVudFRhcmdldCA9IGUudGFyZ2V0O1xuICBjb25zdCBzZWxmID0gZXZlbnRUYXJnZXQuY2xvc2VzdChjYXJvdXNlbFNlbGVjdG9yKVtjYXJvdXNlbENvbXBvbmVudF07XG4gIGNvbnN0IHsgZWxlbWVudCwgaXNBbmltYXRpbmcgfSA9IHNlbGY7XG5cbiAgaWYgKCFoYXNDbGFzcyhlbGVtZW50LCBwYXVzZWRDbGFzcykpIHtcbiAgICBhZGRDbGFzcyhlbGVtZW50LCBwYXVzZWRDbGFzcyk7XG4gICAgaWYgKCFpc0FuaW1hdGluZykge1xuICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLnRpbWVyKTtcbiAgICAgIHNlbGYudGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjYXJvdXNlbFJlc3VtZUhhbmRsZXIoZSkge1xuICBjb25zdCBldmVudFRhcmdldCA9IGUudGFyZ2V0O1xuICBjb25zdCBzZWxmID0gZXZlbnRUYXJnZXQuY2xvc2VzdChjYXJvdXNlbFNlbGVjdG9yKVtjYXJvdXNlbENvbXBvbmVudF07XG4gIGNvbnN0IHsgaXNQYXVzZWQsIGlzQW5pbWF0aW5nLCBlbGVtZW50IH0gPSBzZWxmO1xuXG4gIGlmICghaXNQYXVzZWQgJiYgaGFzQ2xhc3MoZWxlbWVudCwgcGF1c2VkQ2xhc3MpKSB7XG4gICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgcGF1c2VkQ2xhc3MpO1xuXG4gICAgaWYgKCFpc0FuaW1hdGluZykge1xuICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLnRpbWVyKTtcbiAgICAgIHNlbGYudGltZXIgPSBudWxsO1xuICAgICAgc2VsZi5jeWNsZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjYXJvdXNlbEluZGljYXRvckhhbmRsZXIoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIGNvbnN0IHsgdGFyZ2V0IH0gPSBlO1xuICBjb25zdCBzZWxmID0gdGFyZ2V0LmNsb3Nlc3QoY2Fyb3VzZWxTZWxlY3RvcilbY2Fyb3VzZWxDb21wb25lbnRdO1xuXG4gIGlmIChzZWxmLmlzQW5pbWF0aW5nKSByZXR1cm47XG5cbiAgY29uc3QgbmV3SW5kZXggPSB0YXJnZXQuZ2V0QXR0cmlidXRlKGRhdGFCc1NsaWRlVG8pO1xuXG4gIGlmICh0YXJnZXQgJiYgIWhhc0NsYXNzKHRhcmdldCwgYWN0aXZlQ2xhc3MpIC8vIGV2ZW50IHRhcmdldCBpcyBub3QgYWN0aXZlXG4gICAgJiYgbmV3SW5kZXgpIHsgLy8gQU5EIGhhcyB0aGUgc3BlY2lmaWMgYXR0cmlidXRlXG4gICAgc2VsZi50bygrbmV3SW5kZXgpOyAvLyBkbyB0aGUgc2xpZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXJvdXNlbENvbnRyb2xzSGFuZGxlcihlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgdGhhdCA9IHRoaXM7XG4gIGNvbnN0IHNlbGYgPSB0aGF0LmNsb3Nlc3QoY2Fyb3VzZWxTZWxlY3RvcilbY2Fyb3VzZWxDb21wb25lbnRdO1xuICBjb25zdCB7IGNvbnRyb2xzIH0gPSBzZWxmO1xuXG4gIGlmIChjb250cm9sc1sxXSAmJiB0aGF0ID09PSBjb250cm9sc1sxXSkge1xuICAgIHNlbGYubmV4dCgpO1xuICB9IGVsc2UgaWYgKGNvbnRyb2xzWzFdICYmIHRoYXQgPT09IGNvbnRyb2xzWzBdKSB7XG4gICAgc2VsZi5wcmV2KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2Fyb3VzZWxLZXlIYW5kbGVyKHsgd2hpY2ggfSkge1xuICBjb25zdCBbZWxlbWVudF0gPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY2Fyb3VzZWxTZWxlY3RvcikpXG4gICAgLmZpbHRlcigoeCkgPT4gaXNFbGVtZW50SW5TY3JvbGxSYW5nZSh4KSk7XG5cbiAgaWYgKCFlbGVtZW50KSByZXR1cm47XG4gIGNvbnN0IHNlbGYgPSBlbGVtZW50W2Nhcm91c2VsQ29tcG9uZW50XTtcblxuICBzd2l0Y2ggKHdoaWNoKSB7XG4gICAgY2FzZSAzOTpcbiAgICAgIHNlbGYubmV4dCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzNzpcbiAgICAgIHNlbGYucHJldigpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gQ0FST1VTRUwgVE9VQ0ggSEFORExFUlNcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5mdW5jdGlvbiBjYXJvdXNlbFRvdWNoRG93bkhhbmRsZXIoZSkge1xuICBjb25zdCBlbGVtZW50ID0gdGhpcztcbiAgY29uc3Qgc2VsZiA9IGVsZW1lbnRbY2Fyb3VzZWxDb21wb25lbnRdO1xuXG4gIGlmICghc2VsZiB8fCBzZWxmLmlzVG91Y2gpIHsgcmV0dXJuOyB9XG5cbiAgc3RhcnRYID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcblxuICBpZiAoZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICBzZWxmLmlzVG91Y2ggPSB0cnVlO1xuICAgIHRvZ2dsZUNhcm91c2VsVG91Y2hIYW5kbGVycyhzZWxmLCAxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXJvdXNlbFRvdWNoTW92ZUhhbmRsZXIoZSkge1xuICBjb25zdCB7IGNoYW5nZWRUb3VjaGVzLCB0eXBlIH0gPSBlO1xuICBjb25zdCBzZWxmID0gdGhpc1tjYXJvdXNlbENvbXBvbmVudF07XG5cbiAgaWYgKCFzZWxmIHx8ICFzZWxmLmlzVG91Y2gpIHsgcmV0dXJuOyB9XG5cbiAgY3VycmVudFggPSBjaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcblxuICAvLyBjYW5jZWwgdG91Y2ggaWYgbW9yZSB0aGFuIG9uZSBjaGFuZ2VkVG91Y2hlcyBkZXRlY3RlZFxuICBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScgJiYgY2hhbmdlZFRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXJvdXNlbFRvdWNoRW5kSGFuZGxlcihlKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSB0aGlzO1xuICBjb25zdCBzZWxmID0gZWxlbWVudFtjYXJvdXNlbENvbXBvbmVudF07XG5cbiAgaWYgKCFzZWxmIHx8ICFzZWxmLmlzVG91Y2gpIHsgcmV0dXJuOyB9XG5cbiAgZW5kWCA9IGN1cnJlbnRYIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG5cbiAgaWYgKHNlbGYuaXNUb3VjaCkge1xuICAgIC8vIHRoZSBldmVudCB0YXJnZXQgaXMgb3V0c2lkZSB0aGUgY2Fyb3VzZWwgT1IgY2Fyb3VzZWwgZG9lbnMndCBpbmNsdWRlIHRoZSByZWxhdGVkIHRhcmdldFxuICAgIGlmICgoIWVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpIHx8ICFlbGVtZW50LmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkpXG4gICAgICAmJiBNYXRoLmFicyhzdGFydFggLSBlbmRYKSA8IDc1KSB7IC8vIEFORCBzd2lwZSBkaXN0YW5jZSBpcyBsZXNzIHRoYW4gNzVweFxuICAgICAgLy8gd2hlbiB0aGUgYWJvdmUgY29uZGl0aW9ucyBhcmUgc2F0aXNmaWVkLCBubyBuZWVkIHRvIGNvbnRpbnVlXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBPUiBkZXRlcm1pbmUgbmV4dCBpbmRleCB0byBzbGlkZSB0b1xuICAgIGlmIChjdXJyZW50WCA8IHN0YXJ0WCkge1xuICAgICAgc2VsZi5pbmRleCArPSAxO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFggPiBzdGFydFgpIHtcbiAgICAgIHNlbGYuaW5kZXggLT0gMTtcbiAgICB9XG5cbiAgICBzZWxmLmlzVG91Y2ggPSBmYWxzZTtcbiAgICBzZWxmLnRvKHNlbGYuaW5kZXgpOyAvLyBkbyB0aGUgc2xpZGVcblxuICAgIHRvZ2dsZUNhcm91c2VsVG91Y2hIYW5kbGVycyhzZWxmKTsgLy8gcmVtb3ZlIHRvdWNoIGV2ZW50cyBoYW5kbGVyc1xuICB9XG59XG5cbi8vIENBUk9VU0VMIFBSSVZBVEUgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09XG5mdW5jdGlvbiBhY3RpdmF0ZUNhcm91c2VsSW5kaWNhdG9yKHNlbGYsIHBhZ2VJbmRleCkgeyAvLyBpbmRpY2F0b3JzXG4gIGNvbnN0IHsgaW5kaWNhdG9ycyB9ID0gc2VsZjtcbiAgQXJyYXkuZnJvbShpbmRpY2F0b3JzKS5mb3JFYWNoKCh4KSA9PiByZW1vdmVDbGFzcyh4LCBhY3RpdmVDbGFzcykpO1xuICBpZiAoc2VsZi5pbmRpY2F0b3JzW3BhZ2VJbmRleF0pIGFkZENsYXNzKGluZGljYXRvcnNbcGFnZUluZGV4XSwgYWN0aXZlQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiB0b2dnbGVDYXJvdXNlbFRvdWNoSGFuZGxlcnMoc2VsZiwgYWRkKSB7XG4gIGNvbnN0IHsgZWxlbWVudCB9ID0gc2VsZjtcbiAgY29uc3QgYWN0aW9uID0gYWRkID8gYWRkRXZlbnRMaXN0ZW5lciA6IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gIGVsZW1lbnRbYWN0aW9uXSgndG91Y2htb3ZlJywgY2Fyb3VzZWxUb3VjaE1vdmVIYW5kbGVyLCBwYXNzaXZlSGFuZGxlcik7XG4gIGVsZW1lbnRbYWN0aW9uXSgndG91Y2hlbmQnLCBjYXJvdXNlbFRvdWNoRW5kSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIpO1xufVxuXG5mdW5jdGlvbiB0b2dnbGVDYXJvdXNlbEhhbmRsZXJzKHNlbGYsIGFkZCkge1xuICBjb25zdCB7XG4gICAgZWxlbWVudCwgb3B0aW9ucywgc2xpZGVzLCBjb250cm9scywgaW5kaWNhdG9yLFxuICB9ID0gc2VsZjtcbiAgY29uc3Qge1xuICAgIHRvdWNoLCBwYXVzZSwgaW50ZXJ2YWwsIGtleWJvYXJkLFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgYWN0aW9uID0gYWRkID8gYWRkRXZlbnRMaXN0ZW5lciA6IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbiAgaWYgKHBhdXNlICYmIGludGVydmFsKSB7XG4gICAgZWxlbWVudFthY3Rpb25dKCdtb3VzZWVudGVyJywgY2Fyb3VzZWxQYXVzZUhhbmRsZXIpO1xuICAgIGVsZW1lbnRbYWN0aW9uXSgnbW91c2VsZWF2ZScsIGNhcm91c2VsUmVzdW1lSGFuZGxlcik7XG4gICAgZWxlbWVudFthY3Rpb25dKCd0b3VjaHN0YXJ0JywgY2Fyb3VzZWxQYXVzZUhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyKTtcbiAgICBlbGVtZW50W2FjdGlvbl0oJ3RvdWNoZW5kJywgY2Fyb3VzZWxSZXN1bWVIYW5kbGVyLCBwYXNzaXZlSGFuZGxlcik7XG4gIH1cblxuICBpZiAodG91Y2ggJiYgc2xpZGVzLmxlbmd0aCA+IDEpIHtcbiAgICBlbGVtZW50W2FjdGlvbl0oJ3RvdWNoc3RhcnQnLCBjYXJvdXNlbFRvdWNoRG93bkhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyKTtcbiAgfVxuXG4gIGNvbnRyb2xzLmZvckVhY2goKGFycm93KSA9PiB7XG4gICAgaWYgKGFycm93KSBhcnJvd1thY3Rpb25dKCdjbGljaycsIGNhcm91c2VsQ29udHJvbHNIYW5kbGVyKTtcbiAgfSk7XG5cbiAgaWYgKGluZGljYXRvcikgaW5kaWNhdG9yW2FjdGlvbl0oJ2NsaWNrJywgY2Fyb3VzZWxJbmRpY2F0b3JIYW5kbGVyKTtcbiAgaWYgKGtleWJvYXJkKSB3aW5kb3dbYWN0aW9uXSgna2V5ZG93bicsIGNhcm91c2VsS2V5SGFuZGxlcik7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZUluZGV4KHNlbGYpIHtcbiAgY29uc3QgeyBzbGlkZXMsIGVsZW1lbnQgfSA9IHNlbGY7XG4gIHJldHVybiBBcnJheS5mcm9tKHNsaWRlcylcbiAgICAuaW5kZXhPZihlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYCR7Y2Fyb3VzZWxJdGVtfSAke2FjdGl2ZUNsYXNzfWApWzBdKSB8fCAwO1xufVxuXG4vLyBDQVJPVVNFTCBERUZJTklUSU9OXG4vLyA9PT09PT09PT09PT09PT09PT09XG5jbGFzcyBDYXJvdXNlbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNvbmZpZykge1xuICAgIHN1cGVyKGNhcm91c2VsQ29tcG9uZW50LCB0YXJnZXQsIGRlZmF1bHRDYXJvdXNlbE9wdGlvbnMsIGNvbmZpZyk7XG4gICAgLy8gYmluZFxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gICAgc2VsZi50aW1lciA9IG51bGw7XG4gICAgc2VsZi5kaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgc2VsZi5pc1BhdXNlZCA9IGZhbHNlO1xuICAgIHNlbGYuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICBzZWxmLmluZGV4ID0gMDtcbiAgICBzZWxmLnRpbWVyID0gbnVsbDtcbiAgICBzZWxmLmlzVG91Y2ggPSBmYWxzZTtcblxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnRcbiAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHNlbGY7XG4gICAgLy8gY2Fyb3VzZWwgZWxlbWVudHNcbiAgICAvLyBhIExJVkUgY29sbGVjdGlvbiBpcyBwcmVmZmVyYWJsZVxuICAgIHNlbGYuc2xpZGVzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNhcm91c2VsSXRlbSk7XG4gICAgY29uc3QgeyBzbGlkZXMgfSA9IHNlbGY7XG5cbiAgICAvLyBpbnZhbGlkYXRlIHdoZW4gbm90IGVub3VnaCBpdGVtc1xuICAgIC8vIG5vIG5lZWQgdG8gZ28gZnVydGhlclxuICAgIGlmIChzbGlkZXMubGVuZ3RoIDwgMikgeyByZXR1cm47IH1cblxuICAgIHNlbGYuY29udHJvbHMgPSBbXG4gICAgICBxdWVyeUVsZW1lbnQoYC4ke2Nhcm91c2VsQ29udHJvbH0tcHJldmAsIGVsZW1lbnQpLFxuICAgICAgcXVlcnlFbGVtZW50KGAuJHtjYXJvdXNlbENvbnRyb2x9LW5leHRgLCBlbGVtZW50KSxcbiAgICBdO1xuXG4gICAgLy8gYSBMSVZFIGNvbGxlY3Rpb24gaXMgcHJlZmZlcmFibGVcbiAgICBzZWxmLmluZGljYXRvciA9IHF1ZXJ5RWxlbWVudCgnLmNhcm91c2VsLWluZGljYXRvcnMnLCBlbGVtZW50KTtcbiAgICBzZWxmLmluZGljYXRvcnMgPSAoc2VsZi5pbmRpY2F0b3IgJiYgc2VsZi5pbmRpY2F0b3IucXVlcnlTZWxlY3RvckFsbChgWyR7ZGF0YUJzU2xpZGVUb31dYCkpIHx8IFtdO1xuXG4gICAgLy8gc2V0IEphdmFTY3JpcHQgYW5kIERBVEEgQVBJIG9wdGlvbnNcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHNlbGY7XG5cbiAgICAvLyBkb24ndCB1c2UgVFJVRSBhcyBpbnRlcnZhbCwgaXQncyBhY3R1YWxseSAwLCB1c2UgdGhlIGRlZmF1bHQgNTAwMG1zIGJldHRlclxuICAgIHNlbGYub3B0aW9ucy5pbnRlcnZhbCA9IG9wdGlvbnMuaW50ZXJ2YWwgPT09IHRydWVcbiAgICAgID8gZGVmYXVsdENhcm91c2VsT3B0aW9ucy5pbnRlcnZhbFxuICAgICAgOiBvcHRpb25zLmludGVydmFsO1xuXG4gICAgLy8gc2V0IGZpcnN0IHNsaWRlIGFjdGl2ZSBpZiBub25lXG4gICAgaWYgKGdldEFjdGl2ZUluZGV4KHNlbGYpIDwgMCkge1xuICAgICAgaWYgKHNsaWRlcy5sZW5ndGgpIGFkZENsYXNzKHNsaWRlc1swXSwgYWN0aXZlQ2xhc3MpO1xuICAgICAgaWYgKHNlbGYuaW5kaWNhdG9ycy5sZW5ndGgpIGFjdGl2YXRlQ2Fyb3VzZWxJbmRpY2F0b3Ioc2VsZiwgMCk7XG4gICAgfVxuXG4gICAgLy8gYXR0YWNoIGV2ZW50IGhhbmRsZXJzXG4gICAgdG9nZ2xlQ2Fyb3VzZWxIYW5kbGVycyhzZWxmLCAxKTtcblxuICAgIC8vIHN0YXJ0IHRvIGN5Y2xlIGlmIGludGVydmFsIGlzIHNldFxuICAgIGlmIChvcHRpb25zLmludGVydmFsKSBzZWxmLmN5Y2xlKCk7XG4gIH1cblxuICAvLyBDQVJPVVNFTCBQVUJMSUMgTUVUSE9EU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuICBjeWNsZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCB7IGlzUGF1c2VkLCBlbGVtZW50LCBvcHRpb25zIH0gPSBzZWxmO1xuICAgIGlmIChzZWxmLnRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHNlbGYudGltZXIpO1xuICAgICAgc2VsZi50aW1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGlzUGF1c2VkKSB7XG4gICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBwYXVzZWRDbGFzcyk7XG4gICAgICBzZWxmLmlzUGF1c2VkID0gIWlzUGF1c2VkO1xuICAgIH1cblxuICAgIHNlbGYudGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAoaXNFbGVtZW50SW5TY3JvbGxSYW5nZShlbGVtZW50KSkge1xuICAgICAgICBzZWxmLmluZGV4ICs9IDE7XG4gICAgICAgIHNlbGYudG8oc2VsZi5pbmRleCk7XG4gICAgICB9XG4gICAgfSwgb3B0aW9ucy5pbnRlcnZhbCk7XG4gIH1cblxuICBwYXVzZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCB7IGVsZW1lbnQsIG9wdGlvbnMsIGlzUGF1c2VkIH0gPSBzZWxmO1xuICAgIGlmIChvcHRpb25zLmludGVydmFsICYmICFpc1BhdXNlZCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLnRpbWVyKTtcbiAgICAgIHNlbGYudGltZXIgPSBudWxsO1xuICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgcGF1c2VkQ2xhc3MpO1xuICAgICAgc2VsZi5pc1BhdXNlZCA9ICFpc1BhdXNlZDtcbiAgICB9XG4gIH1cblxuICBuZXh0KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5pc0FuaW1hdGluZykgeyBzZWxmLmluZGV4ICs9IDE7IHNlbGYudG8oc2VsZi5pbmRleCk7IH1cbiAgfVxuXG4gIHByZXYoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLmlzQW5pbWF0aW5nKSB7IHNlbGYuaW5kZXggLT0gMTsgc2VsZi50byhzZWxmLmluZGV4KTsgfVxuICB9XG5cbiAgdG8oaWR4KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudCwgaXNBbmltYXRpbmcsIHNsaWRlcywgb3B0aW9ucyxcbiAgICB9ID0gc2VsZjtcbiAgICBjb25zdCBhY3RpdmVJdGVtID0gZ2V0QWN0aXZlSW5kZXgoc2VsZik7XG4gICAgbGV0IG5leHQgPSBpZHg7XG5cbiAgICAvLyB3aGVuIGNvbnRyb2xlZCB2aWEgbWV0aG9kcywgbWFrZSBzdXJlIHRvIGNoZWNrIGFnYWluXG4gICAgLy8gZmlyc3QgcmV0dXJuIGlmIHdlJ3JlIG9uIHRoZSBzYW1lIGl0ZW0gIzIyN1xuICAgIGlmIChpc0FuaW1hdGluZyB8fCBhY3RpdmVJdGVtID09PSBuZXh0KSByZXR1cm47XG5cbiAgICAvLyBkZXRlcm1pbmUgdHJhbnNpdGlvbiBkaXJlY3Rpb25cbiAgICBpZiAoKGFjdGl2ZUl0ZW0gPCBuZXh0KSB8fCAoYWN0aXZlSXRlbSA9PT0gMCAmJiBuZXh0ID09PSBzbGlkZXMubGVuZ3RoIC0gMSkpIHtcbiAgICAgIHNlbGYuZGlyZWN0aW9uID0gJ2xlZnQnOyAvLyBuZXh0XG4gICAgfSBlbHNlIGlmICgoYWN0aXZlSXRlbSA+IG5leHQpIHx8IChhY3RpdmVJdGVtID09PSBzbGlkZXMubGVuZ3RoIC0gMSAmJiBuZXh0ID09PSAwKSkge1xuICAgICAgc2VsZi5kaXJlY3Rpb24gPSAncmlnaHQnOyAvLyBwcmV2XG4gICAgfVxuICAgIGNvbnN0IHsgZGlyZWN0aW9uIH0gPSBzZWxmO1xuXG4gICAgLy8gZmluZCB0aGUgcmlnaHQgbmV4dCBpbmRleFxuICAgIGlmIChuZXh0IDwgMCkgeyBuZXh0ID0gc2xpZGVzLmxlbmd0aCAtIDE7IH0gZWxzZSBpZiAobmV4dCA+PSBzbGlkZXMubGVuZ3RoKSB7IG5leHQgPSAwOyB9XG5cbiAgICAvLyBvcmllbnRhdGlvbiwgY2xhc3MgbmFtZSwgZXZlbnRQcm9wZXJ0aWVzXG4gICAgY29uc3Qgb3JpZW50YXRpb24gPSBkaXJlY3Rpb24gPT09ICdsZWZ0JyA/ICduZXh0JyA6ICdwcmV2JztcbiAgICBjb25zdCBkaXJlY3Rpb25DbGFzcyA9IGRpcmVjdGlvbiA9PT0gJ2xlZnQnID8gJ3N0YXJ0JyA6ICdlbmQnO1xuICAgIGNvbnN0IGV2ZW50UHJvcGVydGllcyA9IHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHNsaWRlc1tuZXh0XSwgZGlyZWN0aW9uLCBmcm9tOiBhY3RpdmVJdGVtLCB0bzogbmV4dCxcbiAgICB9O1xuXG4gICAgLy8gdXBkYXRlIGV2ZW50IHByb3BlcnRpZXNcbiAgICBPYmplY3Qua2V5cyhldmVudFByb3BlcnRpZXMpLmZvckVhY2goKGspID0+IHtcbiAgICAgIGNhcm91c2VsU2xpZGVFdmVudFtrXSA9IGV2ZW50UHJvcGVydGllc1trXTtcbiAgICAgIGNhcm91c2VsU2xpZEV2ZW50W2tdID0gZXZlbnRQcm9wZXJ0aWVzW2tdO1xuICAgIH0pO1xuXG4gICAgLy8gZGlzY29udGludWUgd2hlbiBwcmV2ZW50ZWRcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoY2Fyb3VzZWxTbGlkZUV2ZW50KTtcbiAgICBpZiAoY2Fyb3VzZWxTbGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgIC8vIHVwZGF0ZSBpbmRleFxuICAgIHNlbGYuaW5kZXggPSBuZXh0O1xuXG4gICAgY2xlYXJJbnRlcnZhbChzZWxmLnRpbWVyKTtcbiAgICBzZWxmLnRpbWVyID0gbnVsbDtcblxuICAgIHNlbGYuaXNBbmltYXRpbmcgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2Fyb3VzZWxJbmRpY2F0b3Ioc2VsZiwgbmV4dCk7XG5cbiAgICBpZiAoZ2V0RWxlbWVudFRyYW5zaXRpb25EdXJhdGlvbihzbGlkZXNbbmV4dF0pICYmIGhhc0NsYXNzKGVsZW1lbnQsICdzbGlkZScpKSB7XG4gICAgICBhZGRDbGFzcyhzbGlkZXNbbmV4dF0sIGAke2Nhcm91c2VsSXRlbX0tJHtvcmllbnRhdGlvbn1gKTtcbiAgICAgIHJlZmxvdyhzbGlkZXNbbmV4dF0pO1xuICAgICAgYWRkQ2xhc3Moc2xpZGVzW25leHRdLCBgJHtjYXJvdXNlbEl0ZW19LSR7ZGlyZWN0aW9uQ2xhc3N9YCk7XG4gICAgICBhZGRDbGFzcyhzbGlkZXNbYWN0aXZlSXRlbV0sIGAke2Nhcm91c2VsSXRlbX0tJHtkaXJlY3Rpb25DbGFzc31gKTtcblxuICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoc2xpZGVzW25leHRdLCAoKSA9PiBjYXJvdXNlbFRyYW5zaXRpb25FbmRIYW5kbGVyKHNlbGYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkQ2xhc3Moc2xpZGVzW25leHRdLCBhY3RpdmVDbGFzcyk7XG4gICAgICByZW1vdmVDbGFzcyhzbGlkZXNbYWN0aXZlSXRlbV0sIGFjdGl2ZUNsYXNzKTtcblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNlbGYuaXNBbmltYXRpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBjaGVjayBmb3IgZWxlbWVudCwgbWlnaHQgaGF2ZSBiZWVuIGRpc3Bvc2VkXG4gICAgICAgIGlmIChlbGVtZW50ICYmIG9wdGlvbnMuaW50ZXJ2YWwgJiYgIWhhc0NsYXNzKGVsZW1lbnQsIHBhdXNlZENsYXNzKSkge1xuICAgICAgICAgIHNlbGYuY3ljbGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChjYXJvdXNlbFNsaWRFdmVudCk7XG4gICAgICB9LCAxMDApO1xuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgeyBzbGlkZXMgfSA9IHNlbGY7XG4gICAgY29uc3QgaXRlbUNsYXNzZXMgPSBbJ3N0YXJ0JywgJ2VuZCcsICdwcmV2JywgJ25leHQnXTtcblxuICAgIEFycmF5LmZyb20oc2xpZGVzKS5mb3JFYWNoKChzbGlkZSwgaWR4KSA9PiB7XG4gICAgICBpZiAoaGFzQ2xhc3Moc2xpZGUsIGFjdGl2ZUNsYXNzKSkgYWN0aXZhdGVDYXJvdXNlbEluZGljYXRvcihzZWxmLCBpZHgpO1xuICAgICAgaXRlbUNsYXNzZXMuZm9yRWFjaCgoYykgPT4gcmVtb3ZlQ2xhc3Moc2xpZGUsIGAke2Nhcm91c2VsSXRlbX0tJHtjfWApKTtcbiAgICB9KTtcblxuICAgIHRvZ2dsZUNhcm91c2VsSGFuZGxlcnMoc2VsZik7XG4gICAgY2xlYXJJbnRlcnZhbChzZWxmLnRpbWVyKTtcbiAgICBzdXBlci5kaXNwb3NlKGNhcm91c2VsQ29tcG9uZW50KTtcbiAgfVxufVxuXG5DYXJvdXNlbC5pbml0ID0ge1xuICBjb21wb25lbnQ6IGNhcm91c2VsQ29tcG9uZW50LFxuICBzZWxlY3RvcjogY2Fyb3VzZWxTZWxlY3RvcixcbiAgY29uc3RydWN0b3I6IENhcm91c2VsLFxufTtcblxuY29uc3QgYXJpYUV4cGFuZGVkID0gJ2FyaWEtZXhwYW5kZWQnO1xuXG4vLyBjb2xsYXBzZSAvIHRhYlxuY29uc3QgY29sbGFwc2luZ0NsYXNzID0gJ2NvbGxhcHNpbmcnO1xuXG5jb25zdCBkYXRhQnNUYXJnZXQgPSAnZGF0YS1icy10YXJnZXQnO1xuXG5jb25zdCBkYXRhQnNQYXJlbnQgPSAnZGF0YS1icy1wYXJlbnQnO1xuXG5jb25zdCBkYXRhQnNDb250YWluZXIgPSAnZGF0YS1icy1jb250YWluZXInO1xuXG5mdW5jdGlvbiBnZXRUYXJnZXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIHF1ZXJ5RWxlbWVudChlbGVtZW50LmdldEF0dHJpYnV0ZShkYXRhQnNUYXJnZXQpIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJykpXG4gICAgICAgIHx8IGVsZW1lbnQuY2xvc2VzdChlbGVtZW50LmdldEF0dHJpYnV0ZShkYXRhQnNQYXJlbnQpKVxuICAgICAgICB8fCBxdWVyeUVsZW1lbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoZGF0YUJzQ29udGFpbmVyKSk7XG59XG5cbi8qIE5hdGl2ZSBKYXZhU2NyaXB0IGZvciBCb290c3RyYXAgNSB8IENvbGxhcHNlXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vLyBDT0xMQVBTRSBHQ1xuLy8gPT09PT09PT09PT1cbmNvbnN0IGNvbGxhcHNlU3RyaW5nID0gJ2NvbGxhcHNlJztcbmNvbnN0IGNvbGxhcHNlQ29tcG9uZW50ID0gJ0NvbGxhcHNlJztcbmNvbnN0IGNvbGxhcHNlU2VsZWN0b3IgPSBgLiR7Y29sbGFwc2VTdHJpbmd9YDtcbmNvbnN0IGNvbGxhcHNlVG9nZ2xlU2VsZWN0b3IgPSBgWyR7ZGF0YUJzVG9nZ2xlfT1cIiR7Y29sbGFwc2VTdHJpbmd9XCJdYDtcblxuLy8gQ09MTEFQU0UgQ1VTVE9NIEVWRU5UU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PVxuY29uc3Qgc2hvd0NvbGxhcHNlRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudChgc2hvdy5icy4ke2NvbGxhcHNlU3RyaW5nfWApO1xuY29uc3Qgc2hvd25Db2xsYXBzZUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoYHNob3duLmJzLiR7Y29sbGFwc2VTdHJpbmd9YCk7XG5jb25zdCBoaWRlQ29sbGFwc2VFdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KGBoaWRlLmJzLiR7Y29sbGFwc2VTdHJpbmd9YCk7XG5jb25zdCBoaWRkZW5Db2xsYXBzZUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoYGhpZGRlbi5icy4ke2NvbGxhcHNlU3RyaW5nfWApO1xuXG4vLyBDT0xMQVBTRSBQUklWQVRFIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PVxuZnVuY3Rpb24gZXhwYW5kQ29sbGFwc2Uoc2VsZikge1xuICBjb25zdCB7XG4gICAgZWxlbWVudCwgcGFyZW50LCB0cmlnZ2VycyxcbiAgfSA9IHNlbGY7XG5cbiAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHNob3dDb2xsYXBzZUV2ZW50KTtcbiAgaWYgKHNob3dDb2xsYXBzZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICBzZWxmLmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgaWYgKHBhcmVudCkgcGFyZW50LmlzQW5pbWF0aW5nID0gdHJ1ZTtcblxuICBhZGRDbGFzcyhlbGVtZW50LCBjb2xsYXBzaW5nQ2xhc3MpO1xuICByZW1vdmVDbGFzcyhlbGVtZW50LCBjb2xsYXBzZVN0cmluZyk7XG5cbiAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHtlbGVtZW50LnNjcm9sbEhlaWdodH1weGA7XG5cbiAgZW11bGF0ZVRyYW5zaXRpb25FbmQoZWxlbWVudCwgKCkgPT4ge1xuICAgIHNlbGYuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuaXNBbmltYXRpbmcgPSBmYWxzZTtcblxuICAgIHRyaWdnZXJzLmZvckVhY2goKGJ0bikgPT4gYnRuLnNldEF0dHJpYnV0ZShhcmlhRXhwYW5kZWQsICd0cnVlJykpO1xuXG4gICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY29sbGFwc2luZ0NsYXNzKTtcbiAgICBhZGRDbGFzcyhlbGVtZW50LCBjb2xsYXBzZVN0cmluZyk7XG4gICAgYWRkQ2xhc3MoZWxlbWVudCwgc2hvd0NsYXNzKTtcblxuICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJyc7XG5cbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoc2hvd25Db2xsYXBzZUV2ZW50KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbGxhcHNlQ29udGVudChzZWxmKSB7XG4gIGNvbnN0IHtcbiAgICBlbGVtZW50LCBwYXJlbnQsIHRyaWdnZXJzLFxuICB9ID0gc2VsZjtcblxuICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoaGlkZUNvbGxhcHNlRXZlbnQpO1xuXG4gIGlmIChoaWRlQ29sbGFwc2VFdmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgc2VsZi5pc0FuaW1hdGluZyA9IHRydWU7XG4gIGlmIChwYXJlbnQpIHBhcmVudC5pc0FuaW1hdGluZyA9IHRydWU7XG5cbiAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHtlbGVtZW50LnNjcm9sbEhlaWdodH1weGA7XG5cbiAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY29sbGFwc2VTdHJpbmcpO1xuICByZW1vdmVDbGFzcyhlbGVtZW50LCBzaG93Q2xhc3MpO1xuICBhZGRDbGFzcyhlbGVtZW50LCBjb2xsYXBzaW5nQ2xhc3MpO1xuXG4gIHJlZmxvdyhlbGVtZW50KTtcbiAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMHB4JztcblxuICBlbXVsYXRlVHJhbnNpdGlvbkVuZChlbGVtZW50LCAoKSA9PiB7XG4gICAgc2VsZi5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5pc0FuaW1hdGluZyA9IGZhbHNlO1xuXG4gICAgdHJpZ2dlcnMuZm9yRWFjaCgoYnRuKSA9PiBidG4uc2V0QXR0cmlidXRlKGFyaWFFeHBhbmRlZCwgJ2ZhbHNlJykpO1xuXG4gICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY29sbGFwc2luZ0NsYXNzKTtcbiAgICBhZGRDbGFzcyhlbGVtZW50LCBjb2xsYXBzZVN0cmluZyk7XG5cbiAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9ICcnO1xuXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGhpZGRlbkNvbGxhcHNlRXZlbnQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdG9nZ2xlQ29sbGFwc2VIYW5kbGVyKHNlbGYsIGFkZCkge1xuICBjb25zdCBhY3Rpb24gPSBhZGQgPyBhZGRFdmVudExpc3RlbmVyIDogcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgY29uc3QgeyB0cmlnZ2VycyB9ID0gc2VsZjtcblxuICBpZiAodHJpZ2dlcnMubGVuZ3RoKSB7XG4gICAgdHJpZ2dlcnMuZm9yRWFjaCgoYnRuKSA9PiBidG5bYWN0aW9uXSgnY2xpY2snLCBjb2xsYXBzZUNsaWNrSGFuZGxlcikpO1xuICB9XG59XG5cbi8vIENPTExBUFNFIEVWRU5UIEhBTkRMRVJcbi8vID09PT09PT09PT09PT09PT09PT09PT1cbmZ1bmN0aW9uIGNvbGxhcHNlQ2xpY2tIYW5kbGVyKGUpIHtcbiAgY29uc3QgeyB0YXJnZXQgfSA9IGU7XG4gIGNvbnN0IHRyaWdnZXIgPSB0YXJnZXQuY2xvc2VzdChjb2xsYXBzZVRvZ2dsZVNlbGVjdG9yKTtcbiAgY29uc3QgZWxlbWVudCA9IGdldFRhcmdldEVsZW1lbnQodHJpZ2dlcik7XG4gIGNvbnN0IHNlbGYgPSBlbGVtZW50ICYmIGVsZW1lbnRbY29sbGFwc2VDb21wb25lbnRdO1xuICBpZiAoc2VsZikgc2VsZi50b2dnbGUodGFyZ2V0KTtcblxuICAvLyBldmVudCB0YXJnZXQgaXMgYW5jaG9yIGxpbmsgIzM5OFxuICBpZiAodHJpZ2dlciAmJiB0cmlnZ2VyLnRhZ05hbWUgPT09ICdBJykgZS5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG4vLyBDT0xMQVBTRSBERUZJTklUSU9OXG4vLyA9PT09PT09PT09PT09PT09PT09XG5jbGFzcyBDb2xsYXBzZSBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNvbmZpZykge1xuICAgIHN1cGVyKGNvbGxhcHNlQ29tcG9uZW50LCB0YXJnZXQsIHsgcGFyZW50OiBudWxsIH0sIGNvbmZpZyk7XG4gICAgLy8gYmluZFxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gc2VsZjtcblxuICAgIC8vIHNldCB0cmlnZ2VyaW5nIGVsZW1lbnRzXG4gICAgc2VsZi50cmlnZ2VycyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChjb2xsYXBzZVRvZ2dsZVNlbGVjdG9yKSlcbiAgICAgIC5maWx0ZXIoKGJ0bikgPT4gZ2V0VGFyZ2V0RWxlbWVudChidG4pID09PSBlbGVtZW50KTtcblxuICAgIC8vIHNldCBwYXJlbnQgYWNjb3JkaW9uXG4gICAgc2VsZi5wYXJlbnQgPSBxdWVyeUVsZW1lbnQoc2VsZi5vcHRpb25zLnBhcmVudCk7XG4gICAgY29uc3QgeyBwYXJlbnQgfSA9IHNlbGY7XG5cbiAgICAvLyBzZXQgaW5pdGlhbCBzdGF0ZVxuICAgIHNlbGYuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuaXNBbmltYXRpbmcgPSBmYWxzZTtcblxuICAgIC8vIGFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICB0b2dnbGVDb2xsYXBzZUhhbmRsZXIoc2VsZiwgMSk7XG4gIH1cblxuICAvLyBDT0xMQVBTRSBQVUJMSUMgTUVUSE9EU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuICB0b2dnbGUocmVsYXRlZCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghaGFzQ2xhc3Moc2VsZi5lbGVtZW50LCBzaG93Q2xhc3MpKSBzZWxmLnNob3cocmVsYXRlZCk7XG4gICAgZWxzZSBzZWxmLmhpZGUocmVsYXRlZCk7XG4gIH1cblxuICBoaWRlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHsgdHJpZ2dlcnMsIGlzQW5pbWF0aW5nIH0gPSBzZWxmO1xuICAgIGlmIChpc0FuaW1hdGluZykgcmV0dXJuO1xuXG4gICAgY29sbGFwc2VDb250ZW50KHNlbGYpO1xuICAgIGlmICh0cmlnZ2Vycy5sZW5ndGgpIHtcbiAgICAgIHRyaWdnZXJzLmZvckVhY2goKGJ0bikgPT4gYWRkQ2xhc3MoYnRuLCBgJHtjb2xsYXBzZVN0cmluZ31kYCkpO1xuICAgIH1cbiAgfVxuXG4gIHNob3coKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudCwgcGFyZW50LCB0cmlnZ2VycywgaXNBbmltYXRpbmcsXG4gICAgfSA9IHNlbGY7XG4gICAgbGV0IGFjdGl2ZUNvbGxhcHNlO1xuICAgIGxldCBhY3RpdmVDb2xsYXBzZUluc3RhbmNlO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgYWN0aXZlQ29sbGFwc2UgPSBBcnJheS5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtjb2xsYXBzZVN0cmluZ30uJHtzaG93Q2xhc3N9YCkpXG4gICAgICAgIC5maW5kKChpKSA9PiBpW2NvbGxhcHNlQ29tcG9uZW50XSk7XG4gICAgICBhY3RpdmVDb2xsYXBzZUluc3RhbmNlID0gYWN0aXZlQ29sbGFwc2UgJiYgYWN0aXZlQ29sbGFwc2VbY29sbGFwc2VDb21wb25lbnRdO1xuICAgIH1cblxuICAgIGlmICgoIXBhcmVudCB8fCAocGFyZW50ICYmICFwYXJlbnQuaXNBbmltYXRpbmcpKSAmJiAhaXNBbmltYXRpbmcpIHtcbiAgICAgIGlmIChhY3RpdmVDb2xsYXBzZUluc3RhbmNlICYmIGFjdGl2ZUNvbGxhcHNlICE9PSBlbGVtZW50KSB7XG4gICAgICAgIGNvbGxhcHNlQ29udGVudChhY3RpdmVDb2xsYXBzZUluc3RhbmNlKTtcbiAgICAgICAgYWN0aXZlQ29sbGFwc2VJbnN0YW5jZS50cmlnZ2Vycy5mb3JFYWNoKChidG4pID0+IHtcbiAgICAgICAgICBhZGRDbGFzcyhidG4sIGAke2NvbGxhcHNlU3RyaW5nfWRgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGV4cGFuZENvbGxhcHNlKHNlbGYpO1xuICAgICAgaWYgKHRyaWdnZXJzLmxlbmd0aCkge1xuICAgICAgICB0cmlnZ2Vycy5mb3JFYWNoKChidG4pID0+IHJlbW92ZUNsYXNzKGJ0biwgYCR7Y29sbGFwc2VTdHJpbmd9ZGApKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHsgcGFyZW50IH0gPSBzZWxmO1xuICAgIHRvZ2dsZUNvbGxhcHNlSGFuZGxlcihzZWxmKTtcblxuICAgIGlmIChwYXJlbnQpIGRlbGV0ZSBwYXJlbnQuaXNBbmltYXRpbmc7XG4gICAgc3VwZXIuZGlzcG9zZShjb2xsYXBzZUNvbXBvbmVudCk7XG4gIH1cbn1cblxuQ29sbGFwc2UuaW5pdCA9IHtcbiAgY29tcG9uZW50OiBjb2xsYXBzZUNvbXBvbmVudCxcbiAgc2VsZWN0b3I6IGNvbGxhcHNlU2VsZWN0b3IsXG4gIGNvbnN0cnVjdG9yOiBDb2xsYXBzZSxcbn07XG5cbmNvbnN0IGRyb3Bkb3duTWVudUNsYXNzZXMgPSBbJ2Ryb3Bkb3duJywgJ2Ryb3B1cCcsICdkcm9wc3RhcnQnLCAnZHJvcGVuZCddO1xuXG5jb25zdCBkcm9wZG93bk1lbnVDbGFzcyA9ICdkcm9wZG93bi1tZW51JztcblxuZnVuY3Rpb24gaXNFbXB0eUFuY2hvcihlbGVtKSB7XG4gIGNvbnN0IHBhcmVudEFuY2hvciA9IGVsZW0uY2xvc2VzdCgnQScpO1xuICAvLyBhbmNob3IgaHJlZiBzdGFydHMgd2l0aCAjXG4gIHJldHVybiBlbGVtICYmICgoZWxlbS5ocmVmICYmIGVsZW0uaHJlZi5zbGljZSgtMSkgPT09ICcjJylcbiAgICAvLyBPUiBhIGNoaWxkIG9mIGFuIGFuY2hvciB3aXRoIGhyZWYgc3RhcnRzIHdpdGggI1xuICAgIHx8IChwYXJlbnRBbmNob3IgJiYgcGFyZW50QW5jaG9yLmhyZWYgJiYgcGFyZW50QW5jaG9yLmhyZWYuc2xpY2UoLTEpID09PSAnIycpKTtcbn1cblxuZnVuY3Rpb24gc2V0Rm9jdXMoZWxlbWVudCkge1xuICBlbGVtZW50LmZvY3VzKCk7XG59XG5cbi8qIE5hdGl2ZSBKYXZhU2NyaXB0IGZvciBCb290c3RyYXAgNSB8IERyb3Bkb3duXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vLyBEUk9QRE9XTiBQUklWQVRFIEdDXG4vLyA9PT09PT09PT09PT09PT09PT09XG5jb25zdCBbZHJvcGRvd25TdHJpbmddID0gZHJvcGRvd25NZW51Q2xhc3NlcztcbmNvbnN0IGRyb3Bkb3duQ29tcG9uZW50ID0gJ0Ryb3Bkb3duJztcbmNvbnN0IGRyb3Bkb3duU2VsZWN0b3IgPSBgWyR7ZGF0YUJzVG9nZ2xlfT1cIiR7ZHJvcGRvd25TdHJpbmd9XCJdYDtcblxuLy8gRFJPUERPV04gUFJJVkFURSBHQ1xuLy8gPT09PT09PT09PT09PT09PT09PVxuY29uc3QgZHJvcHVwU3RyaW5nID0gZHJvcGRvd25NZW51Q2xhc3Nlc1sxXTtcbmNvbnN0IGRyb3BzdGFydFN0cmluZyA9IGRyb3Bkb3duTWVudUNsYXNzZXNbMl07XG5jb25zdCBkcm9wZW5kU3RyaW5nID0gZHJvcGRvd25NZW51Q2xhc3Nlc1szXTtcbmNvbnN0IGRyb3Bkb3duTWVudUVuZENsYXNzID0gYCR7ZHJvcGRvd25NZW51Q2xhc3N9LWVuZGA7XG5jb25zdCBoaWRlTWVudUNsYXNzID0gWydkLWJsb2NrJywgJ2ludmlzaWJsZSddO1xuY29uc3QgdmVydGljYWxDbGFzcyA9IFtkcm9wZG93blN0cmluZywgZHJvcHVwU3RyaW5nXTtcbmNvbnN0IGhvcml6b250YWxDbGFzcyA9IFtkcm9wc3RhcnRTdHJpbmcsIGRyb3BlbmRTdHJpbmddO1xuY29uc3QgZGVmYXVsdERyb3Bkb3duT3B0aW9ucyA9IHtcbiAgb2Zmc2V0OiA1LCAvLyBbbnVtYmVyXSA1KHB4KVxuICBkaXNwbGF5OiAnZHluYW1pYycsIC8vIFtkeW5hbWljfHN0YXRpY11cbn07XG5cbi8vIERST1BET1dOIENVU1RPTSBFVkVOVFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3Qgc2hvd0Ryb3Bkb3duRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudChgc2hvdy5icy4ke2Ryb3Bkb3duU3RyaW5nfWApO1xuY29uc3Qgc2hvd25Ecm9wZG93bkV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoYHNob3duLmJzLiR7ZHJvcGRvd25TdHJpbmd9YCk7XG5jb25zdCBoaWRlRHJvcGRvd25FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KGBoaWRlLmJzLiR7ZHJvcGRvd25TdHJpbmd9YCk7XG5jb25zdCBoaWRkZW5Ecm9wZG93bkV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoYGhpZGRlbi5icy4ke2Ryb3Bkb3duU3RyaW5nfWApO1xuXG4vLyBEUk9QRE9XTiBQUklWQVRFIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PVxuZnVuY3Rpb24gc3R5bGVEcm9wZG93bihzZWxmLCBzaG93KSB7XG4gIGNvbnN0IHtcbiAgICBlbGVtZW50LCBtZW51LCBvcmlnaW5hbENsYXNzLCBtZW51RW5kLCBvcHRpb25zLFxuICB9ID0gc2VsZjtcbiAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXG4gIC8vIHJlc2V0IG1lbnUgb2Zmc2V0IGFuZCBwb3NpdGlvblxuICBjb25zdCByZXNldFByb3BzID0gWydtYXJnaW4nLCAndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J107XG4gIHJlc2V0UHJvcHMuZm9yRWFjaCgocCkgPT4geyBtZW51LnN0eWxlW3BdID0gJyc7IH0pO1xuICByZW1vdmVDbGFzcyhwYXJlbnQsICdwb3NpdGlvbi1zdGF0aWMnKTtcblxuICBpZiAoIXNob3cpIHtcbiAgICBwYXJlbnQuY2xhc3NOYW1lID0gb3JpZ2luYWxDbGFzcy5qb2luKCcgJyk7XG4gICAgY29uc3QgbWVudUFjdGlvbiA9IG1lbnVFbmQgJiYgIWhhc0NsYXNzKG1lbnUsIGRyb3Bkb3duTWVudUVuZENsYXNzKSA/IGFkZENsYXNzIDogcmVtb3ZlQ2xhc3M7XG4gICAgbWVudUFjdGlvbihtZW51LCBkcm9wZG93bk1lbnVFbmRDbGFzcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgeyBvZmZzZXQgfSA9IG9wdGlvbnM7XG4gIGxldCBwb3NpdGlvbkNsYXNzID0gZHJvcGRvd25NZW51Q2xhc3Nlcy5maW5kKChjKSA9PiBvcmlnaW5hbENsYXNzLmluY2x1ZGVzKGMpKTtcblxuICBsZXQgZHJvcGRvd25NYXJnaW4gPSB7XG4gICAgZHJvcGRvd246IFtvZmZzZXQsIDAsIDBdLFxuICAgIGRyb3B1cDogWzAsIDAsIG9mZnNldF0sXG4gICAgZHJvcHN0YXJ0OiBbLTEsIG9mZnNldCwgMF0sXG4gICAgZHJvcGVuZDogWy0xLCAwLCAwLCBvZmZzZXRdLFxuICB9O1xuXG4gIGNvbnN0IGRyb3Bkb3duUG9zaXRpb24gPSB7XG4gICAgZHJvcGRvd246IHsgdG9wOiAnMTAwJScgfSxcbiAgICBkcm9wdXA6IHsgdG9wOiAnYXV0bycsIGJvdHRvbTogJzEwMCUnIH0sXG4gICAgZHJvcHN0YXJ0OiB7IGxlZnQ6ICdhdXRvJywgcmlnaHQ6ICcxMDAlJyB9LFxuICAgIGRyb3BlbmQ6IHsgbGVmdDogJzEwMCUnLCByaWdodDogJ2F1dG8nIH0sXG4gICAgbWVudUVuZDogeyByaWdodDogMCwgbGVmdDogJ2F1dG8nIH0sXG4gIH07XG5cbiAgLy8gZm9yY2Ugc2hvd2luZyB0aGUgbWVudSB0byBjYWxjdWxhdGUgaXRzIHNpemVcbiAgaGlkZU1lbnVDbGFzcy5mb3JFYWNoKChjKSA9PiBhZGRDbGFzcyhtZW51LCBjKSk7XG5cbiAgY29uc3QgZHJvcGRvd25SZWdleCA9IG5ldyBSZWdFeHAoYFxcXFxiKCR7ZHJvcGRvd25TdHJpbmd9fCR7ZHJvcHVwU3RyaW5nfXwke2Ryb3BzdGFydFN0cmluZ318JHtkcm9wZW5kU3RyaW5nfSkrYCk7XG4gIGNvbnN0IGVsZW1lbnREaW1lbnNpb25zID0geyB3OiBlbGVtZW50Lm9mZnNldFdpZHRoLCBoOiBlbGVtZW50Lm9mZnNldEhlaWdodCB9O1xuICBjb25zdCBtZW51RGltZW5zaW9ucyA9IHsgdzogbWVudS5vZmZzZXRXaWR0aCwgaDogbWVudS5vZmZzZXRIZWlnaHQgfTtcbiAgY29uc3QgSFRNTCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgY29uc3QgQkQgPSBkb2N1bWVudC5ib2R5O1xuICBjb25zdCB3aW5kb3dXaWR0aCA9IChIVE1MLmNsaWVudFdpZHRoIHx8IEJELmNsaWVudFdpZHRoKTtcbiAgY29uc3Qgd2luZG93SGVpZ2h0ID0gKEhUTUwuY2xpZW50SGVpZ2h0IHx8IEJELmNsaWVudEhlaWdodCk7XG4gIGNvbnN0IHRhcmdldEJDUiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIC8vIGRyb3Bkb3duTWVudUVuZCAmJiBbIGRyb3Bkb3duIHwgZHJvcHVwIF1cbiAgY29uc3QgbGVmdEV4Y2VlZCA9IHRhcmdldEJDUi5sZWZ0ICsgZWxlbWVudERpbWVuc2lvbnMudyAtIG1lbnVEaW1lbnNpb25zLncgPCAwO1xuICAvLyBkcm9wc3RhcnRcbiAgY29uc3QgbGVmdEZ1bGxFeGNlZWQgPSB0YXJnZXRCQ1IubGVmdCAtIG1lbnVEaW1lbnNpb25zLncgPCAwO1xuICAvLyAhZHJvcGRvd25NZW51RW5kICYmIFsgZHJvcGRvd24gfCBkcm9wdXAgXVxuICBjb25zdCByaWdodEV4Y2VlZCA9IHRhcmdldEJDUi5sZWZ0ICsgbWVudURpbWVuc2lvbnMudyA+PSB3aW5kb3dXaWR0aDtcbiAgLy8gZHJvcGVuZFxuICBjb25zdCByaWdodEZ1bGxFeGNlZWQgPSB0YXJnZXRCQ1IubGVmdCArIG1lbnVEaW1lbnNpb25zLncgKyBlbGVtZW50RGltZW5zaW9ucy53ID49IHdpbmRvd1dpZHRoO1xuICAvLyBkcm9wc3RhcnQgfCBkcm9wZW5kXG4gIGNvbnN0IGJvdHRvbUV4Y2VlZCA9IHRhcmdldEJDUi50b3AgKyBtZW51RGltZW5zaW9ucy5oID49IHdpbmRvd0hlaWdodDtcbiAgLy8gZHJvcGRvd25cbiAgY29uc3QgYm90dG9tRnVsbEV4Y2VlZCA9IHRhcmdldEJDUi50b3AgKyBtZW51RGltZW5zaW9ucy5oICsgZWxlbWVudERpbWVuc2lvbnMuaCA+PSB3aW5kb3dIZWlnaHQ7XG4gIC8vIGRyb3B1cFxuICBjb25zdCB0b3BFeGNlZWQgPSB0YXJnZXRCQ1IudG9wIC0gbWVudURpbWVuc2lvbnMuaCA8IDA7XG5cbiAgY29uc3QgYnRuR3JvdXAgPSBwYXJlbnQucGFyZW50Tm9kZS5jbG9zZXN0KCcuYnRuLWdyb3VwLC5idG4tZ3JvdXAtdmVydGljYWwnKTtcblxuICAvLyByZWNvbXB1dGUgcG9zaXRpb25cbiAgaWYgKGhvcml6b250YWxDbGFzcy5pbmNsdWRlcyhwb3NpdGlvbkNsYXNzKSAmJiBsZWZ0RnVsbEV4Y2VlZCAmJiByaWdodEZ1bGxFeGNlZWQpIHtcbiAgICBwb3NpdGlvbkNsYXNzID0gZHJvcGRvd25TdHJpbmc7XG4gIH1cbiAgaWYgKGhvcml6b250YWxDbGFzcy5pbmNsdWRlcyhwb3NpdGlvbkNsYXNzKSAmJiBib3R0b21FeGNlZWQpIHtcbiAgICBwb3NpdGlvbkNsYXNzID0gZHJvcHVwU3RyaW5nO1xuICB9XG4gIGlmIChwb3NpdGlvbkNsYXNzID09PSBkcm9wc3RhcnRTdHJpbmcgJiYgbGVmdEZ1bGxFeGNlZWQgJiYgIWJvdHRvbUV4Y2VlZCkge1xuICAgIHBvc2l0aW9uQ2xhc3MgPSBkcm9wZW5kU3RyaW5nO1xuICB9XG4gIGlmIChwb3NpdGlvbkNsYXNzID09PSBkcm9wZW5kU3RyaW5nICYmIHJpZ2h0RnVsbEV4Y2VlZCAmJiAhYm90dG9tRXhjZWVkKSB7XG4gICAgcG9zaXRpb25DbGFzcyA9IGRyb3BzdGFydFN0cmluZztcbiAgfVxuICBpZiAocG9zaXRpb25DbGFzcyA9PT0gZHJvcHVwU3RyaW5nICYmIHRvcEV4Y2VlZCAmJiAhYm90dG9tRnVsbEV4Y2VlZCkge1xuICAgIHBvc2l0aW9uQ2xhc3MgPSBkcm9wZG93blN0cmluZztcbiAgfVxuICBpZiAocG9zaXRpb25DbGFzcyA9PT0gZHJvcGRvd25TdHJpbmcgJiYgYm90dG9tRnVsbEV4Y2VlZCAmJiAhdG9wRXhjZWVkKSB7XG4gICAgcG9zaXRpb25DbGFzcyA9IGRyb3B1cFN0cmluZztcbiAgfVxuXG4gIC8vIHNldCBzcGFjaW5nXG4gIGRyb3Bkb3duTWFyZ2luID0gZHJvcGRvd25NYXJnaW5bcG9zaXRpb25DbGFzc107XG4gIG1lbnUuc3R5bGUubWFyZ2luID0gYCR7ZHJvcGRvd25NYXJnaW4ubWFwKCh4KSA9PiAoeCA/IGAke3h9cHhgIDogeCkpLmpvaW4oJyAnKX1gO1xuICBPYmplY3Qua2V5cyhkcm9wZG93blBvc2l0aW9uW3Bvc2l0aW9uQ2xhc3NdKS5mb3JFYWNoKChwb3NpdGlvbikgPT4ge1xuICAgIG1lbnUuc3R5bGVbcG9zaXRpb25dID0gZHJvcGRvd25Qb3NpdGlvbltwb3NpdGlvbkNsYXNzXVtwb3NpdGlvbl07XG4gIH0pO1xuXG4gIC8vIHVwZGF0ZSBkcm9wZG93biBwb3NpdGlvbiBjbGFzc1xuICBpZiAoIWhhc0NsYXNzKHBhcmVudCwgcG9zaXRpb25DbGFzcykpIHtcbiAgICBwYXJlbnQuY2xhc3NOYW1lID0gcGFyZW50LmNsYXNzTmFtZS5yZXBsYWNlKGRyb3Bkb3duUmVnZXgsIHBvc2l0aW9uQ2xhc3MpO1xuICB9XG5cbiAgLy8gdXBkYXRlIGRyb3Bkb3duIC8gZHJvcHVwIHRvIGhhbmRsZSBwYXJlbnQgYnRuLWdyb3VwIGVsZW1lbnRcbiAgLy8gYXMgd2VsbCBhcyB0aGUgZHJvcGRvd24tbWVudS1lbmQgdXRpbGl0eSBjbGFzc1xuICBpZiAodmVydGljYWxDbGFzcy5pbmNsdWRlcyhwb3NpdGlvbkNsYXNzKSkge1xuICAgIGNvbnN0IG1lbnVFbmRBY3Rpb24gPSByaWdodEV4Y2VlZCA/IGFkZENsYXNzIDogcmVtb3ZlQ2xhc3M7XG5cbiAgICBpZiAoIWJ0bkdyb3VwKSBtZW51RW5kQWN0aW9uKG1lbnUsIGRyb3Bkb3duTWVudUVuZENsYXNzKTtcbiAgICBlbHNlIGlmIChsZWZ0RXhjZWVkKSBhZGRDbGFzcyhwYXJlbnQsICdwb3NpdGlvbi1zdGF0aWMnKTtcblxuICAgIGlmIChoYXNDbGFzcyhtZW51LCBkcm9wZG93bk1lbnVFbmRDbGFzcykpIHtcbiAgICAgIE9iamVjdC5rZXlzKGRyb3Bkb3duUG9zaXRpb24ubWVudUVuZCkuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICBtZW51LnN0eWxlW3BdID0gZHJvcGRvd25Qb3NpdGlvbi5tZW51RW5kW3BdO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVtb3ZlIHV0aWwgY2xhc3NlcyBmcm9tIHRoZSBtZW51LCB3ZSBoYXZlIGl0cyBzaXplXG4gIGhpZGVNZW51Q2xhc3MuZm9yRWFjaCgoYykgPT4gcmVtb3ZlQ2xhc3MobWVudSwgYykpO1xufVxuXG5mdW5jdGlvbiB0b2dnbGVEcm9wZG93bkRpc21pc3Moc2VsZikge1xuICBjb25zdCBhY3Rpb24gPSBzZWxmLm9wZW4gPyBhZGRFdmVudExpc3RlbmVyIDogcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxuICBkb2N1bWVudFthY3Rpb25dKCdjbGljaycsIGRyb3Bkb3duRGlzbWlzc0hhbmRsZXIpO1xuICBkb2N1bWVudFthY3Rpb25dKCdmb2N1cycsIGRyb3Bkb3duRGlzbWlzc0hhbmRsZXIpO1xuICBkb2N1bWVudFthY3Rpb25dKCdrZXlkb3duJywgZHJvcGRvd25QcmV2ZW50U2Nyb2xsKTtcbiAgZG9jdW1lbnRbYWN0aW9uXSgna2V5dXAnLCBkcm9wZG93bktleUhhbmRsZXIpO1xuICBpZiAoc2VsZi5vcHRpb25zLmRpc3BsYXkgPT09ICdkeW5hbWljJykge1xuICAgIHdpbmRvd1thY3Rpb25dKCdzY3JvbGwnLCBkcm9wZG93bkxheW91dEhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyKTtcbiAgICB3aW5kb3dbYWN0aW9uXSgncmVzaXplJywgZHJvcGRvd25MYXlvdXRIYW5kbGVyLCBwYXNzaXZlSGFuZGxlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9nZ2xlRHJvcGRvd25IYW5kbGVyKHNlbGYsIGFkZCkge1xuICBjb25zdCBhY3Rpb24gPSBhZGQgPyBhZGRFdmVudExpc3RlbmVyIDogcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgc2VsZi5lbGVtZW50W2FjdGlvbl0oJ2NsaWNrJywgZHJvcGRvd25DbGlja0hhbmRsZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50T3BlbkRyb3Bkb3duKCkge1xuICBjb25zdCBjdXJyZW50UGFyZW50ID0gZHJvcGRvd25NZW51Q2xhc3Nlc1xuICAgIC5tYXAoKGMpID0+IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYCR7Y30gJHtzaG93Q2xhc3N9YCkpXG4gICAgLmZpbmQoKHgpID0+IHgubGVuZ3RoKTtcblxuICBpZiAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lmxlbmd0aCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGN1cnJlbnRQYXJlbnRbMF0uY2hpbGRyZW4pLmZpbmQoKHgpID0+IHguaGFzQXR0cmlidXRlKGRhdGFCc1RvZ2dsZSkpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBEUk9QRE9XTiBFVkVOVCBIQU5ETEVSU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmZ1bmN0aW9uIGRyb3Bkb3duRGlzbWlzc0hhbmRsZXIoZSkge1xuICBjb25zdCB7IHRhcmdldCwgdHlwZSB9ID0gZTtcbiAgaWYgKCF0YXJnZXQuY2xvc2VzdCkgcmV0dXJuOyAvLyBzb21lIHdlaXJkIEZGIGJ1ZyAjNDA5XG5cbiAgY29uc3QgZWxlbWVudCA9IGdldEN1cnJlbnRPcGVuRHJvcGRvd24oKTtcbiAgY29uc3QgcGFyZW50ID0gZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGU7XG4gIGNvbnN0IHNlbGYgPSBlbGVtZW50ICYmIGVsZW1lbnRbZHJvcGRvd25Db21wb25lbnRdO1xuICBjb25zdCBtZW51ID0gc2VsZiAmJiBzZWxmLm1lbnU7XG5cbiAgY29uc3QgaGFzRGF0YSA9IHRhcmdldC5jbG9zZXN0KGRyb3Bkb3duU2VsZWN0b3IpICE9PSBudWxsO1xuICBjb25zdCBpc0Zvcm0gPSBwYXJlbnQgJiYgcGFyZW50LmNvbnRhaW5zKHRhcmdldClcbiAgICAmJiAodGFyZ2V0LnRhZ05hbWUgPT09ICdmb3JtJyB8fCB0YXJnZXQuY2xvc2VzdCgnZm9ybScpICE9PSBudWxsKTtcblxuICBpZiAodHlwZSA9PT0gJ2NsaWNrJyAmJiBpc0VtcHR5QW5jaG9yKHRhcmdldCkpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdmb2N1cydcbiAgICAmJiAodGFyZ2V0ID09PSBlbGVtZW50IHx8IHRhcmdldCA9PT0gbWVudSB8fCBtZW51LmNvbnRhaW5zKHRhcmdldCkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlzRm9ybSB8fCBoYXNEYXRhKSA7IGVsc2UgaWYgKHNlbGYpIHtcbiAgICBzZWxmLmhpZGUoZWxlbWVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJvcGRvd25DbGlja0hhbmRsZXIoZSkge1xuICBjb25zdCBlbGVtZW50ID0gdGhpcztcbiAgY29uc3Qgc2VsZiA9IGVsZW1lbnRbZHJvcGRvd25Db21wb25lbnRdO1xuICBzZWxmLnRvZ2dsZShlbGVtZW50KTtcblxuICBpZiAoaXNFbXB0eUFuY2hvcihlLnRhcmdldCkpIGUucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gZHJvcGRvd25QcmV2ZW50U2Nyb2xsKGUpIHtcbiAgaWYgKGUud2hpY2ggPT09IDM4IHx8IGUud2hpY2ggPT09IDQwKSBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmZ1bmN0aW9uIGRyb3Bkb3duS2V5SGFuZGxlcih7IHdoaWNoIH0pIHtcbiAgY29uc3QgZWxlbWVudCA9IGdldEN1cnJlbnRPcGVuRHJvcGRvd24oKTtcbiAgY29uc3Qgc2VsZiA9IGVsZW1lbnRbZHJvcGRvd25Db21wb25lbnRdO1xuICBjb25zdCB7IG1lbnUsIG1lbnVJdGVtcywgb3BlbiB9ID0gc2VsZjtcbiAgY29uc3QgYWN0aXZlSXRlbSA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIGNvbnN0IGlzU2FtZUVsZW1lbnQgPSBhY3RpdmVJdGVtID09PSBlbGVtZW50O1xuICBjb25zdCBpc0luc2lkZU1lbnUgPSBtZW51LmNvbnRhaW5zKGFjdGl2ZUl0ZW0pO1xuICBjb25zdCBpc01lbnVJdGVtID0gYWN0aXZlSXRlbS5wYXJlbnROb2RlID09PSBtZW51IHx8IGFjdGl2ZUl0ZW0ucGFyZW50Tm9kZS5wYXJlbnROb2RlID09PSBtZW51O1xuXG4gIGxldCBpZHggPSBtZW51SXRlbXMuaW5kZXhPZihhY3RpdmVJdGVtKTtcblxuICBpZiAoaXNNZW51SXRlbSkgeyAvLyBuYXZpZ2F0ZSB1cCB8IGRvd25cbiAgICBpZiAoaXNTYW1lRWxlbWVudCkge1xuICAgICAgaWR4ID0gMDtcbiAgICB9IGVsc2UgaWYgKHdoaWNoID09PSAzOCkge1xuICAgICAgaWR4ID0gaWR4ID4gMSA/IGlkeCAtIDEgOiAwO1xuICAgIH0gZWxzZSBpZiAod2hpY2ggPT09IDQwKSB7XG4gICAgICBpZHggPSBpZHggPCBtZW51SXRlbXMubGVuZ3RoIC0gMSA/IGlkeCArIDEgOiBpZHg7XG4gICAgfVxuXG4gICAgaWYgKG1lbnVJdGVtc1tpZHhdKSBzZXRGb2N1cyhtZW51SXRlbXNbaWR4XSk7XG4gIH1cblxuICBpZiAoKChtZW51SXRlbXMubGVuZ3RoICYmIGlzTWVudUl0ZW0pIC8vIG1lbnUgaGFzIGl0ZW1zXG4gICAgICB8fCAoIW1lbnVJdGVtcy5sZW5ndGggJiYgKGlzSW5zaWRlTWVudSB8fCBpc1NhbWVFbGVtZW50KSkgLy8gbWVudSBtaWdodCBiZSBhIGZvcm1cbiAgICAgIHx8ICFpc0luc2lkZU1lbnUpIC8vIG9yIHRoZSBmb2N1c2VkIGVsZW1lbnQgaXMgbm90IGluIHRoZSBtZW51IGF0IGFsbFxuICAgICAgJiYgb3BlbiAmJiB3aGljaCA9PT0gMjcgLy8gbWVudSBtdXN0IGJlIG9wZW5cbiAgKSB7XG4gICAgc2VsZi50b2dnbGUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcm9wZG93bkxheW91dEhhbmRsZXIoKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBnZXRDdXJyZW50T3BlbkRyb3Bkb3duKCk7XG4gIGNvbnN0IHNlbGYgPSBlbGVtZW50ICYmIGVsZW1lbnRbZHJvcGRvd25Db21wb25lbnRdO1xuXG4gIGlmIChzZWxmICYmIHNlbGYub3Blbikgc3R5bGVEcm9wZG93bihzZWxmLCAxKTtcbn1cblxuLy8gRFJPUERPV04gREVGSU5JVElPTlxuLy8gPT09PT09PT09PT09PT09PT09PVxuY2xhc3MgRHJvcGRvd24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IodGFyZ2V0LCBjb25maWcpIHtcbiAgICBzdXBlcihkcm9wZG93bkNvbXBvbmVudCwgdGFyZ2V0LCBkZWZhdWx0RHJvcGRvd25PcHRpb25zLCBjb25maWcpO1xuICAgIC8vIGJpbmRcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnRcbiAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHNlbGY7XG5cbiAgICAvLyBzZXQgdGFyZ2V0c1xuICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICBzZWxmLm1lbnUgPSBxdWVyeUVsZW1lbnQoYC4ke2Ryb3Bkb3duTWVudUNsYXNzfWAsIHBhcmVudCk7XG4gICAgY29uc3QgeyBtZW51IH0gPSBzZWxmO1xuXG4gICAgc2VsZi5vcmlnaW5hbENsYXNzID0gQXJyYXkuZnJvbShwYXJlbnQuY2xhc3NMaXN0KTtcblxuICAgIC8vIHNldCBvcmlnaW5hbCBwb3NpdGlvblxuICAgIHNlbGYubWVudUVuZCA9IGhhc0NsYXNzKG1lbnUsIGRyb3Bkb3duTWVudUVuZENsYXNzKTtcblxuICAgIHNlbGYubWVudUl0ZW1zID0gW107XG5cbiAgICBBcnJheS5mcm9tKG1lbnUuY2hpbGRyZW4pLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBpZiAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoICYmIChjaGlsZC5jaGlsZHJlblswXS50YWdOYW1lID09PSAnQScpKSBzZWxmLm1lbnVJdGVtcy5wdXNoKGNoaWxkLmNoaWxkcmVuWzBdKTtcbiAgICAgIGlmIChjaGlsZC50YWdOYW1lID09PSAnQScpIHNlbGYubWVudUl0ZW1zLnB1c2goY2hpbGQpO1xuICAgIH0pO1xuXG4gICAgLy8gc2V0IGluaXRpYWwgc3RhdGUgdG8gY2xvc2VkXG4gICAgc2VsZi5vcGVuID0gZmFsc2U7XG5cbiAgICAvLyBhZGQgZXZlbnQgbGlzdGVuZXJcbiAgICB0b2dnbGVEcm9wZG93bkhhbmRsZXIoc2VsZiwgMSk7XG4gIH1cblxuICAvLyBEUk9QRE9XTiBQVUJMSUMgTUVUSE9EU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuICB0b2dnbGUocmVsYXRlZCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHsgb3BlbiB9ID0gc2VsZjtcblxuICAgIGlmIChvcGVuKSBzZWxmLmhpZGUocmVsYXRlZCk7XG4gICAgZWxzZSBzZWxmLnNob3cocmVsYXRlZCk7XG4gIH1cblxuICBzaG93KHJlbGF0ZWQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50UGFyZW50ID0gcXVlcnlFbGVtZW50KGRyb3Bkb3duTWVudUNsYXNzZXMubWFwKChjKSA9PiBgLiR7Y30uJHtzaG93Q2xhc3N9YCkuam9pbignLCcpKTtcbiAgICBjb25zdCBjdXJyZW50RWxlbWVudCA9IGN1cnJlbnRQYXJlbnQgJiYgcXVlcnlFbGVtZW50KGRyb3Bkb3duU2VsZWN0b3IsIGN1cnJlbnRQYXJlbnQpO1xuXG4gICAgaWYgKGN1cnJlbnRFbGVtZW50KSBjdXJyZW50RWxlbWVudFtkcm9wZG93bkNvbXBvbmVudF0uaGlkZSgpO1xuXG4gICAgY29uc3QgeyBlbGVtZW50LCBtZW51LCBvcGVuIH0gPSBzZWxmO1xuICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgIC8vIHVwZGF0ZSByZWxhdGVkVGFyZ2V0IGFuZCBkaXNwYXRjaFxuICAgIHNob3dEcm9wZG93bkV2ZW50LnJlbGF0ZWRUYXJnZXQgPSByZWxhdGVkIHx8IG51bGw7XG4gICAgcGFyZW50LmRpc3BhdGNoRXZlbnQoc2hvd0Ryb3Bkb3duRXZlbnQpO1xuICAgIGlmIChzaG93RHJvcGRvd25FdmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAvLyBjaGFuZ2UgbWVudSBwb3NpdGlvblxuICAgIHN0eWxlRHJvcGRvd24oc2VsZiwgMSk7XG5cbiAgICBhZGRDbGFzcyhtZW51LCBzaG93Q2xhc3MpO1xuICAgIGFkZENsYXNzKHBhcmVudCwgc2hvd0NsYXNzKTtcblxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGFyaWFFeHBhbmRlZCwgdHJ1ZSk7XG4gICAgc2VsZi5vcGVuID0gIW9wZW47XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldEZvY3VzKG1lbnUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0lOUFVUJylbMF0gfHwgZWxlbWVudCk7IC8vIGZvY3VzIHRoZSBmaXJzdCBpbnB1dCBpdGVtIHwgZWxlbWVudFxuICAgICAgdG9nZ2xlRHJvcGRvd25EaXNtaXNzKHNlbGYpO1xuXG4gICAgICBzaG93bkRyb3Bkb3duRXZlbnQucmVsYXRlZFRhcmdldCA9IHJlbGF0ZWQgfHwgbnVsbDtcbiAgICAgIHBhcmVudC5kaXNwYXRjaEV2ZW50KHNob3duRHJvcGRvd25FdmVudCk7XG4gICAgfSwgMSk7XG4gIH1cblxuICBoaWRlKHJlbGF0ZWQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCB7IGVsZW1lbnQsIG1lbnUsIG9wZW4gfSA9IHNlbGY7XG4gICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGhpZGVEcm9wZG93bkV2ZW50LnJlbGF0ZWRUYXJnZXQgPSByZWxhdGVkIHx8IG51bGw7XG4gICAgcGFyZW50LmRpc3BhdGNoRXZlbnQoaGlkZURyb3Bkb3duRXZlbnQpO1xuICAgIGlmIChoaWRlRHJvcGRvd25FdmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICByZW1vdmVDbGFzcyhtZW51LCBzaG93Q2xhc3MpO1xuICAgIHJlbW92ZUNsYXNzKHBhcmVudCwgc2hvd0NsYXNzKTtcblxuICAgIC8vIHJldmVydCB0byBvcmlnaW5hbCBwb3NpdGlvblxuICAgIHN0eWxlRHJvcGRvd24oc2VsZik7XG5cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhcmlhRXhwYW5kZWQsIGZhbHNlKTtcbiAgICBzZWxmLm9wZW4gPSAhb3BlbjtcblxuICAgIHNldEZvY3VzKGVsZW1lbnQpO1xuXG4gICAgLy8gb25seSByZS1hdHRhY2ggaGFuZGxlciBpZiB0aGUgaW5zdGFuY2UgaXMgbm90IGRpc3Bvc2VkXG4gICAgc2V0VGltZW91dCgoKSA9PiB0b2dnbGVEcm9wZG93bkRpc21pc3Moc2VsZiksIDEpO1xuXG4gICAgLy8gdXBkYXRlIHJlbGF0ZWRUYXJnZXQgYW5kIGRpc3BhdGNoXG4gICAgaGlkZGVuRHJvcGRvd25FdmVudC5yZWxhdGVkVGFyZ2V0ID0gcmVsYXRlZCB8fCBudWxsO1xuICAgIHBhcmVudC5kaXNwYXRjaEV2ZW50KGhpZGRlbkRyb3Bkb3duRXZlbnQpO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHNlbGY7XG5cbiAgICBpZiAoaGFzQ2xhc3MoZWxlbWVudC5wYXJlbnROb2RlLCBzaG93Q2xhc3MpICYmIHNlbGYub3Blbikgc2VsZi5oaWRlKCk7XG5cbiAgICB0b2dnbGVEcm9wZG93bkhhbmRsZXIoc2VsZik7XG5cbiAgICBzdXBlci5kaXNwb3NlKGRyb3Bkb3duQ29tcG9uZW50KTtcbiAgfVxufVxuXG5Ecm9wZG93bi5pbml0ID0ge1xuICBjb21wb25lbnQ6IGRyb3Bkb3duQ29tcG9uZW50LFxuICBzZWxlY3RvcjogZHJvcGRvd25TZWxlY3RvcixcbiAgY29uc3RydWN0b3I6IERyb3Bkb3duLFxufTtcblxuY29uc3QgYXJpYUhpZGRlbiA9ICdhcmlhLWhpZGRlbic7XG5cbmNvbnN0IGFyaWFNb2RhbCA9ICdhcmlhLW1vZGFsJztcblxuY29uc3QgZml4ZWRUb3BDbGFzcyA9ICdmaXhlZC10b3AnO1xuXG5jb25zdCBmaXhlZEJvdHRvbUNsYXNzID0gJ2ZpeGVkLWJvdHRvbSc7XG5cbmNvbnN0IHN0aWNreVRvcENsYXNzID0gJ3N0aWNreS10b3AnO1xuXG5jb25zdCBmaXhlZEl0ZW1zID0gQXJyYXkuZnJvbShkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGZpeGVkVG9wQ2xhc3MpKVxuICAuY29uY2F0KEFycmF5LmZyb20oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShmaXhlZEJvdHRvbUNsYXNzKSkpXG4gIC5jb25jYXQoQXJyYXkuZnJvbShkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHN0aWNreVRvcENsYXNzKSkpXG4gIC5jb25jYXQoQXJyYXkuZnJvbShkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdpcy1maXhlZCcpKSk7XG5cbmZ1bmN0aW9uIHJlc2V0U2Nyb2xsYmFyKCkge1xuICBjb25zdCBiZCA9IGRvY3VtZW50LmJvZHk7XG4gIGJkLnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICBiZC5zdHlsZS5vdmVyZmxvdyA9ICcnO1xuXG4gIGlmIChmaXhlZEl0ZW1zLmxlbmd0aCkge1xuICAgIGZpeGVkSXRlbXMuZm9yRWFjaCgoZml4ZWQpID0+IHtcbiAgICAgIGZpeGVkLnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICAgICAgZml4ZWQuc3R5bGUubWFyZ2luUmlnaHQgPSAnJztcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZWFzdXJlU2Nyb2xsYmFyKCkge1xuICBjb25zdCB3aW5kb3dXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5pbm5lcldpZHRoIC0gd2luZG93V2lkdGgpO1xufVxuXG5mdW5jdGlvbiBzZXRTY3JvbGxiYXIoc2Nyb2xsYmFyV2lkdGgsIG92ZXJmbG93LCBpc09wZW4pIHtcbiAgY29uc3QgYmQgPSBkb2N1bWVudC5ib2R5O1xuICBjb25zdCBib2R5UGFkID0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShiZCkucGFkZGluZ1JpZ2h0LCAxMCk7XG4gIGNvbnN0IHNiV2lkdGggPSBpc09wZW4gJiYgYm9keVBhZCA/IDAgOiBzY3JvbGxiYXJXaWR0aDtcblxuICBpZiAob3ZlcmZsb3cpIHtcbiAgICBiZC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHtib2R5UGFkICsgc2JXaWR0aH1weGA7XG5cbiAgICBpZiAoZml4ZWRJdGVtcy5sZW5ndGgpIHtcbiAgICAgIGZpeGVkSXRlbXMuZm9yRWFjaCgoZml4ZWQpID0+IHtcbiAgICAgICAgY29uc3QgaXNTdGlja3kgPSBoYXNDbGFzcyhmaXhlZCwgc3RpY2t5VG9wQ2xhc3MpO1xuICAgICAgICBjb25zdCBpdGVtUGFkVmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlKGZpeGVkKS5wYWRkaW5nUmlnaHQ7XG4gICAgICAgIGZpeGVkLnN0eWxlLnBhZGRpbmdSaWdodCA9IGAke3BhcnNlSW50KGl0ZW1QYWRWYWx1ZSwgMTApICsgc2JXaWR0aH1weGA7XG4gICAgICAgIGlmIChpc1N0aWNreSkge1xuICAgICAgICAgIGNvbnN0IGl0ZW1NVmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlKGZpeGVkKS5tYXJnaW5SaWdodDtcbiAgICAgICAgICBmaXhlZC5zdHlsZS5tYXJnaW5SaWdodCA9IGAke3BhcnNlSW50KGl0ZW1NVmFsdWUsIDEwKSAtIHNiV2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbW9kYWxPcGVuQ2xhc3MgPSAnbW9kYWwtb3Blbic7XG5jb25zdCBtb2RhbEJhY2tkcm9wQ2xhc3MgPSAnbW9kYWwtYmFja2Ryb3AnO1xuY29uc3QgbW9kYWxBY3RpdmVTZWxlY3RvciA9IGAubW9kYWwuJHtzaG93Q2xhc3N9YDtcbmNvbnN0IG9mZmNhbnZhc0FjdGl2ZVNlbGVjdG9yID0gYC5vZmZjYW52YXMuJHtzaG93Q2xhc3N9YDtcblxuY29uc3Qgb3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xub3ZlcmxheS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYCR7bW9kYWxCYWNrZHJvcENsYXNzfWApO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50T3BlbigpIHtcbiAgcmV0dXJuIHF1ZXJ5RWxlbWVudChgJHttb2RhbEFjdGl2ZVNlbGVjdG9yfSwke29mZmNhbnZhc0FjdGl2ZVNlbGVjdG9yfWApO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRPdmVybGF5KGhhc0ZhZGUpIHtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdmVybGF5KTtcbiAgaWYgKGhhc0ZhZGUpIGFkZENsYXNzKG92ZXJsYXksIGZhZGVDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIHNob3dPdmVybGF5KCkge1xuICBhZGRDbGFzcyhvdmVybGF5LCBzaG93Q2xhc3MpO1xuICByZWZsb3cob3ZlcmxheSk7XG59XG5cbmZ1bmN0aW9uIGhpZGVPdmVybGF5KCkge1xuICByZW1vdmVDbGFzcyhvdmVybGF5LCBzaG93Q2xhc3MpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVPdmVybGF5KCkge1xuICBjb25zdCBiZCA9IGRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IGN1cnJlbnRPcGVuID0gZ2V0Q3VycmVudE9wZW4oKTtcblxuICBpZiAoIWN1cnJlbnRPcGVuKSB7XG4gICAgcmVtb3ZlQ2xhc3Mob3ZlcmxheSwgZmFkZUNsYXNzKTtcbiAgICByZW1vdmVDbGFzcyhiZCwgbW9kYWxPcGVuQ2xhc3MpO1xuICAgIGJkLnJlbW92ZUNoaWxkKG92ZXJsYXkpO1xuICAgIHJlc2V0U2Nyb2xsYmFyKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWaXNpYmxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkudmlzaWJpbGl0eSAhPT0gJ2hpZGRlbidcbiAgICAmJiBlbGVtZW50Lm9mZnNldFBhcmVudCAhPT0gbnVsbDtcbn1cblxuLyogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCA1IHwgTW9kYWxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8vIE1PREFMIFBSSVZBVEUgR0Ncbi8vID09PT09PT09PT09PT09PT1cbmNvbnN0IG1vZGFsU3RyaW5nID0gJ21vZGFsJztcbmNvbnN0IG1vZGFsQ29tcG9uZW50ID0gJ01vZGFsJztcbmNvbnN0IG1vZGFsU2VsZWN0b3IgPSBgLiR7bW9kYWxTdHJpbmd9YDtcbi8vIGNvbnN0IG1vZGFsQWN0aXZlU2VsZWN0b3IgPSBgLiR7bW9kYWxTdHJpbmd9LiR7c2hvd0NsYXNzfWA7XG5jb25zdCBtb2RhbFRvZ2dsZVNlbGVjdG9yID0gYFske2RhdGFCc1RvZ2dsZX09XCIke21vZGFsU3RyaW5nfVwiXWA7XG5jb25zdCBtb2RhbERpc21pc3NTZWxlY3RvciA9IGBbJHtkYXRhQnNEaXNtaXNzfT1cIiR7bW9kYWxTdHJpbmd9XCJdYDtcbmNvbnN0IG1vZGFsU3RhdGljQ2xhc3MgPSBgJHttb2RhbFN0cmluZ30tc3RhdGljYDtcbmNvbnN0IG1vZGFsRGVmYXVsdE9wdGlvbnMgPSB7XG4gIGJhY2tkcm9wOiB0cnVlLCAvLyBib29sZWFufHN0cmluZ1xuICBrZXlib2FyZDogdHJ1ZSwgLy8gYm9vbGVhblxufTtcblxuLy8gTU9EQUwgQ1VTVE9NIEVWRU5UU1xuLy8gPT09PT09PT09PT09PT09PT09PVxuY29uc3Qgc2hvd01vZGFsRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudChgc2hvdy5icy4ke21vZGFsU3RyaW5nfWApO1xuY29uc3Qgc2hvd25Nb2RhbEV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoYHNob3duLmJzLiR7bW9kYWxTdHJpbmd9YCk7XG5jb25zdCBoaWRlTW9kYWxFdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KGBoaWRlLmJzLiR7bW9kYWxTdHJpbmd9YCk7XG5jb25zdCBoaWRkZW5Nb2RhbEV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoYGhpZGRlbi5icy4ke21vZGFsU3RyaW5nfWApO1xuXG4vLyBNT0RBTCBQUklWQVRFIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09PT09PT09PVxuZnVuY3Rpb24gc2V0TW9kYWxTY3JvbGxiYXIoc2VsZikge1xuICBjb25zdCB7IGVsZW1lbnQsIHNjcm9sbGJhcldpZHRoIH0gPSBzZWxmO1xuICBjb25zdCBiZCA9IGRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGNvbnN0IG9wZW5Nb2RhbCA9IGhhc0NsYXNzKGJkLCBtb2RhbE9wZW5DbGFzcyk7XG4gIGNvbnN0IGJvZHlPdmVyZmxvdyA9IGh0bWwuY2xpZW50SGVpZ2h0ICE9PSBodG1sLnNjcm9sbEhlaWdodFxuICAgICAgICAgICAgICAgICAgICB8fCBiZC5jbGllbnRIZWlnaHQgIT09IGJkLnNjcm9sbEhlaWdodDtcbiAgY29uc3QgbW9kYWxPdmVyZmxvdyA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0ICE9PSBlbGVtZW50LnNjcm9sbEhlaWdodDtcblxuICBpZiAoIW1vZGFsT3ZlcmZsb3cgJiYgc2Nyb2xsYmFyV2lkdGgpIHtcbiAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IGAke3Njcm9sbGJhcldpZHRofXB4YDtcbiAgfVxuICBzZXRTY3JvbGxiYXIoc2Nyb2xsYmFyV2lkdGgsIChtb2RhbE92ZXJmbG93IHx8IGJvZHlPdmVyZmxvdyksIG9wZW5Nb2RhbCk7XG59XG5cbmZ1bmN0aW9uIHRvZ2dsZU1vZGFsRGlzbWlzcyhzZWxmLCBhZGQpIHtcbiAgY29uc3QgYWN0aW9uID0gYWRkID8gYWRkRXZlbnRMaXN0ZW5lciA6IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gIHdpbmRvd1thY3Rpb25dKCdyZXNpemUnLCBzZWxmLnVwZGF0ZSwgcGFzc2l2ZUhhbmRsZXIpO1xuICBzZWxmLmVsZW1lbnRbYWN0aW9uXSgnY2xpY2snLCBtb2RhbERpc21pc3NIYW5kbGVyKTtcbiAgZG9jdW1lbnRbYWN0aW9uXSgna2V5ZG93bicsIG1vZGFsS2V5SGFuZGxlcik7XG59XG5cbmZ1bmN0aW9uIHRvZ2dsZU1vZGFsSGFuZGxlcihzZWxmLCBhZGQpIHtcbiAgY29uc3QgYWN0aW9uID0gYWRkID8gYWRkRXZlbnRMaXN0ZW5lciA6IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gIGNvbnN0IHsgdHJpZ2dlcnMgfSA9IHNlbGY7XG5cbiAgaWYgKHRyaWdnZXJzLmxlbmd0aCkge1xuICAgIHRyaWdnZXJzLmZvckVhY2goKGJ0bikgPT4gYnRuW2FjdGlvbl0oJ2NsaWNrJywgbW9kYWxDbGlja0hhbmRsZXIpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlck1vZGFsSGlkZShzZWxmKSB7XG4gIGNvbnN0IHsgdHJpZ2dlcnMgfSA9IHNlbGY7XG4gIHJlbW92ZU92ZXJsYXkoKTtcbiAgc2VsZi5lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICBzZWxmLmlzQW5pbWF0aW5nID0gZmFsc2U7XG5cbiAgaWYgKHRyaWdnZXJzLmxlbmd0aCkge1xuICAgIGNvbnN0IHZpc2libGVUcmlnZ2VyID0gdHJpZ2dlcnMuZmluZCgoeCkgPT4gaXNWaXNpYmxlKHgpKTtcbiAgICBpZiAodmlzaWJsZVRyaWdnZXIpIHNldEZvY3VzKHZpc2libGVUcmlnZ2VyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlck1vZGFsU2hvdyhzZWxmKSB7XG4gIGNvbnN0IHsgZWxlbWVudCwgcmVsYXRlZFRhcmdldCB9ID0gc2VsZjtcbiAgc2V0Rm9jdXMoZWxlbWVudCk7XG4gIHNlbGYuaXNBbmltYXRpbmcgPSBmYWxzZTtcblxuICB0b2dnbGVNb2RhbERpc21pc3Moc2VsZiwgMSk7XG5cbiAgc2hvd25Nb2RhbEV2ZW50LnJlbGF0ZWRUYXJnZXQgPSByZWxhdGVkVGFyZ2V0O1xuICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoc2hvd25Nb2RhbEV2ZW50KTtcbn1cblxuZnVuY3Rpb24gYmVmb3JlTW9kYWxTaG93KHNlbGYpIHtcbiAgY29uc3QgeyBlbGVtZW50LCBoYXNGYWRlIH0gPSBzZWxmO1xuICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gIHNldE1vZGFsU2Nyb2xsYmFyKHNlbGYpO1xuICBpZiAoIXF1ZXJ5RWxlbWVudChtb2RhbEFjdGl2ZVNlbGVjdG9yKSkge1xuICAgIGFkZENsYXNzKGRvY3VtZW50LmJvZHksIG1vZGFsT3BlbkNsYXNzKTtcbiAgfVxuXG4gIGFkZENsYXNzKGVsZW1lbnQsIHNob3dDbGFzcyk7XG4gIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGFyaWFIaWRkZW4pO1xuICBlbGVtZW50LnNldEF0dHJpYnV0ZShhcmlhTW9kYWwsIHRydWUpO1xuXG4gIGlmIChoYXNGYWRlKSBlbXVsYXRlVHJhbnNpdGlvbkVuZChlbGVtZW50LCAoKSA9PiBhZnRlck1vZGFsU2hvdyhzZWxmKSk7XG4gIGVsc2UgYWZ0ZXJNb2RhbFNob3coc2VsZik7XG59XG5cbmZ1bmN0aW9uIGJlZm9yZU1vZGFsSGlkZShzZWxmLCBmb3JjZSkge1xuICBjb25zdCB7XG4gICAgZWxlbWVudCwgcmVsYXRlZFRhcmdldCwgaGFzRmFkZSxcbiAgfSA9IHNlbGY7XG4gIGNvbnN0IGN1cnJlbnRPcGVuID0gZ2V0Q3VycmVudE9wZW4oKTtcblxuICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAvLyBmb3JjZSBjYW4gYWxzbyBiZSB0aGUgdHJhbnNpdGlvbkV2ZW50IG9iamVjdCwgd2Ugd2FubmEgbWFrZSBzdXJlIGl0J3Mgbm90XG4gIC8vIGNhbGwgaXMgbm90IGZvcmNlZCBhbmQgb3ZlcmxheSBpcyB2aXNpYmxlXG4gIGlmICghZm9yY2UgJiYgaGFzRmFkZSAmJiBoYXNDbGFzcyhvdmVybGF5LCBzaG93Q2xhc3MpXG4gICAgJiYgIWN1cnJlbnRPcGVuKSB7IC8vIEFORCBubyBtb2RhbCBpcyB2aXNpYmxlXG4gICAgaGlkZU92ZXJsYXkoKTtcbiAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZChvdmVybGF5LCAoKSA9PiBhZnRlck1vZGFsSGlkZShzZWxmKSk7XG4gIH0gZWxzZSB7XG4gICAgYWZ0ZXJNb2RhbEhpZGUoc2VsZik7XG4gIH1cblxuICB0b2dnbGVNb2RhbERpc21pc3Moc2VsZik7XG5cbiAgaGlkZGVuTW9kYWxFdmVudC5yZWxhdGVkVGFyZ2V0ID0gcmVsYXRlZFRhcmdldDtcbiAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGhpZGRlbk1vZGFsRXZlbnQpO1xufVxuXG4vLyBNT0RBTCBFVkVOVCBIQU5ETEVSU1xuLy8gPT09PT09PT09PT09PT09PT09PT1cbmZ1bmN0aW9uIG1vZGFsQ2xpY2tIYW5kbGVyKGUpIHtcbiAgY29uc3QgeyB0YXJnZXQgfSA9IGU7XG4gIGNvbnN0IHRyaWdnZXIgPSB0YXJnZXQuY2xvc2VzdChtb2RhbFRvZ2dsZVNlbGVjdG9yKTtcbiAgY29uc3QgZWxlbWVudCA9IGdldFRhcmdldEVsZW1lbnQodHJpZ2dlcik7XG4gIGNvbnN0IHNlbGYgPSBlbGVtZW50ICYmIGVsZW1lbnRbbW9kYWxDb21wb25lbnRdO1xuXG4gIGlmICh0cmlnZ2VyLnRhZ05hbWUgPT09ICdBJykgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIGlmIChzZWxmLmlzQW5pbWF0aW5nKSByZXR1cm47XG5cbiAgc2VsZi5yZWxhdGVkVGFyZ2V0ID0gdHJpZ2dlcjtcblxuICBzZWxmLnRvZ2dsZSgpO1xufVxuXG5mdW5jdGlvbiBtb2RhbEtleUhhbmRsZXIoeyB3aGljaCB9KSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQobW9kYWxBY3RpdmVTZWxlY3Rvcik7XG4gIGNvbnN0IHNlbGYgPSBlbGVtZW50W21vZGFsQ29tcG9uZW50XTtcbiAgY29uc3QgeyBvcHRpb25zLCBpc0FuaW1hdGluZyB9ID0gc2VsZjtcbiAgaWYgKCFpc0FuaW1hdGluZyAvLyBtb2RhbCBoYXMgbm8gYW5pbWF0aW9ucyBydW5uaW5nXG4gICAgJiYgb3B0aW9ucy5rZXlib2FyZCAmJiB3aGljaCA9PT0gMjcgLy8gdGhlIGtleWJvYXJkIG9wdGlvbiBpcyBlbmFibGVkIGFuZCB0aGUga2V5IGlzIDI3XG4gICAgJiYgaGFzQ2xhc3MoZWxlbWVudCwgc2hvd0NsYXNzKSkgeyAvLyB0aGUgbW9kYWwgaXMgbm90IHZpc2libGVcbiAgICBzZWxmLnJlbGF0ZWRUYXJnZXQgPSBudWxsO1xuICAgIHNlbGYuaGlkZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vZGFsRGlzbWlzc0hhbmRsZXIoZSkge1xuICBjb25zdCBlbGVtZW50ID0gdGhpcztcbiAgY29uc3Qgc2VsZiA9IGVsZW1lbnRbbW9kYWxDb21wb25lbnRdO1xuXG4gIGlmIChzZWxmLmlzQW5pbWF0aW5nKSByZXR1cm47XG5cbiAgY29uc3QgeyBpc1N0YXRpYywgbW9kYWxEaWFsb2cgfSA9IHNlbGY7XG4gIGNvbnN0IHsgdGFyZ2V0IH0gPSBlO1xuICBjb25zdCBzZWxlY3RlZFRleHQgPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpLmxlbmd0aDtcbiAgY29uc3QgdGFyZ2V0SW5zaWRlRGlhbG9nID0gbW9kYWxEaWFsb2cuY29udGFpbnModGFyZ2V0KTtcbiAgY29uc3QgZGlzbWlzcyA9IHRhcmdldC5jbG9zZXN0KG1vZGFsRGlzbWlzc1NlbGVjdG9yKTtcblxuICBpZiAoaXNTdGF0aWMgJiYgIXRhcmdldEluc2lkZURpYWxvZykge1xuICAgIGFkZENsYXNzKGVsZW1lbnQsIG1vZGFsU3RhdGljQ2xhc3MpO1xuICAgIHNlbGYuaXNBbmltYXRpbmcgPSB0cnVlO1xuICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKG1vZGFsRGlhbG9nLCAoKSA9PiBzdGF0aWNUcmFuc2l0aW9uRW5kKHNlbGYpKTtcbiAgfSBlbHNlIGlmIChkaXNtaXNzIHx8ICghc2VsZWN0ZWRUZXh0ICYmICFpc1N0YXRpYyAmJiAhdGFyZ2V0SW5zaWRlRGlhbG9nKSkge1xuICAgIHNlbGYucmVsYXRlZFRhcmdldCA9IGRpc21pc3MgfHwgbnVsbDtcbiAgICBzZWxmLmhpZGUoKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhdGljVHJhbnNpdGlvbkVuZChzZWxmKSB7XG4gIGNvbnN0IGR1cmF0aW9uID0gZ2V0RWxlbWVudFRyYW5zaXRpb25EdXJhdGlvbihzZWxmLm1vZGFsRGlhbG9nKSArIDE3O1xuICByZW1vdmVDbGFzcyhzZWxmLmVsZW1lbnQsIG1vZGFsU3RhdGljQ2xhc3MpO1xuICAvLyB1c2VyIG11c3Qgd2FpdCBmb3Igem9vbSBvdXQgdHJhbnNpdGlvblxuICBzZXRUaW1lb3V0KCgpID0+IHsgc2VsZi5pc0FuaW1hdGluZyA9IGZhbHNlOyB9LCBkdXJhdGlvbik7XG59XG5cbi8vIE1PREFMIERFRklOSVRJT05cbi8vID09PT09PT09PT09PT09PT1cbmNsYXNzIE1vZGFsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHRhcmdldCwgY29uZmlnKSB7XG4gICAgc3VwZXIobW9kYWxDb21wb25lbnQsIHRhcmdldCwgbW9kYWxEZWZhdWx0T3B0aW9ucywgY29uZmlnKTtcblxuICAgIC8vIGJpbmRcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIHRoZSBtb2RhbFxuICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gc2VsZjtcblxuICAgIC8vIHRoZSBtb2RhbC1kaWFsb2dcbiAgICBzZWxmLm1vZGFsRGlhbG9nID0gcXVlcnlFbGVtZW50KGAuJHttb2RhbFN0cmluZ30tZGlhbG9nYCwgZWxlbWVudCk7XG5cbiAgICAvLyBtb2RhbCBjYW4gaGF2ZSBtdWx0aXBsZSB0cmlnZ2VyaW5nIGVsZW1lbnRzXG4gICAgc2VsZi50cmlnZ2VycyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChtb2RhbFRvZ2dsZVNlbGVjdG9yKSlcbiAgICAgIC5maWx0ZXIoKGJ0bikgPT4gZ2V0VGFyZ2V0RWxlbWVudChidG4pID09PSBlbGVtZW50KTtcblxuICAgIC8vIGFkZGl0aW9uYWwgaW50ZXJuYWxzXG4gICAgc2VsZi5pc1N0YXRpYyA9IHNlbGYub3B0aW9ucy5iYWNrZHJvcCA9PT0gJ3N0YXRpYyc7XG4gICAgc2VsZi5oYXNGYWRlID0gaGFzQ2xhc3MoZWxlbWVudCwgZmFkZUNsYXNzKTtcbiAgICBzZWxmLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgc2VsZi5zY3JvbGxiYXJXaWR0aCA9IG1lYXN1cmVTY3JvbGxiYXIoKTtcbiAgICBzZWxmLnJlbGF0ZWRUYXJnZXQgPSBudWxsO1xuXG4gICAgLy8gYXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRvZ2dsZU1vZGFsSGFuZGxlcihzZWxmLCAxKTtcblxuICAgIC8vIGJpbmRcbiAgICBzZWxmLnVwZGF0ZSA9IHNlbGYudXBkYXRlLmJpbmQoc2VsZik7XG4gIH1cblxuICAvLyBNT0RBTCBQVUJMSUMgTUVUSE9EU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PVxuICB0b2dnbGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGhhc0NsYXNzKHNlbGYuZWxlbWVudCwgc2hvd0NsYXNzKSkgc2VsZi5oaWRlKCk7XG4gICAgZWxzZSBzZWxmLnNob3coKTtcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudCwgaXNBbmltYXRpbmcsIGhhc0ZhZGUsIHJlbGF0ZWRUYXJnZXQsXG4gICAgfSA9IHNlbGY7XG4gICAgbGV0IG92ZXJsYXlEZWxheSA9IDA7XG5cbiAgICBpZiAoaGFzQ2xhc3MoZWxlbWVudCwgc2hvd0NsYXNzKSAmJiAhaXNBbmltYXRpbmcpIHJldHVybjtcblxuICAgIHNob3dNb2RhbEV2ZW50LnJlbGF0ZWRUYXJnZXQgPSByZWxhdGVkVGFyZ2V0IHx8IG51bGw7XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHNob3dNb2RhbEV2ZW50KTtcbiAgICBpZiAoc2hvd01vZGFsRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gICAgc2VsZi5pc0FuaW1hdGluZyA9IHRydWU7XG5cbiAgICAvLyB3ZSBlbGVnYW50bHkgaGlkZSBhbnkgb3BlbmVkIG1vZGFsL29mZmNhbnZhc1xuICAgIGNvbnN0IGN1cnJlbnRPcGVuID0gZ2V0Q3VycmVudE9wZW4oKTtcbiAgICBpZiAoY3VycmVudE9wZW4gJiYgY3VycmVudE9wZW4gIT09IGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHRoYXQgPSBjdXJyZW50T3Blblttb2RhbENvbXBvbmVudF1cbiAgICAgICAgPyBjdXJyZW50T3Blblttb2RhbENvbXBvbmVudF1cbiAgICAgICAgOiBjdXJyZW50T3Blbi5PZmZjYW52YXM7XG4gICAgICB0aGF0LmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXF1ZXJ5RWxlbWVudChgLiR7bW9kYWxCYWNrZHJvcENsYXNzfWApKSB7XG4gICAgICBhcHBlbmRPdmVybGF5KGhhc0ZhZGUpO1xuICAgIH1cbiAgICBvdmVybGF5RGVsYXkgPSBnZXRFbGVtZW50VHJhbnNpdGlvbkR1cmF0aW9uKG92ZXJsYXkpO1xuXG4gICAgaWYgKCFoYXNDbGFzcyhvdmVybGF5LCBzaG93Q2xhc3MpKSB7XG4gICAgICBzaG93T3ZlcmxheSgpO1xuICAgIH1cblxuICAgIGlmICghY3VycmVudE9wZW4pIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gYmVmb3JlTW9kYWxTaG93KHNlbGYpLCBvdmVybGF5RGVsYXkpO1xuICAgIH0gZWxzZSBiZWZvcmVNb2RhbFNob3coc2VsZik7XG4gIH1cblxuICBoaWRlKGZvcmNlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudCwgaXNBbmltYXRpbmcsIGhhc0ZhZGUsIHJlbGF0ZWRUYXJnZXQsXG4gICAgfSA9IHNlbGY7XG4gICAgaWYgKCFoYXNDbGFzcyhlbGVtZW50LCBzaG93Q2xhc3MpICYmICFpc0FuaW1hdGluZykgcmV0dXJuO1xuXG4gICAgaGlkZU1vZGFsRXZlbnQucmVsYXRlZFRhcmdldCA9IHJlbGF0ZWRUYXJnZXQgfHwgbnVsbDtcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoaGlkZU1vZGFsRXZlbnQpO1xuICAgIGlmIChoaWRlTW9kYWxFdmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICBzZWxmLmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBzaG93Q2xhc3MpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGFyaWFIaWRkZW4sIHRydWUpO1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGFyaWFNb2RhbCk7XG5cbiAgICBpZiAoaGFzRmFkZSAmJiBmb3JjZSAhPT0gMSkge1xuICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoZWxlbWVudCwgKCkgPT4gYmVmb3JlTW9kYWxIaWRlKHNlbGYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmVmb3JlTW9kYWxIaWRlKHNlbGYsIGZvcmNlKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoaGFzQ2xhc3Moc2VsZi5lbGVtZW50LCBzaG93Q2xhc3MpKSBzZXRNb2RhbFNjcm9sbGJhcihzZWxmKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5oaWRlKDEpOyAvLyBmb3JjZWQgY2FsbFxuXG4gICAgdG9nZ2xlTW9kYWxIYW5kbGVyKHNlbGYpO1xuXG4gICAgc3VwZXIuZGlzcG9zZShtb2RhbENvbXBvbmVudCk7XG4gIH1cbn1cblxuTW9kYWwuaW5pdCA9IHtcbiAgY29tcG9uZW50OiBtb2RhbENvbXBvbmVudCxcbiAgc2VsZWN0b3I6IG1vZGFsU2VsZWN0b3IsXG4gIGNvbnN0cnVjdG9yOiBNb2RhbCxcbn07XG5cbi8qIE5hdGl2ZSBKYXZhU2NyaXB0IGZvciBCb290c3RyYXAgNSB8IE9mZkNhbnZhc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8vIE9GRkNBTlZBUyBQUklWQVRFIEdDXG4vLyA9PT09PT09PT09PT09PT09PT09PVxuY29uc3Qgb2ZmY2FudmFzU3RyaW5nID0gJ29mZmNhbnZhcyc7XG5jb25zdCBvZmZjYW52YXNDb21wb25lbnQgPSAnT2ZmY2FudmFzJztcbmNvbnN0IE9mZmNhbnZhc1NlbGVjdG9yID0gYC4ke29mZmNhbnZhc1N0cmluZ31gO1xuY29uc3Qgb2ZmY2FudmFzVG9nZ2xlU2VsZWN0b3IgPSBgWyR7ZGF0YUJzVG9nZ2xlfT1cIiR7b2ZmY2FudmFzU3RyaW5nfVwiXWA7XG5jb25zdCBvZmZjYW52YXNEaXNtaXNzU2VsZWN0b3IgPSBgWyR7ZGF0YUJzRGlzbWlzc309XCIke29mZmNhbnZhc1N0cmluZ31cIl1gO1xuY29uc3Qgb2ZmY2FudmFzVG9nZ2xpbmdDbGFzcyA9IGAke29mZmNhbnZhc1N0cmluZ30tdG9nZ2xpbmdgO1xuY29uc3Qgb2ZmY2FudmFzRGVmYXVsdE9wdGlvbnMgPSB7XG4gIGJhY2tkcm9wOiB0cnVlLCAvLyBib29sZWFuXG4gIGtleWJvYXJkOiB0cnVlLCAvLyBib29sZWFuXG4gIHNjcm9sbDogZmFsc2UsIC8vIGJvb2xlYW5cbn07XG5cbi8vIE9GRkNBTlZBUyBDVVNUT00gRVZFTlRTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3Qgc2hvd09mZmNhbnZhc0V2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoYHNob3cuYnMuJHtvZmZjYW52YXNTdHJpbmd9YCk7XG5jb25zdCBzaG93bk9mZmNhbnZhc0V2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoYHNob3duLmJzLiR7b2ZmY2FudmFzU3RyaW5nfWApO1xuY29uc3QgaGlkZU9mZmNhbnZhc0V2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoYGhpZGUuYnMuJHtvZmZjYW52YXNTdHJpbmd9YCk7XG5jb25zdCBoaWRkZW5PZmZjYW52YXNFdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KGBoaWRkZW4uYnMuJHtvZmZjYW52YXNTdHJpbmd9YCk7XG5cbi8vIE9GRkNBTlZBUyBQUklWQVRFIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT1cbmZ1bmN0aW9uIHNldE9mZkNhbnZhc1Njcm9sbGJhcihzZWxmKSB7XG4gIGNvbnN0IGJkID0gZG9jdW1lbnQuYm9keTtcbiAgY29uc3QgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgY29uc3Qgb3Blbk9mZkNhbnZhcyA9IGhhc0NsYXNzKGJkLCBtb2RhbE9wZW5DbGFzcyk7XG4gIGNvbnN0IGJvZHlPdmVyZmxvdyA9IGh0bWwuY2xpZW50SGVpZ2h0ICE9PSBodG1sLnNjcm9sbEhlaWdodFxuICAgICAgICAgICAgICAgICAgICB8fCBiZC5jbGllbnRIZWlnaHQgIT09IGJkLnNjcm9sbEhlaWdodDtcbiAgc2V0U2Nyb2xsYmFyKHNlbGYuc2Nyb2xsYmFyV2lkdGgsIGJvZHlPdmVyZmxvdywgb3Blbk9mZkNhbnZhcyk7XG59XG5cbmZ1bmN0aW9uIHRvZ2dsZU9mZmNhbnZhc0V2ZW50cyhzZWxmLCBhZGQpIHtcbiAgY29uc3QgYWN0aW9uID0gYWRkID8gYWRkRXZlbnRMaXN0ZW5lciA6IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gIHNlbGYudHJpZ2dlcnMuZm9yRWFjaCgoYnRuKSA9PiBidG5bYWN0aW9uXSgnY2xpY2snLCBvZmZjYW52YXNUcmlnZ2VySGFuZGxlcikpO1xufVxuXG5mdW5jdGlvbiB0b2dnbGVPZmZDYW52YXNEaXNtaXNzKGFkZCkge1xuICBjb25zdCBhY3Rpb24gPSBhZGQgPyBhZGRFdmVudExpc3RlbmVyIDogcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgZG9jdW1lbnRbYWN0aW9uXSgna2V5ZG93bicsIG9mZmNhbnZhc0tleURpc21pc3NIYW5kbGVyKTtcbiAgZG9jdW1lbnRbYWN0aW9uXSgnY2xpY2snLCBvZmZjYW52YXNEaXNtaXNzSGFuZGxlcik7XG59XG5cbmZ1bmN0aW9uIGJlZm9yZU9mZmNhbnZhc1Nob3coc2VsZikge1xuICBjb25zdCB7IGVsZW1lbnQsIG9wdGlvbnMgfSA9IHNlbGY7XG5cbiAgaWYgKCFvcHRpb25zLnNjcm9sbCkge1xuICAgIGFkZENsYXNzKGRvY3VtZW50LmJvZHksIG1vZGFsT3BlbkNsYXNzKTtcbiAgICBzZXRPZmZDYW52YXNTY3JvbGxiYXIoc2VsZik7XG4gIH1cblxuICBhZGRDbGFzcyhlbGVtZW50LCBvZmZjYW52YXNUb2dnbGluZ0NsYXNzKTtcbiAgYWRkQ2xhc3MoZWxlbWVudCwgc2hvd0NsYXNzKTtcbiAgZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuXG4gIGVtdWxhdGVUcmFuc2l0aW9uRW5kKGVsZW1lbnQsICgpID0+IHNob3dPZmZjYW52YXNDb21wbGV0ZShzZWxmKSk7XG59XG5cbmZ1bmN0aW9uIGJlZm9yZU9mZmNhbnZhc0hpZGUoc2VsZikge1xuICBjb25zdCB7IGVsZW1lbnQsIG9wdGlvbnMgfSA9IHNlbGY7XG4gIGNvbnN0IGN1cnJlbnRPcGVuID0gZ2V0Q3VycmVudE9wZW4oKTtcblxuICBlbGVtZW50LmJsdXIoKTtcblxuICBpZiAoIWN1cnJlbnRPcGVuICYmIG9wdGlvbnMuYmFja2Ryb3AgJiYgaGFzQ2xhc3Mob3ZlcmxheSwgc2hvd0NsYXNzKSkge1xuICAgIGhpZGVPdmVybGF5KCk7XG4gICAgZW11bGF0ZVRyYW5zaXRpb25FbmQob3ZlcmxheSwgKCkgPT4gaGlkZU9mZmNhbnZhc0NvbXBsZXRlKHNlbGYpKTtcbiAgfSBlbHNlIGhpZGVPZmZjYW52YXNDb21wbGV0ZShzZWxmKTtcbn1cblxuLy8gT0ZGQ0FOVkFTIEVWRU5UIEhBTkRMRVJTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT1cbmZ1bmN0aW9uIG9mZmNhbnZhc1RyaWdnZXJIYW5kbGVyKGUpIHtcbiAgY29uc3QgdHJpZ2dlciA9IHRoaXMuY2xvc2VzdChvZmZjYW52YXNUb2dnbGVTZWxlY3Rvcik7XG4gIGNvbnN0IGVsZW1lbnQgPSBnZXRUYXJnZXRFbGVtZW50KHRyaWdnZXIpO1xuICBjb25zdCBzZWxmID0gZWxlbWVudCAmJiBlbGVtZW50W29mZmNhbnZhc0NvbXBvbmVudF07XG5cbiAgaWYgKHRyaWdnZXIudGFnTmFtZSA9PT0gJ0EnKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gIGlmIChzZWxmKSB7XG4gICAgc2VsZi5yZWxhdGVkVGFyZ2V0ID0gdHJpZ2dlcjtcbiAgICBzZWxmLnRvZ2dsZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9mZmNhbnZhc0Rpc21pc3NIYW5kbGVyKGUpIHtcbiAgY29uc3QgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChvZmZjYW52YXNBY3RpdmVTZWxlY3Rvcik7XG4gIGlmICghZWxlbWVudCkgcmV0dXJuO1xuXG4gIGNvbnN0IG9mZkNhbnZhc0Rpc21pc3MgPSBxdWVyeUVsZW1lbnQob2ZmY2FudmFzRGlzbWlzc1NlbGVjdG9yLCBlbGVtZW50KTtcbiAgY29uc3Qgc2VsZiA9IGVsZW1lbnRbb2ZmY2FudmFzQ29tcG9uZW50XTtcbiAgaWYgKCFzZWxmKSByZXR1cm47XG5cbiAgY29uc3QgeyBvcHRpb25zLCBvcGVuLCB0cmlnZ2VycyB9ID0gc2VsZjtcbiAgY29uc3QgeyB0YXJnZXQgfSA9IGU7XG4gIGNvbnN0IHRyaWdnZXIgPSB0YXJnZXQuY2xvc2VzdChvZmZjYW52YXNUb2dnbGVTZWxlY3Rvcik7XG5cbiAgaWYgKHRyaWdnZXIgJiYgdHJpZ2dlci50YWdOYW1lID09PSAnQScpIGUucHJldmVudERlZmF1bHQoKTtcblxuICBpZiAob3BlbiAmJiAoKCFlbGVtZW50LmNvbnRhaW5zKHRhcmdldCkgJiYgb3B0aW9ucy5iYWNrZHJvcFxuICAgICYmICghdHJpZ2dlciB8fCAodHJpZ2dlciAmJiAhdHJpZ2dlcnMuaW5jbHVkZXModHJpZ2dlcikpKSlcbiAgICB8fCBvZmZDYW52YXNEaXNtaXNzLmNvbnRhaW5zKHRhcmdldCkpKSB7XG4gICAgc2VsZi5yZWxhdGVkVGFyZ2V0ID0gdGFyZ2V0ID09PSBvZmZDYW52YXNEaXNtaXNzID8gb2ZmQ2FudmFzRGlzbWlzcyA6IG51bGw7XG4gICAgc2VsZi5oaWRlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb2ZmY2FudmFzS2V5RGlzbWlzc0hhbmRsZXIoeyB3aGljaCB9KSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQob2ZmY2FudmFzQWN0aXZlU2VsZWN0b3IpO1xuICBpZiAoIWVsZW1lbnQpIHJldHVybjtcblxuICBjb25zdCBzZWxmID0gZWxlbWVudFtvZmZjYW52YXNDb21wb25lbnRdO1xuXG4gIGlmIChzZWxmICYmIHNlbGYub3B0aW9ucy5rZXlib2FyZCAmJiB3aGljaCA9PT0gMjcpIHtcbiAgICBzZWxmLnJlbGF0ZWRUYXJnZXQgPSBudWxsO1xuICAgIHNlbGYuaGlkZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3dPZmZjYW52YXNDb21wbGV0ZShzZWxmKSB7XG4gIGNvbnN0IHsgZWxlbWVudCwgdHJpZ2dlcnMsIHJlbGF0ZWRUYXJnZXQgfSA9IHNlbGY7XG4gIHJlbW92ZUNsYXNzKGVsZW1lbnQsIG9mZmNhbnZhc1RvZ2dsaW5nQ2xhc3MpO1xuXG4gIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGFyaWFIaWRkZW4pO1xuICBlbGVtZW50LnNldEF0dHJpYnV0ZShhcmlhTW9kYWwsIHRydWUpO1xuICBlbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcbiAgc2VsZi5pc0FuaW1hdGluZyA9IGZhbHNlO1xuXG4gIGlmICh0cmlnZ2Vycy5sZW5ndGgpIHtcbiAgICB0cmlnZ2Vycy5mb3JFYWNoKChidG4pID0+IGJ0bi5zZXRBdHRyaWJ1dGUoYXJpYUV4cGFuZGVkLCB0cnVlKSk7XG4gIH1cblxuICBzaG93bk9mZmNhbnZhc0V2ZW50LnJlbGF0ZWRUYXJnZXQgPSByZWxhdGVkVGFyZ2V0IHx8IG51bGw7XG4gIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChzaG93bk9mZmNhbnZhc0V2ZW50KTtcblxuICB0b2dnbGVPZmZDYW52YXNEaXNtaXNzKDEpO1xuICBzZXRGb2N1cyhlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gaGlkZU9mZmNhbnZhc0NvbXBsZXRlKHNlbGYpIHtcbiAgY29uc3Qge1xuICAgIGVsZW1lbnQsIG9wdGlvbnMsIHJlbGF0ZWRUYXJnZXQsIHRyaWdnZXJzLFxuICB9ID0gc2VsZjtcbiAgY29uc3QgY3VycmVudE9wZW4gPSBnZXRDdXJyZW50T3BlbigpO1xuXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKGFyaWFIaWRkZW4sIHRydWUpO1xuICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhcmlhTW9kYWwpO1xuICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuICBlbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgc2VsZi5vcGVuID0gZmFsc2U7XG4gIHNlbGYuaXNBbmltYXRpbmcgPSBmYWxzZTtcblxuICBpZiAodHJpZ2dlcnMubGVuZ3RoKSB7XG4gICAgdHJpZ2dlcnMuZm9yRWFjaCgoYnRuKSA9PiBidG4uc2V0QXR0cmlidXRlKGFyaWFFeHBhbmRlZCwgZmFsc2UpKTtcbiAgICBjb25zdCB2aXNpYmxlVHJpZ2dlciA9IHRyaWdnZXJzLmZpbmQoKHgpID0+IGlzVmlzaWJsZSh4KSk7XG4gICAgaWYgKHZpc2libGVUcmlnZ2VyKSBzZXRGb2N1cyh2aXNpYmxlVHJpZ2dlcik7XG4gIH1cblxuICAvLyBoYW5kbGUgbmV3IG9mZmNhbnZhcyBzaG93aW5nIHVwXG4gIGlmICghY3VycmVudE9wZW4pIHtcbiAgICBpZiAob3B0aW9ucy5iYWNrZHJvcCkgcmVtb3ZlT3ZlcmxheSgpO1xuICAgIGlmICghb3B0aW9ucy5zY3JvbGwpIHtcbiAgICAgIHJlc2V0U2Nyb2xsYmFyKCk7XG4gICAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCBtb2RhbE9wZW5DbGFzcyk7XG4gICAgfVxuICB9XG5cbiAgaGlkZGVuT2ZmY2FudmFzRXZlbnQucmVsYXRlZFRhcmdldCA9IHJlbGF0ZWRUYXJnZXQgfHwgbnVsbDtcbiAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGhpZGRlbk9mZmNhbnZhc0V2ZW50KTtcbiAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgb2ZmY2FudmFzVG9nZ2xpbmdDbGFzcyk7XG5cbiAgdG9nZ2xlT2ZmQ2FudmFzRGlzbWlzcygpO1xufVxuXG4vLyBPRkZDQU5WQVMgREVGSU5JVElPTlxuLy8gPT09PT09PT09PT09PT09PT09PT1cbmNsYXNzIE9mZmNhbnZhcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNvbmZpZykge1xuICAgIHN1cGVyKG9mZmNhbnZhc0NvbXBvbmVudCwgdGFyZ2V0LCBvZmZjYW52YXNEZWZhdWx0T3B0aW9ucywgY29uZmlnKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIGluc3RhbmNlIGVsZW1lbnRcbiAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHNlbGY7XG5cbiAgICAvLyBhbGwgdGhlIHRyaWdnZXJpbmcgYnV0dG9uc1xuICAgIHNlbGYudHJpZ2dlcnMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwob2ZmY2FudmFzVG9nZ2xlU2VsZWN0b3IpKVxuICAgICAgLmZpbHRlcigoYnRuKSA9PiBnZXRUYXJnZXRFbGVtZW50KGJ0bikgPT09IGVsZW1lbnQpO1xuXG4gICAgLy8gYWRkaXRpb25hbCBpbnN0YW5jZSBwcm9wZXJ0eVxuICAgIHNlbGYub3BlbiA9IGZhbHNlO1xuICAgIHNlbGYuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICBzZWxmLnNjcm9sbGJhcldpZHRoID0gbWVhc3VyZVNjcm9sbGJhcigpO1xuXG4gICAgLy8gYXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRvZ2dsZU9mZmNhbnZhc0V2ZW50cyhzZWxmLCAxKTtcbiAgfVxuXG4gIC8vIE9GRkNBTlZBUyBQVUJMSUMgTUVUSE9EU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT1cbiAgdG9nZ2xlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBzZWxmLm9wZW4gPyBzZWxmLmhpZGUoKSA6IHNlbGYuc2hvdygpO1xuICB9XG5cbiAgc2hvdygpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1tvZmZjYW52YXNDb21wb25lbnRdID8gdGhpc1tvZmZjYW52YXNDb21wb25lbnRdIDogdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50LCBvcHRpb25zLCBpc0FuaW1hdGluZywgcmVsYXRlZFRhcmdldCxcbiAgICB9ID0gc2VsZjtcbiAgICBsZXQgb3ZlcmxheURlbGF5ID0gMDtcblxuICAgIGlmIChzZWxmLm9wZW4gfHwgaXNBbmltYXRpbmcpIHJldHVybjtcblxuICAgIHNob3dPZmZjYW52YXNFdmVudC5yZWxhdGVkVGFyZ2V0ID0gcmVsYXRlZFRhcmdldCB8fCBudWxsO1xuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChzaG93T2ZmY2FudmFzRXZlbnQpO1xuXG4gICAgaWYgKHNob3dPZmZjYW52YXNFdmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAvLyB3ZSBlbGVnYW50bHkgaGlkZSBhbnkgb3BlbmVkIG1vZGFsL29mZmNhbnZhc1xuICAgIGNvbnN0IGN1cnJlbnRPcGVuID0gZ2V0Q3VycmVudE9wZW4oKTtcbiAgICBpZiAoY3VycmVudE9wZW4gJiYgY3VycmVudE9wZW4gIT09IGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHRoYXQgPSBjdXJyZW50T3BlbltvZmZjYW52YXNDb21wb25lbnRdXG4gICAgICAgID8gY3VycmVudE9wZW5bb2ZmY2FudmFzQ29tcG9uZW50XVxuICAgICAgICA6IGN1cnJlbnRPcGVuLk1vZGFsO1xuICAgICAgdGhhdC5oaWRlKCk7XG4gICAgfVxuXG4gICAgc2VsZi5vcGVuID0gdHJ1ZTtcbiAgICBzZWxmLmlzQW5pbWF0aW5nID0gdHJ1ZTtcblxuICAgIGlmIChvcHRpb25zLmJhY2tkcm9wKSB7XG4gICAgICBpZiAoIXF1ZXJ5RWxlbWVudChgLiR7bW9kYWxCYWNrZHJvcENsYXNzfWApKSB7XG4gICAgICAgIGFwcGVuZE92ZXJsYXkoMSk7XG4gICAgICB9XG5cbiAgICAgIG92ZXJsYXlEZWxheSA9IGdldEVsZW1lbnRUcmFuc2l0aW9uRHVyYXRpb24ob3ZlcmxheSk7XG5cbiAgICAgIGlmICghaGFzQ2xhc3Mob3ZlcmxheSwgc2hvd0NsYXNzKSkgc2hvd092ZXJsYXkoKTtcblxuICAgICAgc2V0VGltZW91dCgoKSA9PiBiZWZvcmVPZmZjYW52YXNTaG93KHNlbGYpLCBvdmVybGF5RGVsYXkpO1xuICAgIH0gZWxzZSBiZWZvcmVPZmZjYW52YXNTaG93KHNlbGYpO1xuICB9XG5cbiAgaGlkZShmb3JjZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHsgZWxlbWVudCwgaXNBbmltYXRpbmcsIHJlbGF0ZWRUYXJnZXQgfSA9IHNlbGY7XG5cbiAgICBpZiAoIXNlbGYub3BlbiB8fCBpc0FuaW1hdGluZykgcmV0dXJuO1xuXG4gICAgaGlkZU9mZmNhbnZhc0V2ZW50LnJlbGF0ZWRUYXJnZXQgPSByZWxhdGVkVGFyZ2V0IHx8IG51bGw7XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGhpZGVPZmZjYW52YXNFdmVudCk7XG4gICAgaWYgKGhpZGVPZmZjYW52YXNFdmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICBzZWxmLmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICBhZGRDbGFzcyhlbGVtZW50LCBvZmZjYW52YXNUb2dnbGluZ0NsYXNzKTtcbiAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBzaG93Q2xhc3MpO1xuXG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoZWxlbWVudCwgKCkgPT4gYmVmb3JlT2ZmY2FudmFzSGlkZShzZWxmKSk7XG4gICAgfSBlbHNlIGJlZm9yZU9mZmNhbnZhc0hpZGUoc2VsZik7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuaGlkZSgxKTtcbiAgICB0b2dnbGVPZmZjYW52YXNFdmVudHMoc2VsZik7XG4gICAgc3VwZXIuZGlzcG9zZShvZmZjYW52YXNDb21wb25lbnQpO1xuICB9XG59XG5cbk9mZmNhbnZhcy5pbml0ID0ge1xuICBjb21wb25lbnQ6IG9mZmNhbnZhc0NvbXBvbmVudCxcbiAgc2VsZWN0b3I6IE9mZmNhbnZhc1NlbGVjdG9yLFxuICBjb25zdHJ1Y3RvcjogT2ZmY2FudmFzLFxufTtcblxuY29uc3QgYXJpYURlc2NyaWJlZEJ5ID0gJ2FyaWEtZGVzY3JpYmVkYnknO1xuXG52YXIgdGlwQ2xhc3NQb3NpdGlvbnMgPSB7XG4gIHRvcDogJ3RvcCcsIGJvdHRvbTogJ2JvdHRvbScsIGxlZnQ6ICdzdGFydCcsIHJpZ2h0OiAnZW5kJyxcbn07XG5cbmZ1bmN0aW9uIGlzVmlzaWJsZVRpcCh0aXAsIGNvbnRhaW5lcikge1xuICByZXR1cm4gY29udGFpbmVyLmNvbnRhaW5zKHRpcCk7XG59XG5cbmZ1bmN0aW9uIGlzTWVkaWEoZWxlbWVudCkge1xuICByZXR1cm4gW1NWR0VsZW1lbnQsIEhUTUxJbWFnZUVsZW1lbnQsIEhUTUxWaWRlb0VsZW1lbnRdXG4gICAgLnNvbWUoKG1lZGlhVHlwZSkgPT4gZWxlbWVudCBpbnN0YW5jZW9mIG1lZGlhVHlwZSk7XG59XG5cbmZ1bmN0aW9uIGNsb3Nlc3RSZWxhdGl2ZShlbGVtZW50KSB7XG4gIGxldCByZXR2YWwgPSBudWxsO1xuICBsZXQgZWwgPSBlbGVtZW50O1xuICB3aGlsZSAoZWwgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKGdldENvbXB1dGVkU3R5bGUoZWwpLnBvc2l0aW9uID09PSAncmVsYXRpdmUnKSB7XG4gICAgICByZXR2YWwgPSBlbDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0dmFsO1xufVxuXG4vLyBib3RoIHBvcG92ZXJzIGFuZCB0b29sdGlwcyAodGhpcywgZXZlbnQpXG5mdW5jdGlvbiBzdHlsZVRpcChzZWxmLCBlKSB7XG4gIGNvbnN0IHRpcENsYXNzZXMgPSAvXFxiKHRvcHxib3R0b218c3RhcnR8ZW5kKSsvO1xuICBjb25zdCB0aXAgPSBzZWxmLnRvb2x0aXAgfHwgc2VsZi5wb3BvdmVyO1xuICAvLyByZXNldCB0aXAgc3R5bGVcbiAgdGlwLnN0eWxlLnRvcCA9ICcnO1xuICB0aXAuc3R5bGUubGVmdCA9ICcnO1xuICB0aXAuc3R5bGUucmlnaHQgPSAnJztcbiAgLy8gY29udGludWUgd2l0aCBtZXRyaWNzXG4gIGNvbnN0IGlzUG9wb3ZlciA9ICEhc2VsZi5wb3BvdmVyO1xuICBsZXQgdGlwRGltZW5zaW9ucyA9IHsgdzogdGlwLm9mZnNldFdpZHRoLCBoOiB0aXAub2Zmc2V0SGVpZ2h0IH07XG4gIGNvbnN0IHdpbmRvd1dpZHRoID0gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoKTtcbiAgY29uc3Qgd2luZG93SGVpZ2h0ID0gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQpO1xuICBjb25zdCB7IGVsZW1lbnQsIG9wdGlvbnMsIGFycm93IH0gPSBzZWxmO1xuICBsZXQgeyBjb250YWluZXIsIHBsYWNlbWVudCB9ID0gb3B0aW9ucztcbiAgbGV0IHBhcmVudElzQm9keSA9IGNvbnRhaW5lciA9PT0gZG9jdW1lbnQuYm9keTtcbiAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uO1xuICBjb25zdCBwYXJlbnRQb3NpdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS5wb3NpdGlvbjtcbiAgY29uc3Qgc3RhdGljUGFyZW50ID0gIXBhcmVudElzQm9keSAmJiBwYXJlbnRQb3NpdGlvbiA9PT0gJ3N0YXRpYyc7XG4gIGxldCByZWxhdGl2ZVBhcmVudCA9ICFwYXJlbnRJc0JvZHkgJiYgcGFyZW50UG9zaXRpb24gPT09ICdyZWxhdGl2ZSc7XG4gIGNvbnN0IHJlbENvbnRhaW5lciA9IHN0YXRpY1BhcmVudCAmJiBjbG9zZXN0UmVsYXRpdmUoY29udGFpbmVyKTtcbiAgLy8gc3RhdGljIGNvbnRhaW5lcnMgc2hvdWxkIHJlZmVyIHRvIGFub3RoZXIgcmVsYXRpdmUgY29udGFpbmVyIG9yIHRoZSBib2R5XG4gIGNvbnRhaW5lciA9IHJlbENvbnRhaW5lciB8fCBjb250YWluZXI7XG4gIHJlbGF0aXZlUGFyZW50ID0gc3RhdGljUGFyZW50ICYmIHJlbENvbnRhaW5lciA/IDEgOiByZWxhdGl2ZVBhcmVudDtcbiAgcGFyZW50SXNCb2R5ID0gY29udGFpbmVyID09PSBkb2N1bWVudC5ib2R5O1xuICBjb25zdCBwYXJlbnRSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBsZWZ0Qm91bmRyeSA9IHJlbGF0aXZlUGFyZW50ID8gcGFyZW50UmVjdC5sZWZ0IDogMDtcbiAgY29uc3QgcmlnaHRCb3VuZHJ5ID0gcmVsYXRpdmVQYXJlbnQgPyBwYXJlbnRSZWN0LnJpZ2h0IDogd2luZG93V2lkdGg7XG4gIC8vIHRoaXMgY2FzZSBzaG91bGQgbm90IGJlIHBvc3NpYmxlXG4gIC8vIGFic29sdXRlUGFyZW50ID0gIXBhcmVudElzQm9keSAmJiBwYXJlbnRQb3NpdGlvbiA9PT0gJ2Fic29sdXRlJyxcbiAgLy8gdGhpcyBjYXNlIHJlcXVpcmVzIGEgY29udGFpbmVyIHdpdGggcGxhY2VtZW50OiByZWxhdGl2ZVxuICBjb25zdCBhYnNvbHV0ZVRhcmdldCA9IHRhcmdldFBvc2l0aW9uID09PSAnYWJzb2x1dGUnO1xuICBjb25zdCB0YXJnZXRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3Qgc2Nyb2xsID0gcGFyZW50SXNCb2R5XG4gICAgPyB7IHg6IHdpbmRvdy5wYWdlWE9mZnNldCwgeTogd2luZG93LnBhZ2VZT2Zmc2V0IH1cbiAgICA6IHsgeDogY29udGFpbmVyLnNjcm9sbExlZnQsIHk6IGNvbnRhaW5lci5zY3JvbGxUb3AgfTtcbiAgY29uc3QgZWxlbURpbWVuc2lvbnMgPSB7IHc6IGVsZW1lbnQub2Zmc2V0V2lkdGgsIGg6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IH07XG4gIGNvbnN0IHRvcCA9IHJlbGF0aXZlUGFyZW50ID8gZWxlbWVudC5vZmZzZXRUb3AgOiB0YXJnZXRSZWN0LnRvcDtcbiAgY29uc3QgbGVmdCA9IHJlbGF0aXZlUGFyZW50ID8gZWxlbWVudC5vZmZzZXRMZWZ0IDogdGFyZ2V0UmVjdC5sZWZ0O1xuICAvLyByZXNldCBhcnJvdyBzdHlsZVxuICBhcnJvdy5zdHlsZS50b3AgPSAnJztcbiAgYXJyb3cuc3R5bGUubGVmdCA9ICcnO1xuICBhcnJvdy5zdHlsZS5yaWdodCA9ICcnO1xuICBsZXQgdG9wUG9zaXRpb247XG4gIGxldCBsZWZ0UG9zaXRpb247XG4gIGxldCByaWdodFBvc2l0aW9uO1xuICBsZXQgYXJyb3dUb3A7XG4gIGxldCBhcnJvd0xlZnQ7XG4gIGxldCBhcnJvd1JpZ2h0O1xuXG4gIC8vIGNoZWNrIHBsYWNlbWVudFxuICBsZXQgdG9wRXhjZWVkID0gdGFyZ2V0UmVjdC50b3AgLSB0aXBEaW1lbnNpb25zLmggPCAwO1xuICBsZXQgYm90dG9tRXhjZWVkID0gdGFyZ2V0UmVjdC50b3AgKyB0aXBEaW1lbnNpb25zLmggKyBlbGVtRGltZW5zaW9ucy5oID49IHdpbmRvd0hlaWdodDtcbiAgbGV0IGxlZnRFeGNlZWQgPSB0YXJnZXRSZWN0LmxlZnQgLSB0aXBEaW1lbnNpb25zLncgPCBsZWZ0Qm91bmRyeTtcbiAgbGV0IHJpZ2h0RXhjZWVkID0gdGFyZ2V0UmVjdC5sZWZ0ICsgdGlwRGltZW5zaW9ucy53ICsgZWxlbURpbWVuc2lvbnMudyA+PSByaWdodEJvdW5kcnk7XG5cbiAgdG9wRXhjZWVkID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5jbHVkZXMocGxhY2VtZW50KVxuICAgID8gdGFyZ2V0UmVjdC50b3AgKyBlbGVtRGltZW5zaW9ucy5oIC8gMiAtIHRpcERpbWVuc2lvbnMuaCAvIDIgPCAwXG4gICAgOiB0b3BFeGNlZWQ7XG4gIGJvdHRvbUV4Y2VlZCA9IFsnbGVmdCcsICdyaWdodCddLmluY2x1ZGVzKHBsYWNlbWVudClcbiAgICA/IHRhcmdldFJlY3QudG9wICsgdGlwRGltZW5zaW9ucy5oIC8gMiArIGVsZW1EaW1lbnNpb25zLmggLyAyID49IHdpbmRvd0hlaWdodFxuICAgIDogYm90dG9tRXhjZWVkO1xuICBsZWZ0RXhjZWVkID0gWyd0b3AnLCAnYm90dG9tJ10uaW5jbHVkZXMocGxhY2VtZW50KVxuICAgID8gdGFyZ2V0UmVjdC5sZWZ0ICsgZWxlbURpbWVuc2lvbnMudyAvIDIgLSB0aXBEaW1lbnNpb25zLncgLyAyIDwgbGVmdEJvdW5kcnlcbiAgICA6IGxlZnRFeGNlZWQ7XG4gIHJpZ2h0RXhjZWVkID0gWyd0b3AnLCAnYm90dG9tJ10uaW5jbHVkZXMocGxhY2VtZW50KVxuICAgID8gdGFyZ2V0UmVjdC5sZWZ0ICsgdGlwRGltZW5zaW9ucy53IC8gMiArIGVsZW1EaW1lbnNpb25zLncgLyAyID49IHJpZ2h0Qm91bmRyeVxuICAgIDogcmlnaHRFeGNlZWQ7XG5cbiAgLy8gcmVjb21wdXRlIHBsYWNlbWVudFxuICAvLyBmaXJzdCwgd2hlbiBib3RoIGxlZnQgYW5kIHJpZ2h0IGxpbWl0cyBhcmUgZXhjZWVkZWQsIHdlIGZhbGwgYmFjayB0byB0b3B8Ym90dG9tXG4gIHBsYWNlbWVudCA9IChbJ2xlZnQnLCAncmlnaHQnXS5pbmNsdWRlcyhwbGFjZW1lbnQpKSAmJiBsZWZ0RXhjZWVkICYmIHJpZ2h0RXhjZWVkID8gJ3RvcCcgOiBwbGFjZW1lbnQ7XG4gIHBsYWNlbWVudCA9IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgdG9wRXhjZWVkID8gJ2JvdHRvbScgOiBwbGFjZW1lbnQ7XG4gIHBsYWNlbWVudCA9IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgYm90dG9tRXhjZWVkID8gJ3RvcCcgOiBwbGFjZW1lbnQ7XG4gIHBsYWNlbWVudCA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIGxlZnRFeGNlZWQgPyAncmlnaHQnIDogcGxhY2VtZW50O1xuICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgcmlnaHRFeGNlZWQgPyAnbGVmdCcgOiBwbGFjZW1lbnQ7XG5cbiAgLy8gdXBkYXRlIHRvb2x0aXAvcG9wb3ZlciBjbGFzc1xuICBpZiAoIXRpcC5jbGFzc05hbWUuaW5jbHVkZXMocGxhY2VtZW50KSkge1xuICAgIHRpcC5jbGFzc05hbWUgPSB0aXAuY2xhc3NOYW1lLnJlcGxhY2UodGlwQ2xhc3NlcywgdGlwQ2xhc3NQb3NpdGlvbnNbcGxhY2VtZW50XSk7XG4gIH1cbiAgLy8gaWYgcG9zaXRpb24gaGFzIGNoYW5nZWQsIHVwZGF0ZSB0aXAgZGltZW5zaW9uc1xuICB0aXBEaW1lbnNpb25zID0geyB3OiB0aXAub2Zmc2V0V2lkdGgsIGg6IHRpcC5vZmZzZXRIZWlnaHQgfTtcblxuICAvLyB3ZSBjaGVjayB0aGUgY29tcHV0ZWQgd2lkdGggJiBoZWlnaHQgYW5kIHVwZGF0ZSBoZXJlXG4gIGNvbnN0IGFycm93V2lkdGggPSBhcnJvdy5vZmZzZXRXaWR0aCB8fCAwO1xuICBjb25zdCBhcnJvd0hlaWdodCA9IGFycm93Lm9mZnNldEhlaWdodCB8fCAwO1xuICBjb25zdCBhcnJvd0FkanVzdCA9IGFycm93V2lkdGggLyAyO1xuXG4gIC8vIGNvbXB1dGUgdG9vbHRpcCAvIHBvcG92ZXIgY29vcmRpbmF0ZXNcbiAgaWYgKFsnbGVmdCcsICdyaWdodCddLmluY2x1ZGVzKHBsYWNlbWVudCkpIHsgLy8gc2Vjb25kYXJ5fHNpZGUgcG9zaXRpb25zXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7IC8vIExFRlRcbiAgICAgIGxlZnRQb3NpdGlvbiA9IGxlZnQgKyBzY3JvbGwueCAtIHRpcERpbWVuc2lvbnMudyAtIChpc1BvcG92ZXIgPyBhcnJvd1dpZHRoIDogMCk7XG4gICAgfSBlbHNlIHsgLy8gUklHSFRcbiAgICAgIGxlZnRQb3NpdGlvbiA9IGxlZnQgKyBzY3JvbGwueCArIGVsZW1EaW1lbnNpb25zLncgKyAoaXNQb3BvdmVyID8gYXJyb3dXaWR0aCA6IDApO1xuICAgIH1cblxuICAgIC8vIGFkanVzdCB0b3AgYW5kIGFycm93XG4gICAgaWYgKHRvcEV4Y2VlZCkge1xuICAgICAgdG9wUG9zaXRpb24gPSB0b3AgKyBzY3JvbGwueTtcbiAgICAgIGFycm93VG9wID0gZWxlbURpbWVuc2lvbnMuaCAvIDIgLSBhcnJvd1dpZHRoO1xuICAgIH0gZWxzZSBpZiAoYm90dG9tRXhjZWVkKSB7XG4gICAgICB0b3BQb3NpdGlvbiA9IHRvcCArIHNjcm9sbC55IC0gdGlwRGltZW5zaW9ucy5oICsgZWxlbURpbWVuc2lvbnMuaDtcbiAgICAgIGFycm93VG9wID0gdGlwRGltZW5zaW9ucy5oIC0gZWxlbURpbWVuc2lvbnMuaCAvIDIgLSBhcnJvd1dpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3BQb3NpdGlvbiA9IHRvcCArIHNjcm9sbC55IC0gdGlwRGltZW5zaW9ucy5oIC8gMiArIGVsZW1EaW1lbnNpb25zLmggLyAyO1xuICAgICAgYXJyb3dUb3AgPSB0aXBEaW1lbnNpb25zLmggLyAyIC0gYXJyb3dIZWlnaHQgLyAyO1xuICAgIH1cbiAgfSBlbHNlIGlmIChbJ3RvcCcsICdib3R0b20nXS5pbmNsdWRlcyhwbGFjZW1lbnQpKSB7XG4gICAgaWYgKGUgJiYgaXNNZWRpYShlbGVtZW50KSkge1xuICAgICAgY29uc3QgZVggPSAhcmVsYXRpdmVQYXJlbnQgPyBlLnBhZ2VYIDogZS5sYXllclggKyAoYWJzb2x1dGVUYXJnZXQgPyBlbGVtZW50Lm9mZnNldExlZnQgOiAwKTtcbiAgICAgIGNvbnN0IGVZID0gIXJlbGF0aXZlUGFyZW50ID8gZS5wYWdlWSA6IGUubGF5ZXJZICsgKGFic29sdXRlVGFyZ2V0ID8gZWxlbWVudC5vZmZzZXRUb3AgOiAwKTtcblxuICAgICAgaWYgKHBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgdG9wUG9zaXRpb24gPSBlWSAtIHRpcERpbWVuc2lvbnMuaCAtIChpc1BvcG92ZXIgPyBhcnJvd1dpZHRoIDogYXJyb3dIZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9wUG9zaXRpb24gPSBlWSArIGFycm93SGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICAvLyBhZGp1c3QgbGVmdCB8IHJpZ2h0IGFuZCBhbHNvIHRoZSBhcnJvd1xuICAgICAgaWYgKGUuY2xpZW50WCAtIHRpcERpbWVuc2lvbnMudyAvIDIgPCBsZWZ0Qm91bmRyeSkgeyAvLyB3aGVuIGV4Y2VlZHMgbGVmdFxuICAgICAgICBsZWZ0UG9zaXRpb24gPSAwO1xuICAgICAgICBhcnJvd0xlZnQgPSBlWCAtIGFycm93QWRqdXN0O1xuICAgICAgfSBlbHNlIGlmIChlLmNsaWVudFggKyB0aXBEaW1lbnNpb25zLncgKiAwLjUxID49IHJpZ2h0Qm91bmRyeSkgeyAvLyB3aGVuIGV4Y2VlZHMgcmlnaHRcbiAgICAgICAgbGVmdFBvc2l0aW9uID0gJ2F1dG8nO1xuICAgICAgICByaWdodFBvc2l0aW9uID0gMDtcbiAgICAgICAgYXJyb3dMZWZ0ID0gdGlwRGltZW5zaW9ucy53IC0gKHJpZ2h0Qm91bmRyeSAtIGVYKSAtIGFycm93QWRqdXN0O1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIHRvcC9ib3R0b21cbiAgICAgICAgbGVmdFBvc2l0aW9uID0gZVggLSB0aXBEaW1lbnNpb25zLncgLyAyO1xuICAgICAgICBhcnJvd0xlZnQgPSB0aXBEaW1lbnNpb25zLncgLyAyIC0gYXJyb3dBZGp1c3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgICAgIHRvcFBvc2l0aW9uID0gdG9wICsgc2Nyb2xsLnkgLSB0aXBEaW1lbnNpb25zLmggLSAoaXNQb3BvdmVyID8gYXJyb3dIZWlnaHQgOiAwKTtcbiAgICAgIH0gZWxzZSB7IC8vIEJPVFRPTVxuICAgICAgICB0b3BQb3NpdGlvbiA9IHRvcCArIHNjcm9sbC55ICsgZWxlbURpbWVuc2lvbnMuaCArIChpc1BvcG92ZXIgPyBhcnJvd0hlaWdodCA6IDApO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGp1c3QgbGVmdCB8IHJpZ2h0IGFuZCBhbHNvIHRoZSBhcnJvd1xuICAgICAgaWYgKGxlZnRFeGNlZWQpIHtcbiAgICAgICAgbGVmdFBvc2l0aW9uID0gMDtcbiAgICAgICAgYXJyb3dMZWZ0ID0gbGVmdCArIGVsZW1EaW1lbnNpb25zLncgLyAyIC0gYXJyb3dBZGp1c3Q7XG4gICAgICB9IGVsc2UgaWYgKHJpZ2h0RXhjZWVkKSB7XG4gICAgICAgIGxlZnRQb3NpdGlvbiA9ICdhdXRvJztcbiAgICAgICAgcmlnaHRQb3NpdGlvbiA9IDA7XG4gICAgICAgIGFycm93UmlnaHQgPSBlbGVtRGltZW5zaW9ucy53IC8gMiArIChwYXJlbnRSZWN0LnJpZ2h0IC0gdGFyZ2V0UmVjdC5yaWdodCkgLSBhcnJvd0FkanVzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnRQb3NpdGlvbiA9IGxlZnQgKyBzY3JvbGwueCAtIHRpcERpbWVuc2lvbnMudyAvIDIgKyBlbGVtRGltZW5zaW9ucy53IC8gMjtcbiAgICAgICAgYXJyb3dMZWZ0ID0gdGlwRGltZW5zaW9ucy53IC8gMiAtIGFycm93QWRqdXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFwcGx5IHN0eWxlIHRvIHRvb2x0aXAvcG9wb3ZlciBhbmQgaXRzIGFycm93XG4gIHRpcC5zdHlsZS50b3AgPSBgJHt0b3BQb3NpdGlvbn1weGA7XG4gIHRpcC5zdHlsZS5sZWZ0ID0gbGVmdFBvc2l0aW9uID09PSAnYXV0bycgPyBsZWZ0UG9zaXRpb24gOiBgJHtsZWZ0UG9zaXRpb259cHhgO1xuICB0aXAuc3R5bGUucmlnaHQgPSByaWdodFBvc2l0aW9uICE9PSB1bmRlZmluZWQgPyBgJHtyaWdodFBvc2l0aW9ufXB4YCA6ICcnO1xuICAvLyB1cGRhdGUgYXJyb3cgcGxhY2VtZW50IG9yIGNsZWFyIHNpZGVcbiAgaWYgKGFycm93VG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICBhcnJvdy5zdHlsZS50b3AgPSBgJHthcnJvd1RvcH1weGA7XG4gIH1cblxuICBpZiAoYXJyb3dMZWZ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBhcnJvdy5zdHlsZS5sZWZ0ID0gYCR7YXJyb3dMZWZ0fXB4YDtcbiAgfSBlbHNlIGlmIChhcnJvd1JpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBhcnJvdy5zdHlsZS5yaWdodCA9IGAke2Fycm93UmlnaHR9cHhgO1xuICB9XG59XG5cbmxldCBic25VSUQgPSAxO1xuXG4vLyBwb3BvdmVyLCB0b29sdGlwLCBzY3JvbGxzcHkgbmVlZCBhIHVuaXF1ZSBpZFxuZnVuY3Rpb24gZ2V0VUlEKGVsZW1lbnQsIGtleSkge1xuICBic25VSUQgKz0gMTtcbiAgcmV0dXJuIGVsZW1lbnRba2V5XSB8fCBic25VSUQ7XG59XG5cbmZ1bmN0aW9uIGdldFRpcENvbnRhaW5lcihlbGVtZW50KSB7XG4gIC8vIG1heWJlIHRoZSBlbGVtZW50IGlzIGluc2lkZSBhIG1vZGFsXG4gIGNvbnN0IG1vZGFsID0gZWxlbWVudC5jbG9zZXN0KCcubW9kYWwnKTtcblxuICAvLyBPUiBtYXliZSB0aGUgZWxlbWVudCBpcyBpbnNpZGUgYSBmaXhlZCBuYXZiYXJcbiAgY29uc3QgbmF2YmFyRml4ZWQgPSBlbGVtZW50LmNsb3Nlc3QoYC4ke2ZpeGVkVG9wQ2xhc3N9LC4ke2ZpeGVkQm90dG9tQ2xhc3N9YCk7XG5cbiAgLy8gc2V0IGRlZmF1bHQgY29udGFpbmVyIG9wdGlvbiBhcHByb3ByaWF0ZSBmb3IgdGhlIGNvbnRleHRcbiAgcmV0dXJuIG1vZGFsIHx8IG5hdmJhckZpeGVkIHx8IGRvY3VtZW50LmJvZHk7XG59XG5cbi8qIE5hdGl2ZSBKYXZhU2NyaXB0IGZvciBCb290c3RyYXAgNSB8IFBvcG92ZXJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLy8gUE9QT1ZFUiBQUklWQVRFIEdDXG4vLyA9PT09PT09PT09PT09PT09PT1cbmNvbnN0IHBvcG92ZXJTdHJpbmcgPSAncG9wb3Zlcic7XG5jb25zdCBwb3BvdmVyQ29tcG9uZW50ID0gJ1BvcG92ZXInO1xuY29uc3QgcG9wb3ZlclNlbGVjdG9yID0gYFske2RhdGFCc1RvZ2dsZX09XCIke3BvcG92ZXJTdHJpbmd9XCJdLFtkYXRhLXRpcD1cIiR7cG9wb3ZlclN0cmluZ31cIl1gO1xuY29uc3QgcG9wb3ZlckRlZmF1bHRPcHRpb25zID0ge1xuICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJwb3BvdmVyXCIgcm9sZT1cInRvb2x0aXBcIj48ZGl2IGNsYXNzPVwicG9wb3Zlci1hcnJvd1wiPjwvZGl2PjxoMyBjbGFzcz1cInBvcG92ZXItaGVhZGVyXCI+PC9oMz48ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5XCI+PC9kaXY+PC9kaXY+JywgLy8gc3RyaW5nXG4gIHRpdGxlOiBudWxsLCAvLyBzdHJpbmdcbiAgY29udGVudDogbnVsbCwgLy8gc3RyaW5nXG4gIHNhbml0aXplRm46IG51bGwsIC8vIGZ1bmN0aW9uXG4gIGN1c3RvbUNsYXNzOiBudWxsLCAvLyBzdHJpbmdcbiAgZGlzbWlzc2libGU6IGZhbHNlLCAvLyBib29sZWFuXG4gIGFuaW1hdGlvbjogdHJ1ZSwgLy8gYm9vbGVhblxuICB0cmlnZ2VyOiAnaG92ZXInLCAvLyBzdHJpbmdcbiAgcGxhY2VtZW50OiAndG9wJywgLy8gc3RyaW5nXG4gIGRlbGF5OiAyMDAsIC8vIG51bWJlclxufTtcblxuLy8gUE9QT1ZFUiBQUklWQVRFIEdDXG4vLyA9PT09PT09PT09PT09PT09PT1cbmNvbnN0IGlzSXBob25lID0gLyhpUGhvbmV8aVBvZHxpUGFkKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIHBvcG92ZXJBcnJvd0NsYXNzID0gYCR7cG9wb3ZlclN0cmluZ30tYXJyb3dgLFxuY29uc3QgcG9wb3ZlckhlYWRlckNsYXNzID0gYCR7cG9wb3ZlclN0cmluZ30taGVhZGVyYDtcbmNvbnN0IHBvcG92ZXJCb2R5Q2xhc3MgPSBgJHtwb3BvdmVyU3RyaW5nfS1ib2R5YDtcbi8vIGNsb3NlIGJ0biBmb3IgZGlzc21pc3NpYmxlIHBvcG92ZXJcbmxldCBwb3BvdmVyQ2xvc2VCdXR0b24gPSAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4tY2xvc2VcIj48L2J1dHRvbj4nO1xuXG4vLyBQT1BPVkVSIENVU1RPTSBFVkVOVFNcbi8vID09PT09PT09PT09PT09PT09PT09PVxuY29uc3Qgc2hvd1BvcG92ZXJFdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KGBzaG93LmJzLiR7cG9wb3ZlclN0cmluZ31gKTtcbmNvbnN0IHNob3duUG9wb3ZlckV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoYHNob3duLmJzLiR7cG9wb3ZlclN0cmluZ31gKTtcbmNvbnN0IGhpZGVQb3BvdmVyRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudChgaGlkZS5icy4ke3BvcG92ZXJTdHJpbmd9YCk7XG5jb25zdCBoaWRkZW5Qb3BvdmVyRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudChgaGlkZGVuLmJzLiR7cG9wb3ZlclN0cmluZ31gKTtcblxuLy8gUE9QT1ZFUiBFVkVOVCBIQU5ETEVSU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PVxuZnVuY3Rpb24gcG9wb3ZlckZvcmNlRm9jdXMoKSB7XG4gIHNldEZvY3VzKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBwb3BvdmVyVG91Y2hIYW5kbGVyKHsgdGFyZ2V0IH0pIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGNvbnN0IHsgcG9wb3ZlciwgZWxlbWVudCB9ID0gc2VsZjtcblxuICBpZiAoKHBvcG92ZXIgJiYgcG9wb3Zlci5jb250YWlucyh0YXJnZXQpKSAvLyBwb3BvdmVyIGluY2x1ZGVzIHRvdWNoIHRhcmdldFxuICAgIHx8IHRhcmdldCA9PT0gZWxlbWVudCAvLyBPUiB0b3VjaCB0YXJnZXQgaXMgZWxlbWVudFxuICAgIHx8IGVsZW1lbnQuY29udGFpbnModGFyZ2V0KSkgOyBlbHNlIHtcbiAgICBzZWxmLmhpZGUoKTtcbiAgfVxufVxuXG4vLyBQT1BPVkVSIFBSSVZBVEUgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cbmZ1bmN0aW9uIGNyZWF0ZVBvcG92ZXIoc2VsZikge1xuICBjb25zdCB7IGlkLCBvcHRpb25zIH0gPSBzZWxmO1xuICBjb25zdCB7XG4gICAgYW5pbWF0aW9uLCBjdXN0b21DbGFzcywgc2FuaXRpemVGbiwgcGxhY2VtZW50LCBkaXNtaXNzaWJsZSxcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCB7IHRpdGxlLCBjb250ZW50LCB0ZW1wbGF0ZSB9ID0gb3B0aW9ucztcblxuICAvLyBzZXQgaW5pdGlhbCBwb3BvdmVyIGNsYXNzXG4gIGNvbnN0IHBsYWNlbWVudENsYXNzID0gYGJzLSR7cG9wb3ZlclN0cmluZ30tJHt0aXBDbGFzc1Bvc2l0aW9uc1twbGFjZW1lbnRdfWA7XG5cbiAgLy8gZml4aW5nICMyMzNcbiAgdGl0bGUgPSB0aXRsZSA/IHRpdGxlLnRyaW0oKSA6IG51bGw7XG4gIGNvbnRlbnQgPSBjb250ZW50ID8gY29udGVudC50cmltKCkgOiBudWxsO1xuXG4gIC8vIHNhbml0aXplIHRpdGxlICYmIGNvbnRlbnRcbiAgaWYgKHNhbml0aXplRm4pIHtcbiAgICB0aXRsZSA9IHRpdGxlID8gc2FuaXRpemVGbih0aXRsZSkgOiBudWxsO1xuICAgIGNvbnRlbnQgPSBjb250ZW50ID8gc2FuaXRpemVGbihjb250ZW50KSA6IG51bGw7XG4gICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZSA/IHNhbml0aXplRm4odGVtcGxhdGUpIDogbnVsbDtcbiAgICBwb3BvdmVyQ2xvc2VCdXR0b24gPSBzYW5pdGl6ZUZuKHBvcG92ZXJDbG9zZUJ1dHRvbik7XG4gIH1cblxuICBzZWxmLnBvcG92ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29uc3QgeyBwb3BvdmVyIH0gPSBzZWxmO1xuXG4gIC8vIHNldCBpZCBhbmQgYXJpYS1kZXNjcmliZWRieVxuICBwb3BvdmVyLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gIHBvcG92ZXIuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3Rvb2x0aXAnKTtcblxuICAvLyBsb2FkIHRlbXBsYXRlXG4gIGNvbnN0IHBvcG92ZXJUZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBwb3BvdmVyVGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGUudHJpbSgpO1xuICBwb3BvdmVyLmNsYXNzTmFtZSA9IHBvcG92ZXJUZW1wbGF0ZS5maXJzdENoaWxkLmNsYXNzTmFtZTtcbiAgcG9wb3Zlci5pbm5lckhUTUwgPSBwb3BvdmVyVGVtcGxhdGUuZmlyc3RDaGlsZC5pbm5lckhUTUw7XG5cbiAgY29uc3QgcG9wb3ZlckhlYWRlciA9IHF1ZXJ5RWxlbWVudChgLiR7cG9wb3ZlckhlYWRlckNsYXNzfWAsIHBvcG92ZXIpO1xuICBjb25zdCBwb3BvdmVyQm9keSA9IHF1ZXJ5RWxlbWVudChgLiR7cG9wb3ZlckJvZHlDbGFzc31gLCBwb3BvdmVyKTtcblxuICAvLyBzZXQgYXJyb3dcbiAgc2VsZi5hcnJvdyA9IHF1ZXJ5RWxlbWVudChgLiR7cG9wb3ZlclN0cmluZ30tYXJyb3dgLCBwb3BvdmVyKTtcblxuICAvLyBzZXQgZGlzbWlzc2libGUgYnV0dG9uXG4gIGlmIChkaXNtaXNzaWJsZSkge1xuICAgIHRpdGxlID0gdGl0bGUgPyB0aXRsZSArIHBvcG92ZXJDbG9zZUJ1dHRvbiA6IHRpdGxlO1xuICAgIGNvbnRlbnQgPSB0aXRsZSA9PT0gbnVsbCA/ICtwb3BvdmVyQ2xvc2VCdXR0b24gOiBjb250ZW50O1xuICB9XG5cbiAgLy8gZmlsbCB0aGUgdGVtcGxhdGUgd2l0aCBjb250ZW50IGZyb20gZGF0YSBhdHRyaWJ1dGVzXG4gIGlmICh0aXRsZSAmJiBwb3BvdmVySGVhZGVyKSBwb3BvdmVySGVhZGVyLmlubmVySFRNTCA9IHRpdGxlLnRyaW0oKTtcbiAgaWYgKGNvbnRlbnQgJiYgcG9wb3ZlckJvZHkpIHBvcG92ZXJCb2R5LmlubmVySFRNTCA9IGNvbnRlbnQudHJpbSgpO1xuXG4gIC8vIHNldCBwb3BvdmVyIGFuaW1hdGlvbiBhbmQgcGxhY2VtZW50XG4gIGlmICghaGFzQ2xhc3MocG9wb3ZlciwgcG9wb3ZlclN0cmluZykpIGFkZENsYXNzKHBvcG92ZXIsIHBvcG92ZXJTdHJpbmcpO1xuICBpZiAoYW5pbWF0aW9uICYmICFoYXNDbGFzcyhwb3BvdmVyLCBmYWRlQ2xhc3MpKSBhZGRDbGFzcyhwb3BvdmVyLCBmYWRlQ2xhc3MpO1xuICBpZiAoY3VzdG9tQ2xhc3MgJiYgIWhhc0NsYXNzKHBvcG92ZXIsIGN1c3RvbUNsYXNzKSkge1xuICAgIGFkZENsYXNzKHBvcG92ZXIsIGN1c3RvbUNsYXNzKTtcbiAgfVxuICBpZiAoIWhhc0NsYXNzKHBvcG92ZXIsIHBsYWNlbWVudENsYXNzKSkgYWRkQ2xhc3MocG9wb3ZlciwgcGxhY2VtZW50Q2xhc3MpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVQb3BvdmVyKHNlbGYpIHtcbiAgY29uc3QgeyBlbGVtZW50LCBwb3BvdmVyLCBvcHRpb25zIH0gPSBzZWxmO1xuICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhcmlhRGVzY3JpYmVkQnkpO1xuICBvcHRpb25zLmNvbnRhaW5lci5yZW1vdmVDaGlsZChwb3BvdmVyKTtcbiAgc2VsZi50aW1lciA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHRvZ2dsZVBvcG92ZXJIYW5kbGVycyhzZWxmLCBhZGQpIHtcbiAgY29uc3QgYWN0aW9uID0gYWRkID8gYWRkRXZlbnRMaXN0ZW5lciA6IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gIGNvbnN0IHsgZWxlbWVudCwgb3B0aW9ucyB9ID0gc2VsZjtcbiAgY29uc3QgeyB0cmlnZ2VyLCBkaXNtaXNzaWJsZSB9ID0gb3B0aW9ucztcbiAgc2VsZi5lbmFibGVkID0gISFhZGQ7XG5cbiAgaWYgKHRyaWdnZXIgPT09ICdob3ZlcicpIHtcbiAgICBlbGVtZW50W2FjdGlvbl0oJ21vdXNlZG93bicsIHNlbGYuc2hvdyk7XG4gICAgZWxlbWVudFthY3Rpb25dKCdtb3VzZWVudGVyJywgc2VsZi5zaG93KTtcbiAgICBpZiAoaXNNZWRpYShlbGVtZW50KSkgZWxlbWVudFthY3Rpb25dKCdtb3VzZW1vdmUnLCBzZWxmLnVwZGF0ZSwgcGFzc2l2ZUhhbmRsZXIpO1xuICAgIGlmICghZGlzbWlzc2libGUpIGVsZW1lbnRbYWN0aW9uXSgnbW91c2VsZWF2ZScsIHNlbGYuaGlkZSk7XG4gIH0gZWxzZSBpZiAodHJpZ2dlciA9PT0gJ2NsaWNrJykge1xuICAgIGVsZW1lbnRbYWN0aW9uXSh0cmlnZ2VyLCBzZWxmLnRvZ2dsZSk7XG4gIH0gZWxzZSBpZiAodHJpZ2dlciA9PT0gJ2ZvY3VzJykge1xuICAgIGlmIChpc0lwaG9uZSkgZWxlbWVudFthY3Rpb25dKCdjbGljaycsIHBvcG92ZXJGb3JjZUZvY3VzKTtcbiAgICBlbGVtZW50W2FjdGlvbl0oJ2ZvY3VzaW4nLCBzZWxmLnNob3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc21pc3NIYW5kbGVyVG9nZ2xlKHNlbGYsIGFkZCkge1xuICBjb25zdCBhY3Rpb24gPSBhZGQgPyBhZGRFdmVudExpc3RlbmVyIDogcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgY29uc3QgeyBvcHRpb25zLCBlbGVtZW50LCBwb3BvdmVyIH0gPSBzZWxmO1xuICBjb25zdCB7IHRyaWdnZXIsIGRpc21pc3NpYmxlIH0gPSBvcHRpb25zO1xuXG4gIGlmIChkaXNtaXNzaWJsZSkge1xuICAgIGNvbnN0IFtidG5DbG9zZV0gPSBwb3BvdmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2J0bi1jbG9zZScpO1xuICAgIGlmIChidG5DbG9zZSkgYnRuQ2xvc2VbYWN0aW9uXSgnY2xpY2snLCBzZWxmLmhpZGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0cmlnZ2VyID09PSAnZm9jdXMnKSBlbGVtZW50W2FjdGlvbl0oJ2ZvY3Vzb3V0Jywgc2VsZi5oaWRlKTtcbiAgICBpZiAodHJpZ2dlciA9PT0gJ2hvdmVyJykgZG9jdW1lbnRbYWN0aW9uXSgndG91Y2hzdGFydCcsIHBvcG92ZXJUb3VjaEhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyKTtcbiAgfVxuXG4gIGlmICghaXNNZWRpYShlbGVtZW50KSkge1xuICAgIHdpbmRvd1thY3Rpb25dKCdzY3JvbGwnLCBzZWxmLnVwZGF0ZSwgcGFzc2l2ZUhhbmRsZXIpO1xuICAgIHdpbmRvd1thY3Rpb25dKCdyZXNpemUnLCBzZWxmLnVwZGF0ZSwgcGFzc2l2ZUhhbmRsZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcG92ZXJTaG93VHJpZ2dlcihzZWxmKSB7XG4gIGRpc21pc3NIYW5kbGVyVG9nZ2xlKHNlbGYsIDEpO1xuICBzZWxmLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChzaG93blBvcG92ZXJFdmVudCk7XG59XG5cbmZ1bmN0aW9uIHBvcG92ZXJIaWRlVHJpZ2dlcihzZWxmKSB7XG4gIGRpc21pc3NIYW5kbGVyVG9nZ2xlKHNlbGYpO1xuICByZW1vdmVQb3BvdmVyKHNlbGYpO1xuICBzZWxmLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChoaWRkZW5Qb3BvdmVyRXZlbnQpO1xufVxuXG4vLyBQT1BPVkVSIERFRklOSVRJT05cbi8vID09PT09PT09PT09PT09PT09PVxuY2xhc3MgUG9wb3ZlciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNvbmZpZykge1xuICAgIHBvcG92ZXJEZWZhdWx0T3B0aW9ucy5jb250YWluZXIgPSBnZXRUaXBDb250YWluZXIocXVlcnlFbGVtZW50KHRhcmdldCkpO1xuICAgIHN1cGVyKHBvcG92ZXJDb21wb25lbnQsIHRhcmdldCwgcG9wb3ZlckRlZmF1bHRPcHRpb25zLCBjb25maWcpO1xuXG4gICAgLy8gYmluZFxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gZWxlbWVudFxuICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gc2VsZjtcbiAgICAvLyBhZGRpdGlvbmFsIGluc3RhbmNlIHByb3BlcnRpZXNcbiAgICBzZWxmLnRpbWVyID0gbnVsbDtcbiAgICBzZWxmLnBvcG92ZXIgPSBudWxsO1xuICAgIHNlbGYuYXJyb3cgPSBudWxsO1xuICAgIHNlbGYuZW5hYmxlZCA9IGZhbHNlO1xuICAgIC8vIHNldCB1bmlxdWUgSUQgZm9yIGFyaWEtZGVzY3JpYmVkYnlcbiAgICBzZWxmLmlkID0gYCR7cG9wb3ZlclN0cmluZ30tJHtnZXRVSUQoZWxlbWVudCl9YDtcblxuICAgIC8vIHNldCBpbnN0YW5jZSBvcHRpb25zXG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSBzZWxmO1xuXG4gICAgLy8gbWVkaWEgZWxlbWVudHMgb25seSB3b3JrIHdpdGggYm9keSBhcyBhIGNvbnRhaW5lclxuICAgIHNlbGYub3B0aW9ucy5jb250YWluZXIgPSBpc01lZGlhKGVsZW1lbnQpXG4gICAgICA/IHBvcG92ZXJEZWZhdWx0T3B0aW9ucy5jb250YWluZXJcbiAgICAgIDogcXVlcnlFbGVtZW50KG9wdGlvbnMuY29udGFpbmVyKTtcblxuICAgIC8vIHJlc2V0IGRlZmF1bHQgY29udGFpbmVyXG4gICAgcG9wb3ZlckRlZmF1bHRPcHRpb25zLmNvbnRhaW5lciA9IG51bGw7XG5cbiAgICAvLyBpbnZhbGlkYXRlIHdoZW4gbm8gY29udGVudCBpcyBzZXRcbiAgICBpZiAoIW9wdGlvbnMuY29udGVudCkgcmV0dXJuO1xuXG4gICAgLy8gY3JhdGUgcG9wb3ZlclxuICAgIGNyZWF0ZVBvcG92ZXIoc2VsZik7XG5cbiAgICAvLyBiaW5kXG4gICAgc2VsZi51cGRhdGUgPSBzZWxmLnVwZGF0ZS5iaW5kKHNlbGYpO1xuXG4gICAgLy8gYXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRvZ2dsZVBvcG92ZXJIYW5kbGVycyhzZWxmLCAxKTtcbiAgfVxuXG4gIHVwZGF0ZShlKSB7XG4gICAgc3R5bGVUaXAodGhpcywgZSk7XG4gIH1cblxuICAvLyBQT1BPVkVSIFBVQkxJQyBNRVRIT0RTXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT1cbiAgdG9nZ2xlKGUpIHtcbiAgICBjb25zdCBzZWxmID0gZSA/IHRoaXNbcG9wb3ZlckNvbXBvbmVudF0gOiB0aGlzO1xuICAgIGNvbnN0IHsgcG9wb3Zlciwgb3B0aW9ucyB9ID0gc2VsZjtcbiAgICBpZiAoIWlzVmlzaWJsZVRpcChwb3BvdmVyLCBvcHRpb25zLmNvbnRhaW5lcikpIHNlbGYuc2hvdygpO1xuICAgIGVsc2Ugc2VsZi5oaWRlKCk7XG4gIH1cblxuICBzaG93KGUpIHtcbiAgICBjb25zdCBzZWxmID0gZSA/IHRoaXNbcG9wb3ZlckNvbXBvbmVudF0gOiB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnQsIHBvcG92ZXIsIG9wdGlvbnMsIGlkLFxuICAgIH0gPSBzZWxmO1xuICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSBvcHRpb25zO1xuXG4gICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZXIpO1xuXG4gICAgc2VsZi50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFpc1Zpc2libGVUaXAocG9wb3ZlciwgY29udGFpbmVyKSkge1xuICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoc2hvd1BvcG92ZXJFdmVudCk7XG4gICAgICAgIGlmIChzaG93UG9wb3ZlckV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgICAgICAvLyBhcHBlbmQgdG8gdGhlIGNvbnRhaW5lclxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQocG9wb3Zlcik7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGFyaWFEZXNjcmliZWRCeSwgaWQpO1xuXG4gICAgICAgIHNlbGYudXBkYXRlKGUpO1xuICAgICAgICBpZiAoIWhhc0NsYXNzKHBvcG92ZXIsIHNob3dDbGFzcykpIGFkZENsYXNzKHBvcG92ZXIsIHNob3dDbGFzcyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uKSBlbXVsYXRlVHJhbnNpdGlvbkVuZChwb3BvdmVyLCAoKSA9PiBwb3BvdmVyU2hvd1RyaWdnZXIoc2VsZikpO1xuICAgICAgICBlbHNlIHBvcG92ZXJTaG93VHJpZ2dlcihzZWxmKTtcbiAgICAgIH1cbiAgICB9LCAxNyk7XG4gIH1cblxuICBoaWRlKGUpIHtcbiAgICBsZXQgc2VsZjtcbiAgICBpZiAoZSAmJiB0aGlzW3BvcG92ZXJDb21wb25lbnRdKSB7XG4gICAgICBzZWxmID0gdGhpc1twb3BvdmVyQ29tcG9uZW50XTtcbiAgICB9IGVsc2UgaWYgKGUpIHsgLy8gZGlzbWlzc2libGUgcG9wb3ZlclxuICAgICAgY29uc3QgZFBvcG92ZXIgPSB0aGlzLmNsb3Nlc3QoYC4ke3BvcG92ZXJTdHJpbmd9YCk7XG4gICAgICBjb25zdCBkRWwgPSBkUG9wb3ZlciAmJiBxdWVyeUVsZW1lbnQoYFske2FyaWFEZXNjcmliZWRCeX09XCIke2RQb3BvdmVyLmlkfVwiXWApO1xuICAgICAgc2VsZiA9IGRFbFtwb3BvdmVyQ29tcG9uZW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZiA9IHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IHsgZWxlbWVudCwgcG9wb3Zlciwgb3B0aW9ucyB9ID0gc2VsZjtcblxuICAgIGNsZWFyVGltZW91dChzZWxmLnRpbWVyKTtcblxuICAgIHNlbGYudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChpc1Zpc2libGVUaXAocG9wb3Zlciwgb3B0aW9ucy5jb250YWluZXIpKSB7XG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChoaWRlUG9wb3ZlckV2ZW50KTtcbiAgICAgICAgaWYgKGhpZGVQb3BvdmVyRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gICAgICAgIHJlbW92ZUNsYXNzKHBvcG92ZXIsIHNob3dDbGFzcyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uKSBlbXVsYXRlVHJhbnNpdGlvbkVuZChwb3BvdmVyLCAoKSA9PiBwb3BvdmVySGlkZVRyaWdnZXIoc2VsZikpO1xuICAgICAgICBlbHNlIHBvcG92ZXJIaWRlVHJpZ2dlcihzZWxmKTtcbiAgICAgIH1cbiAgICB9LCBvcHRpb25zLmRlbGF5ICsgMTcpO1xuICB9XG5cbiAgZW5hYmxlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHsgZW5hYmxlZCB9ID0gc2VsZjtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHRvZ2dsZVBvcG92ZXJIYW5kbGVycyhzZWxmLCAxKTtcbiAgICAgIHNlbGYuZW5hYmxlZCA9ICFlbmFibGVkO1xuICAgIH1cbiAgfVxuXG4gIGRpc2FibGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgeyBlbmFibGVkLCBwb3BvdmVyLCBvcHRpb25zIH0gPSBzZWxmO1xuICAgIGlmIChlbmFibGVkKSB7XG4gICAgICBpZiAoaXNWaXNpYmxlVGlwKHBvcG92ZXIsIG9wdGlvbnMuY29udGFpbmVyKSAmJiBvcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICBzZWxmLmhpZGUoKTtcblxuICAgICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAgICgpID0+IHRvZ2dsZVBvcG92ZXJIYW5kbGVycyhzZWxmKSxcbiAgICAgICAgICBnZXRFbGVtZW50VHJhbnNpdGlvbkR1cmF0aW9uKHBvcG92ZXIpICsgb3B0aW9ucy5kZWxheSArIDE3LFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9nZ2xlUG9wb3ZlckhhbmRsZXJzKHNlbGYpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmFibGVkID0gIWVuYWJsZWQ7XG4gICAgfVxuICB9XG5cbiAgdG9nZ2xlRW5hYmxlZCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuZW5hYmxlZCkgc2VsZi5lbmFibGUoKTtcbiAgICBlbHNlIHNlbGYuZGlzYWJsZSgpO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCB7IHBvcG92ZXIsIG9wdGlvbnMgfSA9IHNlbGY7XG4gICAgY29uc3QgeyBjb250YWluZXIsIGFuaW1hdGlvbiB9ID0gb3B0aW9ucztcbiAgICBpZiAoYW5pbWF0aW9uICYmIGlzVmlzaWJsZVRpcChwb3BvdmVyLCBjb250YWluZXIpKSB7XG4gICAgICBvcHRpb25zLmRlbGF5ID0gMDsgLy8gcmVzZXQgZGVsYXlcbiAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQocG9wb3ZlciwgKCkgPT4gdG9nZ2xlUG9wb3ZlckhhbmRsZXJzKHNlbGYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9nZ2xlUG9wb3ZlckhhbmRsZXJzKHNlbGYpO1xuICAgIH1cbiAgICBzdXBlci5kaXNwb3NlKHBvcG92ZXJDb21wb25lbnQpO1xuICB9XG59XG5cblBvcG92ZXIuaW5pdCA9IHtcbiAgY29tcG9uZW50OiBwb3BvdmVyQ29tcG9uZW50LFxuICBzZWxlY3RvcjogcG9wb3ZlclNlbGVjdG9yLFxuICBjb25zdHJ1Y3RvcjogUG9wb3Zlcixcbn07XG5cbi8qIE5hdGl2ZSBKYXZhU2NyaXB0IGZvciBCb290c3RyYXAgNSB8IFNjcm9sbFNweVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8vIFNDUk9MTFNQWSBQUklWQVRFIEdDXG4vLyA9PT09PT09PT09PT09PT09PT09PVxuY29uc3Qgc2Nyb2xsc3B5U3RyaW5nID0gJ3Njcm9sbHNweSc7XG5jb25zdCBzY3JvbGxzcHlDb21wb25lbnQgPSAnU2Nyb2xsU3B5JztcbmNvbnN0IHNjcm9sbHNweVNlbGVjdG9yID0gJ1tkYXRhLWJzLXNweT1cInNjcm9sbFwiXSc7XG5jb25zdCBzY3JvbGxTcHlEZWZhdWx0T3B0aW9ucyA9IHtcbiAgb2Zmc2V0OiAxMCxcbiAgdGFyZ2V0OiBudWxsLFxufTtcblxuLy8gU0NST0xMU1BZIENVU1RPTSBFVkVOVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgYWN0aXZhdGVTY3JvbGxTcHkgPSBib290c3RyYXBDdXN0b21FdmVudChgYWN0aXZhdGUuYnMuJHtzY3JvbGxzcHlTdHJpbmd9YCk7XG5cbi8vIFNDUk9MTFNQWSBQUklWQVRFIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT1cbmZ1bmN0aW9uIHVwZGF0ZVNweVRhcmdldHMoc2VsZikge1xuICBjb25zdCB7XG4gICAgdGFyZ2V0LCBzY3JvbGxUYXJnZXQsIGlzV2luZG93LCBvcHRpb25zLCBpdGVtc0xlbmd0aCwgc2Nyb2xsSGVpZ2h0LFxuICB9ID0gc2VsZjtcbiAgY29uc3QgeyBvZmZzZXQgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGxpbmtzID0gdGFyZ2V0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdBJyk7XG5cbiAgc2VsZi5zY3JvbGxUb3AgPSBpc1dpbmRvd1xuICAgID8gc2Nyb2xsVGFyZ2V0LnBhZ2VZT2Zmc2V0XG4gICAgOiBzY3JvbGxUYXJnZXQuc2Nyb2xsVG9wO1xuXG4gIC8vIG9ubHkgdXBkYXRlIGl0ZW1zL29mZnNldHMgb25jZSBvciB3aXRoIGVhY2ggbXV0YXRpb25cbiAgaWYgKGl0ZW1zTGVuZ3RoICE9PSBsaW5rcy5sZW5ndGggfHwgZ2V0U2Nyb2xsSGVpZ2h0KHNjcm9sbFRhcmdldCkgIT09IHNjcm9sbEhlaWdodCkge1xuICAgIGxldCBocmVmO1xuICAgIGxldCB0YXJnZXRJdGVtO1xuICAgIGxldCByZWN0O1xuXG4gICAgLy8gcmVzZXQgYXJyYXlzICYgdXBkYXRlXG4gICAgc2VsZi5pdGVtcyA9IFtdO1xuICAgIHNlbGYub2Zmc2V0cyA9IFtdO1xuICAgIHNlbGYuc2Nyb2xsSGVpZ2h0ID0gZ2V0U2Nyb2xsSGVpZ2h0KHNjcm9sbFRhcmdldCk7XG4gICAgc2VsZi5tYXhTY3JvbGwgPSBzZWxmLnNjcm9sbEhlaWdodCAtIGdldE9mZnNldEhlaWdodChzZWxmKTtcblxuICAgIEFycmF5LmZyb20obGlua3MpLmZvckVhY2goKGxpbmspID0+IHtcbiAgICAgIGhyZWYgPSBsaW5rLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgdGFyZ2V0SXRlbSA9IGhyZWYgJiYgaHJlZi5jaGFyQXQoMCkgPT09ICcjJyAmJiBocmVmLnNsaWNlKC0xKSAhPT0gJyMnICYmIHF1ZXJ5RWxlbWVudChocmVmKTtcblxuICAgICAgaWYgKHRhcmdldEl0ZW0pIHtcbiAgICAgICAgc2VsZi5pdGVtcy5wdXNoKGxpbmspO1xuICAgICAgICByZWN0ID0gdGFyZ2V0SXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgc2VsZi5vZmZzZXRzLnB1c2goKGlzV2luZG93ID8gcmVjdC50b3AgKyBzZWxmLnNjcm9sbFRvcCA6IHRhcmdldEl0ZW0ub2Zmc2V0VG9wKSAtIG9mZnNldCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2VsZi5pdGVtc0xlbmd0aCA9IHNlbGYuaXRlbXMubGVuZ3RoO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbEhlaWdodChzY3JvbGxUYXJnZXQpIHtcbiAgcmV0dXJuIHNjcm9sbFRhcmdldC5zY3JvbGxIZWlnaHQgfHwgTWF0aC5tYXgoXG4gICAgZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCxcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0SGVpZ2h0KHsgZWxlbWVudCwgaXNXaW5kb3cgfSkge1xuICBpZiAoIWlzV2luZG93KSByZXR1cm4gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGNsZWFyKHRhcmdldCkge1xuICBBcnJheS5mcm9tKHRhcmdldC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnQScpKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgaWYgKGhhc0NsYXNzKGl0ZW0sIGFjdGl2ZUNsYXNzKSkgcmVtb3ZlQ2xhc3MoaXRlbSwgYWN0aXZlQ2xhc3MpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGUoc2VsZiwgaXRlbSkge1xuICBjb25zdCB7IHRhcmdldCwgZWxlbWVudCB9ID0gc2VsZjtcbiAgY2xlYXIodGFyZ2V0KTtcbiAgc2VsZi5hY3RpdmVJdGVtID0gaXRlbTtcbiAgYWRkQ2xhc3MoaXRlbSwgYWN0aXZlQ2xhc3MpO1xuXG4gIC8vIGFjdGl2YXRlIGFsbCBwYXJlbnRzXG4gIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgbGV0IHBhcmVudEl0ZW0gPSBpdGVtO1xuICB3aGlsZSAocGFyZW50SXRlbSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgIHBhcmVudEl0ZW0gPSBwYXJlbnRJdGVtLnBhcmVudE5vZGU7XG4gICAgaWYgKGhhc0NsYXNzKHBhcmVudEl0ZW0sICduYXYnKSB8fCBoYXNDbGFzcyhwYXJlbnRJdGVtLCAnZHJvcGRvd24tbWVudScpKSBwYXJlbnRzLnB1c2gocGFyZW50SXRlbSk7XG4gIH1cblxuICBwYXJlbnRzLmZvckVhY2goKG1lbnVJdGVtKSA9PiB7XG4gICAgY29uc3QgcGFyZW50TGluayA9IG1lbnVJdGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG5cbiAgICBpZiAocGFyZW50TGluayAmJiAhaGFzQ2xhc3MocGFyZW50TGluaywgYWN0aXZlQ2xhc3MpKSB7XG4gICAgICBhZGRDbGFzcyhwYXJlbnRMaW5rLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICB9KTtcblxuICAvLyB1cGRhdGUgcmVsYXRlZFRhcmdldCBhbmQgZGlzcGF0Y2hcbiAgYWN0aXZhdGVTY3JvbGxTcHkucmVsYXRlZFRhcmdldCA9IGl0ZW07XG4gIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChhY3RpdmF0ZVNjcm9sbFNweSk7XG59XG5cbmZ1bmN0aW9uIHRvZ2dsZVNweUhhbmRsZXJzKHNlbGYsIGFkZCkge1xuICBjb25zdCBhY3Rpb24gPSBhZGQgPyBhZGRFdmVudExpc3RlbmVyIDogcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgc2VsZi5zY3JvbGxUYXJnZXRbYWN0aW9uXSgnc2Nyb2xsJywgc2VsZi5yZWZyZXNoLCBwYXNzaXZlSGFuZGxlcik7XG59XG5cbi8vIFNDUk9MTFNQWSBERUZJTklUSU9OXG4vLyA9PT09PT09PT09PT09PT09PT09PVxuY2xhc3MgU2Nyb2xsU3B5IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHRhcmdldCwgY29uZmlnKSB7XG4gICAgc3VwZXIoc2Nyb2xsc3B5Q29tcG9uZW50LCB0YXJnZXQsIHNjcm9sbFNweURlZmF1bHRPcHRpb25zLCBjb25maWcpO1xuICAgIC8vIGJpbmRcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIGluaXRpYWxpemF0aW9uIGVsZW1lbnQgJiBvcHRpb25zXG4gICAgY29uc3QgeyBlbGVtZW50LCBvcHRpb25zIH0gPSBzZWxmO1xuXG4gICAgLy8gYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gICAgc2VsZi50YXJnZXQgPSBxdWVyeUVsZW1lbnQob3B0aW9ucy50YXJnZXQpO1xuXG4gICAgLy8gaW52YWxpZGF0ZVxuICAgIGlmICghc2VsZi50YXJnZXQpIHJldHVybjtcblxuICAgIC8vIHNldCBpbml0aWFsIHN0YXRlXG4gICAgc2VsZi5zY3JvbGxUYXJnZXQgPSBlbGVtZW50LmNsaWVudEhlaWdodCA8IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID8gZWxlbWVudCA6IHdpbmRvdztcbiAgICBzZWxmLmlzV2luZG93ID0gc2VsZi5zY3JvbGxUYXJnZXQgPT09IHdpbmRvdztcbiAgICBzZWxmLnNjcm9sbFRvcCA9IDA7XG4gICAgc2VsZi5tYXhTY3JvbGwgPSAwO1xuICAgIHNlbGYuc2Nyb2xsSGVpZ2h0ID0gMDtcbiAgICBzZWxmLmFjdGl2ZUl0ZW0gPSBudWxsO1xuICAgIHNlbGYuaXRlbXMgPSBbXTtcbiAgICBzZWxmLm9mZnNldHMgPSBbXTtcblxuICAgIC8vIGJpbmQgZXZlbnRzXG4gICAgc2VsZi5yZWZyZXNoID0gc2VsZi5yZWZyZXNoLmJpbmQoc2VsZik7XG5cbiAgICAvLyBhZGQgZXZlbnQgaGFuZGxlcnNcbiAgICB0b2dnbGVTcHlIYW5kbGVycyhzZWxmLCAxKTtcblxuICAgIHNlbGYucmVmcmVzaCgpO1xuICB9XG5cbiAgLy8gU0NST0xMU1BZIFBVQkxJQyBNRVRIT0RTXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PVxuICByZWZyZXNoKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBzZWxmO1xuXG4gICAgLy8gY2hlY2sgaWYgdGFyZ2V0IGlzIHZpc2libGUgYW5kIGludmFsaWRhdGVcbiAgICBpZiAodGFyZ2V0Lm9mZnNldEhlaWdodCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgdXBkYXRlU3B5VGFyZ2V0cyhzZWxmKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIHNjcm9sbFRvcCwgbWF4U2Nyb2xsLCBpdGVtc0xlbmd0aCwgaXRlbXMsIGFjdGl2ZUl0ZW0sXG4gICAgfSA9IHNlbGY7XG5cbiAgICBpZiAoc2Nyb2xsVG9wID49IG1heFNjcm9sbCkge1xuICAgICAgY29uc3QgbmV3QWN0aXZlSXRlbSA9IGl0ZW1zW2l0ZW1zTGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChhY3RpdmVJdGVtICE9PSBuZXdBY3RpdmVJdGVtKSB7XG4gICAgICAgIGFjdGl2YXRlKHNlbGYsIG5ld0FjdGl2ZUl0ZW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgb2Zmc2V0cyB9ID0gc2VsZjtcblxuICAgIGlmIChhY3RpdmVJdGVtICYmIHNjcm9sbFRvcCA8IG9mZnNldHNbMF0gJiYgb2Zmc2V0c1swXSA+IDApIHtcbiAgICAgIHNlbGYuYWN0aXZlSXRlbSA9IG51bGw7XG4gICAgICBjbGVhcih0YXJnZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgIGlmIChhY3RpdmVJdGVtICE9PSBpdGVtICYmIHNjcm9sbFRvcCA+PSBvZmZzZXRzW2ldXG4gICAgICAgICYmICh0eXBlb2Ygb2Zmc2V0c1tpICsgMV0gPT09ICd1bmRlZmluZWQnIHx8IHNjcm9sbFRvcCA8IG9mZnNldHNbaSArIDFdKSkge1xuICAgICAgICBhY3RpdmF0ZShzZWxmLCBpdGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdG9nZ2xlU3B5SGFuZGxlcnModGhpcyk7XG4gICAgc3VwZXIuZGlzcG9zZShzY3JvbGxzcHlDb21wb25lbnQpO1xuICB9XG59XG5cblNjcm9sbFNweS5pbml0ID0ge1xuICBjb21wb25lbnQ6IHNjcm9sbHNweUNvbXBvbmVudCxcbiAgc2VsZWN0b3I6IHNjcm9sbHNweVNlbGVjdG9yLFxuICBjb25zdHJ1Y3RvcjogU2Nyb2xsU3B5LFxufTtcblxuY29uc3QgYXJpYVNlbGVjdGVkID0gJ2FyaWEtc2VsZWN0ZWQnO1xuXG4vKiBOYXRpdmUgSmF2YVNjcmlwdCBmb3IgQm9vdHN0cmFwIDUgfCBUYWJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vLyBUQUIgUFJJVkFURSBHQ1xuLy8gPT09PT09PT09PT09PT09PVxuY29uc3QgdGFiU3RyaW5nID0gJ3RhYic7XG5jb25zdCB0YWJDb21wb25lbnQgPSAnVGFiJztcbmNvbnN0IHRhYlNlbGVjdG9yID0gYFske2RhdGFCc1RvZ2dsZX09XCIke3RhYlN0cmluZ31cIl1gO1xuXG4vLyBUQUIgQ1VTVE9NIEVWRU5UU1xuLy8gPT09PT09PT09PT09PT09PT1cbmNvbnN0IHNob3dUYWJFdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KGBzaG93LmJzLiR7dGFiU3RyaW5nfWApO1xuY29uc3Qgc2hvd25UYWJFdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KGBzaG93bi5icy4ke3RhYlN0cmluZ31gKTtcbmNvbnN0IGhpZGVUYWJFdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KGBoaWRlLmJzLiR7dGFiU3RyaW5nfWApO1xuY29uc3QgaGlkZGVuVGFiRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudChgaGlkZGVuLmJzLiR7dGFiU3RyaW5nfWApO1xuXG5sZXQgbmV4dFRhYjtcbmxldCBuZXh0VGFiQ29udGVudDtcbmxldCBuZXh0VGFiSGVpZ2h0O1xubGV0IGFjdGl2ZVRhYjtcbmxldCBhY3RpdmVUYWJDb250ZW50O1xubGV0IHRhYkNvbnRhaW5lckhlaWdodDtcbmxldCB0YWJFcXVhbENvbnRlbnRzO1xuXG4vLyBUQUIgUFJJVkFURSBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PT09PT09XG5mdW5jdGlvbiB0cmlnZ2VyVGFiRW5kKHNlbGYpIHtcbiAgY29uc3QgeyB0YWJDb250ZW50LCBuYXYgfSA9IHNlbGY7XG4gIHRhYkNvbnRlbnQuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gIHJlbW92ZUNsYXNzKHRhYkNvbnRlbnQsIGNvbGxhcHNpbmdDbGFzcyk7XG4gIG5hdi5pc0FuaW1hdGluZyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyVGFiU2hvdyhzZWxmKSB7XG4gIGNvbnN0IHsgdGFiQ29udGVudCwgbmF2IH0gPSBzZWxmO1xuXG4gIGlmICh0YWJDb250ZW50KSB7IC8vIGhlaWdodCBhbmltYXRpb25cbiAgICBpZiAodGFiRXF1YWxDb250ZW50cykge1xuICAgICAgdHJpZ2dlclRhYkVuZChzZWxmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7IC8vIGVuYWJsZXMgaGVpZ2h0IGFuaW1hdGlvblxuICAgICAgICB0YWJDb250ZW50LnN0eWxlLmhlaWdodCA9IGAke25leHRUYWJIZWlnaHR9cHhgOyAvLyBoZWlnaHQgYW5pbWF0aW9uXG4gICAgICAgIHJlZmxvdyh0YWJDb250ZW50KTtcbiAgICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQodGFiQ29udGVudCwgKCkgPT4gdHJpZ2dlclRhYkVuZChzZWxmKSk7XG4gICAgICB9LCA1MCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5hdi5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICB9XG4gIHNob3duVGFiRXZlbnQucmVsYXRlZFRhcmdldCA9IGFjdGl2ZVRhYjtcbiAgbmV4dFRhYi5kaXNwYXRjaEV2ZW50KHNob3duVGFiRXZlbnQpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyVGFiSGlkZShzZWxmKSB7XG4gIGNvbnN0IHsgdGFiQ29udGVudCB9ID0gc2VsZjtcbiAgaWYgKHRhYkNvbnRlbnQpIHtcbiAgICBhY3RpdmVUYWJDb250ZW50LnN0eWxlLmZsb2F0ID0gJ2xlZnQnO1xuICAgIG5leHRUYWJDb250ZW50LnN0eWxlLmZsb2F0ID0gJ2xlZnQnO1xuICAgIHRhYkNvbnRhaW5lckhlaWdodCA9IGFjdGl2ZVRhYkNvbnRlbnQuc2Nyb2xsSGVpZ2h0O1xuICB9XG5cbiAgLy8gdXBkYXRlIHJlbGF0ZWRUYXJnZXQgYW5kIGRpc3BhdGNoIGV2ZW50XG4gIHNob3dUYWJFdmVudC5yZWxhdGVkVGFyZ2V0ID0gYWN0aXZlVGFiO1xuICBoaWRkZW5UYWJFdmVudC5yZWxhdGVkVGFyZ2V0ID0gbmV4dFRhYjtcbiAgbmV4dFRhYi5kaXNwYXRjaEV2ZW50KHNob3dUYWJFdmVudCk7XG4gIGlmIChzaG93VGFiRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gIGFkZENsYXNzKG5leHRUYWJDb250ZW50LCBhY3RpdmVDbGFzcyk7XG4gIHJlbW92ZUNsYXNzKGFjdGl2ZVRhYkNvbnRlbnQsIGFjdGl2ZUNsYXNzKTtcblxuICBpZiAodGFiQ29udGVudCkge1xuICAgIG5leHRUYWJIZWlnaHQgPSBuZXh0VGFiQ29udGVudC5zY3JvbGxIZWlnaHQ7XG4gICAgdGFiRXF1YWxDb250ZW50cyA9IG5leHRUYWJIZWlnaHQgPT09IHRhYkNvbnRhaW5lckhlaWdodDtcbiAgICBhZGRDbGFzcyh0YWJDb250ZW50LCBjb2xsYXBzaW5nQ2xhc3MpO1xuICAgIHRhYkNvbnRlbnQuc3R5bGUuaGVpZ2h0ID0gYCR7dGFiQ29udGFpbmVySGVpZ2h0fXB4YDsgLy8gaGVpZ2h0IGFuaW1hdGlvblxuICAgIHJlZmxvdyh0YWJDb250ZW50KTtcbiAgICBhY3RpdmVUYWJDb250ZW50LnN0eWxlLmZsb2F0ID0gJyc7XG4gICAgbmV4dFRhYkNvbnRlbnQuc3R5bGUuZmxvYXQgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNDbGFzcyhuZXh0VGFiQ29udGVudCwgZmFkZUNsYXNzKSkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYWRkQ2xhc3MobmV4dFRhYkNvbnRlbnQsIHNob3dDbGFzcyk7XG4gICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZChuZXh0VGFiQ29udGVudCwgKCkgPT4ge1xuICAgICAgICB0cmlnZ2VyVGFiU2hvdyhzZWxmKTtcbiAgICAgIH0pO1xuICAgIH0sIDIwKTtcbiAgfSBlbHNlIHsgdHJpZ2dlclRhYlNob3coc2VsZik7IH1cblxuICBhY3RpdmVUYWIuZGlzcGF0Y2hFdmVudChoaWRkZW5UYWJFdmVudCk7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZVRhYih7IG5hdiB9KSB7XG4gIGNvbnN0IGFjdGl2ZVRhYnMgPSBuYXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShhY3RpdmVDbGFzcyk7XG5cbiAgaWYgKGFjdGl2ZVRhYnMubGVuZ3RoID09PSAxXG4gICAgJiYgIWRyb3Bkb3duTWVudUNsYXNzZXMuc29tZSgoYykgPT4gaGFzQ2xhc3MoYWN0aXZlVGFic1swXS5wYXJlbnROb2RlLCBjKSkpIHtcbiAgICBbYWN0aXZlVGFiXSA9IGFjdGl2ZVRhYnM7XG4gIH0gZWxzZSBpZiAoYWN0aXZlVGFicy5sZW5ndGggPiAxKSB7XG4gICAgYWN0aXZlVGFiID0gYWN0aXZlVGFic1thY3RpdmVUYWJzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBhY3RpdmVUYWI7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZVRhYkNvbnRlbnQoc2VsZikge1xuICByZXR1cm4gcXVlcnlFbGVtZW50KGdldEFjdGl2ZVRhYihzZWxmKS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSk7XG59XG5cbmZ1bmN0aW9uIHRvZ2dsZVRhYkhhbmRsZXIoc2VsZiwgYWRkKSB7XG4gIGNvbnN0IGFjdGlvbiA9IGFkZCA/IGFkZEV2ZW50TGlzdGVuZXIgOiByZW1vdmVFdmVudExpc3RlbmVyO1xuICBzZWxmLmVsZW1lbnRbYWN0aW9uXSgnY2xpY2snLCB0YWJDbGlja0hhbmRsZXIpO1xufVxuXG4vLyBUQUIgRVZFTlQgSEFORExFUlxuLy8gPT09PT09PT09PT09PT09PT1cbmZ1bmN0aW9uIHRhYkNsaWNrSGFuZGxlcihlKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzW3RhYkNvbXBvbmVudF07XG4gIGUucHJldmVudERlZmF1bHQoKTtcbiAgaWYgKCFzZWxmLm5hdi5pc0FuaW1hdGluZykgc2VsZi5zaG93KCk7XG59XG5cbi8vIFRBQiBERUZJTklUSU9OXG4vLyA9PT09PT09PT09PT09PVxuY2xhc3MgVGFiIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHRhcmdldCkge1xuICAgIHN1cGVyKHRhYkNvbXBvbmVudCwgdGFyZ2V0KTtcbiAgICAvLyBiaW5kXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgY29uc3QgeyBlbGVtZW50IH0gPSBzZWxmO1xuXG4gICAgLy8gZXZlbnQgdGFyZ2V0c1xuICAgIHNlbGYubmF2ID0gZWxlbWVudC5jbG9zZXN0KCcubmF2Jyk7XG4gICAgY29uc3QgeyBuYXYgfSA9IHNlbGY7XG4gICAgc2VsZi5kcm9wZG93biA9IG5hdiAmJiBxdWVyeUVsZW1lbnQoYC4ke2Ryb3Bkb3duTWVudUNsYXNzZXNbMF19LXRvZ2dsZWAsIG5hdik7XG4gICAgYWN0aXZlVGFiQ29udGVudCA9IGdldEFjdGl2ZVRhYkNvbnRlbnQoc2VsZik7XG4gICAgc2VsZi50YWJDb250ZW50ID0gc3VwcG9ydFRyYW5zaXRpb24gJiYgYWN0aXZlVGFiQ29udGVudC5jbG9zZXN0KCcudGFiLWNvbnRlbnQnKTtcbiAgICB0YWJDb250YWluZXJIZWlnaHQgPSBhY3RpdmVUYWJDb250ZW50LnNjcm9sbEhlaWdodDtcblxuICAgIC8vIHNldCBkZWZhdWx0IGFuaW1hdGlvbiBzdGF0ZVxuICAgIG5hdi5pc0FuaW1hdGluZyA9IGZhbHNlO1xuXG4gICAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyXG4gICAgdG9nZ2xlVGFiSGFuZGxlcihzZWxmLCAxKTtcbiAgfVxuXG4gIC8vIFRBQiBQVUJMSUMgTUVUSE9EU1xuICAvLyA9PT09PT09PT09PT09PT09PT1cbiAgc2hvdygpIHsgLy8gdGhlIHRhYiB3ZSBjbGlja2VkIGlzIG5vdyB0aGUgbmV4dFRhYiB0YWJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCB7IGVsZW1lbnQsIG5hdiwgZHJvcGRvd24gfSA9IHNlbGY7XG4gICAgbmV4dFRhYiA9IGVsZW1lbnQ7XG4gICAgaWYgKCFoYXNDbGFzcyhuZXh0VGFiLCBhY3RpdmVDbGFzcykpIHtcbiAgICAgIC8vIHRoaXMgaXMgdGhlIGFjdHVhbCBvYmplY3QsIHRoZSBuZXh0VGFiIHRhYiBjb250ZW50IHRvIGFjdGl2YXRlXG4gICAgICBuZXh0VGFiQ29udGVudCA9IHF1ZXJ5RWxlbWVudChuZXh0VGFiLmdldEF0dHJpYnV0ZSgnaHJlZicpKTtcbiAgICAgIGFjdGl2ZVRhYiA9IGdldEFjdGl2ZVRhYih7IG5hdiB9KTtcbiAgICAgIGFjdGl2ZVRhYkNvbnRlbnQgPSBnZXRBY3RpdmVUYWJDb250ZW50KHsgbmF2IH0pO1xuXG4gICAgICAvLyB1cGRhdGUgcmVsYXRlZFRhcmdldCBhbmQgZGlzcGF0Y2hcbiAgICAgIGhpZGVUYWJFdmVudC5yZWxhdGVkVGFyZ2V0ID0gbmV4dFRhYjtcbiAgICAgIGFjdGl2ZVRhYi5kaXNwYXRjaEV2ZW50KGhpZGVUYWJFdmVudCk7XG4gICAgICBpZiAoaGlkZVRhYkV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgICAgbmF2LmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgIHJlbW92ZUNsYXNzKGFjdGl2ZVRhYiwgYWN0aXZlQ2xhc3MpO1xuICAgICAgYWN0aXZlVGFiLnNldEF0dHJpYnV0ZShhcmlhU2VsZWN0ZWQsICdmYWxzZScpO1xuICAgICAgYWRkQ2xhc3MobmV4dFRhYiwgYWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dFRhYi5zZXRBdHRyaWJ1dGUoYXJpYVNlbGVjdGVkLCAndHJ1ZScpO1xuXG4gICAgICBpZiAoZHJvcGRvd24pIHtcbiAgICAgICAgaWYgKCFoYXNDbGFzcyhlbGVtZW50LnBhcmVudE5vZGUsIGRyb3Bkb3duTWVudUNsYXNzKSkge1xuICAgICAgICAgIGlmIChoYXNDbGFzcyhkcm9wZG93biwgYWN0aXZlQ2xhc3MpKSByZW1vdmVDbGFzcyhkcm9wZG93biwgYWN0aXZlQ2xhc3MpO1xuICAgICAgICB9IGVsc2UgaWYgKCFoYXNDbGFzcyhkcm9wZG93biwgYWN0aXZlQ2xhc3MpKSBhZGRDbGFzcyhkcm9wZG93biwgYWN0aXZlQ2xhc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzQ2xhc3MoYWN0aXZlVGFiQ29udGVudCwgZmFkZUNsYXNzKSkge1xuICAgICAgICByZW1vdmVDbGFzcyhhY3RpdmVUYWJDb250ZW50LCBzaG93Q2xhc3MpO1xuICAgICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZChhY3RpdmVUYWJDb250ZW50LCAoKSA9PiB0cmlnZ2VyVGFiSGlkZShzZWxmKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmlnZ2VyVGFiSGlkZShzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIHRvZ2dsZVRhYkhhbmRsZXIodGhpcyk7XG4gICAgc3VwZXIuZGlzcG9zZSh0YWJDb21wb25lbnQpO1xuICB9XG59XG5cblRhYi5pbml0ID0ge1xuICBjb21wb25lbnQ6IHRhYkNvbXBvbmVudCxcbiAgc2VsZWN0b3I6IHRhYlNlbGVjdG9yLFxuICBjb25zdHJ1Y3RvcjogVGFiLFxufTtcblxuLyogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCA1IHwgVG9hc3Rcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8vIFRPQVNUIFBSSVZBVEUgR0Ncbi8vID09PT09PT09PT09PT09PT1cbmNvbnN0IHRvYXN0U3RyaW5nID0gJ3RvYXN0JztcbmNvbnN0IHRvYXN0Q29tcG9uZW50ID0gJ1RvYXN0JztcbmNvbnN0IHRvYXN0U2VsZWN0b3IgPSBgLiR7dG9hc3RTdHJpbmd9YDtcbmNvbnN0IHRvYXN0RGlzbWlzc1NlbGVjdG9yID0gYFske2RhdGFCc0Rpc21pc3N9PVwiJHt0b2FzdFN0cmluZ31cIl1gO1xuY29uc3Qgc2hvd2luZ0NsYXNzID0gJ3Nob3dpbmcnO1xuY29uc3QgaGlkZUNsYXNzID0gJ2hpZGUnO1xuY29uc3QgdG9hc3REZWZhdWx0T3B0aW9ucyA9IHtcbiAgYW5pbWF0aW9uOiB0cnVlLFxuICBhdXRvaGlkZTogdHJ1ZSxcbiAgZGVsYXk6IDUwMCxcbn07XG5cbi8vIFRPQVNUIENVU1RPTSBFVkVOVFNcbi8vID09PT09PT09PT09PT09PT09PT1cbmNvbnN0IHNob3dUb2FzdEV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoYHNob3cuYnMuJHt0b2FzdFN0cmluZ31gKTtcbmNvbnN0IGhpZGVUb2FzdEV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoYGhpZGUuYnMuJHt0b2FzdFN0cmluZ31gKTtcbmNvbnN0IHNob3duVG9hc3RFdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KGBzaG93bi5icy4ke3RvYXN0U3RyaW5nfWApO1xuY29uc3QgaGlkZGVuVG9hc3RFdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KGBoaWRkZW4uYnMuJHt0b2FzdFN0cmluZ31gKTtcblxuLy8gVE9BU1QgUFJJVkFURSBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PT09PT09PT1cbmZ1bmN0aW9uIHNob3dUb2FzdENvbXBsZXRlKHNlbGYpIHtcbiAgY29uc3QgeyBlbGVtZW50LCBvcHRpb25zIH0gPSBzZWxmO1xuICBpZiAoIW9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgc2hvd2luZ0NsYXNzKTtcbiAgICBhZGRDbGFzcyhlbGVtZW50LCBzaG93Q2xhc3MpO1xuICB9XG5cbiAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHNob3duVG9hc3RFdmVudCk7XG4gIGlmIChvcHRpb25zLmF1dG9oaWRlKSBzZWxmLmhpZGUoKTtcbn1cblxuZnVuY3Rpb24gaGlkZVRvYXN0Q29tcGxldGUoc2VsZikge1xuICBjb25zdCB7IGVsZW1lbnQgfSA9IHNlbGY7XG4gIGFkZENsYXNzKGVsZW1lbnQsIGhpZGVDbGFzcyk7XG4gIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChoaWRkZW5Ub2FzdEV2ZW50KTtcbn1cblxuZnVuY3Rpb24gY2xvc2VUb2FzdChzZWxmKSB7XG4gIGNvbnN0IHsgZWxlbWVudCwgb3B0aW9ucyB9ID0gc2VsZjtcbiAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgc2hvd0NsYXNzKTtcblxuICBpZiAob3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICByZWZsb3coZWxlbWVudCk7XG4gICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoZWxlbWVudCwgKCkgPT4gaGlkZVRvYXN0Q29tcGxldGUoc2VsZikpO1xuICB9IGVsc2Uge1xuICAgIGhpZGVUb2FzdENvbXBsZXRlKHNlbGYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9wZW5Ub2FzdChzZWxmKSB7XG4gIGNvbnN0IHsgZWxlbWVudCwgb3B0aW9ucyB9ID0gc2VsZjtcbiAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgaGlkZUNsYXNzKTtcblxuICBpZiAob3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICByZWZsb3coZWxlbWVudCk7XG4gICAgYWRkQ2xhc3MoZWxlbWVudCwgc2hvd2luZ0NsYXNzKTtcbiAgICBhZGRDbGFzcyhlbGVtZW50LCBzaG93Q2xhc3MpO1xuXG4gICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoZWxlbWVudCwgKCkgPT4gc2hvd1RvYXN0Q29tcGxldGUoc2VsZikpO1xuICB9IGVsc2Uge1xuICAgIHNob3dUb2FzdENvbXBsZXRlKHNlbGYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvZ2dsZVRvYXN0SGFuZGxlcihzZWxmLCBhZGQpIHtcbiAgY29uc3QgYWN0aW9uID0gYWRkID8gYWRkRXZlbnRMaXN0ZW5lciA6IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gIGlmIChzZWxmLmRpc21pc3MpIHtcbiAgICBzZWxmLmRpc21pc3NbYWN0aW9uXSgnY2xpY2snLCBzZWxmLmhpZGUpO1xuICB9XG59XG5cbi8vIFRPQVNUIEVWRU5UIEhBTkRMRVJTXG4vLyA9PT09PT09PT09PT09PT09PT09PVxuZnVuY3Rpb24gY29tcGxldGVEaXNwb3NlVG9hc3Qoc2VsZikge1xuICBjbGVhclRpbWVvdXQoc2VsZi50aW1lcik7XG4gIHRvZ2dsZVRvYXN0SGFuZGxlcihzZWxmKTtcbn1cblxuLy8gVE9BU1QgREVGSU5JVElPTlxuLy8gPT09PT09PT09PT09PT09PVxuY2xhc3MgVG9hc3QgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IodGFyZ2V0LCBjb25maWcpIHtcbiAgICBzdXBlcih0b2FzdENvbXBvbmVudCwgdGFyZ2V0LCB0b2FzdERlZmF1bHRPcHRpb25zLCBjb25maWcpO1xuICAgIC8vIGJpbmRcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIGRpc21pc3MgYnV0dG9uXG4gICAgc2VsZi5kaXNtaXNzID0gcXVlcnlFbGVtZW50KHRvYXN0RGlzbWlzc1NlbGVjdG9yLCBzZWxmLmVsZW1lbnQpO1xuXG4gICAgLy8gYmluZFxuICAgIHNlbGYuc2hvdyA9IHNlbGYuc2hvdy5iaW5kKHNlbGYpO1xuICAgIHNlbGYuaGlkZSA9IHNlbGYuaGlkZS5iaW5kKHNlbGYpO1xuXG4gICAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyXG4gICAgdG9nZ2xlVG9hc3RIYW5kbGVyKHNlbGYsIDEpO1xuICB9XG5cbiAgLy8gVE9BU1QgUFVCTElDIE1FVEhPRFNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cbiAgc2hvdygpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHNlbGY7XG4gICAgaWYgKGVsZW1lbnQgJiYgaGFzQ2xhc3MoZWxlbWVudCwgaGlkZUNsYXNzKSkge1xuICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KHNob3dUb2FzdEV2ZW50KTtcbiAgICAgIGlmIChzaG93VG9hc3RFdmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAgIGFkZENsYXNzKGVsZW1lbnQsIGZhZGVDbGFzcyk7XG4gICAgICBjbGVhclRpbWVvdXQoc2VsZi50aW1lcik7XG4gICAgICBzZWxmLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiBvcGVuVG9hc3Qoc2VsZiksIDEwKTtcbiAgICB9XG4gIH1cblxuICBoaWRlKG5vVGltZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCB7IGVsZW1lbnQsIG9wdGlvbnMgfSA9IHNlbGY7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBoYXNDbGFzcyhlbGVtZW50LCBzaG93Q2xhc3MpKSB7XG4gICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoaGlkZVRvYXN0RXZlbnQpO1xuICAgICAgaWYgKGhpZGVUb2FzdEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZXIpO1xuICAgICAgc2VsZi50aW1lciA9IHNldFRpbWVvdXQoXG4gICAgICAgIGNsb3NlVG9hc3Qoc2VsZiksXG4gICAgICAgIG5vVGltZXIgPyAxMCA6IG9wdGlvbnMuZGVsYXksXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgeyBlbGVtZW50LCBvcHRpb25zIH0gPSBzZWxmO1xuICAgIHNlbGYuaGlkZSgpO1xuXG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uKSBlbXVsYXRlVHJhbnNpdGlvbkVuZChlbGVtZW50LCAoKSA9PiBjb21wbGV0ZURpc3Bvc2VUb2FzdChzZWxmKSk7XG4gICAgZWxzZSBjb21wbGV0ZURpc3Bvc2VUb2FzdChzZWxmKTtcblxuICAgIHN1cGVyLmRpc3Bvc2UodG9hc3RDb21wb25lbnQpO1xuICB9XG59XG5cblRvYXN0LmluaXQgPSB7XG4gIGNvbXBvbmVudDogdG9hc3RDb21wb25lbnQsXG4gIHNlbGVjdG9yOiB0b2FzdFNlbGVjdG9yLFxuICBjb25zdHJ1Y3RvcjogVG9hc3QsXG59O1xuXG5jb25zdCBkYXRhT3JpZ2luYWxUaXRsZSA9ICdkYXRhLW9yaWdpbmFsLXRpdGxlJztcblxuLyogTmF0aXZlIEphdmFTY3JpcHQgZm9yIEJvb3RzdHJhcCA1IHwgVG9vbHRpcFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vLyBUT09MVElQIFBSSVZBVEUgR0Ncbi8vID09PT09PT09PT09PT09PT09PVxuY29uc3QgdG9vbHRpcFN0cmluZyA9ICd0b29sdGlwJztcbmNvbnN0IHRvb2x0aXBDb21wb25lbnQgPSAnVG9vbHRpcCc7XG5jb25zdCB0b29sdGlwU2VsZWN0b3IgPSBgWyR7ZGF0YUJzVG9nZ2xlfT1cIiR7dG9vbHRpcFN0cmluZ31cIl0sW2RhdGEtdGlwPVwiJHt0b29sdGlwU3RyaW5nfVwiXWA7XG5cbmNvbnN0IHRpdGxlQXR0ciA9ICd0aXRsZSc7XG5jb25zdCB0b29sdGlwSW5uZXJDbGFzcyA9IGAke3Rvb2x0aXBTdHJpbmd9LWlubmVyYDtcbmNvbnN0IHRvb2x0aXBEZWZhdWx0T3B0aW9ucyA9IHtcbiAgdGl0bGU6IG51bGwsXG4gIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLFxuICBwbGFjZW1lbnQ6ICd0b3AnLFxuICBhbmltYXRpb246IHRydWUsXG4gIGN1c3RvbUNsYXNzOiBudWxsLFxuICBkZWxheTogMjAwLFxuICBzYW5pdGl6ZUZuOiBudWxsLFxufTtcblxuLy8gVE9PTFRJUCBDVVNUT00gRVZFTlRTXG4vLyA9PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IHNob3dUb29sdGlwRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudChgc2hvdy5icy4ke3Rvb2x0aXBTdHJpbmd9YCk7XG5jb25zdCBzaG93blRvb2x0aXBFdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KGBzaG93bi5icy4ke3Rvb2x0aXBTdHJpbmd9YCk7XG5jb25zdCBoaWRlVG9vbHRpcEV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoYGhpZGUuYnMuJHt0b29sdGlwU3RyaW5nfWApO1xuY29uc3QgaGlkZGVuVG9vbHRpcEV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoYGhpZGRlbi5icy4ke3Rvb2x0aXBTdHJpbmd9YCk7XG5cbi8vIFRPT0xUSVAgUFJJVkFURSBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcChzZWxmKSB7XG4gIGNvbnN0IHsgb3B0aW9ucywgaWQgfSA9IHNlbGY7XG4gIGNvbnN0IHBsYWNlbWVudENsYXNzID0gYGJzLSR7dG9vbHRpcFN0cmluZ30tJHt0aXBDbGFzc1Bvc2l0aW9uc1tvcHRpb25zLnBsYWNlbWVudF19YDtcbiAgbGV0IHRpdGxlU3RyaW5nID0gb3B0aW9ucy50aXRsZS50cmltKCk7XG5cbiAgLy8gc2FuaXRpemUgc3R1ZmZcbiAgaWYgKG9wdGlvbnMuc2FuaXRpemVGbikge1xuICAgIHRpdGxlU3RyaW5nID0gb3B0aW9ucy5zYW5pdGl6ZUZuKHRpdGxlU3RyaW5nKTtcbiAgICBvcHRpb25zLnRlbXBsYXRlID0gb3B0aW9ucy5zYW5pdGl6ZUZuKG9wdGlvbnMudGVtcGxhdGUpO1xuICB9XG5cbiAgaWYgKCF0aXRsZVN0cmluZykgcmV0dXJuO1xuXG4gIC8vIGNyZWF0ZSB0b29sdGlwXG4gIHNlbGYudG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb25zdCB7IHRvb2x0aXAgfSA9IHNlbGY7XG5cbiAgLy8gc2V0IGFyaWFcbiAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQpO1xuXG4gIC8vIHNldCBtYXJrdXBcbiAgY29uc3QgdG9vbHRpcE1hcmt1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0b29sdGlwTWFya3VwLmlubmVySFRNTCA9IG9wdGlvbnMudGVtcGxhdGUudHJpbSgpO1xuXG4gIHRvb2x0aXAuY2xhc3NOYW1lID0gdG9vbHRpcE1hcmt1cC5maXJzdENoaWxkLmNsYXNzTmFtZTtcbiAgdG9vbHRpcC5pbm5lckhUTUwgPSB0b29sdGlwTWFya3VwLmZpcnN0Q2hpbGQuaW5uZXJIVE1MO1xuXG4gIHF1ZXJ5RWxlbWVudChgLiR7dG9vbHRpcElubmVyQ2xhc3N9YCwgdG9vbHRpcCkuaW5uZXJIVE1MID0gdGl0bGVTdHJpbmc7XG5cbiAgLy8gc2V0IGFycm93XG4gIHNlbGYuYXJyb3cgPSBxdWVyeUVsZW1lbnQoYC4ke3Rvb2x0aXBTdHJpbmd9LWFycm93YCwgdG9vbHRpcCk7XG5cbiAgLy8gc2V0IGNsYXNzIGFuZCByb2xlIGF0dHJpYnV0ZVxuICB0b29sdGlwLnNldEF0dHJpYnV0ZSgncm9sZScsIHRvb2x0aXBTdHJpbmcpO1xuICAvLyBzZXQgY2xhc3Nlc1xuICBpZiAoIWhhc0NsYXNzKHRvb2x0aXAsIHRvb2x0aXBTdHJpbmcpKSBhZGRDbGFzcyh0b29sdGlwLCB0b29sdGlwU3RyaW5nKTtcbiAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uICYmICFoYXNDbGFzcyh0b29sdGlwLCBmYWRlQ2xhc3MpKSBhZGRDbGFzcyh0b29sdGlwLCBmYWRlQ2xhc3MpO1xuICBpZiAob3B0aW9ucy5jdXN0b21DbGFzcyAmJiAhaGFzQ2xhc3ModG9vbHRpcCwgb3B0aW9ucy5jdXN0b21DbGFzcykpIHtcbiAgICBhZGRDbGFzcyh0b29sdGlwLCBvcHRpb25zLmN1c3RvbUNsYXNzKTtcbiAgfVxuICBpZiAoIWhhc0NsYXNzKHRvb2x0aXAsIHBsYWNlbWVudENsYXNzKSkgYWRkQ2xhc3ModG9vbHRpcCwgcGxhY2VtZW50Q2xhc3MpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVUb29sdGlwKHNlbGYpIHtcbiAgY29uc3QgeyBlbGVtZW50LCBvcHRpb25zLCB0b29sdGlwIH0gPSBzZWxmO1xuICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhcmlhRGVzY3JpYmVkQnkpO1xuICBvcHRpb25zLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0b29sdGlwKTtcbiAgc2VsZi50aW1lciA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGRpc3Bvc2VUb29sdGlwQ29tcGxldGUoc2VsZikge1xuICBjb25zdCB7IGVsZW1lbnQgfSA9IHNlbGY7XG4gIHRvZ2dsZVRvb2x0aXBIYW5kbGVycyhzZWxmKTtcbiAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKGRhdGFPcmlnaW5hbFRpdGxlKSkgdG9nZ2xlVG9vbHRpcFRpdGxlKHNlbGYpO1xufVxuZnVuY3Rpb24gdG9nZ2xlVG9vbHRpcEFjdGlvbihzZWxmLCBhZGQpIHtcbiAgY29uc3QgYWN0aW9uID0gYWRkID8gYWRkRXZlbnRMaXN0ZW5lciA6IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbiAgZG9jdW1lbnRbYWN0aW9uXSgndG91Y2hzdGFydCcsIHRvb2x0aXBUb3VjaEhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyKTtcblxuICBpZiAoIWlzTWVkaWEoc2VsZi5lbGVtZW50KSkge1xuICAgIHdpbmRvd1thY3Rpb25dKCdzY3JvbGwnLCBzZWxmLnVwZGF0ZSwgcGFzc2l2ZUhhbmRsZXIpO1xuICAgIHdpbmRvd1thY3Rpb25dKCdyZXNpemUnLCBzZWxmLnVwZGF0ZSwgcGFzc2l2ZUhhbmRsZXIpO1xuICB9XG59XG5mdW5jdGlvbiB0b29sdGlwU2hvd25BY3Rpb24oc2VsZikge1xuICB0b2dnbGVUb29sdGlwQWN0aW9uKHNlbGYsIDEpO1xuICBzZWxmLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChzaG93blRvb2x0aXBFdmVudCk7XG59XG5mdW5jdGlvbiB0b29sdGlwSGlkZGVuQWN0aW9uKHNlbGYpIHtcbiAgdG9nZ2xlVG9vbHRpcEFjdGlvbihzZWxmKTtcbiAgcmVtb3ZlVG9vbHRpcChzZWxmKTtcbiAgc2VsZi5lbGVtZW50LmRpc3BhdGNoRXZlbnQoaGlkZGVuVG9vbHRpcEV2ZW50KTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZVRvb2x0aXBIYW5kbGVycyhzZWxmLCBhZGQpIHtcbiAgY29uc3QgYWN0aW9uID0gYWRkID8gYWRkRXZlbnRMaXN0ZW5lciA6IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gIGNvbnN0IHsgZWxlbWVudCB9ID0gc2VsZjtcblxuICBpZiAoaXNNZWRpYShlbGVtZW50KSkgZWxlbWVudFthY3Rpb25dKCdtb3VzZW1vdmUnLCBzZWxmLnVwZGF0ZSwgcGFzc2l2ZUhhbmRsZXIpO1xuICBlbGVtZW50W2FjdGlvbl0oJ21vdXNlZG93bicsIHNlbGYuc2hvdyk7XG4gIGVsZW1lbnRbYWN0aW9uXSgnbW91c2VlbnRlcicsIHNlbGYuc2hvdyk7XG4gIGVsZW1lbnRbYWN0aW9uXSgnbW91c2VsZWF2ZScsIHNlbGYuaGlkZSk7XG59XG5cbmZ1bmN0aW9uIHRvZ2dsZVRvb2x0aXBUaXRsZShzZWxmLCBjb250ZW50KSB7XG4gIC8vIFswIC0gYWRkLCAxIC0gcmVtb3ZlXSB8IFswIC0gcmVtb3ZlLCAxIC0gYWRkXVxuICBjb25zdCB0aXRsZUF0dCA9IFtkYXRhT3JpZ2luYWxUaXRsZSwgdGl0bGVBdHRyXTtcbiAgY29uc3QgeyBlbGVtZW50IH0gPSBzZWxmO1xuXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKHRpdGxlQXR0W2NvbnRlbnQgPyAwIDogMV0sXG4gICAgKGNvbnRlbnQgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUodGl0bGVBdHRbMF0pKSk7XG4gIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHRpdGxlQXR0W2NvbnRlbnQgPyAxIDogMF0pO1xufVxuXG4vLyBUT09MVElQIEVWRU5UIEhBTkRMRVJTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09XG5mdW5jdGlvbiB0b29sdGlwVG91Y2hIYW5kbGVyKHsgdGFyZ2V0IH0pIHtcbiAgY29uc3QgeyB0b29sdGlwLCBlbGVtZW50IH0gPSB0aGlzO1xuICBpZiAodG9vbHRpcC5jb250YWlucyh0YXJnZXQpIHx8IHRhcmdldCA9PT0gZWxlbWVudCB8fCBlbGVtZW50LmNvbnRhaW5zKHRhcmdldCkpIDsgZWxzZSB7XG4gICAgdGhpcy5oaWRlKCk7XG4gIH1cbn1cblxuLy8gVE9PTFRJUCBERUZJTklUSU9OXG4vLyA9PT09PT09PT09PT09PT09PT1cbmNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IodGFyZ2V0LCBjb25maWcpIHtcbiAgICAvLyBpbml0aWFsaXphdGlvbiBlbGVtZW50XG4gICAgY29uc3QgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudCh0YXJnZXQpO1xuICAgIHRvb2x0aXBEZWZhdWx0T3B0aW9ucy50aXRsZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKHRpdGxlQXR0cik7XG4gICAgdG9vbHRpcERlZmF1bHRPcHRpb25zLmNvbnRhaW5lciA9IGdldFRpcENvbnRhaW5lcihlbGVtZW50KTtcbiAgICBzdXBlcih0b29sdGlwQ29tcG9uZW50LCBlbGVtZW50LCB0b29sdGlwRGVmYXVsdE9wdGlvbnMsIGNvbmZpZyk7XG5cbiAgICAvLyBiaW5kXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAgICBzZWxmLnRvb2x0aXAgPSBudWxsO1xuICAgIHNlbGYuYXJyb3cgPSBudWxsO1xuICAgIHNlbGYudGltZXIgPSBudWxsO1xuICAgIHNlbGYuZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLy8gaW5zdGFuY2Ugb3B0aW9uc1xuICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gc2VsZjtcblxuICAgIC8vIG1lZGlhIGVsZW1lbnRzIG9ubHkgd29yayB3aXRoIGJvZHkgYXMgYSBjb250YWluZXJcbiAgICBzZWxmLm9wdGlvbnMuY29udGFpbmVyID0gaXNNZWRpYShlbGVtZW50KVxuICAgICAgPyB0b29sdGlwRGVmYXVsdE9wdGlvbnMuY29udGFpbmVyXG4gICAgICA6IHF1ZXJ5RWxlbWVudChvcHRpb25zLmNvbnRhaW5lcik7XG5cbiAgICAvLyByZXNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICB0b29sdGlwRGVmYXVsdE9wdGlvbnMuY29udGFpbmVyID0gbnVsbDtcbiAgICB0b29sdGlwRGVmYXVsdE9wdGlvbnNbdGl0bGVBdHRyXSA9IG51bGw7XG5cbiAgICAvLyBpbnZhbGlkYXRlXG4gICAgaWYgKCFvcHRpb25zLnRpdGxlKSByZXR1cm47XG5cbiAgICAvLyBhbGwgZnVuY3Rpb25zIGJpbmRcbiAgICB0b29sdGlwVG91Y2hIYW5kbGVyLmJpbmQoc2VsZik7XG4gICAgc2VsZi51cGRhdGUgPSBzZWxmLnVwZGF0ZS5iaW5kKHNlbGYpO1xuXG4gICAgLy8gc2V0IHRpdGxlIGF0dHJpYnV0ZXMgYW5kIGFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUodGl0bGVBdHRyKSkgdG9nZ2xlVG9vbHRpcFRpdGxlKHNlbGYsIG9wdGlvbnMudGl0bGUpO1xuXG4gICAgLy8gY3JlYXRlIHRvb2x0aXAgaGVyZVxuICAgIHNlbGYuaWQgPSBgJHt0b29sdGlwU3RyaW5nfS0ke2dldFVJRChlbGVtZW50KX1gO1xuICAgIGNyZWF0ZVRvb2x0aXAoc2VsZik7XG5cbiAgICAvLyBhdHRhY2ggZXZlbnRzXG4gICAgdG9nZ2xlVG9vbHRpcEhhbmRsZXJzKHNlbGYsIDEpO1xuICB9XG5cbiAgLy8gVE9PTFRJUCBQVUJMSUMgTUVUSE9EU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG4gIHNob3coZSkge1xuICAgIGNvbnN0IHNlbGYgPSBlID8gdGhpc1t0b29sdGlwQ29tcG9uZW50XSA6IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgb3B0aW9ucywgdG9vbHRpcCwgZWxlbWVudCwgaWQsXG4gICAgfSA9IHNlbGY7XG4gICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZXIpO1xuICAgIHNlbGYudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghaXNWaXNpYmxlVGlwKHRvb2x0aXAsIG9wdGlvbnMuY29udGFpbmVyKSkge1xuICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoc2hvd1Rvb2x0aXBFdmVudCk7XG4gICAgICAgIGlmIChzaG93VG9vbHRpcEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgICAgICAvLyBhcHBlbmQgdG8gY29udGFpbmVyXG4gICAgICAgIG9wdGlvbnMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRvb2x0aXApO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhcmlhRGVzY3JpYmVkQnksIGlkKTtcblxuICAgICAgICBzZWxmLnVwZGF0ZShlKTtcbiAgICAgICAgaWYgKCFoYXNDbGFzcyh0b29sdGlwLCBzaG93Q2xhc3MpKSBhZGRDbGFzcyh0b29sdGlwLCBzaG93Q2xhc3MpO1xuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24pIGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRvb2x0aXAsICgpID0+IHRvb2x0aXBTaG93bkFjdGlvbihzZWxmKSk7XG4gICAgICAgIGVsc2UgdG9vbHRpcFNob3duQWN0aW9uKHNlbGYpO1xuICAgICAgfVxuICAgIH0sIDIwKTtcbiAgfVxuXG4gIGhpZGUoZSkge1xuICAgIGNvbnN0IHNlbGYgPSBlID8gdGhpc1t0b29sdGlwQ29tcG9uZW50XSA6IHRoaXM7XG4gICAgY29uc3QgeyBvcHRpb25zLCB0b29sdGlwLCBlbGVtZW50IH0gPSBzZWxmO1xuXG4gICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZXIpO1xuICAgIHNlbGYudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChpc1Zpc2libGVUaXAodG9vbHRpcCwgb3B0aW9ucy5jb250YWluZXIpKSB7XG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChoaWRlVG9vbHRpcEV2ZW50KTtcbiAgICAgICAgaWYgKGhpZGVUb29sdGlwRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gICAgICAgIHJlbW92ZUNsYXNzKHRvb2x0aXAsIHNob3dDbGFzcyk7XG4gICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbikgZW11bGF0ZVRyYW5zaXRpb25FbmQodG9vbHRpcCwgKCkgPT4gdG9vbHRpcEhpZGRlbkFjdGlvbihzZWxmKSk7XG4gICAgICAgIGVsc2UgdG9vbHRpcEhpZGRlbkFjdGlvbihzZWxmKTtcbiAgICAgIH1cbiAgICB9LCBvcHRpb25zLmRlbGF5KTtcbiAgfVxuXG4gIHVwZGF0ZShlKSB7XG4gICAgc3R5bGVUaXAodGhpcywgZSk7XG4gIH1cblxuICB0b2dnbGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgeyB0b29sdGlwLCBvcHRpb25zIH0gPSBzZWxmO1xuICAgIGlmICghaXNWaXNpYmxlVGlwKHRvb2x0aXAsIG9wdGlvbnMuY29udGFpbmVyKSkgc2VsZi5zaG93KCk7XG4gICAgZWxzZSBzZWxmLmhpZGUoKTtcbiAgfVxuXG4gIGVuYWJsZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCB7IGVuYWJsZWQgfSA9IHNlbGY7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICB0b2dnbGVUb29sdGlwSGFuZGxlcnMoc2VsZiwgMSk7XG4gICAgICBzZWxmLmVuYWJsZWQgPSAhZW5hYmxlZDtcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHsgdG9vbHRpcCwgb3B0aW9ucywgZW5hYmxlZCB9ID0gc2VsZjtcbiAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgaWYgKCFpc1Zpc2libGVUaXAodG9vbHRpcCwgb3B0aW9ucy5jb250YWluZXIpICYmIG9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgIHNlbGYuaGlkZSgpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgKCkgPT4gdG9nZ2xlVG9vbHRpcEhhbmRsZXJzKHNlbGYpLFxuICAgICAgICAgIGdldEVsZW1lbnRUcmFuc2l0aW9uRHVyYXRpb24odG9vbHRpcCkgKyBvcHRpb25zLmRlbGF5ICsgMTcsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2dnbGVUb29sdGlwSGFuZGxlcnMoc2VsZik7XG4gICAgICB9XG4gICAgICBzZWxmLmVuYWJsZWQgPSAhZW5hYmxlZDtcbiAgICB9XG4gIH1cblxuICB0b2dnbGVFbmFibGVkKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5lbmFibGVkKSBzZWxmLmVuYWJsZSgpO1xuICAgIGVsc2Ugc2VsZi5kaXNhYmxlKCk7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHsgdG9vbHRpcCwgb3B0aW9ucyB9ID0gc2VsZjtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiAmJiBpc1Zpc2libGVUaXAodG9vbHRpcCwgb3B0aW9ucy5jb250YWluZXIpKSB7XG4gICAgICBvcHRpb25zLmRlbGF5ID0gMDsgLy8gcmVzZXQgZGVsYXlcbiAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQodG9vbHRpcCwgKCkgPT4gZGlzcG9zZVRvb2x0aXBDb21wbGV0ZShzZWxmKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3Bvc2VUb29sdGlwQ29tcGxldGUoc2VsZik7XG4gICAgfVxuICAgIHN1cGVyLmRpc3Bvc2UodG9vbHRpcENvbXBvbmVudCk7XG4gIH1cbn1cblxuVG9vbHRpcC5pbml0ID0ge1xuICBjb21wb25lbnQ6IHRvb2x0aXBDb21wb25lbnQsXG4gIHNlbGVjdG9yOiB0b29sdGlwU2VsZWN0b3IsXG4gIGNvbnN0cnVjdG9yOiBUb29sdGlwLFxufTtcblxudmFyIHZlcnNpb24gPSBcIjMuMC4xNVwiO1xuXG4vLyBpbXBvcnQgeyBhbGVydEluaXQgfSBmcm9tICcuLi9jb21wb25lbnRzL2FsZXJ0LW5hdGl2ZS5qcyc7XG4vLyBpbXBvcnQgeyBidXR0b25Jbml0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9idXR0b24tbmF0aXZlLmpzJztcbi8vIGltcG9ydCB7IGNhcm91c2VsSW5pdCB9IGZyb20gJy4uL2NvbXBvbmVudHMvY2Fyb3VzZWwtbmF0aXZlLmpzJztcbi8vIGltcG9ydCB7IGNvbGxhcHNlSW5pdCB9IGZyb20gJy4uL2NvbXBvbmVudHMvY29sbGFwc2UtbmF0aXZlLmpzJztcbi8vIGltcG9ydCB7IGRyb3Bkb3duSW5pdCB9IGZyb20gJy4uL2NvbXBvbmVudHMvZHJvcGRvd24tbmF0aXZlLmpzJztcbi8vIGltcG9ydCB7IG1vZGFsSW5pdCB9IGZyb20gJy4uL2NvbXBvbmVudHMvbW9kYWwtbmF0aXZlLmpzJztcbi8vIGltcG9ydCB7IG9mZmNhbnZhc0luaXQgfSBmcm9tICcuLi9jb21wb25lbnRzL29mZmNhbnZhcy1uYXRpdmUuanMnO1xuLy8gaW1wb3J0IHsgcG9wb3ZlckluaXQgfSBmcm9tICcuLi9jb21wb25lbnRzL3BvcG92ZXItbmF0aXZlLmpzJztcbi8vIGltcG9ydCB7IHNjcm9sbFNweUluaXQgfSBmcm9tICcuLi9jb21wb25lbnRzL3Njcm9sbHNweS1uYXRpdmUuanMnO1xuLy8gaW1wb3J0IHsgdGFiSW5pdCB9IGZyb20gJy4uL2NvbXBvbmVudHMvdGFiLW5hdGl2ZS5qcyc7XG4vLyBpbXBvcnQgeyB0b2FzdEluaXQgfSBmcm9tICcuLi9jb21wb25lbnRzL3RvYXN0LW5hdGl2ZS5qcyc7XG4vLyBpbXBvcnQgeyB0b29sdGlwSW5pdCB9IGZyb20gJy4uL2NvbXBvbmVudHMvdG9vbHRpcC1uYXRpdmUuanMnO1xuXG5jb25zdCBjb21wb25lbnRzSW5pdCA9IHtcbiAgQWxlcnQ6IEFsZXJ0LmluaXQsXG4gIEJ1dHRvbjogQnV0dG9uLmluaXQsXG4gIENhcm91c2VsOiBDYXJvdXNlbC5pbml0LFxuICBDb2xsYXBzZTogQ29sbGFwc2UuaW5pdCxcbiAgRHJvcGRvd246IERyb3Bkb3duLmluaXQsXG4gIE1vZGFsOiBNb2RhbC5pbml0LFxuICBPZmZjYW52YXM6IE9mZmNhbnZhcy5pbml0LFxuICBQb3BvdmVyOiBQb3BvdmVyLmluaXQsXG4gIFNjcm9sbFNweTogU2Nyb2xsU3B5LmluaXQsXG4gIFRhYjogVGFiLmluaXQsXG4gIFRvYXN0OiBUb2FzdC5pbml0LFxuICBUb29sdGlwOiBUb29sdGlwLmluaXQsXG59O1xuXG5mdW5jdGlvbiBpbml0aWFsaXplRGF0YUFQSShLb25zdHJ1Y3RvciwgY29sbGVjdGlvbikge1xuICBBcnJheS5mcm9tKGNvbGxlY3Rpb24pLmZvckVhY2goKHgpID0+IG5ldyBLb25zdHJ1Y3Rvcih4KSk7XG59XG5cbmZ1bmN0aW9uIGluaXRDYWxsYmFjayhjb250ZXh0KSB7XG4gIGNvbnN0IGxvb2tVcCA9IGNvbnRleHQgaW5zdGFuY2VvZiBFbGVtZW50ID8gY29udGV4dCA6IGRvY3VtZW50O1xuXG4gIE9iamVjdC5rZXlzKGNvbXBvbmVudHNJbml0KS5mb3JFYWNoKChjb21wKSA9PiB7XG4gICAgY29uc3QgeyBjb25zdHJ1Y3Rvciwgc2VsZWN0b3IgfSA9IGNvbXBvbmVudHNJbml0W2NvbXBdO1xuICAgIGluaXRpYWxpemVEYXRhQVBJKGNvbnN0cnVjdG9yLCBsb29rVXAucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICB9KTtcbn1cblxuLy8gYnVsayBpbml0aWFsaXplIGFsbCBjb21wb25lbnRzXG5pZiAoZG9jdW1lbnQuYm9keSkgaW5pdENhbGxiYWNrKCk7XG5lbHNlIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IGluaXRDYWxsYmFjaygpLCB7IG9uY2U6IHRydWUgfSk7XG59XG5cbnZhciBpbmRleCA9IHtcbiAgQWxlcnQsXG4gIEJ1dHRvbixcbiAgQ2Fyb3VzZWwsXG4gIENvbGxhcHNlLFxuICBEcm9wZG93bixcbiAgTW9kYWwsXG4gIE9mZmNhbnZhcyxcbiAgUG9wb3ZlcixcbiAgU2Nyb2xsU3B5LFxuICBUYWIsXG4gIFRvYXN0LFxuICBUb29sdGlwLFxuXG4gIGluaXRDYWxsYmFjayxcbiAgVmVyc2lvbjogdmVyc2lvbixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbmNvbnN0IGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbmNvbnN0IGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sWydmb3InXSA9PT0gJ2Z1bmN0aW9uJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA/IFN5bWJvbFsnZm9yJ10oJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG5jb25zdCBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGNvbnN0IHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgY29uc3QgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICBjb25zdCBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheVZpZXcgKGFycmF5Vmlldykge1xuICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5VmlldylcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aClcbiAgfVxuICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBsZXQgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIGxldCB4ID0gYS5sZW5ndGhcbiAgbGV0IHkgPSBiLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICBsZXQgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGxldCBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgYnVmLFxuICAgICAgICAgIHBvc1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIH1cbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgY29uc3QgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgY29uc3QgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgbGV0IHN0ciA9ICcnXG4gIGNvbnN0IG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIGxldCB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICBsZXQgeSA9IGVuZCAtIHN0YXJ0XG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgY29uc3QgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgY29uc3QgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIGxldCBpbmRleFNpemUgPSAxXG4gIGxldCBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIGxldCB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIGxldCBpXG4gIGlmIChkaXIpIHtcbiAgICBsZXQgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgY29uc3QgcmVzID0gW11cblxuICBsZXQgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgbGV0IGNvZGVQb2ludCA9IG51bGxcbiAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKVxuICAgICAgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKVxuICAgICAgICAgID8gM1xuICAgICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpXG4gICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIGxldCBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbmNvbnN0IE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICBjb25zdCBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICBsZXQgb3V0ID0gJydcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICBsZXQgcmVzID0gJydcbiAgLy8gSWYgYnl0ZXMubGVuZ3RoIGlzIG9kZCwgdGhlIGxhc3QgOCBiaXRzIG11c3QgYmUgaWdub3JlZCAoc2FtZSBhcyBub2RlLmpzKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICBjb25zdCBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIGxldCBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgbG8gPSBmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0XG5cbiAgY29uc3QgaGkgPSB0aGlzWysrb2Zmc2V0XSArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgbGFzdCAqIDIgKiogMjRcblxuICByZXR1cm4gQmlnSW50KGxvKSArIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBoaSA9IGZpcnN0ICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICBjb25zdCBsbyA9IHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdFxuXG4gIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbylcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgaSA9IGJ5dGVMZW5ndGhcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgNF0gK1xuICAgIHRoaXNbb2Zmc2V0ICsgNV0gKiAyICoqIDggK1xuICAgIHRoaXNbb2Zmc2V0ICsgNl0gKiAyICoqIDE2ICtcbiAgICAobGFzdCA8PCAyNCkgLy8gT3ZlcmZsb3dcblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQoZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSAoZmlyc3QgPDwgMjQpICsgLy8gT3ZlcmZsb3dcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludCh0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3QpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NExFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIHJldHVybiBvZmZzZXRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0QkUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDddID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA2XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNV0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDRdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyAzXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMl0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDFdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXRdID0gaGlcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSAwXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICBjb25zdCBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIGxldCBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIENVU1RPTSBFUlJPUlNcbi8vID09PT09PT09PT09PT1cblxuLy8gU2ltcGxpZmllZCB2ZXJzaW9ucyBmcm9tIE5vZGUsIGNoYW5nZWQgZm9yIEJ1ZmZlci1vbmx5IHVzYWdlXG5jb25zdCBlcnJvcnMgPSB7fVxuZnVuY3Rpb24gRSAoc3ltLCBnZXRNZXNzYWdlLCBCYXNlKSB7XG4gIGVycm9yc1tzeW1dID0gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgc3VwZXIoKVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiBnZXRNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFkZCB0aGUgZXJyb3IgY29kZSB0byB0aGUgbmFtZSB0byBpbmNsdWRlIGl0IGluIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMubmFtZX0gWyR7c3ltfV1gXG4gICAgICAvLyBBY2Nlc3MgdGhlIHN0YWNrIHRvIGdlbmVyYXRlIHRoZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZVxuICAgICAgLy8gZnJvbSB0aGUgbmFtZS5cbiAgICAgIHRoaXMuc3RhY2sgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgIC8vIFJlc2V0IHRoZSBuYW1lIHRvIHRoZSBhY3R1YWwgbmFtZS5cbiAgICAgIGRlbGV0ZSB0aGlzLm5hbWVcbiAgICB9XG5cbiAgICBnZXQgY29kZSAoKSB7XG4gICAgICByZXR1cm4gc3ltXG4gICAgfVxuXG4gICAgc2V0IGNvZGUgKHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvZGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske3N5bX1dOiAke3RoaXMubWVzc2FnZX1gXG4gICAgfVxuICB9XG59XG5cbkUoJ0VSUl9CVUZGRVJfT1VUX09GX0JPVU5EUycsXG4gIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiBgJHtuYW1lfSBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgXG4gICAgfVxuXG4gICAgcmV0dXJuICdBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzJ1xuICB9LCBSYW5nZUVycm9yKVxuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLFxuICBmdW5jdGlvbiAobmFtZSwgYWN0dWFsKSB7XG4gICAgcmV0dXJuIGBUaGUgXCIke25hbWV9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YFxuICB9LCBUeXBlRXJyb3IpXG5FKCdFUlJfT1VUX09GX1JBTkdFJyxcbiAgZnVuY3Rpb24gKHN0ciwgcmFuZ2UsIGlucHV0KSB7XG4gICAgbGV0IG1zZyA9IGBUaGUgdmFsdWUgb2YgXCIke3N0cn1cIiBpcyBvdXQgb2YgcmFuZ2UuYFxuICAgIGxldCByZWNlaXZlZCA9IGlucHV0XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IDIgKiogMzIpIHtcbiAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dClcbiAgICAgIGlmIChpbnB1dCA+IEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpIHx8IGlucHV0IDwgLShCaWdJbnQoMikgKiogQmlnSW50KDMyKSkpIHtcbiAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IocmVjZWl2ZWQpXG4gICAgICB9XG4gICAgICByZWNlaXZlZCArPSAnbidcbiAgICB9XG4gICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gXG4gICAgcmV0dXJuIG1zZ1xuICB9LCBSYW5nZUVycm9yKVxuXG5mdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IgKHZhbCkge1xuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSB2YWwubGVuZ3RoXG4gIGNvbnN0IHN0YXJ0ID0gdmFsWzBdID09PSAnLScgPyAxIDogMFxuICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykge1xuICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWBcbiAgfVxuICByZXR1cm4gYCR7dmFsLnNsaWNlKDAsIGkpfSR7cmVzfWBcbn1cblxuLy8gQ0hFQ0sgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gY2hlY2tCb3VuZHMgKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGlmIChidWZbb2Zmc2V0XSA9PT0gdW5kZWZpbmVkIHx8IGJ1ZltvZmZzZXQgKyBieXRlTGVuZ3RoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCBidWYubGVuZ3RoIC0gKGJ5dGVMZW5ndGggKyAxKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ludEJJICh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikge1xuICAgIGNvbnN0IG4gPSB0eXBlb2YgbWluID09PSAnYmlnaW50JyA/ICduJyA6ICcnXG4gICAgbGV0IHJhbmdlXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAzKSB7XG4gICAgICBpZiAobWluID09PSAwIHx8IG1pbiA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgIHJhbmdlID0gYD49IDAke259IGFuZCA8IDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDh9JHtufWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gYD49IC0oMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufSkgYW5kIDwgMiAqKiBgICtcbiAgICAgICAgICAgICAgICBgJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufWBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2UgPSBgPj0gJHttaW59JHtufSBhbmQgPD0gJHttYXh9JHtufWBcbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKCd2YWx1ZScsIHJhbmdlLCB2YWx1ZSlcbiAgfVxuICBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIgKHZhbHVlLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gYm91bmRzRXJyb3IgKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHtcbiAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCB0eXBlKVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLCAnYW4gaW50ZWdlcicsIHZhbHVlKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpXG4gIH1cblxuICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA+PSAke3R5cGUgPyAxIDogMH0gYW5kIDw9ICR7bGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSlcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5jb25zdCBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgbGV0IGNvZGVQb2ludFxuICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIGxldCBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICBjb25zdCBieXRlcyA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgbGV0IGMsIGhpLCBsb1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG5jb25zdCBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgY29uc3QgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBjb25zdCBpMTYgPSBpICogMTZcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcblxuLy8gUmV0dXJuIG5vdCBmdW5jdGlvbiB3aXRoIEVycm9yIGlmIEJpZ0ludCBub3Qgc3VwcG9ydGVkXG5mdW5jdGlvbiBkZWZpbmVCaWdJbnRNZXRob2QgKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmblxufVxuXG5mdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdCaWdJbnQgbm90IHN1cHBvcnRlZCcpXG59XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc2xpY2UoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1hZ2VzL29icy1jcmVhdGUtdGV4dC1zb3VyY2UucG5nXCI7IiwiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltYWdlcy9vYnMtd2Vic29ja2V0LWNvbm5lY3Rpb24ucG5nXCI7IiwiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXhvZ2Rlbi93ZWJzb2NrZXQtc3RyZWFtL2Jsb2IvNDhkYzNkZGY5NDNlNWFkYTY2OGMzMWNjZDk0ZTkxODZmMDJmYWZiZC93cy1mYWxsYmFjay5qc1xuXG52YXIgd3MgPSBudWxsXG5cbmlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICB3cyA9IFdlYlNvY2tldFxufSBlbHNlIGlmICh0eXBlb2YgTW96V2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICB3cyA9IE1veldlYlNvY2tldFxufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICB3cyA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldFxufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3cyA9IHdpbmRvdy5XZWJTb2NrZXQgfHwgd2luZG93Lk1veldlYlNvY2tldFxufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd3MgPSBzZWxmLldlYlNvY2tldCB8fCBzZWxmLk1veldlYlNvY2tldFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdzXG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsImNvbnN0IFNvY2tldCA9IHJlcXVpcmUoJy4vU29ja2V0Jyk7XG5jb25zdCBTdGF0dXMgPSByZXF1aXJlKCcuL1N0YXR1cycpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdvYnMtd2Vic29ja2V0LWpzOkNvcmUnKTtcblxubGV0IHJlcXVlc3RDb3VudGVyID0gMDtcblxuZnVuY3Rpb24gZ2VuZXJhdGVNZXNzYWdlSWQoKSB7XG4gIHJldHVybiBTdHJpbmcocmVxdWVzdENvdW50ZXIrKyk7XG59XG5cbmNsYXNzIE9CU1dlYlNvY2tldCBleHRlbmRzIFNvY2tldCB7XG4gIC8qKlxuICAgKiBHZW5lcmljIFNvY2tldCByZXF1ZXN0IG1ldGhvZC4gUmV0dXJucyBhIHByb21pc2UuXG4gICAqIEdlbmVyYXRlcyBhIG1lc3NhZ2VJZCBpbnRlcm5hbGx5IGFuZCB3aWxsIG92ZXJyaWRlIGFueSBwYXNzZWQgaW4gdGhlIGFyZ3MuXG4gICAqIE5vdGUgdGhhdCB0aGUgcmVxdWVzdFR5cGUgaGVyZSBpcyBwcmUtbWFyc2hhbGluZyBhbmQgY3VycmVudGx5IG11c3QgbWF0Y2ggZXhhY3RseSB3aGF0IHRoZSB3ZWJzb2NrZXQgcGx1Z2luIGlzIGV4cGVjdGluZy5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgIHJlcXVlc3RUeXBlIG9icy13ZWJzb2NrZXQgcGx1Z2luIGV4cGVjdGVkIHJlcXVlc3QgdHlwZS5cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIFthcmdzPXt9XSAgIHJlcXVlc3QgYXJndW1lbnRzLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgUHJvbWlzZSwgcGFzc2VzIHRoZSBwbHVnaW4gcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgc2VuZChyZXF1ZXN0VHlwZSwgYXJncyA9IHt9KSB7XG4gICAgYXJncyA9IGFyZ3MgfHwge307XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZUlkID0gZ2VuZXJhdGVNZXNzYWdlSWQoKTtcbiAgICAgIGxldCByZWplY3RSZWFzb247XG5cbiAgICAgIGlmICghcmVxdWVzdFR5cGUpIHtcbiAgICAgICAgcmVqZWN0UmVhc29uID0gU3RhdHVzLlJFUVVFU1RfVFlQRV9OT1RfU1BFQ0lGSUVEO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJncyAmJiAodHlwZW9mIGFyZ3MgIT09ICdvYmplY3QnIHx8IGFyZ3MgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShhcmdzKSkpIHtcbiAgICAgICAgcmVqZWN0UmVhc29uID0gU3RhdHVzLkFSR1NfTk9UX09CSkVDVDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgcmVqZWN0UmVhc29uID0gU3RhdHVzLk5PVF9DT05ORUNURUQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEFzc2lnbiBhIHRlbXBvcmFyeSBldmVudCBsaXN0ZW5lciBmb3IgdGhpcyBwYXJ0aWN1bGFyIG1lc3NhZ2VJZCB0byB1bmlxdWVseSBpZGVudGlmeSB0aGUgcmVzcG9uc2UuXG4gICAgICB0aGlzLm9uY2UoYG9iczppbnRlcm5hbDptZXNzYWdlOmlkLSR7bWVzc2FnZUlkfWAsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGRlYnVnKCdbc2VuZDpyZWplY3RdICVvJywgZXJyKTtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnW3NlbmQ6cmVzb2x2ZV0gJW8nLCBkYXRhKTtcbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHJlYXNvbiB0byBmYWlsIGZhc3QsIHNlbmQgdGhlIHJlcXVlc3QgdG8gdGhlIHNvY2tldC5cbiAgICAgIGlmICghcmVqZWN0UmVhc29uKSB7XG4gICAgICAgIGFyZ3NbJ3JlcXVlc3QtdHlwZSddID0gcmVxdWVzdFR5cGU7XG4gICAgICAgIGFyZ3NbJ21lc3NhZ2UtaWQnXSA9IG1lc3NhZ2VJZDtcblxuICAgICAgICAvLyBTdWJtaXQgdGhlIHJlcXVlc3QgdG8gdGhlIHdlYnNvY2tldC5cbiAgICAgICAgZGVidWcoJ1tzZW5kXSAlcyAlcyAlbycsIG1lc3NhZ2VJZCwgcmVxdWVzdFR5cGUsIGFyZ3MpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuX3NvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KGFyZ3MpKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIC8vIFRPRE86IENvbnNpZGVyIGluc3BlY3RpbmcgdGhlIGV4Y2VwdGlvbiB0aHJvd24gdG8gZ2xlYW0gc29tZSByZWxldmFudCBpbmZvIGFuZCBwYXNzIHRoYXQgb24uXG4gICAgICAgICAgcmVqZWN0UmVhc29uID0gU3RhdHVzLlNPQ0tFVF9FWENFUFRJT047XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHNvY2tldCBjYWxsIHdhcyB1bnN1Y2Nlc3NmdWwgb3IgYnlwYXNzZWQsIHNpbXVsYXRlIGl0cyByZXNvbHV0aW9uLlxuICAgICAgaWYgKHJlamVjdFJlYXNvbikge1xuICAgICAgICB0aGlzLmVtaXQoYG9iczppbnRlcm5hbDptZXNzYWdlOmlkLSR7bWVzc2FnZUlkfWAsIHJlamVjdFJlYXNvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJpYyBTb2NrZXQgcmVxdWVzdCBtZXRob2QuIEhhbmRsZXMgY2FsbGJhY2tzLlxuICAgKiBJbnRlcm5hbGx5IGNhbGxzIGBzZW5kYCAod2hpY2ggaXMgcHJvbWlzZS1iYXNlZCkuIFNlZSBgc2VuZGAncyBkb2NzIGZvciBtb3JlIGRldGFpbHMuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICByZXF1ZXN0VHlwZSBvYnMtd2Vic29ja2V0IHBsdWdpbiBleHBlY3RlZCByZXF1ZXN0IHR5cGUuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBbYXJncz17fV0gICByZXF1ZXN0IGFyZ3VtZW50cy5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrICAgIE9wdGlvbmFsLiBjYWxsYmFjayhlcnIsIGRhdGEpXG4gICAqL1xuICBzZW5kQ2FsbGJhY2socmVxdWVzdFR5cGUsIGFyZ3MgPSB7fSwgY2FsbGJhY2spIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZWZhdWx0LXBhcmFtLWxhc3RcbiAgICAvLyBBbGxvdyB0aGUgYGFyZ3NgIGFyZ3VtZW50IHRvIGJlIG9taXR0ZWQuXG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIGFyZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gYXJncztcbiAgICAgIGFyZ3MgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIHRoZSBhY3R1YWwgcmVxdWVzdCwgdXNpbmcgYHNlbmRgLlxuICAgIHRoaXMuc2VuZChyZXF1ZXN0VHlwZSwgYXJncykudGhlbigoLi4ucmVzcG9uc2UpID0+IHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIC4uLnJlc3BvbnNlKTtcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPQlNXZWJTb2NrZXQ7XG4iLCJjb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCdpc29tb3JwaGljLXdzJyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGhhc2ggPSByZXF1aXJlKCcuL3V0aWwvYXV0aGVudGljYXRpb25IYXNoaW5nJyk7XG5jb25zdCBTdGF0dXMgPSByZXF1aXJlKCcuL1N0YXR1cycpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdvYnMtd2Vic29ja2V0LWpzOlNvY2tldCcpO1xuY29uc3QgbG9nQW1iaWd1b3VzRXJyb3IgPSByZXF1aXJlKCcuL3V0aWwvbG9nQW1iaWd1b3VzRXJyb3InKTtcbmNvbnN0IGNhbWVsQ2FzZUtleXMgPSByZXF1aXJlKCcuL3V0aWwvY2FtZWxDYXNlS2V5cycpO1xuXG5jbGFzcyBTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3NvY2tldCA9IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IG9yaWdpbmFsRW1pdCA9IHRoaXMuZW1pdDtcbiAgICB0aGlzLmVtaXQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgZGVidWcoJ1tlbWl0XSAlcyBlcnI6ICVvIGRhdGE6ICVvJywgLi4uYXJncyk7XG4gICAgICBvcmlnaW5hbEVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGNvbm5lY3QoYXJncyA9IHt9KSB7XG4gICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgY29uc3QgYWRkcmVzcyA9IGFyZ3MuYWRkcmVzcyB8fCAnbG9jYWxob3N0OjQ0NDQnO1xuXG4gICAgaWYgKHRoaXMuX3NvY2tldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQmxpbmRseSB0cnkgdG8gY2xvc2UgdGhlIHNvY2tldC5cbiAgICAgICAgLy8gRG9uJ3QgY2FyZSBpZiBpdHMgYWxyZWFkeSBjbG9zZWQuXG4gICAgICAgIC8vIFdlIGp1c3QgZG9uJ3Qgd2FudCBhbnkgc29ja2V0cyB0byBsZWFrLlxuICAgICAgICB0aGlzLl9zb2NrZXQuY2xvc2UoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFRoZXNlIGVycm9ycyBhcmUgcHJvYmFibHkgc2FmZSB0byBpZ25vcmUsIGJ1dCBkZWJ1ZyBsb2cgdGhlbSBqdXN0IGluIGNhc2UuXG4gICAgICAgIGRlYnVnKCdGYWlsZWQgdG8gY2xvc2UgcHJldmlvdXMgV2ViU29ja2V0OicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2Nvbm5lY3QoYWRkcmVzcywgQm9vbGVhbihhcmdzLnNlY3VyZSkpO1xuICAgICAgICBhd2FpdCB0aGlzLl9hdXRoZW50aWNhdGUoYXJncy5wYXNzd29yZCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLl9zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIGxvZ0FtYmlndW91c0Vycm9yKGRlYnVnLCAnQ29ubmVjdGlvbiBmYWlsZWQ6JywgZXJyKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgYSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byBhbiBvYnMtd2Vic29ja2V0IHNlcnZlciwgYnV0IGRvZXMgbm90IGF0dGVtcHQgYW55IGF1dGhlbnRpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB1cmwgd2l0aG91dCB3czovLyBvciB3c3M6Ly8gcHJlZml4LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNlY3VyZSB3aGV0aGVyIHRvIHVzIHdzOi8vIG9yIHdzczovL1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7UHJvbWlzZX0gb24gYXR0ZW1wdGVkIGNyZWF0aW9uIG9mIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgX2Nvbm5lY3QoYWRkcmVzcywgc2VjdXJlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBzZXR0bGVkID0gZmFsc2U7XG5cbiAgICAgIGRlYnVnKCdBdHRlbXB0aW5nIHRvIGNvbm5lY3QgdG86ICVzIChzZWN1cmU6ICVzKScsIGFkZHJlc3MsIHNlY3VyZSk7XG4gICAgICB0aGlzLl9zb2NrZXQgPSBuZXcgV2ViU29ja2V0KChzZWN1cmUgPyAnd3NzOi8vJyA6ICd3czovLycpICsgYWRkcmVzcyk7XG5cbiAgICAgIC8vIFdlIG9ubHkgaGFuZGxlIHRoZSBpbml0aWFsIGNvbm5lY3Rpb24gZXJyb3IuXG4gICAgICAvLyBCZXlvbmQgdGhhdCwgdGhlIGNvbnN1bWVyIGlzIHJlc3BvbnNpYmxlIGZvciBhZGRpbmcgdGhlaXIgb3duIGdlbmVyaWMgYGVycm9yYCBldmVudCBsaXN0ZW5lci5cbiAgICAgIC8vIEZJWE1FOiBVbnN1cmUgaG93IGJlc3QgdG8gZXhwb3NlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIFdlYlNvY2tldCBlcnJvci5cbiAgICAgIHRoaXMuX3NvY2tldC5vbmVycm9yID0gZXJyID0+IHtcbiAgICAgICAgaWYgKHNldHRsZWQpIHtcbiAgICAgICAgICBsb2dBbWJpZ3VvdXNFcnJvcihkZWJ1ZywgJ1Vua25vd24gU29ja2V0IEVycm9yJywgZXJyKTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgbG9nQW1iaWd1b3VzRXJyb3IoZGVidWcsICdXZWJzb2NrZXQgQ29ubmVjdGlvbiBmYWlsZWQ6JywgZXJyKTtcbiAgICAgICAgcmVqZWN0KFN0YXR1cy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3NvY2tldC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIGlmIChzZXR0bGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgc2V0dGxlZCA9IHRydWU7XG5cbiAgICAgICAgZGVidWcoJ0Nvbm5lY3Rpb24gb3BlbmVkOiAlcycsIGFkZHJlc3MpO1xuICAgICAgICB0aGlzLmVtaXQoJ0Nvbm5lY3Rpb25PcGVuZWQnKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcblxuICAgICAgLy8gTG9va3MgbGlrZSB0aGlzIHNob3VsZCBiZSBib3VuZC4gV2UgZG9uJ3QgdGVjaG5pY2FsbHkgY2FuY2VsIHRoZSBjb25uZWN0aW9uIHdoZW4gdGhlIGF1dGhlbnRpY2F0aW9uIGZhaWxzLlxuICAgICAgdGhpcy5fc29ja2V0Lm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBkZWJ1ZygnQ29ubmVjdGlvbiBjbG9zZWQ6ICVzJywgYWRkcmVzcyk7XG4gICAgICAgIHRoaXMuZW1pdCgnQ29ubmVjdGlvbkNsb3NlZCcpO1xuICAgICAgfTtcblxuICAgICAgLy8gVGhpcyBoYW5kbGVyIG11c3QgYmUgcHJlc2VudCBiZWZvcmUgd2UgY2FuIGNhbGwgX2F1dGhlbnRpY2F0ZS5cbiAgICAgIHRoaXMuX3NvY2tldC5vbm1lc3NhZ2UgPSBtc2cgPT4ge1xuICAgICAgICBkZWJ1ZygnW09uTWVzc2FnZV06ICVvJywgbXNnKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNhbWVsQ2FzZUtleXMoSlNPTi5wYXJzZShtc2cuZGF0YSkpO1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBsZXQgZGF0YTtcblxuICAgICAgICBpZiAobWVzc2FnZS5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICBlcnIgPSBtZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBtZXNzYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW1pdCB0aGUgbWVzc2FnZSB3aXRoIElEIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHRyeSB0byBmaW5kIGEgbm9uLW1lc3NhZ2VJZCBkcml2ZW4gZXZlbnQuXG4gICAgICAgIGlmIChtZXNzYWdlLm1lc3NhZ2VJZCkge1xuICAgICAgICAgIHRoaXMuZW1pdChgb2JzOmludGVybmFsOm1lc3NhZ2U6aWQtJHttZXNzYWdlLm1lc3NhZ2VJZH1gLCBlcnIsIGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudXBkYXRlVHlwZSkge1xuICAgICAgICAgIHRoaXMuZW1pdChtZXNzYWdlLnVwZGF0ZVR5cGUsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ0FtYmlndW91c0Vycm9yKGRlYnVnLCAnVW5yZWNvZ25pemVkIFNvY2tldCBNZXNzYWdlOicsIG1lc3NhZ2UpO1xuICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEF1dGhlbnRpY2F0ZXMgdG8gYW4gb2JzLXdlYnNvY2tldCBzZXJ2ZXIuIE11c3QgYWxyZWFkeSBoYXZlIGFuIGFjdGl2ZSBjb25uZWN0aW9uIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3Bhc3N3b3JkPScnXSBhdXRoZW50aWNhdGlvbiBzdHJpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IG9uIHJlc29sdXRpb24gb2YgYXV0aGVudGljYXRpb24gY2FsbC5cbiAgICovXG4gIGFzeW5jIF9hdXRoZW50aWNhdGUocGFzc3dvcmQgPSAnJykge1xuICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICB0aHJvdyBTdGF0dXMuTk9UX0NPTk5FQ1RFRDtcbiAgICB9XG5cbiAgICBjb25zdCBhdXRoID0gYXdhaXQgdGhpcy5zZW5kKCdHZXRBdXRoUmVxdWlyZWQnKTtcblxuICAgIGlmICghYXV0aC5hdXRoUmVxdWlyZWQpIHtcbiAgICAgIGRlYnVnKCdBdXRoZW50aWNhdGlvbiBub3QgUmVxdWlyZWQnKTtcbiAgICAgIHRoaXMuZW1pdCgnQXV0aGVudGljYXRpb25TdWNjZXNzJyk7XG4gICAgICByZXR1cm4gU3RhdHVzLkFVVEhfTk9UX1JFUVVJUkVEO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnNlbmQoJ0F1dGhlbnRpY2F0ZScsIHtcbiAgICAgICAgYXV0aDogaGFzaChhdXRoLnNhbHQsIGF1dGguY2hhbGxlbmdlLCBwYXNzd29yZClcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCdBdXRoZW50aWNhdGlvbiBGYWlsdXJlICVvJywgZSk7XG4gICAgICB0aGlzLmVtaXQoJ0F1dGhlbnRpY2F0aW9uRmFpbHVyZScpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBkZWJ1ZygnQXV0aGVudGljYXRpb24gU3VjY2VzcycpO1xuICAgIHRoaXMuZW1pdCgnQXV0aGVudGljYXRpb25TdWNjZXNzJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2UgYW5kIGRpc2Nvbm5lY3QgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKiBGSVhNRTogdGhpcyBzaG91bGQgc3VwcG9ydCBhIGNhbGxiYWNrIGFuZCByZXR1cm4gYSBQcm9taXNlIHRvIG1hdGNoIHRoZSBjb25uZWN0IG1ldGhvZC5cbiAgICpcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBjYXRlZ29yeSByZXF1ZXN0XG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIGRlYnVnKCdEaXNjb25uZWN0IHJlcXVlc3RlZC4nKTtcbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9zb2NrZXQuY2xvc2UoKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgTk9UX0NPTk5FQ1RFRDoge1xuICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICBkZXNjcmlwdGlvbjogJ1RoZXJlIGlzIG5vIFNvY2tldCBjb25uZWN0aW9uIGF2YWlsYWJsZS4nXG4gIH0sXG4gIENPTk5FQ1RJT05fRVJST1I6IHtcbiAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgZGVzY3JpcHRpb246ICdDb25uZWN0aW9uIGVycm9yLidcbiAgfSxcbiAgU09DS0VUX0VYQ0VQVElPTjoge1xuICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICBkZXNjcmlwdGlvbjogJ0FuIGV4Y2VwdGlvbiBvY2N1cnJlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIFdlYlNvY2tldC4nXG4gIH0sXG4gIEFVVEhfTk9UX1JFUVVJUkVEOiB7XG4gICAgc3RhdHVzOiAnb2snLFxuICAgIGRlc2NyaXB0aW9uOiAnQXV0aGVudGljYXRpb24gaXMgbm90IHJlcXVpcmVkLidcbiAgfSxcbiAgUkVRVUVTVF9UWVBFX05PVF9TUEVDSUZJRUQ6IHtcbiAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgZGVzY3JpcHRpb246ICdBIFJlcXVlc3QgVHlwZSB3YXMgbm90IHNwZWNpZmllZC4nXG4gIH0sXG4gIEFSR1NfTk9UX09CSkVDVDoge1xuICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBzdXBwbGllZCBhcmdtZW50cyBwYXJhbWV0ZXIgaXMgbm90IGFuIG9iamVjdC4nXG4gIH0sXG5cbiAgaW5pdCgpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzKSB7XG4gICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBrZXkpKSB7XG4gICAgICAgIC8vIEFzc2lnbiBhIHZhbHVlIHRvICdjb2RlJyBpZGVudGlmaWVkIGJ5IHRoZSBzdGF0dXMnIGtleS5cbiAgICAgICAgdGhpc1trZXldLmNvZGUgPSBrZXk7XG5cbiAgICAgICAgLy8gQXNzaWduIGEgdmFsdWUgdG8gJ2Vycm9yJyBpZiBvbmUgaXMgbm90IGFscmVhZHkgZGVmaW5lZC5cbiAgICAgICAgaWYgKHRoaXNba2V5XS5zdGF0dXMgPT09ICdlcnJvcicgJiYgIXRoaXNba2V5XS5lcnJvcikge1xuICAgICAgICAgIHRoaXNba2V5XS5lcnJvciA9IHRoaXNba2V5XS5kZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLmluaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0uaW5pdCgpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL09CU1dlYlNvY2tldC5qcycpO1xuIiwiY29uc3QgU0hBMjU2ID0gcmVxdWlyZSgnc2hhLmpzL3NoYTI1NicpO1xuXG4vKipcbiAqIFNIQTI1NiBIYXNoaW5nLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gW3NhbHQ9JyddIHNhbHQuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFtjaGFsbGVuZ2U9JyddIGNoYWxsZW5nZS5cbiAqIEBwYXJhbSAge1N0cmluZ30gbXNnIE1lc3NhZ2UgdG8gZW5jb2RlLlxuICogQHJldHVybiB7U3RyaW5nfSBzaGEyNTYgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LXBhcmFtLWxhc3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNhbHQgPSAnJywgY2hhbGxlbmdlID0gJycsIG1zZykge1xuICBjb25zdCBoYXNoID0gbmV3IFNIQTI1NigpXG4gICAgLnVwZGF0ZShtc2cpXG4gICAgLnVwZGF0ZShzYWx0KVxuICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gIGNvbnN0IHJlc3AgPSBuZXcgU0hBMjU2KClcbiAgICAudXBkYXRlKGhhc2gpXG4gICAgLnVwZGF0ZShjaGFsbGVuZ2UpXG4gICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgcmV0dXJuIHJlc3A7XG59O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBrZWJhYi1jYXNlIHRvIGNhbWVsQ2FzZS5cbiAqIFJldGFpbnMgdGhlIG9yaWdpbmFsIGtlYmFiLWNhc2UgZW50cmllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29iaj17fV0gS2V5ZWQgb2JqZWN0LlxuICogQHJldHVybiB7T2JqZWN0fSBLZXllZCBvYmplY3Qgd2l0aCBhZGRlZCBjYW1lbENhc2VkIGtleXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICBvYmogPSBvYmogfHwge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbWVsQ2FzZWRLZXkgPSBrZXkucmVwbGFjZSgvLShbYS16XSkvZ2ksICgkMCwgJDEpID0+IHtcbiAgICAgIHJldHVybiAkMS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICAgIG9ialtjYW1lbENhc2VkS2V5XSA9IG9ialtrZXldO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG4iLCIvKipcbiAqIERpc2FtYmlndWF0ZXMgYW4gXCJlcnJvclwiIGFuZCBmb3JtYXRzIGl0IG5pY2VseSBmb3IgYGRlYnVnYCBvdXRwdXQuXG4gKiBQYXJ0aWN1bGFybHkgdXNlZnVsIHdoZW4gZGVhbGluZyB3aXRoIGVycm9yIHJlc3BvbnNlIG9iamVjdHMgZnJvbSBvYnMtd2Vic29ja2V0LFxuICogd2hpY2ggYXJlIG5vdCBhY3R1YWwgRXJyb3ItdHlwZSBlcnJvcnMsIGJ1dCBzaW1wbHkgT2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVidWcgQSBgZGVidWdgIGluc3RhbmNlLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBBIHN0cmluZyB0byBwcmludCBpbiBmcm9udCBvZiB0aGUgZm9ybWF0dGVkIGVycm9yLlxuICogQHBhcmFtIHtPYmplY3R8RXJyb3J9IGVycm9yIEFuIGVycm9yIG9mIGFtYmlndW91cyB0eXBlIHRoYXQgeW91IHdpc2ggdG8gbG9nIHRvIGBkZWJ1Z2AuIENhbiBiZSBhbiBFcnJvciwgT2JqZWN0LCBvciBTdHJpbmcuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRlYnVnLCBwcmVmaXgsIGVycm9yKSB7XG4gIGlmIChlcnJvciAmJiBlcnJvci5zdGFjaykge1xuICAgIGRlYnVnKGAke3ByZWZpeH1cXG4gJU9gLCBlcnJvci5zdGFjayk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuICAgIGRlYnVnKGAke3ByZWZpeH0gJW9gLCBlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoYCR7cHJlZml4fSAlc2AsIGVycm9yKTtcbiAgfVxufTtcbiIsIi8qIFJpb3QgdjUuNC41LCBAbGljZW5zZSBNSVQgKi9cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyBmcm9tIGNhbWVsIGNhc2UgdG8gZGFzaC1jYXNlXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBzdHJpbmcgLSBwcm9iYWJseSBhIGNvbXBvbmVudCB0YWcgbmFtZVxuICogQHJldHVybnMge3N0cmluZ30gY29tcG9uZW50IG5hbWUgbm9ybWFsaXplZFxuICovXG5mdW5jdGlvbiBjYW1lbFRvRGFzaENhc2Uoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbn1cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyBjb250YWluaW5nIGRhc2hlcyB0byBjYW1lbCBjYXNlXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBzdHJpbmcgLSBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IG15LXN0cmluZyAtPiBteVN0cmluZ1xuICovXG5cbmZ1bmN0aW9uIGRhc2hUb0NhbWVsQ2FzZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8tKFxcdykvZywgKF8sIGMpID0+IGMudG9VcHBlckNhc2UoKSk7XG59XG5cbi8qKlxuICogR2V0IGFsbCB0aGUgZWxlbWVudCBhdHRyaWJ1dGVzIGFzIG9iamVjdFxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gRE9NIG5vZGUgd2Ugd2FudCB0byBwYXJzZVxuICogQHJldHVybnMge09iamVjdH0gYWxsIHRoZSBhdHRyaWJ1dGVzIGZvdW5kIGFzIGEga2V5IHZhbHVlIHBhaXJzXG4gKi9cblxuZnVuY3Rpb24gRE9NYXR0cmlidXRlc1RvT2JqZWN0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5hdHRyaWJ1dGVzKS5yZWR1Y2UoKGFjYywgYXR0cmlidXRlKSA9PiB7XG4gICAgYWNjW2Rhc2hUb0NhbWVsQ2FzZShhdHRyaWJ1dGUubmFtZSldID0gYXR0cmlidXRlLnZhbHVlO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cbi8qKlxuICogTW92ZSBhbGwgdGhlIGNoaWxkIG5vZGVzIGZyb20gYSBzb3VyY2UgdGFnIHRvIGFub3RoZXJcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gc291cmNlIC0gc291cmNlIG5vZGVcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gdGFyZ2V0IG5vZGVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9IGl0J3MgYSB2b2lkIG1ldGhvZCDCr1xcXyjjg4QpXy/Cr1xuICovXG4vLyBJZ25vcmUgdGhpcyBoZWxwZXIgYmVjYXVzZSBpdCdzIG5lZWRlZCBvbmx5IGZvciBzdmcgdGFnc1xuXG5mdW5jdGlvbiBtb3ZlQ2hpbGRyZW4oc291cmNlLCB0YXJnZXQpIHtcbiAgaWYgKHNvdXJjZS5maXJzdENoaWxkKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHNvdXJjZS5maXJzdENoaWxkKTtcbiAgICBtb3ZlQ2hpbGRyZW4oc291cmNlLCB0YXJnZXQpO1xuICB9XG59XG4vKipcbiAqIFJlbW92ZSB0aGUgY2hpbGQgbm9kZXMgZnJvbSBhbnkgRE9NIG5vZGVcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gbm9kZSAtIHRhcmdldCBub2RlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNsZWFuTm9kZShub2RlKSB7XG4gIGNsZWFyQ2hpbGRyZW4obm9kZS5jaGlsZE5vZGVzKTtcbn1cbi8qKlxuICogQ2xlYXIgbXVsdGlwbGUgY2hpbGRyZW4gaW4gYSBub2RlXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnRbXX0gY2hpbGRyZW4gLSBkaXJlY3QgY2hpbGRyZW4gbm9kZXNcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gY2xlYXJDaGlsZHJlbihjaGlsZHJlbikge1xuICBBcnJheS5mcm9tKGNoaWxkcmVuKS5mb3JFYWNoKHJlbW92ZUNoaWxkKTtcbn1cbi8qKlxuICogUmVtb3ZlIGEgbm9kZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH1ub2RlIC0gbm9kZSB0byByZW1vdmVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuY29uc3QgcmVtb3ZlQ2hpbGQgPSBub2RlID0+IG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlICYmIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbi8qKlxuICogSW5zZXJ0IGJlZm9yZSBhIG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5ld05vZGUgLSBub2RlIHRvIGluc2VydFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmTm9kZSAtIHJlZiBjaGlsZFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5jb25zdCBpbnNlcnRCZWZvcmUgPSAobmV3Tm9kZSwgcmVmTm9kZSkgPT4gcmVmTm9kZSAmJiByZWZOb2RlLnBhcmVudE5vZGUgJiYgcmVmTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZOb2RlKTtcbi8qKlxuICogUmVwbGFjZSBhIG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5ld05vZGUgLSBuZXcgbm9kZSB0byBhZGQgdG8gdGhlIERPTVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVwbGFjZWQgLSBub2RlIHRvIHJlcGxhY2VcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuY29uc3QgcmVwbGFjZUNoaWxkID0gKG5ld05vZGUsIHJlcGxhY2VkKSA9PiByZXBsYWNlZCAmJiByZXBsYWNlZC5wYXJlbnROb2RlICYmIHJlcGxhY2VkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld05vZGUsIHJlcGxhY2VkKTtcblxuLy8gUmlvdC5qcyBjb25zdGFudHMgdGhhdCBjYW4gYmUgdXNlZCBhY2Nyb3NzIG1vcmUgbW9kdWxlc1xuY29uc3QgQ09NUE9ORU5UU19JTVBMRU1FTlRBVElPTl9NQVAkMSA9IG5ldyBNYXAoKSxcbiAgICAgIERPTV9DT01QT05FTlRfSU5TVEFOQ0VfUFJPUEVSVFkkMSA9IFN5bWJvbCgncmlvdC1jb21wb25lbnQnKSxcbiAgICAgIFBMVUdJTlNfU0VUJDEgPSBuZXcgU2V0KCksXG4gICAgICBJU19ESVJFQ1RJVkUgPSAnaXMnLFxuICAgICAgVkFMVUVfQVRUUklCVVRFID0gJ3ZhbHVlJyxcbiAgICAgIE1PVU5UX01FVEhPRF9LRVkgPSAnbW91bnQnLFxuICAgICAgVVBEQVRFX01FVEhPRF9LRVkgPSAndXBkYXRlJyxcbiAgICAgIFVOTU9VTlRfTUVUSE9EX0tFWSA9ICd1bm1vdW50JyxcbiAgICAgIFNIT1VMRF9VUERBVEVfS0VZID0gJ3Nob3VsZFVwZGF0ZScsXG4gICAgICBPTl9CRUZPUkVfTU9VTlRfS0VZID0gJ29uQmVmb3JlTW91bnQnLFxuICAgICAgT05fTU9VTlRFRF9LRVkgPSAnb25Nb3VudGVkJyxcbiAgICAgIE9OX0JFRk9SRV9VUERBVEVfS0VZID0gJ29uQmVmb3JlVXBkYXRlJyxcbiAgICAgIE9OX1VQREFURURfS0VZID0gJ29uVXBkYXRlZCcsXG4gICAgICBPTl9CRUZPUkVfVU5NT1VOVF9LRVkgPSAnb25CZWZvcmVVbm1vdW50JyxcbiAgICAgIE9OX1VOTU9VTlRFRF9LRVkgPSAnb25Vbm1vdW50ZWQnLFxuICAgICAgUFJPUFNfS0VZID0gJ3Byb3BzJyxcbiAgICAgIFNUQVRFX0tFWSA9ICdzdGF0ZScsXG4gICAgICBTTE9UU19LRVkgPSAnc2xvdHMnLFxuICAgICAgUk9PVF9LRVkgPSAncm9vdCcsXG4gICAgICBJU19QVVJFX1NZTUJPTCA9IFN5bWJvbCgncHVyZScpLFxuICAgICAgSVNfQ09NUE9ORU5UX1VQREFUSU5HID0gU3ltYm9sKCdpc191cGRhdGluZycpLFxuICAgICAgUEFSRU5UX0tFWV9TWU1CT0wgPSBTeW1ib2woJ3BhcmVudCcpLFxuICAgICAgQVRUUklCVVRFU19LRVlfU1lNQk9MID0gU3ltYm9sKCdhdHRyaWJ1dGVzJyksXG4gICAgICBURU1QTEFURV9LRVlfU1lNQk9MID0gU3ltYm9sKCd0ZW1wbGF0ZScpO1xuXG52YXIgZ2xvYmFscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBDT01QT05FTlRTX0lNUExFTUVOVEFUSU9OX01BUDogQ09NUE9ORU5UU19JTVBMRU1FTlRBVElPTl9NQVAkMSxcbiAgRE9NX0NPTVBPTkVOVF9JTlNUQU5DRV9QUk9QRVJUWTogRE9NX0NPTVBPTkVOVF9JTlNUQU5DRV9QUk9QRVJUWSQxLFxuICBQTFVHSU5TX1NFVDogUExVR0lOU19TRVQkMSxcbiAgSVNfRElSRUNUSVZFOiBJU19ESVJFQ1RJVkUsXG4gIFZBTFVFX0FUVFJJQlVURTogVkFMVUVfQVRUUklCVVRFLFxuICBNT1VOVF9NRVRIT0RfS0VZOiBNT1VOVF9NRVRIT0RfS0VZLFxuICBVUERBVEVfTUVUSE9EX0tFWTogVVBEQVRFX01FVEhPRF9LRVksXG4gIFVOTU9VTlRfTUVUSE9EX0tFWTogVU5NT1VOVF9NRVRIT0RfS0VZLFxuICBTSE9VTERfVVBEQVRFX0tFWTogU0hPVUxEX1VQREFURV9LRVksXG4gIE9OX0JFRk9SRV9NT1VOVF9LRVk6IE9OX0JFRk9SRV9NT1VOVF9LRVksXG4gIE9OX01PVU5URURfS0VZOiBPTl9NT1VOVEVEX0tFWSxcbiAgT05fQkVGT1JFX1VQREFURV9LRVk6IE9OX0JFRk9SRV9VUERBVEVfS0VZLFxuICBPTl9VUERBVEVEX0tFWTogT05fVVBEQVRFRF9LRVksXG4gIE9OX0JFRk9SRV9VTk1PVU5UX0tFWTogT05fQkVGT1JFX1VOTU9VTlRfS0VZLFxuICBPTl9VTk1PVU5URURfS0VZOiBPTl9VTk1PVU5URURfS0VZLFxuICBQUk9QU19LRVk6IFBST1BTX0tFWSxcbiAgU1RBVEVfS0VZOiBTVEFURV9LRVksXG4gIFNMT1RTX0tFWTogU0xPVFNfS0VZLFxuICBST09UX0tFWTogUk9PVF9LRVksXG4gIElTX1BVUkVfU1lNQk9MOiBJU19QVVJFX1NZTUJPTCxcbiAgSVNfQ09NUE9ORU5UX1VQREFUSU5HOiBJU19DT01QT05FTlRfVVBEQVRJTkcsXG4gIFBBUkVOVF9LRVlfU1lNQk9MOiBQQVJFTlRfS0VZX1NZTUJPTCxcbiAgQVRUUklCVVRFU19LRVlfU1lNQk9MOiBBVFRSSUJVVEVTX0tFWV9TWU1CT0wsXG4gIFRFTVBMQVRFX0tFWV9TWU1CT0w6IFRFTVBMQVRFX0tFWV9TWU1CT0xcbn0pO1xuXG5jb25zdCBFQUNIID0gMDtcbmNvbnN0IElGID0gMTtcbmNvbnN0IFNJTVBMRSA9IDI7XG5jb25zdCBUQUcgPSAzO1xuY29uc3QgU0xPVCA9IDQ7XG52YXIgYmluZGluZ1R5cGVzID0ge1xuICBFQUNILFxuICBJRixcbiAgU0lNUExFLFxuICBUQUcsXG4gIFNMT1Rcbn07XG5cbmNvbnN0IEFUVFJJQlVURSA9IDA7XG5jb25zdCBFVkVOVCA9IDE7XG5jb25zdCBURVhUID0gMjtcbmNvbnN0IFZBTFVFID0gMztcbnZhciBleHByZXNzaW9uVHlwZXMgPSB7XG4gIEFUVFJJQlVURSxcbiAgRVZFTlQsXG4gIFRFWFQsXG4gIFZBTFVFXG59O1xuXG5jb25zdCBIRUFEX1NZTUJPTCA9IFN5bWJvbCgnaGVhZCcpO1xuY29uc3QgVEFJTF9TWU1CT0wgPSBTeW1ib2woJ3RhaWwnKTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIDx0ZW1wbGF0ZT4gZnJhZ21lbnRzIHRleHQgbm9kZXNcbiAqIEByZXR1cm4ge09iamVjdH0ge3toZWFkOiBUZXh0Tm9kZSwgdGFpbDogVGV4dE5vZGV9fVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRUYWlsUGxhY2Vob2xkZXJzKCkge1xuICBjb25zdCBoZWFkID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBjb25zdCB0YWlsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBoZWFkW0hFQURfU1lNQk9MXSA9IHRydWU7XG4gIHRhaWxbVEFJTF9TWU1CT0xdID0gdHJ1ZTtcbiAgcmV0dXJuIHtcbiAgICBoZWFkLFxuICAgIHRhaWxcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIHRlbXBsYXRlIG1ldGEgb2JqZWN0IGluIGNhc2Ugb2YgPHRlbXBsYXRlPiBmcmFnbWVudHNcbiAqIEBwYXJhbSAgIHtUZW1wbGF0ZUNodW5rfSBjb21wb25lbnRUZW1wbGF0ZSAtIHRlbXBsYXRlIGNodW5rIG9iamVjdFxuICogQHJldHVybnMge09iamVjdH0gdGhlIG1ldGEgcHJvcGVydHkgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbW91bnQgZnVuY3Rpb24gb2YgdGhlIFRlbXBsYXRlQ2h1bmtcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZU1ldGEoY29tcG9uZW50VGVtcGxhdGUpIHtcbiAgY29uc3QgZnJhZ21lbnQgPSBjb21wb25lbnRUZW1wbGF0ZS5kb20uY2xvbmVOb2RlKHRydWUpO1xuICBjb25zdCB7XG4gICAgaGVhZCxcbiAgICB0YWlsXG4gIH0gPSBjcmVhdGVIZWFkVGFpbFBsYWNlaG9sZGVycygpO1xuICByZXR1cm4ge1xuICAgIGF2b2lkRE9NSW5qZWN0aW9uOiB0cnVlLFxuICAgIGZyYWdtZW50LFxuICAgIGhlYWQsXG4gICAgdGFpbCxcbiAgICBjaGlsZHJlbjogW2hlYWQsIC4uLkFycmF5LmZyb20oZnJhZ21lbnQuY2hpbGROb2RlcyksIHRhaWxdXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IDx0ZW1wbGF0ZT4gZnJhZ21lbnQgY2hpbGRyZW4gbG9jYXRlZCBpbiBiZXR3ZWVuIHRoZSBoZWFkIGFuZCB0YWlsIGNvbW1lbnRzXG4gKiBAcGFyYW0ge0NvbW1lbnR9IGhlYWQgLSBoZWFkIGNvbW1lbnQgbm9kZVxuICogQHBhcmFtIHtDb21tZW50fSB0YWlsIC0gdGFpbCBjb21tZW50IG5vZGVcbiAqIEByZXR1cm4ge0FycmF5W119IGNoaWxkcmVuIGxpc3Qgb2YgdGhlIG5vZGVzIGZvdW5kIGluIHRoaXMgdGVtcGxhdGUgZnJhZ21lbnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRGcmFnbWVudENoaWxkcmVuKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBoZWFkLFxuICAgIHRhaWxcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IG5vZGVzID0gd2Fsa05vZGVzKFtoZWFkXSwgaGVhZC5uZXh0U2libGluZywgbiA9PiBuID09PSB0YWlsLCBmYWxzZSk7XG4gIG5vZGVzLnB1c2godGFpbCk7XG4gIHJldHVybiBub2Rlcztcbn1cbi8qKlxuICogUmVjdXJzaXZlIGZ1bmN0aW9uIHRvIHdhbGsgYWxsIHRoZSA8dGVtcGxhdGU+IGNoaWxkcmVuIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5W119IGNoaWxkcmVuIC0gY2hpbGRyZW4gbm9kZXMgY29sbGVjdGlvblxuICogQHBhcmFtIHtDaGlsZE5vZGV9IG5vZGUgLSBjdXJyZW50IG5vZGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoZWNrIC0gZXhpdCBmdW5jdGlvbiBjaGVja1xuICogQHBhcmFtIHtib29sZWFufSBpc0ZpbHRlckFjdGl2ZSAtIGZpbHRlciBmbGFnIHRvIHNraXAgbm9kZXMgbWFuYWdlZCBieSBvdGhlciBiaW5kaW5nc1xuICogQHJldHVybnMge0FycmF5W119IGNoaWxkcmVuIGxpc3Qgb2YgdGhlIG5vZGVzIGZvdW5kIGluIHRoaXMgdGVtcGxhdGUgZnJhZ21lbnRcbiAqL1xuXG5mdW5jdGlvbiB3YWxrTm9kZXMoY2hpbGRyZW4sIG5vZGUsIGNoZWNrLCBpc0ZpbHRlckFjdGl2ZSkge1xuICBjb25zdCB7XG4gICAgbmV4dFNpYmxpbmdcbiAgfSA9IG5vZGU7IC8vIGZpbHRlciB0YWlsIGFuZCBoZWFkIG5vZGVzIHRvZ2V0aGVyIHdpdGggYWxsIHRoZSBub2RlcyBpbiBiZXR3ZWVuXG4gIC8vIHRoaXMgaXMgbmVlZGVkIG9ubHkgdG8gZml4IGEgcmVhbGx5IHVnbHkgZWRnZSBjYXNlIGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L3Jpb3QvaXNzdWVzLzI4OTJcblxuICBpZiAoIWlzRmlsdGVyQWN0aXZlICYmICFub2RlW0hFQURfU1lNQk9MXSAmJiAhbm9kZVtUQUlMX1NZTUJPTF0pIHtcbiAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICB9XG5cbiAgaWYgKCFuZXh0U2libGluZyB8fCBjaGVjayhub2RlKSkgcmV0dXJuIGNoaWxkcmVuO1xuICByZXR1cm4gd2Fsa05vZGVzKGNoaWxkcmVuLCBuZXh0U2libGluZywgY2hlY2ssIC8vIGFjdGl2YXRlIHRoZSBmaWx0ZXJzIHRvIHNraXAgbm9kZXMgYmV0d2VlbiA8dGVtcGxhdGU+IGZyYWdtZW50cyB0aGF0IHdpbGwgYmUgbWFuYWdlZCBieSBvdGhlciBiaW5kaW5nc1xuICBpc0ZpbHRlckFjdGl2ZSAmJiAhbm9kZVtUQUlMX1NZTUJPTF0gfHwgbmV4dFNpYmxpbmdbSEVBRF9TWU1CT0xdKTtcbn1cblxuLyoqXG4gKiBRdWljayB0eXBlIGNoZWNraW5nXG4gKiBAcGFyYW0gICB7Kn0gZWxlbWVudCAtIGFueXRoaW5nXG4gKiBAcGFyYW0gICB7c3RyaW5nfSB0eXBlIC0gdHlwZSBkZWZpbml0aW9uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHlwZSBjb3JyZXNwb25kc1xuICovXG5mdW5jdGlvbiBjaGVja1R5cGUoZWxlbWVudCwgdHlwZSkge1xuICByZXR1cm4gdHlwZW9mIGVsZW1lbnQgPT09IHR5cGU7XG59XG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgcGFydCBvZiBhbiBzdmdcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gIGVsIC0gZWxlbWVudCB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgd2UgYXJlIGluIGFuIHN2ZyBjb250ZXh0XG4gKi9cblxuZnVuY3Rpb24gaXNTdmcoZWwpIHtcbiAgY29uc3Qgb3duZXIgPSBlbC5vd25lclNWR0VsZW1lbnQ7XG4gIHJldHVybiAhIW93bmVyIHx8IG93bmVyID09PSBudWxsO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGEgdGVtcGxhdGUgdGFnXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICBlbCAtIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGl0J3MgYSA8dGVtcGxhdGU+XG4gKi9cblxuZnVuY3Rpb24gaXNUZW1wbGF0ZShlbCkge1xuICByZXR1cm4gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGVtcGxhdGUnO1xufVxuLyoqXG4gKiBDaGVjayB0aGF0IHdpbGwgYmUgcGFzc2VkIGlmIGl0cyBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uXG4gKiBAcGFyYW0gICB7Kn0gdmFsdWUgLSB2YWx1ZSB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrVHlwZSh2YWx1ZSwgJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBCb29sZWFuXG4gKiBAcGFyYW0gICB7Kn0gIHZhbHVlIC0gYW55dGhpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9ubHkgZm9yIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW5cbiAqL1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrVHlwZSh2YWx1ZSwgJ2Jvb2xlYW4nKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqIEBwYXJhbSAgIHsqfSAgdmFsdWUgLSBhbnl0aGluZ1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb25seSBmb3IgdGhlIHZhbHVlIGlzIGFuIG9iamVjdFxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiAhaXNOaWwodmFsdWUpICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWRcbiAqIEBwYXJhbSAgIHsqfSAgdmFsdWUgLSBhbnl0aGluZ1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb25seSBmb3IgdGhlICd1bmRlZmluZWQnIGFuZCAnbnVsbCcgdHlwZXNcbiAqL1xuXG5mdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBJU0MgTGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAyMCwgQW5kcmVhIEdpYW1tYXJjaGksIEBXZWJSZWZsZWN0aW9uXG4gKlxuICogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4gKiBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcbiAqIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuICogQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuICogSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG4gKiBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRVxuICogT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuICogUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAqL1xuLy8gZm9yayBvZiBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi91ZG9tZGlmZiB2ZXJzaW9uIDEuMS4wXG4vLyBkdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vdWRvbWRpZmYvcHVsbC8yXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbi8qKlxuICogQHBhcmFtIHtOb2RlW119IGEgVGhlIGxpc3Qgb2YgY3VycmVudC9saXZlIGNoaWxkcmVuXG4gKiBAcGFyYW0ge05vZGVbXX0gYiBUaGUgbGlzdCBvZiBmdXR1cmUgY2hpbGRyZW5cbiAqIEBwYXJhbSB7KGVudHJ5OiBOb2RlLCBhY3Rpb246IG51bWJlcikgPT4gTm9kZX0gZ2V0XG4gKiBUaGUgY2FsbGJhY2sgaW52b2tlZCBwZXIgZWFjaCBlbnRyeSByZWxhdGVkIERPTSBvcGVyYXRpb24uXG4gKiBAcGFyYW0ge05vZGV9IFtiZWZvcmVdIFRoZSBvcHRpb25hbCBub2RlIHVzZWQgYXMgYW5jaG9yIHRvIGluc2VydCBiZWZvcmUuXG4gKiBAcmV0dXJucyB7Tm9kZVtdfSBUaGUgc2FtZSBsaXN0IG9mIGZ1dHVyZSBjaGlsZHJlbi5cbiAqL1xuXG52YXIgdWRvbWRpZmYgPSAoKGEsIGIsIGdldCwgYmVmb3JlKSA9PiB7XG4gIGNvbnN0IGJMZW5ndGggPSBiLmxlbmd0aDtcbiAgbGV0IGFFbmQgPSBhLmxlbmd0aDtcbiAgbGV0IGJFbmQgPSBiTGVuZ3RoO1xuICBsZXQgYVN0YXJ0ID0gMDtcbiAgbGV0IGJTdGFydCA9IDA7XG4gIGxldCBtYXAgPSBudWxsO1xuXG4gIHdoaWxlIChhU3RhcnQgPCBhRW5kIHx8IGJTdGFydCA8IGJFbmQpIHtcbiAgICAvLyBhcHBlbmQgaGVhZCwgdGFpbCwgb3Igbm9kZXMgaW4gYmV0d2VlbjogZmFzdCBwYXRoXG4gICAgaWYgKGFFbmQgPT09IGFTdGFydCkge1xuICAgICAgLy8gd2UgY291bGQgYmUgaW4gYSBzaXR1YXRpb24gd2hlcmUgdGhlIHJlc3Qgb2Ygbm9kZXMgdGhhdFxuICAgICAgLy8gbmVlZCB0byBiZSBhZGRlZCBhcmUgbm90IGF0IHRoZSBlbmQsIGFuZCBpbiBzdWNoIGNhc2VcbiAgICAgIC8vIHRoZSBub2RlIHRvIGBpbnNlcnRCZWZvcmVgLCBpZiB0aGUgaW5kZXggaXMgbW9yZSB0aGFuIDBcbiAgICAgIC8vIG11c3QgYmUgcmV0cmlldmVkLCBvdGhlcndpc2UgaXQncyBnb25uYSBiZSB0aGUgZmlyc3QgaXRlbS5cbiAgICAgIGNvbnN0IG5vZGUgPSBiRW5kIDwgYkxlbmd0aCA/IGJTdGFydCA/IGdldChiW2JTdGFydCAtIDFdLCAtMCkubmV4dFNpYmxpbmcgOiBnZXQoYltiRW5kIC0gYlN0YXJ0XSwgMCkgOiBiZWZvcmU7XG5cbiAgICAgIHdoaWxlIChiU3RhcnQgPCBiRW5kKSBpbnNlcnRCZWZvcmUoZ2V0KGJbYlN0YXJ0KytdLCAxKSwgbm9kZSk7XG4gICAgfSAvLyByZW1vdmUgaGVhZCBvciB0YWlsOiBmYXN0IHBhdGhcbiAgICBlbHNlIGlmIChiRW5kID09PSBiU3RhcnQpIHtcbiAgICAgICAgd2hpbGUgKGFTdGFydCA8IGFFbmQpIHtcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIG5vZGUgb25seSBpZiBpdCdzIHVua25vd24gb3Igbm90IGxpdmVcbiAgICAgICAgICBpZiAoIW1hcCB8fCAhbWFwLmhhcyhhW2FTdGFydF0pKSByZW1vdmVDaGlsZChnZXQoYVthU3RhcnRdLCAtMSkpO1xuICAgICAgICAgIGFTdGFydCsrO1xuICAgICAgICB9XG4gICAgICB9IC8vIHNhbWUgbm9kZTogZmFzdCBwYXRoXG4gICAgICBlbHNlIGlmIChhW2FTdGFydF0gPT09IGJbYlN0YXJ0XSkge1xuICAgICAgICAgIGFTdGFydCsrO1xuICAgICAgICAgIGJTdGFydCsrO1xuICAgICAgICB9IC8vIHNhbWUgdGFpbDogZmFzdCBwYXRoXG4gICAgICAgIGVsc2UgaWYgKGFbYUVuZCAtIDFdID09PSBiW2JFbmQgLSAxXSkge1xuICAgICAgICAgICAgYUVuZC0tO1xuICAgICAgICAgICAgYkVuZC0tO1xuICAgICAgICAgIH0gLy8gVGhlIG9uY2UgaGVyZSBzaW5nbGUgbGFzdCBzd2FwIFwiZmFzdCBwYXRoXCIgaGFzIGJlZW4gcmVtb3ZlZCBpbiB2MS4xLjBcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi91ZG9tZGlmZi9ibG9iL3NpbmdsZS1maW5hbC1zd2FwL2VzbS9pbmRleC5qcyNMNjktTDg1XG4gICAgICAgICAgLy8gcmV2ZXJzZSBzd2FwOiBhbHNvIGZhc3QgcGF0aFxuICAgICAgICAgIGVsc2UgaWYgKGFbYVN0YXJ0XSA9PT0gYltiRW5kIC0gMV0gJiYgYltiU3RhcnRdID09PSBhW2FFbmQgLSAxXSkge1xuICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgXCJzaHJpbmtcIiBvcGVyYXRpb24gdGhhdCBjb3VsZCBoYXBwZW4gaW4gdGhlc2UgY2FzZXM6XG4gICAgICAgICAgICAgIC8vIFsxLCAyLCAzLCA0LCA1XVxuICAgICAgICAgICAgICAvLyBbMSwgNCwgMywgMiwgNV1cbiAgICAgICAgICAgICAgLy8gb3IgYXN5bW1ldHJpYyB0b29cbiAgICAgICAgICAgICAgLy8gWzEsIDIsIDMsIDQsIDVdXG4gICAgICAgICAgICAgIC8vIFsxLCAyLCAzLCA1LCA2LCA0XVxuICAgICAgICAgICAgICBjb25zdCBub2RlID0gZ2V0KGFbLS1hRW5kXSwgLTEpLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUoZ2V0KGJbYlN0YXJ0KytdLCAxKSwgZ2V0KGFbYVN0YXJ0KytdLCAtMSkubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUoZ2V0KGJbLS1iRW5kXSwgMSksIG5vZGUpOyAvLyBtYXJrIHRoZSBmdXR1cmUgaW5kZXggYXMgaWRlbnRpY2FsICh5ZWFoLCBpdCdzIGRpcnR5LCBidXQgY2hlYXAg8J+RjSlcbiAgICAgICAgICAgICAgLy8gVGhlIG1haW4gcmVhc29uIHRvIGRvIHRoaXMsIGlzIHRoYXQgd2hlbiBhW2FFbmRdIHdpbGwgYmUgcmVhY2hlZCxcbiAgICAgICAgICAgICAgLy8gdGhlIGxvb3Agd2lsbCBsaWtlbHkgYmUgb24gdGhlIGZhc3QgcGF0aCwgYXMgaWRlbnRpY2FsIHRvIGJbYkVuZF0uXG4gICAgICAgICAgICAgIC8vIEluIHRoZSBiZXN0IGNhc2Ugc2NlbmFyaW8sIHRoZSBuZXh0IGxvb3Agd2lsbCBza2lwIHRoZSB0YWlsLFxuICAgICAgICAgICAgICAvLyBidXQgaW4gdGhlIHdvcnN0IG9uZSwgdGhpcyBub2RlIHdpbGwgYmUgY29uc2lkZXJlZCBhcyBhbHJlYWR5XG4gICAgICAgICAgICAgIC8vIHByb2Nlc3NlZCwgYmFpbGluZyBvdXQgcHJldHR5IHF1aWNrbHkgZnJvbSB0aGUgbWFwIGluZGV4IGNoZWNrXG5cbiAgICAgICAgICAgICAgYVthRW5kXSA9IGJbYkVuZF07XG4gICAgICAgICAgICB9IC8vIG1hcCBiYXNlZCBmYWxsYmFjaywgXCJzbG93XCIgcGF0aFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG1hcCByZXF1aXJlcyBhbiBPKGJFbmQgLSBiU3RhcnQpIG9wZXJhdGlvbiBvbmNlXG4gICAgICAgICAgICAgICAgLy8gdG8gc3RvcmUgYWxsIGZ1dHVyZSBub2RlcyBpbmRleGVzIGZvciBsYXRlciBwdXJwb3Nlcy5cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgd29yc3QgY2FzZSBzY2VuYXJpbywgdGhpcyBpcyBhIGZ1bGwgTyhOKSBjb3N0LFxuICAgICAgICAgICAgICAgIC8vIGFuZCBzdWNoIHNjZW5hcmlvIGhhcHBlbnMgYXQgbGVhc3Qgd2hlbiBhbGwgbm9kZXMgYXJlIGRpZmZlcmVudCxcbiAgICAgICAgICAgICAgICAvLyBidXQgYWxzbyBpZiBib3RoIGZpcnN0IGFuZCBsYXN0IGl0ZW1zIG9mIHRoZSBsaXN0cyBhcmUgZGlmZmVyZW50XG4gICAgICAgICAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgICAgICAgIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgIGxldCBpID0gYlN0YXJ0O1xuXG4gICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGJFbmQpIG1hcC5zZXQoYltpXSwgaSsrKTtcbiAgICAgICAgICAgICAgICB9IC8vIGlmIGl0J3MgYSBmdXR1cmUgbm9kZSwgaGVuY2UgaXQgbmVlZHMgc29tZSBoYW5kbGluZ1xuXG5cbiAgICAgICAgICAgICAgICBpZiAobWFwLmhhcyhhW2FTdGFydF0pKSB7XG4gICAgICAgICAgICAgICAgICAvLyBncmFiIHRoZSBpbmRleCBvZiBzdWNoIG5vZGUsICdjYXVzZSBpdCBtaWdodCBoYXZlIGJlZW4gcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG1hcC5nZXQoYVthU3RhcnRdKTsgLy8gaWYgaXQncyBub3QgYWxyZWFkeSBwcm9jZXNzZWQsIGxvb2sgb24gZGVtYW5kIGZvciB0aGUgbmV4dCBMQ1NcblxuICAgICAgICAgICAgICAgICAgaWYgKGJTdGFydCA8IGluZGV4ICYmIGluZGV4IDwgYkVuZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IGFTdGFydDsgLy8gY291bnRzIHRoZSBhbW91bnQgb2Ygbm9kZXMgdGhhdCBhcmUgdGhlIHNhbWUgaW4gdGhlIGZ1dHVyZVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZXF1ZW5jZSA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IGFFbmQgJiYgaSA8IGJFbmQgJiYgbWFwLmdldChhW2ldKSA9PT0gaW5kZXggKyBzZXF1ZW5jZSkgc2VxdWVuY2UrKzsgLy8gZWZmb3J0IGRlY2lzaW9uIGhlcmU6IGlmIHRoZSBzZXF1ZW5jZSBpcyBsb25nZXIgdGhhbiByZXBsYWNlc1xuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkZWQgdG8gcmVhY2ggc3VjaCBzZXF1ZW5jZSwgd2hpY2ggd291bGQgYnJpbmdzIGFnYWluIHRoaXMgbG9vcFxuICAgICAgICAgICAgICAgICAgICAvLyB0byB0aGUgZmFzdCBwYXRoLCBwcmVwZW5kIHRoZSBkaWZmZXJlbmNlIGJlZm9yZSBhIHNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbW92ZSBvbmx5IHRoZSBmdXR1cmUgbGlzdCBpbmRleCBmb3J3YXJkLCBzbyB0aGF0IGFTdGFydFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgYlN0YXJ0IHdpbGwgYmUgYWxpZ25lZCBhZ2FpbiwgaGVuY2Ugb24gdGhlIGZhc3QgcGF0aC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQW4gZXhhbXBsZSBjb25zaWRlcmluZyBhU3RhcnQgYW5kIGJTdGFydCBhcmUgYm90aCAwOlxuICAgICAgICAgICAgICAgICAgICAvLyBhOiBbMSwgMiwgMywgNF1cbiAgICAgICAgICAgICAgICAgICAgLy8gYjogWzcsIDEsIDIsIDMsIDZdXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd291bGQgcGxhY2UgNyBiZWZvcmUgMSBhbmQsIGZyb20gdGhhdCB0aW1lIG9uLCAxLCAyLCBhbmQgM1xuICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBhdCB6ZXJvIGNvc3RcblxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXF1ZW5jZSA+IGluZGV4IC0gYlN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGdldChhW2FTdGFydF0sIDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJTdGFydCA8IGluZGV4KSBpbnNlcnRCZWZvcmUoZ2V0KGJbYlN0YXJ0KytdLCAxKSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gaWYgdGhlIGVmZm9ydCB3YXNuJ3QgZ29vZCBlbm91Z2gsIGZhbGxiYWNrIHRvIGEgcmVwbGFjZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92aW5nIGJvdGggc291cmNlIGFuZCB0YXJnZXQgaW5kZXhlcyBmb3J3YXJkLCBob3BpbmcgdGhhdCBzb21lXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbWlsYXIgbm9kZSB3aWxsIGJlIGZvdW5kIGxhdGVyIG9uLCB0byBnbyBiYWNrIHRvIHRoZSBmYXN0IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlQ2hpbGQoZ2V0KGJbYlN0YXJ0KytdLCAxKSwgZ2V0KGFbYVN0YXJ0KytdLCAtMSkpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gLy8gb3RoZXJ3aXNlIG1vdmUgdGhlIHNvdXJjZSBmb3J3YXJkLCAnY2F1c2UgdGhlcmUncyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICAgICAgICBlbHNlIGFTdGFydCsrO1xuICAgICAgICAgICAgICAgIH0gLy8gdGhpcyBub2RlIGhhcyBubyBtZWFuaW5nIGluIHRoZSBmdXR1cmUgbGlzdCwgc28gaXQncyBtb3JlIHRoYW4gc2FmZVxuICAgICAgICAgICAgICAgIC8vIHRvIHJlbW92ZSBpdCwgYW5kIGNoZWNrIHRoZSBuZXh0IGxpdmUgbm9kZSBvdXQgaW5zdGVhZCwgbWVhbmluZ1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgb25seSB0aGUgbGl2ZSBsaXN0IGluZGV4IHNob3VsZCBiZSBmb3J3YXJkZWRcbiAgICAgICAgICAgICAgICBlbHNlIHJlbW92ZUNoaWxkKGdldChhW2FTdGFydCsrXSwgLTEpKTtcbiAgICAgICAgICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIGI7XG59KTtcblxuY29uc3QgVU5NT1VOVF9TQ09QRSA9IFN5bWJvbCgndW5tb3VudCcpO1xuY29uc3QgRWFjaEJpbmRpbmcgPSB7XG4gIC8vIGR5bmFtaWMgYmluZGluZyBwcm9wZXJ0aWVzXG4gIC8vIGNoaWxkcmVuTWFwOiBudWxsLFxuICAvLyBub2RlOiBudWxsLFxuICAvLyByb290OiBudWxsLFxuICAvLyBjb25kaXRpb246IG51bGwsXG4gIC8vIGV2YWx1YXRlOiBudWxsLFxuICAvLyB0ZW1wbGF0ZTogbnVsbCxcbiAgLy8gaXNUZW1wbGF0ZVRhZzogZmFsc2UsXG4gIG5vZGVzOiBbXSxcblxuICAvLyBnZXRLZXk6IG51bGwsXG4gIC8vIGluZGV4TmFtZTogbnVsbCxcbiAgLy8gaXRlbU5hbWU6IG51bGwsXG4gIC8vIGFmdGVyUGxhY2Vob2xkZXI6IG51bGwsXG4gIC8vIHBsYWNlaG9sZGVyOiBudWxsLFxuICAvLyBBUEkgbWV0aG9kc1xuICBtb3VudChzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGUoc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgfSxcblxuICB1cGRhdGUoc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICBub2RlcyxcbiAgICAgIGNoaWxkcmVuTWFwXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY29sbGVjdGlvbiA9IHNjb3BlID09PSBVTk1PVU5UX1NDT1BFID8gbnVsbCA6IHRoaXMuZXZhbHVhdGUoc2NvcGUpO1xuICAgIGNvbnN0IGl0ZW1zID0gY29sbGVjdGlvbiA/IEFycmF5LmZyb20oY29sbGVjdGlvbikgOiBbXTsgLy8gcHJlcGFyZSB0aGUgZGlmZmluZ1xuXG4gICAgY29uc3Qge1xuICAgICAgbmV3Q2hpbGRyZW5NYXAsXG4gICAgICBiYXRjaGVzLFxuICAgICAgZnV0dXJlTm9kZXNcbiAgICB9ID0gY3JlYXRlUGF0Y2goaXRlbXMsIHNjb3BlLCBwYXJlbnRTY29wZSwgdGhpcyk7IC8vIHBhdGNoIHRoZSBET00gb25seSBpZiB0aGVyZSBhcmUgbmV3IG5vZGVzXG5cbiAgICB1ZG9tZGlmZihub2RlcywgZnV0dXJlTm9kZXMsIHBhdGNoKEFycmF5LmZyb20oY2hpbGRyZW5NYXAudmFsdWVzKCkpLCBwYXJlbnRTY29wZSksIHBsYWNlaG9sZGVyKTsgLy8gdHJpZ2dlciB0aGUgbW91bnRzIGFuZCB0aGUgdXBkYXRlc1xuXG4gICAgYmF0Y2hlcy5mb3JFYWNoKGZuID0+IGZuKCkpOyAvLyB1cGRhdGUgdGhlIGNoaWxkcmVuIG1hcFxuXG4gICAgdGhpcy5jaGlsZHJlbk1hcCA9IG5ld0NoaWxkcmVuTWFwO1xuICAgIHRoaXMubm9kZXMgPSBmdXR1cmVOb2RlczsgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIGxvb3AgZWRnZSBub2RlcyBhcmUgbWFya2VkXG5cbiAgICBtYXJrRWRnZU5vZGVzKHRoaXMubm9kZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHVubW91bnQoc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gICAgdGhpcy51cGRhdGUoVU5NT1VOVF9TQ09QRSwgcGFyZW50U2NvcGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn07XG4vKipcbiAqIFBhdGNoIHRoZSBET00gd2hpbGUgZGlmZmluZ1xuICogQHBhcmFtICAge2FueVtdfSByZWR1bmRhbnQgLSBsaXN0IG9mIGFsbCB0aGUgY2hpbGRyZW4gKHRlbXBsYXRlLCBub2RlcywgY29udGV4dCkgYWRkZWQgdmlhIGVhY2hcbiAqIEBwYXJhbSAgIHsqfSBwYXJlbnRTY29wZSAtIHNjb3BlIG9mIHRoZSBwYXJlbnQgdGVtcGxhdGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gcGF0Y2ggZnVuY3Rpb24gdXNlZCBieSBkb21kaWZmXG4gKi9cblxuZnVuY3Rpb24gcGF0Y2gocmVkdW5kYW50LCBwYXJlbnRTY29wZSkge1xuICByZXR1cm4gKGl0ZW0sIGluZm8pID0+IHtcbiAgICBpZiAoaW5mbyA8IDApIHtcbiAgICAgIC8vIGdldCB0aGUgbGFzdCBlbGVtZW50IGFkZGVkIHRvIHRoZSBjaGlsZHJlbk1hcCBzYXZlZCBwcmV2aW91c2x5XG4gICAgICBjb25zdCBlbGVtZW50ID0gcmVkdW5kYW50W3JlZHVuZGFudC5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBub2RlcyBhbmQgdGhlIHRlbXBsYXRlIGluIHN0b3JlZCBpbiB0aGUgbGFzdCBjaGlsZCBvZiB0aGUgY2hpbGRyZW5NYXBcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHRlbXBsYXRlLFxuICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSA9IGVsZW1lbnQ7IC8vIHJlbW92ZSB0aGUgbGFzdCBub2RlIChub3RpY2UgPHRlbXBsYXRlPiB0YWdzIG1pZ2h0IGhhdmUgbW9yZSBjaGlsZHJlbiBub2RlcylcblxuICAgICAgICBub2Rlcy5wb3AoKTsgLy8gbm90aWNlIHRoYXQgd2UgcGFzcyBudWxsIGFzIGxhc3QgYXJndW1lbnQgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgcm9vdCBub2RlIGFuZCBpdHMgY2hpbGRyZW4gd2lsbCBiZSByZW1vdmVkIGJ5IGRvbWRpZmZcblxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gd2UgaGF2ZSBjbGVhcmVkIGFsbCB0aGUgY2hpbGRyZW4gbm9kZXMgYW5kIHdlIGNhbiB1bm1vdW50IHRoaXMgdGVtcGxhdGVcbiAgICAgICAgICByZWR1bmRhbnQucG9wKCk7XG4gICAgICAgICAgdGVtcGxhdGUudW5tb3VudChjb250ZXh0LCBwYXJlbnRTY29wZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbTtcbiAgfTtcbn1cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIHRlbXBsYXRlIG11c3QgYmUgZmlsdGVyZWQgZnJvbSBhIGxvb3BcbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gY29uZGl0aW9uIC0gZmlsdGVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBjb250ZXh0IC0gYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBmaWx0ZXIgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoaXMgaXRlbSBzaG91bGQgYmUgc2tpcHBlZFxuICovXG5cblxuZnVuY3Rpb24gbXVzdEZpbHRlckl0ZW0oY29uZGl0aW9uLCBjb250ZXh0KSB7XG4gIHJldHVybiBjb25kaXRpb24gPyBCb29sZWFuKGNvbmRpdGlvbihjb250ZXh0KSkgPT09IGZhbHNlIDogZmFsc2U7XG59XG4vKipcbiAqIEV4dGVuZCB0aGUgc2NvcGUgb2YgdGhlIGxvb3BlZCB0ZW1wbGF0ZVxuICogQHBhcmFtICAge09iamVjdH0gc2NvcGUgLSBjdXJyZW50IHRlbXBsYXRlIHNjb3BlXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBvcHRpb25zLml0ZW1OYW1lIC0ga2V5IHRvIGlkZW50aWZ5IHRoZSBsb29wZWQgaXRlbSBpbiB0aGUgbmV3IGNvbnRleHRcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG9wdGlvbnMuaW5kZXhOYW1lIC0ga2V5IHRvIGlkZW50aWZ5IHRoZSBpbmRleCBvZiB0aGUgbG9vcGVkIGl0ZW1cbiAqIEBwYXJhbSAgIHtudW1iZXJ9IG9wdGlvbnMuaW5kZXggLSBjdXJyZW50IGluZGV4XG4gKiBAcGFyYW0gICB7Kn0gb3B0aW9ucy5pdGVtIC0gY29sbGVjdGlvbiBpdGVtIGxvb3BlZFxuICogQHJldHVybnMge09iamVjdH0gZW5oYW5jZWQgc2NvcGUgb2JqZWN0XG4gKi9cblxuXG5mdW5jdGlvbiBleHRlbmRTY29wZShzY29wZSwgX3JlZikge1xuICBsZXQge1xuICAgIGl0ZW1OYW1lLFxuICAgIGluZGV4TmFtZSxcbiAgICBpbmRleCxcbiAgICBpdGVtXG4gIH0gPSBfcmVmO1xuICBzY29wZVtpdGVtTmFtZV0gPSBpdGVtO1xuICBpZiAoaW5kZXhOYW1lKSBzY29wZVtpbmRleE5hbWVdID0gaW5kZXg7XG4gIHJldHVybiBzY29wZTtcbn1cbi8qKlxuICogTWFyayB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZXMgaW4gb3JkZXIgdG8gaWdub3JlIHRoZW0gaW4gY2FzZSB3ZSBuZWVkIHRvIHJldHJpZXZlIHRoZSA8dGVtcGxhdGU+IGZyYWdtZW50IG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5W119IG5vZGVzIC0gZWFjaCBiaW5kaW5nIG5vZGVzIGxpc3RcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9IHZvaWQgZnVuY3Rpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIG1hcmtFZGdlTm9kZXMobm9kZXMpIHtcbiAgY29uc3QgZmlyc3QgPSBub2Rlc1swXTtcbiAgY29uc3QgbGFzdCA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICBpZiAoZmlyc3QpIGZpcnN0W0hFQURfU1lNQk9MXSA9IHRydWU7XG4gIGlmIChsYXN0KSBsYXN0W1RBSUxfU1lNQk9MXSA9IHRydWU7XG59XG4vKipcbiAqIExvb3AgdGhlIGN1cnJlbnQgdGVtcGxhdGUgaXRlbXNcbiAqIEBwYXJhbSAgIHtBcnJheX0gaXRlbXMgLSBleHByZXNzaW9uIGNvbGxlY3Rpb24gdmFsdWVcbiAqIEBwYXJhbSAgIHsqfSBzY29wZSAtIHRlbXBsYXRlIHNjb3BlXG4gKiBAcGFyYW0gICB7Kn0gcGFyZW50U2NvcGUgLSBzY29wZSBvZiB0aGUgcGFyZW50IHRlbXBsYXRlXG4gKiBAcGFyYW0gICB7RWVhY2hCaW5kaW5nfSBiaW5kaW5nIC0gZWFjaCBiaW5kaW5nIG9iamVjdCBpbnN0YW5jZVxuICogQHJldHVybnMge09iamVjdH0gZGF0YVxuICogQHJldHVybnMge01hcH0gZGF0YS5uZXdDaGlsZHJlbk1hcCAtIGEgTWFwIGNvbnRhaW5pbmcgdGhlIG5ldyBjaGlsZHJlbiB0ZW1wbGF0ZSBzdHJ1Y3R1cmVcbiAqIEByZXR1cm5zIHtBcnJheX0gZGF0YS5iYXRjaGVzIC0gYXJyYXkgY29udGFpbmluZyB0aGUgdGVtcGxhdGUgbGlmZWN5Y2xlIGZ1bmN0aW9ucyB0byB0cmlnZ2VyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGRhdGEuZnV0dXJlTm9kZXMgLSBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyB3ZSBuZWVkIHRvIGRpZmZcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoKGl0ZW1zLCBzY29wZSwgcGFyZW50U2NvcGUsIGJpbmRpbmcpIHtcbiAgY29uc3Qge1xuICAgIGNvbmRpdGlvbixcbiAgICB0ZW1wbGF0ZSxcbiAgICBjaGlsZHJlbk1hcCxcbiAgICBpdGVtTmFtZSxcbiAgICBnZXRLZXksXG4gICAgaW5kZXhOYW1lLFxuICAgIHJvb3QsXG4gICAgaXNUZW1wbGF0ZVRhZ1xuICB9ID0gYmluZGluZztcbiAgY29uc3QgbmV3Q2hpbGRyZW5NYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGJhdGNoZXMgPSBbXTtcbiAgY29uc3QgZnV0dXJlTm9kZXMgPSBbXTtcbiAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gZXh0ZW5kU2NvcGUoT2JqZWN0LmNyZWF0ZShzY29wZSksIHtcbiAgICAgIGl0ZW1OYW1lLFxuICAgICAgaW5kZXhOYW1lLFxuICAgICAgaW5kZXgsXG4gICAgICBpdGVtXG4gICAgfSk7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5ID8gZ2V0S2V5KGNvbnRleHQpIDogaW5kZXg7XG4gICAgY29uc3Qgb2xkSXRlbSA9IGNoaWxkcmVuTWFwLmdldChrZXkpO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG5cbiAgICBpZiAobXVzdEZpbHRlckl0ZW0oY29uZGl0aW9uLCBjb250ZXh0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG11c3RNb3VudCA9ICFvbGRJdGVtO1xuICAgIGNvbnN0IGNvbXBvbmVudFRlbXBsYXRlID0gb2xkSXRlbSA/IG9sZEl0ZW0udGVtcGxhdGUgOiB0ZW1wbGF0ZS5jbG9uZSgpO1xuICAgIGNvbnN0IGVsID0gY29tcG9uZW50VGVtcGxhdGUuZWwgfHwgcm9vdC5jbG9uZU5vZGUoKTtcbiAgICBjb25zdCBtZXRhID0gaXNUZW1wbGF0ZVRhZyAmJiBtdXN0TW91bnQgPyBjcmVhdGVUZW1wbGF0ZU1ldGEoY29tcG9uZW50VGVtcGxhdGUpIDogY29tcG9uZW50VGVtcGxhdGUubWV0YTtcblxuICAgIGlmIChtdXN0TW91bnQpIHtcbiAgICAgIGJhdGNoZXMucHVzaCgoKSA9PiBjb21wb25lbnRUZW1wbGF0ZS5tb3VudChlbCwgY29udGV4dCwgcGFyZW50U2NvcGUsIG1ldGEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmF0Y2hlcy5wdXNoKCgpID0+IGNvbXBvbmVudFRlbXBsYXRlLnVwZGF0ZShjb250ZXh0LCBwYXJlbnRTY29wZSkpO1xuICAgIH0gLy8gY3JlYXRlIHRoZSBjb2xsZWN0aW9uIG9mIG5vZGVzIHRvIHVwZGF0ZSBvciB0byBhZGRcbiAgICAvLyBpbiBjYXNlIG9mIHRlbXBsYXRlIHRhZ3Mgd2UgbmVlZCB0byBhZGQgYWxsIGl0cyBjaGlsZHJlbiBub2Rlc1xuXG5cbiAgICBpZiAoaXNUZW1wbGF0ZVRhZykge1xuICAgICAgbm9kZXMucHVzaCguLi4obXVzdE1vdW50ID8gbWV0YS5jaGlsZHJlbiA6IGdldEZyYWdtZW50Q2hpbGRyZW4obWV0YSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZXMucHVzaChlbCk7XG4gICAgfSAvLyBkZWxldGUgdGhlIG9sZCBpdGVtIGZyb20gdGhlIGNoaWxkcmVuIG1hcFxuXG5cbiAgICBjaGlsZHJlbk1hcC5kZWxldGUoa2V5KTtcbiAgICBmdXR1cmVOb2Rlcy5wdXNoKC4uLm5vZGVzKTsgLy8gdXBkYXRlIHRoZSBjaGlsZHJlbiBtYXBcblxuICAgIG5ld0NoaWxkcmVuTWFwLnNldChrZXksIHtcbiAgICAgIG5vZGVzLFxuICAgICAgdGVtcGxhdGU6IGNvbXBvbmVudFRlbXBsYXRlLFxuICAgICAgY29udGV4dCxcbiAgICAgIGluZGV4XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIG5ld0NoaWxkcmVuTWFwLFxuICAgIGJhdGNoZXMsXG4gICAgZnV0dXJlTm9kZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlJDYobm9kZSwgX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBldmFsdWF0ZSxcbiAgICBjb25kaXRpb24sXG4gICAgaXRlbU5hbWUsXG4gICAgaW5kZXhOYW1lLFxuICAgIGdldEtleSxcbiAgICB0ZW1wbGF0ZVxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBjb25zdCByb290ID0gbm9kZS5jbG9uZU5vZGUoKTtcbiAgaW5zZXJ0QmVmb3JlKHBsYWNlaG9sZGVyLCBub2RlKTtcbiAgcmVtb3ZlQ2hpbGQobm9kZSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBFYWNoQmluZGluZywge1xuICAgIGNoaWxkcmVuTWFwOiBuZXcgTWFwKCksXG4gICAgbm9kZSxcbiAgICByb290LFxuICAgIGNvbmRpdGlvbixcbiAgICBldmFsdWF0ZSxcbiAgICBpc1RlbXBsYXRlVGFnOiBpc1RlbXBsYXRlKHJvb3QpLFxuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZS5jcmVhdGVET00obm9kZSksXG4gICAgZ2V0S2V5LFxuICAgIGluZGV4TmFtZSxcbiAgICBpdGVtTmFtZSxcbiAgICBwbGFjZWhvbGRlclxuICB9KTtcbn1cblxuLyoqXG4gKiBCaW5kaW5nIHJlc3BvbnNpYmxlIGZvciB0aGUgYGlmYCBkaXJlY3RpdmVcbiAqL1xuXG5jb25zdCBJZkJpbmRpbmcgPSB7XG4gIC8vIGR5bmFtaWMgYmluZGluZyBwcm9wZXJ0aWVzXG4gIC8vIG5vZGU6IG51bGwsXG4gIC8vIGV2YWx1YXRlOiBudWxsLFxuICAvLyBpc1RlbXBsYXRlVGFnOiBmYWxzZSxcbiAgLy8gcGxhY2Vob2xkZXI6IG51bGwsXG4gIC8vIHRlbXBsYXRlOiBudWxsLFxuICAvLyBBUEkgbWV0aG9kc1xuICBtb3VudChzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGUoc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgfSxcblxuICB1cGRhdGUoc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gICAgY29uc3QgdmFsdWUgPSAhIXRoaXMuZXZhbHVhdGUoc2NvcGUpO1xuICAgIGNvbnN0IG11c3RNb3VudCA9ICF0aGlzLnZhbHVlICYmIHZhbHVlO1xuICAgIGNvbnN0IG11c3RVbm1vdW50ID0gdGhpcy52YWx1ZSAmJiAhdmFsdWU7XG5cbiAgICBjb25zdCBtb3VudCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHByaXN0aW5lID0gdGhpcy5ub2RlLmNsb25lTm9kZSgpO1xuICAgICAgaW5zZXJ0QmVmb3JlKHByaXN0aW5lLCB0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICAgIHRoaXMudGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlLmNsb25lKCk7XG4gICAgICB0aGlzLnRlbXBsYXRlLm1vdW50KHByaXN0aW5lLCBzY29wZSwgcGFyZW50U2NvcGUpO1xuICAgIH07XG5cbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIGNhc2UgbXVzdE1vdW50OlxuICAgICAgICBtb3VudCgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBtdXN0VW5tb3VudDpcbiAgICAgICAgdGhpcy51bm1vdW50KHNjb3BlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh2YWx1ZSkgdGhpcy50ZW1wbGF0ZS51cGRhdGUoc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdW5tb3VudChzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgICB0aGlzLnRlbXBsYXRlLnVubW91bnQoc2NvcGUsIHBhcmVudFNjb3BlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59O1xuZnVuY3Rpb24gY3JlYXRlJDUobm9kZSwgX3JlZikge1xuICBsZXQge1xuICAgIGV2YWx1YXRlLFxuICAgIHRlbXBsYXRlXG4gIH0gPSBfcmVmO1xuICBjb25zdCBwbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgaW5zZXJ0QmVmb3JlKHBsYWNlaG9sZGVyLCBub2RlKTtcbiAgcmVtb3ZlQ2hpbGQobm9kZSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBJZkJpbmRpbmcsIHtcbiAgICBub2RlLFxuICAgIGV2YWx1YXRlLFxuICAgIHBsYWNlaG9sZGVyLFxuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZS5jcmVhdGVET00obm9kZSlcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3cgYW4gZXJyb3Igd2l0aCBhIGRlc2NyaXB0aXZlIG1lc3NhZ2VcbiAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gbWVzc2FnZSAtIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHsgdW5kZWZpbmVkIH0gaG9wcGxhLi4gYXQgdGhpcyBwb2ludCB0aGUgcHJvZ3JhbSBzaG91bGQgc3RvcCB3b3JraW5nXG4gKi9cblxuZnVuY3Rpb24gcGFuaWMobWVzc2FnZSkge1xuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG1lbW9pemVkIChjYWNoZWQpIGZ1bmN0aW9uLlxuICogLy8gYm9ycm93ZWQgZnJvbSBodHRwczovL3d3dy4zMHNlY29uZHNvZmNvZGUub3JnL2pzL3MvbWVtb2l6ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBmdW5jdGlvbiB0byBtZW1vaXplXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IG1lbW9pemUgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBtZW1vaXplKGZuKSB7XG4gIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0IGNhY2hlZCA9IHZhbCA9PiB7XG4gICAgcmV0dXJuIGNhY2hlLmhhcyh2YWwpID8gY2FjaGUuZ2V0KHZhbCkgOiBjYWNoZS5zZXQodmFsLCBmbi5jYWxsKHRoaXMsIHZhbCkpICYmIGNhY2hlLmdldCh2YWwpO1xuICB9O1xuXG4gIGNhY2hlZC5jYWNoZSA9IGNhY2hlO1xuICByZXR1cm4gY2FjaGVkO1xufVxuLyoqXG4gKiBFdmFsdWF0ZSBhIGxpc3Qgb2YgYXR0cmlidXRlIGV4cHJlc3Npb25zXG4gKiBAcGFyYW0gICB7QXJyYXl9IGF0dHJpYnV0ZXMgLSBhdHRyaWJ1dGUgZXhwcmVzc2lvbnMgZ2VuZXJhdGVkIGJ5IHRoZSByaW90IGNvbXBpbGVyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBrZXkgdmFsdWUgcGFpcnMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBjb21wdXRhdGlvblxuICovXG5cbmZ1bmN0aW9uIGV2YWx1YXRlQXR0cmlidXRlRXhwcmVzc2lvbnMoYXR0cmlidXRlcykge1xuICByZXR1cm4gYXR0cmlidXRlcy5yZWR1Y2UoKGFjYywgYXR0cmlidXRlKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICB0eXBlXG4gICAgfSA9IGF0dHJpYnV0ZTtcblxuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgLy8gc3ByZWFkIGF0dHJpYnV0ZVxuICAgICAgY2FzZSAhYXR0cmlidXRlLm5hbWUgJiYgdHlwZSA9PT0gQVRUUklCVVRFOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYWNjLCB2YWx1ZSk7XG4gICAgICAvLyB2YWx1ZSBhdHRyaWJ1dGVcblxuICAgICAgY2FzZSB0eXBlID09PSBWQUxVRTpcbiAgICAgICAgYWNjLnZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIG5vcm1hbCBhdHRyaWJ1dGVzXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFjY1tkYXNoVG9DYW1lbENhc2UoYXR0cmlidXRlLm5hbWUpXSA9IGF0dHJpYnV0ZS52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbmNvbnN0IEVsZW1lbnRQcm90byA9IHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyA/IHt9IDogRWxlbWVudC5wcm90b3R5cGU7XG5jb25zdCBpc05hdGl2ZUh0bWxQcm9wZXJ0eSA9IG1lbW9pemUobmFtZSA9PiBFbGVtZW50UHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSkpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKlxuICogQWRkIGFsbCB0aGUgYXR0cmlidXRlcyBwcm92aWRlZFxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBub2RlIC0gdGFyZ2V0IG5vZGVcbiAqIEBwYXJhbSAgIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBvYmplY3QgY29udGFpbmluZyB0aGUgYXR0cmlidXRlcyBuYW1lcyBhbmQgdmFsdWVzXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfSBzb3JyeSBpdCdzIGEgdm9pZCBmdW5jdGlvbiA6KFxuICovXG5cbmZ1bmN0aW9uIHNldEFsbEF0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuICBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgIGxldCBbbmFtZSwgdmFsdWVdID0gX3JlZjtcbiAgICByZXR1cm4gYXR0cmlidXRlRXhwcmVzc2lvbihub2RlLCB7XG4gICAgICBuYW1lXG4gICAgfSwgdmFsdWUpO1xuICB9KTtcbn1cbi8qKlxuICogUmVtb3ZlIGFsbCB0aGUgYXR0cmlidXRlcyBwcm92aWRlZFxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBub2RlIC0gdGFyZ2V0IG5vZGVcbiAqIEBwYXJhbSAgIHtPYmplY3R9IG5ld0F0dHJpYnV0ZXMgLSBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5ldyBhdHRyaWJ1dGUgbmFtZXNcbiAqIEBwYXJhbSAgIHtPYmplY3R9IG9sZEF0dHJpYnV0ZXMgLSBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG9sZCBhdHRyaWJ1dGUgbmFtZXNcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9IHNvcnJ5IGl0J3MgYSB2b2lkIGZ1bmN0aW9uIDooXG4gKi9cblxuXG5mdW5jdGlvbiByZW1vdmVBbGxBdHRyaWJ1dGVzKG5vZGUsIG5ld0F0dHJpYnV0ZXMsIG9sZEF0dHJpYnV0ZXMpIHtcbiAgY29uc3QgbmV3S2V5cyA9IG5ld0F0dHJpYnV0ZXMgPyBPYmplY3Qua2V5cyhuZXdBdHRyaWJ1dGVzKSA6IFtdO1xuICBPYmplY3Qua2V5cyhvbGRBdHRyaWJ1dGVzKS5maWx0ZXIobmFtZSA9PiAhbmV3S2V5cy5pbmNsdWRlcyhuYW1lKSkuZm9yRWFjaChhdHRyaWJ1dGUgPT4gbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKSk7XG59XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBjYW4gYmUgcmVuZGVyZWRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBleHByZXNzaW9uIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB3ZSBjYW4gcmVuZGVyIHRoaXMgYXR0cmlidXRlIHZhbHVlXG4gKi9cblxuXG5mdW5jdGlvbiBjYW5SZW5kZXJBdHRyaWJ1dGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IFsnc3RyaW5nJywgJ251bWJlciddLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSk7XG59XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGF0dHJpYnV0ZSBzaG91bGQgYmUgcmVtb3ZlZFxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIGV4cHJlc3Npb24gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBib29sZWFuIC0gdHJ1ZSBpZiB0aGUgYXR0cmlidXRlIGNhbiBiZSByZW1vdmVkfVxuICovXG5cblxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlKHZhbHVlKSB7XG4gIHJldHVybiBpc05pbCh2YWx1ZSkgfHwgdmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSAnJztcbn1cbi8qKlxuICogVGhpcyBtZXRob2RzIGhhbmRsZXMgdGhlIERPTSBhdHRyaWJ1dGVzIHVwZGF0ZXNcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gbm9kZSAtIHRhcmdldCBub2RlXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBleHByZXNzaW9uIC0gZXhwcmVzc2lvbiBvYmplY3RcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IGV4cHJlc3Npb24ubmFtZSAtIGF0dHJpYnV0ZSBuYW1lXG4gKiBAcGFyYW0gICB7Kn0gdmFsdWUgLSBuZXcgZXhwcmVzc2lvbiB2YWx1ZVxuICogQHBhcmFtICAgeyp9IG9sZFZhbHVlIC0gdGhlIG9sZCBleHByZXNzaW9uIGNhY2hlZCB2YWx1ZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGF0dHJpYnV0ZUV4cHJlc3Npb24obm9kZSwgX3JlZjIsIHZhbHVlLCBvbGRWYWx1ZSkge1xuICBsZXQge1xuICAgIG5hbWVcbiAgfSA9IF9yZWYyO1xuXG4gIC8vIGlzIGl0IGEgc3ByZWFkIG9wZXJhdG9yPyB7Li4uYXR0cmlidXRlc31cbiAgaWYgKCFuYW1lKSB7XG4gICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAvLyByZW1vdmUgYWxsIHRoZSBvbGQgYXR0cmlidXRlc1xuICAgICAgcmVtb3ZlQWxsQXR0cmlidXRlcyhub2RlLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgIH0gLy8gaXMgdGhlIHZhbHVlIHN0aWxsIHRydXRoeT9cblxuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBzZXRBbGxBdHRyaWJ1dGVzKG5vZGUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0gLy8gaGFuZGxlIGJvb2xlYW4gYXR0cmlidXRlc1xuXG5cbiAgaWYgKCFpc05hdGl2ZUh0bWxQcm9wZXJ0eShuYW1lKSAmJiAoaXNCb29sZWFuKHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkgfHwgaXNGdW5jdGlvbih2YWx1ZSkpKSB7XG4gICAgbm9kZVtuYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZSh2YWx1ZSkpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfSBlbHNlIGlmIChjYW5SZW5kZXJBdHRyaWJ1dGUodmFsdWUpKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgbm9ybWFsaXplVmFsdWUobmFtZSwgdmFsdWUpKTtcbiAgfVxufVxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGFzIHN0cmluZ1xuICogQHBhcmFtICAge3N0cmluZ30gbmFtZSAtIGF0dHJpYnV0ZSBuYW1lXG4gKiBAcGFyYW0gICB7Kn0gdmFsdWUgLSB1c2VyIGlucHV0IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBpbnB1dCB2YWx1ZSBhcyBzdHJpbmdcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZShuYW1lLCB2YWx1ZSkge1xuICAvLyBiZSBzdXJlIHRoYXQgZXhwcmVzc2lvbnMgbGlrZSBzZWxlY3RlZD17IHRydWUgfSB3aWxsIGJlIGFsd2F5cyByZW5kZXJlZCBhcyBzZWxlY3RlZD0nc2VsZWN0ZWQnXG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSkgcmV0dXJuIG5hbWU7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuY29uc3QgUkVfRVZFTlRTX1BSRUZJWCA9IC9eb24vO1xuXG5jb25zdCBnZXRDYWxsYmFja0FuZE9wdGlvbnMgPSB2YWx1ZSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlLCBmYWxzZV07IC8vIHNlZSBhbHNvIGh0dHBzOi8vbWVkaXVtLmNvbS9AV2ViUmVmbGVjdGlvbi9kb20taGFuZGxlZXZlbnQtYS1jcm9zcy1wbGF0Zm9ybS1zdGFuZGFyZC1zaW5jZS15ZWFyLTIwMDAtNWJmMTcyODdmZDM4XG5cblxuY29uc3QgRXZlbnRMaXN0ZW5lciA9IHtcbiAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzW2V2ZW50LnR5cGVdKGV2ZW50KTtcbiAgfVxuXG59O1xuY29uc3QgTGlzdGVuZXJzV2Vha01hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbmNvbnN0IGNyZWF0ZUxpc3RlbmVyID0gbm9kZSA9PiB7XG4gIGNvbnN0IGxpc3RlbmVyID0gT2JqZWN0LmNyZWF0ZShFdmVudExpc3RlbmVyKTtcbiAgTGlzdGVuZXJzV2Vha01hcC5zZXQobm9kZSwgbGlzdGVuZXIpO1xuICByZXR1cm4gbGlzdGVuZXI7XG59O1xuLyoqXG4gKiBTZXQgYSBuZXcgZXZlbnQgbGlzdGVuZXJcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gbm9kZSAtIHRhcmdldCBub2RlXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBleHByZXNzaW9uIC0gZXhwcmVzc2lvbiBvYmplY3RcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IGV4cHJlc3Npb24ubmFtZSAtIGV2ZW50IG5hbWVcbiAqIEBwYXJhbSAgIHsqfSB2YWx1ZSAtIG5ldyBleHByZXNzaW9uIHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWV9IHRoZSBjYWxsYmFjayBqdXN0IHJlY2VpdmVkXG4gKi9cblxuXG5mdW5jdGlvbiBldmVudEV4cHJlc3Npb24obm9kZSwgX3JlZiwgdmFsdWUpIHtcbiAgbGV0IHtcbiAgICBuYW1lXG4gIH0gPSBfcmVmO1xuICBjb25zdCBub3JtYWxpemVkRXZlbnROYW1lID0gbmFtZS5yZXBsYWNlKFJFX0VWRU5UU19QUkVGSVgsICcnKTtcbiAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IExpc3RlbmVyc1dlYWtNYXAuZ2V0KG5vZGUpIHx8IGNyZWF0ZUxpc3RlbmVyKG5vZGUpO1xuICBjb25zdCBbY2FsbGJhY2ssIG9wdGlvbnNdID0gZ2V0Q2FsbGJhY2tBbmRPcHRpb25zKHZhbHVlKTtcbiAgY29uc3QgaGFuZGxlciA9IGV2ZW50TGlzdGVuZXJbbm9ybWFsaXplZEV2ZW50TmFtZV07XG4gIGNvbnN0IG11c3RSZW1vdmVFdmVudCA9IGhhbmRsZXIgJiYgIWNhbGxiYWNrO1xuICBjb25zdCBtdXN0QWRkRXZlbnQgPSBjYWxsYmFjayAmJiAhaGFuZGxlcjtcblxuICBpZiAobXVzdFJlbW92ZUV2ZW50KSB7XG4gICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKG5vcm1hbGl6ZWRFdmVudE5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICB9XG5cbiAgaWYgKG11c3RBZGRFdmVudCkge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihub3JtYWxpemVkRXZlbnROYW1lLCBldmVudExpc3RlbmVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIGV2ZW50TGlzdGVuZXJbbm9ybWFsaXplZEV2ZW50TmFtZV0gPSBjYWxsYmFjaztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIHVzZXIgdmFsdWUgaW4gb3JkZXIgdG8gcmVuZGVyIGEgZW1wdHkgc3RyaW5nIGluIGNhc2Ugb2YgZmFsc3kgdmFsdWVzXG4gKiBAcGFyYW0gICB7Kn0gdmFsdWUgLSB1c2VyIGlucHV0IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBob3BlZnVsbHkgYSBzdHJpbmdcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gaXNOaWwodmFsdWUpID8gJycgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRoZSB0YXJnZXQgdGV4dCBub2RlIHRvIHVwZGF0ZSBvciBjcmVhdGUgb25lIGZyb20gb2YgYSBjb21tZW50IG5vZGVcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gbm9kZSAtIGFueSBodG1sIGVsZW1lbnQgY29udGFpbmluZyBjaGlsZE5vZGVzXG4gKiBAcGFyYW0gICB7bnVtYmVyfSBjaGlsZE5vZGVJbmRleCAtIGluZGV4IG9mIHRoZSB0ZXh0IG5vZGUgaW4gdGhlIGNoaWxkTm9kZXMgbGlzdFxuICogQHJldHVybnMge0hUTUxUZXh0Tm9kZX0gdGhlIHRleHQgbm9kZSB0byB1cGRhdGVcbiAqL1xuXG5jb25zdCBnZXRUZXh0Tm9kZSA9IChub2RlLCBjaGlsZE5vZGVJbmRleCkgPT4ge1xuICBjb25zdCB0YXJnZXQgPSBub2RlLmNoaWxkTm9kZXNbY2hpbGROb2RlSW5kZXhdO1xuXG4gIGlmICh0YXJnZXQubm9kZVR5cGUgPT09IE5vZGUuQ09NTUVOVF9OT0RFKSB7XG4gICAgY29uc3QgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbm9kZS5yZXBsYWNlQ2hpbGQodGV4dE5vZGUsIHRhcmdldCk7XG4gICAgcmV0dXJuIHRleHROb2RlO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG4vKipcbiAqIFRoaXMgbWV0aG9kcyBoYW5kbGVzIGEgc2ltcGxlIHRleHQgZXhwcmVzc2lvbiB1cGRhdGVcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gbm9kZSAtIHRhcmdldCBub2RlXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBkYXRhIC0gZXhwcmVzc2lvbiBvYmplY3RcbiAqIEBwYXJhbSAgIHsqfSB2YWx1ZSAtIG5ldyBleHByZXNzaW9uIHZhbHVlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHRleHRFeHByZXNzaW9uKG5vZGUsIGRhdGEsIHZhbHVlKSB7XG4gIG5vZGUuZGF0YSA9IG5vcm1hbGl6ZVN0cmluZ1ZhbHVlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZHMgaGFuZGxlcyB0aGUgaW5wdXQgZmlsZWRzIHZhbHVlIHVwZGF0ZXNcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gbm9kZSAtIHRhcmdldCBub2RlXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBleHByZXNzaW9uIC0gZXhwcmVzc2lvbiBvYmplY3RcbiAqIEBwYXJhbSAgIHsqfSB2YWx1ZSAtIG5ldyBleHByZXNzaW9uIHZhbHVlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHZhbHVlRXhwcmVzc2lvbihub2RlLCBleHByZXNzaW9uLCB2YWx1ZSkge1xuICBub2RlLnZhbHVlID0gbm9ybWFsaXplU3RyaW5nVmFsdWUodmFsdWUpO1xufVxuXG52YXIgZXhwcmVzc2lvbnMgPSB7XG4gIFtBVFRSSUJVVEVdOiBhdHRyaWJ1dGVFeHByZXNzaW9uLFxuICBbRVZFTlRdOiBldmVudEV4cHJlc3Npb24sXG4gIFtURVhUXTogdGV4dEV4cHJlc3Npb24sXG4gIFtWQUxVRV06IHZhbHVlRXhwcmVzc2lvblxufTtcblxuY29uc3QgRXhwcmVzc2lvbiA9IHtcbiAgLy8gU3RhdGljIHByb3BzXG4gIC8vIG5vZGU6IG51bGwsXG4gIC8vIHZhbHVlOiBudWxsLFxuICAvLyBBUEkgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBNb3VudCB0aGUgZXhwcmVzc2lvbiBldmFsdWF0aW5nIGl0cyBpbml0aWFsIHZhbHVlXG4gICAqIEBwYXJhbSAgIHsqfSBzY29wZSAtIGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgZXhwcmVzc2lvbiB0byBldmFsdWF0ZSBpdHMgY3VycmVudCB2YWx1ZXNcbiAgICogQHJldHVybnMge0V4cHJlc3Npb259IHNlbGZcbiAgICovXG4gIG1vdW50KHNjb3BlKSB7XG4gICAgLy8gaG9wZWZ1bGx5IGEgcHVyZSBmdW5jdGlvblxuICAgIHRoaXMudmFsdWUgPSB0aGlzLmV2YWx1YXRlKHNjb3BlKTsgLy8gSU8oKSBET00gdXBkYXRlc1xuXG4gICAgYXBwbHkodGhpcywgdGhpcy52YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZXhwcmVzc2lvbiBpZiBpdHMgdmFsdWUgY2hhbmdlZFxuICAgKiBAcGFyYW0gICB7Kn0gc2NvcGUgLSBhcmd1bWVudCBwYXNzZWQgdG8gdGhlIGV4cHJlc3Npb24gdG8gZXZhbHVhdGUgaXRzIGN1cnJlbnQgdmFsdWVzXG4gICAqIEByZXR1cm5zIHtFeHByZXNzaW9ufSBzZWxmXG4gICAqL1xuICB1cGRhdGUoc2NvcGUpIHtcbiAgICAvLyBwdXJlIGZ1bmN0aW9uXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmV2YWx1YXRlKHNjb3BlKTtcblxuICAgIGlmICh0aGlzLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgLy8gSU8oKSBET00gdXBkYXRlc1xuICAgICAgYXBwbHkodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHByZXNzaW9uIHRlYXJkb3duIG1ldGhvZFxuICAgKiBAcmV0dXJucyB7RXhwcmVzc2lvbn0gc2VsZlxuICAgKi9cbiAgdW5tb3VudCgpIHtcbiAgICAvLyB1bm1vdW50IG9ubHkgdGhlIGV2ZW50IGhhbmRsaW5nIGV4cHJlc3Npb25zXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gRVZFTlQpIGFwcGx5KHRoaXMsIG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn07XG4vKipcbiAqIElPKCkgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBET00gdXBkYXRlc1xuICogQHBhcmFtIHtFeHByZXNzaW9ufSBleHByZXNzaW9uIC0gZXhwcmVzc2lvbiBvYmplY3RcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBjdXJyZW50IGV4cHJlc3Npb24gdmFsdWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gYXBwbHkoZXhwcmVzc2lvbiwgdmFsdWUpIHtcbiAgcmV0dXJuIGV4cHJlc3Npb25zW2V4cHJlc3Npb24udHlwZV0oZXhwcmVzc2lvbi5ub2RlLCBleHByZXNzaW9uLCB2YWx1ZSwgZXhwcmVzc2lvbi52YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZSQ0KG5vZGUsIGRhdGEpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIEV4cHJlc3Npb24sIGRhdGEsIHtcbiAgICBub2RlOiBkYXRhLnR5cGUgPT09IFRFWFQgPyBnZXRUZXh0Tm9kZShub2RlLCBkYXRhLmNoaWxkTm9kZUluZGV4KSA6IG5vZGVcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZmxhdCBvYmplY3QgaGF2aW5nIGFzIGtleXMgYSBsaXN0IG9mIG1ldGhvZHMgdGhhdCBpZiBkaXNwYXRjaGVkIHdpbGwgcHJvcGFnYXRlXG4gKiBvbiB0aGUgd2hvbGUgY29sbGVjdGlvblxuICogQHBhcmFtICAge0FycmF5fSBjb2xsZWN0aW9uIC0gY29sbGVjdGlvbiB0byBpdGVyYXRlXG4gKiBAcGFyYW0gICB7QXJyYXk8c3RyaW5nPn0gbWV0aG9kcyAtIG1ldGhvZHMgdG8gZXhlY3V0ZSBvbiBlYWNoIGl0ZW0gb2YgdGhlIGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAgIHsqfSBjb250ZXh0IC0gY29udGV4dCByZXR1cm5lZCBieSB0aGUgbmV3IG1ldGhvZHMgY3JlYXRlZFxuICogQHJldHVybnMge09iamVjdH0gYSBuZXcgb2JqZWN0IHRvIHNpbXBsaWZ5IHRoZSB0aGUgbmVzdGVkIG1ldGhvZHMgZGlzcGF0Y2hpbmdcbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkNvbGxlY3Rpb25NZXRob2RzKGNvbGxlY3Rpb24sIG1ldGhvZHMsIGNvbnRleHQpIHtcbiAgcmV0dXJuIG1ldGhvZHMucmVkdWNlKChhY2MsIG1ldGhvZCkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBhY2MsIHtcbiAgICAgIFttZXRob2RdOiBzY29wZSA9PiB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uLm1hcChpdGVtID0+IGl0ZW1bbWV0aG9kXShzY29wZSkpICYmIGNvbnRleHQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlJDMobm9kZSwgX3JlZikge1xuICBsZXQge1xuICAgIGV4cHJlc3Npb25zXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZmxhdHRlbkNvbGxlY3Rpb25NZXRob2RzKGV4cHJlc3Npb25zLm1hcChleHByZXNzaW9uID0+IGNyZWF0ZSQ0KG5vZGUsIGV4cHJlc3Npb24pKSwgWydtb3VudCcsICd1cGRhdGUnLCAndW5tb3VudCddKSk7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZFBhcmVudFNjb3BlKGF0dHJpYnV0ZXMsIHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICBpZiAoIWF0dHJpYnV0ZXMgfHwgIWF0dHJpYnV0ZXMubGVuZ3RoKSByZXR1cm4gcGFyZW50U2NvcGU7XG4gIGNvbnN0IGV4cHJlc3Npb25zID0gYXR0cmlidXRlcy5tYXAoYXR0ciA9PiBPYmplY3QuYXNzaWduKHt9LCBhdHRyLCB7XG4gICAgdmFsdWU6IGF0dHIuZXZhbHVhdGUoc2NvcGUpXG4gIH0pKTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZSB8fCBudWxsKSwgZXZhbHVhdGVBdHRyaWJ1dGVFeHByZXNzaW9ucyhleHByZXNzaW9ucykpO1xufSAvLyB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgbWVhbnQgdG8gZml4IGFuIGVkZ2UgY2FzZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3Jpb3QvcmlvdC9pc3N1ZXMvMjg0MlxuXG5cbmNvbnN0IGdldFJlYWxQYXJlbnQgPSAoc2NvcGUsIHBhcmVudFNjb3BlKSA9PiBzY29wZVtQQVJFTlRfS0VZX1NZTUJPTF0gfHwgcGFyZW50U2NvcGU7XG5cbmNvbnN0IFNsb3RCaW5kaW5nID0ge1xuICAvLyBkeW5hbWljIGJpbmRpbmcgcHJvcGVydGllc1xuICAvLyBub2RlOiBudWxsLFxuICAvLyBuYW1lOiBudWxsLFxuICBhdHRyaWJ1dGVzOiBbXSxcblxuICAvLyB0ZW1wbGF0ZTogbnVsbCxcbiAgZ2V0VGVtcGxhdGVTY29wZShzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgICByZXR1cm4gZXh0ZW5kUGFyZW50U2NvcGUodGhpcy5hdHRyaWJ1dGVzLCBzY29wZSwgcGFyZW50U2NvcGUpO1xuICB9LFxuXG4gIC8vIEFQSSBtZXRob2RzXG4gIG1vdW50KHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICAgIGNvbnN0IHRlbXBsYXRlRGF0YSA9IHNjb3BlLnNsb3RzID8gc2NvcGUuc2xvdHMuZmluZChfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGlkXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiBpZCA9PT0gdGhpcy5uYW1lO1xuICAgIH0pIDogZmFsc2U7XG4gICAgY29uc3Qge1xuICAgICAgcGFyZW50Tm9kZVxuICAgIH0gPSB0aGlzLm5vZGU7XG4gICAgY29uc3QgcmVhbFBhcmVudCA9IGdldFJlYWxQYXJlbnQoc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGVEYXRhICYmIGNyZWF0ZSh0ZW1wbGF0ZURhdGEuaHRtbCwgdGVtcGxhdGVEYXRhLmJpbmRpbmdzKS5jcmVhdGVET00ocGFyZW50Tm9kZSk7XG5cbiAgICBpZiAodGhpcy50ZW1wbGF0ZSkge1xuICAgICAgdGhpcy50ZW1wbGF0ZS5tb3VudCh0aGlzLm5vZGUsIHRoaXMuZ2V0VGVtcGxhdGVTY29wZShzY29wZSwgcmVhbFBhcmVudCksIHJlYWxQYXJlbnQpO1xuICAgICAgdGhpcy50ZW1wbGF0ZS5jaGlsZHJlbiA9IEFycmF5LmZyb20odGhpcy5ub2RlLmNoaWxkTm9kZXMpO1xuICAgICAgbW92ZVNsb3RJbm5lckNvbnRlbnQodGhpcy5ub2RlKTtcbiAgICB9XG5cbiAgICByZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHVwZGF0ZShzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgICBpZiAodGhpcy50ZW1wbGF0ZSkge1xuICAgICAgY29uc3QgcmVhbFBhcmVudCA9IGdldFJlYWxQYXJlbnQoc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgICAgIHRoaXMudGVtcGxhdGUudXBkYXRlKHRoaXMuZ2V0VGVtcGxhdGVTY29wZShzY29wZSwgcmVhbFBhcmVudCksIHJlYWxQYXJlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHVubW91bnQoc2NvcGUsIHBhcmVudFNjb3BlLCBtdXN0UmVtb3ZlUm9vdCkge1xuICAgIGlmICh0aGlzLnRlbXBsYXRlKSB7XG4gICAgICB0aGlzLnRlbXBsYXRlLnVubW91bnQodGhpcy5nZXRUZW1wbGF0ZVNjb3BlKHNjb3BlLCBwYXJlbnRTY29wZSksIG51bGwsIG11c3RSZW1vdmVSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59O1xuLyoqXG4gKiBNb3ZlIHRoZSBpbm5lciBjb250ZW50IG9mIHRoZSBzbG90cyBvdXRzaWRlIG9mIHRoZW1cbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gc2xvdCAtIHNsb3Qgbm9kZVxuICogQHJldHVybnMge3VuZGVmaW5lZH0gaXQncyBhIHZvaWQgbWV0aG9kIMKvXFxfKOODhClfL8KvXG4gKi9cblxuZnVuY3Rpb24gbW92ZVNsb3RJbm5lckNvbnRlbnQoc2xvdCkge1xuICBjb25zdCBjaGlsZCA9IHNsb3QgJiYgc2xvdC5maXJzdENoaWxkO1xuICBpZiAoIWNoaWxkKSByZXR1cm47XG4gIGluc2VydEJlZm9yZShjaGlsZCwgc2xvdCk7XG4gIG1vdmVTbG90SW5uZXJDb250ZW50KHNsb3QpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzaW5nbGUgc2xvdCBiaW5kaW5nXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IG5vZGUgLSBzbG90IG5vZGVcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG9wdGlvbnMubmFtZSAtIHNsb3QgaWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFNsb3QgYmluZGluZyBvYmplY3RcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNsb3Qobm9kZSwgX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBuYW1lLFxuICAgIGF0dHJpYnV0ZXNcbiAgfSA9IF9yZWYyO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgU2xvdEJpbmRpbmcsIHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIG5vZGUsXG4gICAgbmFtZVxuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgdGFnIG9iamVjdCBpZiBpdCB3YXMgcmVnaXN0ZXJlZCBiZWZvcmUsIG90aGVyd2lzZSBmYWxsYmFjayB0byB0aGUgc2ltcGxlXG4gKiB0ZW1wbGF0ZSBjaHVua1xuICogQHBhcmFtICAge0Z1bmN0aW9ufSBjb21wb25lbnQgLSBjb21wb25lbnQgZmFjdG9yeSBmdW5jdGlvblxuICogQHBhcmFtICAge0FycmF5PE9iamVjdD59IHNsb3RzIC0gYXJyYXkgY29udGFpbmluZyB0aGUgc2xvdHMgbWFya3VwXG4gKiBAcGFyYW0gICB7QXJyYXl9IGF0dHJpYnV0ZXMgLSBkeW5hbWljIGF0dHJpYnV0ZXMgdGhhdCB3aWxsIGJlIHJlY2VpdmVkIGJ5IHRoZSB0YWcgZWxlbWVudFxuICogQHJldHVybnMge1RhZ0ltcGxlbWVudGF0aW9ufFRlbXBsYXRlQ2h1bmt9IGEgdGFnIGltcGxlbWVudGF0aW9uIG9yIGEgdGVtcGxhdGUgY2h1bmsgYXMgZmFsbGJhY2tcbiAqL1xuXG5mdW5jdGlvbiBnZXRUYWcoY29tcG9uZW50LCBzbG90cywgYXR0cmlidXRlcykge1xuICBpZiAoc2xvdHMgPT09IHZvaWQgMCkge1xuICAgIHNsb3RzID0gW107XG4gIH1cblxuICBpZiAoYXR0cmlidXRlcyA9PT0gdm9pZCAwKSB7XG4gICAgYXR0cmlidXRlcyA9IFtdO1xuICB9XG5cbiAgLy8gaWYgdGhpcyB0YWcgd2FzIHJlZ2lzdGVyZWQgYmVmb3JlIHdlIHdpbGwgcmV0dXJuIGl0cyBpbXBsZW1lbnRhdGlvblxuICBpZiAoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudCh7XG4gICAgICBzbG90cyxcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9KTtcbiAgfSAvLyBvdGhlcndpc2Ugd2UgcmV0dXJuIGEgdGVtcGxhdGUgY2h1bmtcblxuXG4gIHJldHVybiBjcmVhdGUoc2xvdHNUb01hcmt1cChzbG90cyksIFsuLi5zbG90QmluZGluZ3Moc2xvdHMpLCB7XG4gICAgLy8gdGhlIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgYXMgYmluZGluZ1xuICAgIC8vIGlmIHdlIGZhbGxiYWNrIHRvIGEgbm9ybWFsIHRlbXBsYXRlIGNodW5rXG4gICAgZXhwcmVzc2lvbnM6IGF0dHJpYnV0ZXMubWFwKGF0dHIgPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICB0eXBlOiBBVFRSSUJVVEVcbiAgICAgIH0sIGF0dHIpO1xuICAgIH0pXG4gIH1dKTtcbn1cbi8qKlxuICogTWVyZ2UgYWxsIHRoZSBzbG90cyBiaW5kaW5ncyBpbnRvIGEgc2luZ2xlIGFycmF5XG4gKiBAcGFyYW0gICB7QXJyYXk8T2JqZWN0Pn0gc2xvdHMgLSBzbG90cyBjb2xsZWN0aW9uXG4gKiBAcmV0dXJucyB7QXJyYXk8QmluZGluZ3M+fSBmbGF0dGVuIGJpbmRpbmdzIGFycmF5XG4gKi9cblxuXG5mdW5jdGlvbiBzbG90QmluZGluZ3Moc2xvdHMpIHtcbiAgcmV0dXJuIHNsb3RzLnJlZHVjZSgoYWNjLCBfcmVmKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGJpbmRpbmdzXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoYmluZGluZ3MpO1xuICB9LCBbXSk7XG59XG4vKipcbiAqIE1lcmdlIGFsbCB0aGUgc2xvdHMgdG9nZXRoZXIgaW4gYSBzaW5nbGUgbWFya3VwIHN0cmluZ1xuICogQHBhcmFtICAge0FycmF5PE9iamVjdD59IHNsb3RzIC0gc2xvdHMgY29sbGVjdGlvblxuICogQHJldHVybnMge3N0cmluZ30gbWFya3VwIG9mIGFsbCB0aGUgc2xvdHMgaW4gYSBzaW5nbGUgc3RyaW5nXG4gKi9cblxuXG5mdW5jdGlvbiBzbG90c1RvTWFya3VwKHNsb3RzKSB7XG4gIHJldHVybiBzbG90cy5yZWR1Y2UoKGFjYywgc2xvdCkgPT4ge1xuICAgIHJldHVybiBhY2MgKyBzbG90Lmh0bWw7XG4gIH0sICcnKTtcbn1cblxuY29uc3QgVGFnQmluZGluZyA9IHtcbiAgLy8gZHluYW1pYyBiaW5kaW5nIHByb3BlcnRpZXNcbiAgLy8gbm9kZTogbnVsbCxcbiAgLy8gZXZhbHVhdGU6IG51bGwsXG4gIC8vIG5hbWU6IG51bGwsXG4gIC8vIHNsb3RzOiBudWxsLFxuICAvLyB0YWc6IG51bGwsXG4gIC8vIGF0dHJpYnV0ZXM6IG51bGwsXG4gIC8vIGdldENvbXBvbmVudDogbnVsbCxcbiAgbW91bnQoc2NvcGUpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGUoc2NvcGUpO1xuICB9LFxuXG4gIHVwZGF0ZShzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5ldmFsdWF0ZShzY29wZSk7IC8vIHNpbXBsZSB1cGRhdGVcblxuICAgIGlmIChuYW1lICYmIG5hbWUgPT09IHRoaXMubmFtZSkge1xuICAgICAgdGhpcy50YWcudXBkYXRlKHNjb3BlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5tb3VudCB0aGUgb2xkIHRhZyBpZiBpdCBleGlzdHNcbiAgICAgIHRoaXMudW5tb3VudChzY29wZSwgcGFyZW50U2NvcGUsIHRydWUpOyAvLyBtb3VudCB0aGUgbmV3IHRhZ1xuXG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy50YWcgPSBnZXRUYWcodGhpcy5nZXRDb21wb25lbnQobmFtZSksIHRoaXMuc2xvdHMsIHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICB0aGlzLnRhZy5tb3VudCh0aGlzLm5vZGUsIHNjb3BlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB1bm1vdW50KHNjb3BlLCBwYXJlbnRTY29wZSwga2VlcFJvb3RUYWcpIHtcbiAgICBpZiAodGhpcy50YWcpIHtcbiAgICAgIC8vIGtlZXAgdGhlIHJvb3QgdGFnXG4gICAgICB0aGlzLnRhZy51bm1vdW50KGtlZXBSb290VGFnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59O1xuZnVuY3Rpb24gY3JlYXRlJDIobm9kZSwgX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBldmFsdWF0ZSxcbiAgICBnZXRDb21wb25lbnQsXG4gICAgc2xvdHMsXG4gICAgYXR0cmlidXRlc1xuICB9ID0gX3JlZjI7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBUYWdCaW5kaW5nLCB7XG4gICAgbm9kZSxcbiAgICBldmFsdWF0ZSxcbiAgICBzbG90cyxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGdldENvbXBvbmVudFxuICB9KTtcbn1cblxudmFyIGJpbmRpbmdzID0ge1xuICBbSUZdOiBjcmVhdGUkNSxcbiAgW1NJTVBMRV06IGNyZWF0ZSQzLFxuICBbRUFDSF06IGNyZWF0ZSQ2LFxuICBbVEFHXTogY3JlYXRlJDIsXG4gIFtTTE9UXTogY3JlYXRlU2xvdFxufTtcblxuLyoqXG4gKiBUZXh0IGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGUgdGFnIHdpbGwgZ2V0IGNoaWxkTm9kZUluZGV4IHZhbHVlIG5vcm1hbGl6ZWRcbiAqIGRlcGVuZGluZyBvbiB0aGUgcG9zaXRpb24gb2YgdGhlIDx0ZW1wbGF0ZT4gdGFnIG9mZnNldFxuICogQHBhcmFtICAge0V4cHJlc3Npb25bXX0gZXhwcmVzc2lvbnMgLSByaW90IGV4cHJlc3Npb25zIGFycmF5XG4gKiBAcGFyYW0gICB7bnVtYmVyfSB0ZXh0RXhwcmVzc2lvbnNPZmZzZXQgLSBvZmZzZXQgb2YgdGhlIDx0ZW1wbGF0ZT4gdGFnXG4gKiBAcmV0dXJucyB7RXhwcmVzc2lvbltdfSBleHByZXNzaW9ucyBjb250YWluaW5nIHRoZSB0ZXh0IGV4cHJlc3Npb25zIG5vcm1hbGl6ZWRcbiAqL1xuXG5mdW5jdGlvbiBmaXhUZXh0RXhwcmVzc2lvbnNPZmZzZXQoZXhwcmVzc2lvbnMsIHRleHRFeHByZXNzaW9uc09mZnNldCkge1xuICByZXR1cm4gZXhwcmVzc2lvbnMubWFwKGUgPT4gZS50eXBlID09PSBURVhUID8gT2JqZWN0LmFzc2lnbih7fSwgZSwge1xuICAgIGNoaWxkTm9kZUluZGV4OiBlLmNoaWxkTm9kZUluZGV4ICsgdGV4dEV4cHJlc3Npb25zT2Zmc2V0XG4gIH0pIDogZSk7XG59XG4vKipcbiAqIEJpbmQgYSBuZXcgZXhwcmVzc2lvbiBvYmplY3QgdG8gYSBET00gbm9kZVxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSByb290IC0gRE9NIG5vZGUgd2hlcmUgdG8gYmluZCB0aGUgZXhwcmVzc2lvblxuICogQHBhcmFtICAge09iamVjdH0gYmluZGluZyAtIGJpbmRpbmcgZGF0YVxuICogQHBhcmFtICAge251bWJlcnxudWxsfSB0ZW1wbGF0ZVRhZ09mZnNldCAtIGlmIGl0J3MgZGVmaW5lZCB3ZSBuZWVkIHRvIGZpeCB0aGUgdGV4dCBleHByZXNzaW9ucyBjaGlsZE5vZGVJbmRleCBvZmZzZXRcbiAqIEByZXR1cm5zIHtCaW5kaW5nfSBCaW5kaW5nIG9iamVjdFxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlJDEocm9vdCwgYmluZGluZywgdGVtcGxhdGVUYWdPZmZzZXQpIHtcbiAgY29uc3Qge1xuICAgIHNlbGVjdG9yLFxuICAgIHR5cGUsXG4gICAgcmVkdW5kYW50QXR0cmlidXRlLFxuICAgIGV4cHJlc3Npb25zXG4gIH0gPSBiaW5kaW5nOyAvLyBmaW5kIHRoZSBub2RlIHRvIGFwcGx5IHRoZSBiaW5kaW5nc1xuXG4gIGNvbnN0IG5vZGUgPSBzZWxlY3RvciA/IHJvb3QucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgOiByb290OyAvLyByZW1vdmUgZXZlbnR1YWxseSBhZGRpdGlvbmFsIGF0dHJpYnV0ZXMgY3JlYXRlZCBvbmx5IHRvIHNlbGVjdCB0aGlzIG5vZGVcblxuICBpZiAocmVkdW5kYW50QXR0cmlidXRlKSBub2RlLnJlbW92ZUF0dHJpYnV0ZShyZWR1bmRhbnRBdHRyaWJ1dGUpO1xuICBjb25zdCBiaW5kaW5nRXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucyB8fCBbXTsgLy8gaW5pdCB0aGUgYmluZGluZ1xuXG4gIHJldHVybiAoYmluZGluZ3NbdHlwZV0gfHwgYmluZGluZ3NbU0lNUExFXSkobm9kZSwgT2JqZWN0LmFzc2lnbih7fSwgYmluZGluZywge1xuICAgIGV4cHJlc3Npb25zOiB0ZW1wbGF0ZVRhZ09mZnNldCAmJiAhc2VsZWN0b3IgPyBmaXhUZXh0RXhwcmVzc2lvbnNPZmZzZXQoYmluZGluZ0V4cHJlc3Npb25zLCB0ZW1wbGF0ZVRhZ09mZnNldCkgOiBiaW5kaW5nRXhwcmVzc2lvbnNcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIVE1MVHJlZShodG1sLCByb290KSB7XG4gIGNvbnN0IHRlbXBsYXRlID0gaXNUZW1wbGF0ZShyb290KSA/IHJvb3QgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sO1xuICByZXR1cm4gdGVtcGxhdGUuY29udGVudDtcbn0gLy8gZm9yIHN2ZyBub2RlcyB3ZSBuZWVkIGEgYml0IG1vcmUgd29ya1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNWR1RyZWUoaHRtbCwgY29udGFpbmVyKSB7XG4gIC8vIGNyZWF0ZSB0aGUgU1ZHTm9kZVxuICBjb25zdCBzdmdOb2RlID0gY29udGFpbmVyLm93bmVyRG9jdW1lbnQuaW1wb3J0Tm9kZShuZXcgd2luZG93LkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+JHtodG1sfTwvc3ZnPmAsICdhcHBsaWNhdGlvbi94bWwnKS5kb2N1bWVudEVsZW1lbnQsIHRydWUpO1xuICByZXR1cm4gc3ZnTm9kZTtcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBET00gdGhhdCB3aWxsIGJlIGluamVjdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gcm9vdCAtIERPTSBub2RlIHRvIGZpbmQgb3V0IHRoZSBjb250ZXh0IHdoZXJlIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWRcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IGh0bWwgLSBET00gdG8gY3JlYXRlIGFzIHN0cmluZ1xuICogQHJldHVybnMge0hUTUxEb2N1bWVudEZyYWdtZW50fEhUTUxFbGVtZW50fSBhIG5ldyBodG1sIGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVET01UcmVlKHJvb3QsIGh0bWwpIHtcbiAgaWYgKGlzU3ZnKHJvb3QpKSByZXR1cm4gY3JlYXRlU1ZHVHJlZShodG1sLCByb290KTtcbiAgcmV0dXJuIGNyZWF0ZUhUTUxUcmVlKGh0bWwsIHJvb3QpO1xufVxuXG4vKipcbiAqIEluamVjdCB0aGUgRE9NIHRyZWUgaW50byBhIHRhcmdldCBub2RlXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IGVsIC0gdGFyZ2V0IGVsZW1lbnRcbiAqIEBwYXJhbSAgIHtIVE1MRnJhZ21lbnR8U1ZHRWxlbWVudH0gZG9tIC0gZG9tIHRyZWUgdG8gaW5qZWN0XG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGluamVjdERPTShlbCwgZG9tKSB7XG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2UgaXNTdmcoZWwpOlxuICAgICAgbW92ZUNoaWxkcmVuKGRvbSwgZWwpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGlzVGVtcGxhdGUoZWwpOlxuICAgICAgZWwucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZG9tLCBlbCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBlbC5hcHBlbmRDaGlsZChkb20pO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBUZW1wbGF0ZSBET00gc2tlbGV0b25cbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gZWwgLSByb290IG5vZGUgd2hlcmUgdGhlIERPTSB3aWxsIGJlIGluamVjdGVkXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBodG1sIC0gbWFya3VwIHRoYXQgd2lsbCBiZSBpbmplY3RlZCBpbnRvIHRoZSByb290IG5vZGVcbiAqIEByZXR1cm5zIHtIVE1MRnJhZ21lbnR9IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBpbmplY3RlZCBpbnRvIHRoZSByb290IG5vZGVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZURPTShlbCwgaHRtbCkge1xuICByZXR1cm4gaHRtbCAmJiAodHlwZW9mIGh0bWwgPT09ICdzdHJpbmcnID8gY3JlYXRlRE9NVHJlZShlbCwgaHRtbCkgOiBodG1sKTtcbn1cbi8qKlxuICogR2V0IHRoZSBvZmZzZXQgb2YgdGhlIDx0ZW1wbGF0ZT4gdGFnXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnROb2RlIC0gdGVtcGxhdGUgdGFnIHBhcmVudCBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIHRoZSB0ZW1wbGF0ZSB0YWcgd2Ugd2FudCB0byByZW5kZXJcbiAqIEBwYXJhbSAgIHtPYmplY3R9IG1ldGEgLSBtZXRhIHByb3BlcnRpZXMgbmVlZGVkIHRvIGhhbmRsZSB0aGUgPHRlbXBsYXRlPiB0YWdzIGluIGxvb3BzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBvZmZzZXQgb2YgdGhlIDx0ZW1wbGF0ZT4gdGFnIGNhbGN1bGF0ZWQgZnJvbSBpdHMgc2libGluZ3MgRE9NIG5vZGVzXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRUZW1wbGF0ZVRhZ09mZnNldChwYXJlbnROb2RlLCBlbCwgbWV0YSkge1xuICBjb25zdCBzaWJsaW5ncyA9IEFycmF5LmZyb20ocGFyZW50Tm9kZS5jaGlsZE5vZGVzKTtcbiAgcmV0dXJuIE1hdGgubWF4KHNpYmxpbmdzLmluZGV4T2YoZWwpLCBzaWJsaW5ncy5pbmRleE9mKG1ldGEuaGVhZCkgKyAxLCAwKTtcbn1cbi8qKlxuICogVGVtcGxhdGUgQ2h1bmsgbW9kZWxcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuXG5jb25zdCBUZW1wbGF0ZUNodW5rID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC8vIFN0YXRpYyBwcm9wc1xuICAvLyBiaW5kaW5nczogbnVsbCxcbiAgLy8gYmluZGluZ3NEYXRhOiBudWxsLFxuICAvLyBodG1sOiBudWxsLFxuICAvLyBpc1RlbXBsYXRlVGFnOiBmYWxzZSxcbiAgLy8gZnJhZ21lbnQ6IG51bGwsXG4gIC8vIGNoaWxkcmVuOiBudWxsLFxuICAvLyBkb206IG51bGwsXG4gIC8vIGVsOiBudWxsLFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIHRlbXBsYXRlIERPTSBzdHJ1Y3R1cmUgdGhhdCB3aWxsIGJlIGNsb25lZCBvbiBlYWNoIG1vdW50XG4gICAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gZWwgLSB0aGUgcm9vdCBub2RlXG4gICAqIEByZXR1cm5zIHtUZW1wbGF0ZUNodW5rfSBzZWxmXG4gICAqL1xuICBjcmVhdGVET00oZWwpIHtcbiAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgRE9NIGdldHMgY3JlYXRlZCBiZWZvcmUgY2xvbmluZyB0aGUgdGVtcGxhdGVcbiAgICB0aGlzLmRvbSA9IHRoaXMuZG9tIHx8IGNyZWF0ZVRlbXBsYXRlRE9NKGVsLCB0aGlzLmh0bWwpIHx8IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBBUEkgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBBdHRhY2ggdGhlIHRlbXBsYXRlIHRvIGEgRE9NIG5vZGVcbiAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbCAtIHRhcmdldCBET00gbm9kZVxuICAgKiBAcGFyYW0gICB7Kn0gc2NvcGUgLSB0ZW1wbGF0ZSBkYXRhXG4gICAqIEBwYXJhbSAgIHsqfSBwYXJlbnRTY29wZSAtIHNjb3BlIG9mIHRoZSBwYXJlbnQgdGVtcGxhdGUgdGFnXG4gICAqIEBwYXJhbSAgIHtPYmplY3R9IG1ldGEgLSBtZXRhIHByb3BlcnRpZXMgbmVlZGVkIHRvIGhhbmRsZSB0aGUgPHRlbXBsYXRlPiB0YWdzIGluIGxvb3BzXG4gICAqIEByZXR1cm5zIHtUZW1wbGF0ZUNodW5rfSBzZWxmXG4gICAqL1xuICBtb3VudChlbCwgc2NvcGUsIHBhcmVudFNjb3BlLCBtZXRhKSB7XG4gICAgaWYgKG1ldGEgPT09IHZvaWQgMCkge1xuICAgICAgbWV0YSA9IHt9O1xuICAgIH1cblxuICAgIGlmICghZWwpIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgRE9NIG5vZGUgdG8gbW91bnQgcHJvcGVybHkgeW91ciB0ZW1wbGF0ZScpO1xuICAgIGlmICh0aGlzLmVsKSB0aGlzLnVubW91bnQoc2NvcGUpOyAvLyA8dGVtcGxhdGU+IHRhZ3MgcmVxdWlyZSBhIGJpdCBtb3JlIHdvcmtcbiAgICAvLyB0aGUgdGVtcGxhdGUgZnJhZ21lbnQgbWlnaHQgYmUgYWxyZWFkeSBjcmVhdGVkIHZpYSBtZXRhIG91dHNpZGUgb2YgdGhpcyBjYWxsXG5cbiAgICBjb25zdCB7XG4gICAgICBmcmFnbWVudCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgYXZvaWRET01JbmplY3Rpb25cbiAgICB9ID0gbWV0YTsgLy8gPHRlbXBsYXRlPiBiaW5kaW5ncyBvZiBjb3Vyc2UgY2FuIG5vdCBoYXZlIGEgcm9vdCBlbGVtZW50XG4gICAgLy8gc28gd2UgY2hlY2sgdGhlIHBhcmVudCBub2RlIHRvIHNldCB0aGUgcXVlcnkgc2VsZWN0b3IgYmluZGluZ3NcblxuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudE5vZGVcbiAgICB9ID0gY2hpbGRyZW4gPyBjaGlsZHJlblswXSA6IGVsO1xuICAgIGNvbnN0IGlzVGVtcGxhdGVUYWcgPSBpc1RlbXBsYXRlKGVsKTtcbiAgICBjb25zdCB0ZW1wbGF0ZVRhZ09mZnNldCA9IGlzVGVtcGxhdGVUYWcgPyBnZXRUZW1wbGF0ZVRhZ09mZnNldChwYXJlbnROb2RlLCBlbCwgbWV0YSkgOiBudWxsOyAvLyBjcmVhdGUgdGhlIERPTSBpZiBpdCB3YXNuJ3QgY3JlYXRlZCBiZWZvcmVcblxuICAgIHRoaXMuY3JlYXRlRE9NKGVsKTsgLy8gY3JlYXRlIHRoZSBET00gb2YgdGhpcyB0ZW1wbGF0ZSBjbG9uaW5nIHRoZSBvcmlnaW5hbCBET00gc3RydWN0dXJlIHN0b3JlZCBpbiB0aGlzIGluc3RhbmNlXG4gICAgLy8gbm90aWNlIHRoYXQgaWYgYSBkb2N1bWVudEZyYWdtZW50IHdhcyBwYXNzZWQgKHZpYSBtZXRhKSB3ZSB3aWxsIHVzZSBpdCBpbnN0ZWFkXG5cbiAgICBjb25zdCBjbG9uZU5vZGUgPSBmcmFnbWVudCB8fCB0aGlzLmRvbS5jbG9uZU5vZGUodHJ1ZSk7IC8vIHN0b3JlIHJvb3Qgbm9kZVxuICAgIC8vIG5vdGljZSB0aGF0IGZvciB0ZW1wbGF0ZSB0YWdzIHRoZSByb290IG5vdGUgd2lsbCBiZSB0aGUgcGFyZW50IHRhZ1xuXG4gICAgdGhpcy5lbCA9IGlzVGVtcGxhdGVUYWcgPyBwYXJlbnROb2RlIDogZWw7IC8vIGNyZWF0ZSB0aGUgY2hpbGRyZW4gYXJyYXkgb25seSBmb3IgdGhlIDx0ZW1wbGF0ZT4gZnJhZ21lbnRzXG5cbiAgICB0aGlzLmNoaWxkcmVuID0gaXNUZW1wbGF0ZVRhZyA/IGNoaWxkcmVuIHx8IEFycmF5LmZyb20oY2xvbmVOb2RlLmNoaWxkTm9kZXMpIDogbnVsbDsgLy8gaW5qZWN0IHRoZSBET00gaW50byB0aGUgZWwgb25seSBpZiBhIGZyYWdtZW50IGlzIGF2YWlsYWJsZVxuXG4gICAgaWYgKCFhdm9pZERPTUluamVjdGlvbiAmJiBjbG9uZU5vZGUpIGluamVjdERPTShlbCwgY2xvbmVOb2RlKTsgLy8gY3JlYXRlIHRoZSBiaW5kaW5nc1xuXG4gICAgdGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3NEYXRhLm1hcChiaW5kaW5nID0+IGNyZWF0ZSQxKHRoaXMuZWwsIGJpbmRpbmcsIHRlbXBsYXRlVGFnT2Zmc2V0KSk7XG4gICAgdGhpcy5iaW5kaW5ncy5mb3JFYWNoKGIgPT4gYi5tb3VudChzY29wZSwgcGFyZW50U2NvcGUpKTsgLy8gc3RvcmUgdGhlIHRlbXBsYXRlIG1ldGEgcHJvcGVydGllc1xuXG4gICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB0ZW1wbGF0ZSB3aXRoIGZyZXNoIGRhdGFcbiAgICogQHBhcmFtICAgeyp9IHNjb3BlIC0gdGVtcGxhdGUgZGF0YVxuICAgKiBAcGFyYW0gICB7Kn0gcGFyZW50U2NvcGUgLSBzY29wZSBvZiB0aGUgcGFyZW50IHRlbXBsYXRlIHRhZ1xuICAgKiBAcmV0dXJucyB7VGVtcGxhdGVDaHVua30gc2VsZlxuICAgKi9cbiAgdXBkYXRlKHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICAgIHRoaXMuYmluZGluZ3MuZm9yRWFjaChiID0+IGIudXBkYXRlKHNjb3BlLCBwYXJlbnRTY29wZSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHRlbXBsYXRlIGZyb20gdGhlIG5vZGUgd2hlcmUgaXQgd2FzIGluaXRpYWxseSBtb3VudGVkXG4gICAqIEBwYXJhbSAgIHsqfSBzY29wZSAtIHRlbXBsYXRlIGRhdGFcbiAgICogQHBhcmFtICAgeyp9IHBhcmVudFNjb3BlIC0gc2NvcGUgb2YgdGhlIHBhcmVudCB0ZW1wbGF0ZSB0YWdcbiAgICogQHBhcmFtICAge2Jvb2xlYW58bnVsbH0gbXVzdFJlbW92ZVJvb3QgLSBpZiB0cnVlIHJlbW92ZSB0aGUgcm9vdCBlbGVtZW50LFxuICAgKiBpZiBmYWxzZSBvciB1bmRlZmluZWQgY2xlYW4gdGhlIHJvb3QgdGFnIGNvbnRlbnQsIGlmIG51bGwgZG9uJ3QgdG91Y2ggdGhlIERPTVxuICAgKiBAcmV0dXJucyB7VGVtcGxhdGVDaHVua30gc2VsZlxuICAgKi9cbiAgdW5tb3VudChzY29wZSwgcGFyZW50U2NvcGUsIG11c3RSZW1vdmVSb290KSB7XG4gICAgaWYgKHRoaXMuZWwpIHtcbiAgICAgIHRoaXMuYmluZGluZ3MuZm9yRWFjaChiID0+IGIudW5tb3VudChzY29wZSwgcGFyZW50U2NvcGUsIG11c3RSZW1vdmVSb290KSk7XG5cbiAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAvLyBwdXJlIGNvbXBvbmVudHMgc2hvdWxkIGhhbmRsZSB0aGUgRE9NIHVubW91bnQgdXBkYXRlcyBieSB0aGVtc2VsdmVzXG4gICAgICAgIGNhc2UgdGhpcy5lbFtJU19QVVJFX1NZTUJPTF06XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIDx0ZW1wbGF0ZT4gdGFncyBzaG91bGQgYmUgdHJlYXRlZCBhIGJpdCBkaWZmZXJlbnRseVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGNsZWFyIHRoZWlyIGNoaWxkcmVuIG9ubHkgaWYgaXQncyBleHBsaWNpdGx5IHJlcXVpcmVkIGJ5IHRoZSBjYWxsZXJcbiAgICAgICAgLy8gdmlhIG11c3RSZW1vdmVSb290ICE9PSBudWxsXG5cbiAgICAgICAgY2FzZSB0aGlzLmNoaWxkcmVuICYmIG11c3RSZW1vdmVSb290ICE9PSBudWxsOlxuICAgICAgICAgIGNsZWFyQ2hpbGRyZW4odGhpcy5jaGlsZHJlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgcm9vdCBub2RlIG9ubHkgaWYgdGhlIG11c3RSZW1vdmVSb290ID09PSB0cnVlXG5cbiAgICAgICAgY2FzZSBtdXN0UmVtb3ZlUm9vdCA9PT0gdHJ1ZTpcbiAgICAgICAgICByZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGNsZWFuIHRoZSBub2RlIGNoaWxkcmVuXG5cbiAgICAgICAgY2FzZSBtdXN0UmVtb3ZlUm9vdCAhPT0gbnVsbDpcbiAgICAgICAgICBjbGVhbk5vZGUodGhpcy5lbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZSB0aGUgdGVtcGxhdGUgY2h1bmtcbiAgICogQHJldHVybnMge1RlbXBsYXRlQ2h1bmt9IGEgY2xvbmUgb2YgdGhpcyBvYmplY3QgcmVzZXR0aW5nIHRoZSB0aGlzLmVsIHByb3BlcnR5XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcywge1xuICAgICAgbWV0YToge30sXG4gICAgICBlbDogbnVsbFxuICAgIH0pO1xuICB9XG5cbn0pO1xuLyoqXG4gKiBDcmVhdGUgYSB0ZW1wbGF0ZSBjaHVuayB3aXJpbmcgYWxzbyB0aGUgYmluZGluZ3NcbiAqIEBwYXJhbSAgIHtzdHJpbmd8SFRNTEVsZW1lbnR9IGh0bWwgLSB0ZW1wbGF0ZSBzdHJpbmdcbiAqIEBwYXJhbSAgIHtBcnJheX0gYmluZGluZ3MgLSBiaW5kaW5ncyBjb2xsZWN0aW9uXG4gKiBAcmV0dXJucyB7VGVtcGxhdGVDaHVua30gYSBuZXcgVGVtcGxhdGVDaHVuayBjb3B5XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlKGh0bWwsIGJpbmRpbmdzKSB7XG4gIGlmIChiaW5kaW5ncyA9PT0gdm9pZCAwKSB7XG4gICAgYmluZGluZ3MgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBUZW1wbGF0ZUNodW5rLCB7XG4gICAgaHRtbCxcbiAgICBiaW5kaW5nc0RhdGE6IGJpbmRpbmdzXG4gIH0pO1xufVxuXG4vKipcbiAqIE1ldGhvZCB1c2VkIHRvIGJpbmQgZXhwcmVzc2lvbnMgdG8gYSBET00gbm9kZVxuICogQHBhcmFtICAge3N0cmluZ3xIVE1MRWxlbWVudH0gaHRtbCAtIHlvdXIgc3RhdGljIHRlbXBsYXRlIGh0bWwgc3RydWN0dXJlXG4gKiBAcGFyYW0gICB7QXJyYXl9IGJpbmRpbmdzIC0gbGlzdCBvZiB0aGUgZXhwcmVzc2lvbnMgdG8gYmluZCB0byB1cGRhdGUgdGhlIG1hcmt1cFxuICogQHJldHVybnMge1RlbXBsYXRlQ2h1bmt9IGEgbmV3IFRlbXBsYXRlQ2h1bmsgb2JqZWN0IGhhdmluZyB0aGUgYHVwZGF0ZWAsYG1vdW50YCwgYHVubW91bnRgIGFuZCBgY2xvbmVgIG1ldGhvZHNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHJpb3RET01CaW5kaW5nc1xuICogIC50ZW1wbGF0ZShcbiAqICAgYDxkaXYgZXhwcjA+PCEtLS0tPjwvZGl2PjxkaXY+PHAgZXhwcjE+PCEtLS0tPjxzZWN0aW9uIGV4cHIyPjwvc2VjdGlvbj48L3A+YCxcbiAqICAgW1xuICogICAgIHtcbiAqICAgICAgIHNlbGVjdG9yOiAnW2V4cHIwXScsXG4gKiAgICAgICByZWR1bmRhbnRBdHRyaWJ1dGU6ICdleHByMCcsXG4gKiAgICAgICBleHByZXNzaW9uczogW1xuICogICAgICAgICB7XG4gKiAgICAgICAgICAgdHlwZTogZXhwcmVzc2lvblR5cGVzLlRFWFQsXG4gKiAgICAgICAgICAgY2hpbGROb2RlSW5kZXg6IDAsXG4gKiAgICAgICAgICAgZXZhbHVhdGUoc2NvcGUpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBzY29wZS50aW1lO1xuICogICAgICAgICAgIH0sXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICBdLFxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgc2VsZWN0b3I6ICdbZXhwcjFdJyxcbiAqICAgICAgIHJlZHVuZGFudEF0dHJpYnV0ZTogJ2V4cHIxJyxcbiAqICAgICAgIGV4cHJlc3Npb25zOiBbXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICB0eXBlOiBleHByZXNzaW9uVHlwZXMuVEVYVCxcbiAqICAgICAgICAgICBjaGlsZE5vZGVJbmRleDogMCxcbiAqICAgICAgICAgICBldmFsdWF0ZShzY29wZSkge1xuICogICAgICAgICAgICAgcmV0dXJuIHNjb3BlLm5hbWU7XG4gKiAgICAgICAgICAgfSxcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIHR5cGU6ICdhdHRyaWJ1dGUnLFxuICogICAgICAgICAgIG5hbWU6ICdzdHlsZScsXG4gKiAgICAgICAgICAgZXZhbHVhdGUoc2NvcGUpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBzY29wZS5zdHlsZTtcbiAqICAgICAgICAgICB9LFxuICogICAgICAgICB9LFxuICogICAgICAgXSxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIHNlbGVjdG9yOiAnW2V4cHIyXScsXG4gKiAgICAgICByZWR1bmRhbnRBdHRyaWJ1dGU6ICdleHByMicsXG4gKiAgICAgICB0eXBlOiBiaW5kaW5nVHlwZXMuSUYsXG4gKiAgICAgICBldmFsdWF0ZShzY29wZSkge1xuICogICAgICAgICByZXR1cm4gc2NvcGUuaXNWaXNpYmxlO1xuICogICAgICAgfSxcbiAqICAgICAgIHRlbXBsYXRlOiByaW90RE9NQmluZGluZ3MudGVtcGxhdGUoJ2hlbGxvIHRoZXJlJyksXG4gKiAgICAgfSxcbiAqICAgXVxuICogKVxuICovXG5cbnZhciBET01CaW5kaW5ncyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICB0ZW1wbGF0ZTogY3JlYXRlLFxuICBjcmVhdGVCaW5kaW5nOiBjcmVhdGUkMSxcbiAgY3JlYXRlRXhwcmVzc2lvbjogY3JlYXRlJDQsXG4gIGJpbmRpbmdUeXBlczogYmluZGluZ1R5cGVzLFxuICBleHByZXNzaW9uVHlwZXM6IGV4cHJlc3Npb25UeXBlc1xufSk7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIHJldHVybiB0aGlzO1xufVxuLyoqXG4gKiBBdXRvYmluZCB0aGUgbWV0aG9kcyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gaXRzZWxmXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBzb3VyY2UgLSBwcm9iYWJseSBhIHJpb3QgdGFnIGluc3RhbmNlXG4gKiBAcGFyYW0gICB7QXJyYXk8c3RyaW5nPn0gbWV0aG9kcyAtIGxpc3Qgb2YgdGhlIG1ldGhvZHMgdG8gYXV0b2JpbmRcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBvcmlnaW5hbCBvYmplY3QgcmVjZWl2ZWRcbiAqL1xuXG5mdW5jdGlvbiBhdXRvYmluZE1ldGhvZHMoc291cmNlLCBtZXRob2RzKSB7XG4gIG1ldGhvZHMuZm9yRWFjaChtZXRob2QgPT4ge1xuICAgIHNvdXJjZVttZXRob2RdID0gc291cmNlW21ldGhvZF0uYmluZChzb3VyY2UpO1xuICB9KTtcbiAgcmV0dXJuIHNvdXJjZTtcbn1cbi8qKlxuICogQ2FsbCB0aGUgZmlyc3QgYXJndW1lbnQgcmVjZWl2ZWQgb25seSBpZiBpdCdzIGEgZnVuY3Rpb24gb3RoZXJ3aXNlIHJldHVybiBpdCBhcyBpdCBpc1xuICogQHBhcmFtICAgeyp9IHNvdXJjZSAtIGFueXRoaW5nXG4gKiBAcmV0dXJucyB7Kn0gYW55dGhpbmdcbiAqL1xuXG5mdW5jdGlvbiBjYWxsT3JBc3NpZ24oc291cmNlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHNvdXJjZSkgPyBzb3VyY2UucHJvdG90eXBlICYmIHNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPyBuZXcgc291cmNlKCkgOiBzb3VyY2UoKSA6IHNvdXJjZTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gc2V0IGFuIGltbXV0YWJsZSBwcm9wZXJ0eVxuICogQHBhcmFtICAge09iamVjdH0gc291cmNlIC0gb2JqZWN0IHdoZXJlIHRoZSBuZXcgcHJvcGVydHkgd2lsbCBiZSBzZXRcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IGtleSAtIG9iamVjdCBrZXkgd2hlcmUgdGhlIG5ldyBwcm9wZXJ0eSB3aWxsIGJlIHN0b3JlZFxuICogQHBhcmFtICAgeyp9IHZhbHVlIC0gdmFsdWUgb2YgdGhlIG5ldyBwcm9wZXJ0eVxuICogQHBhcmFtICAge09iamVjdH0gb3B0aW9ucyAtIHNldCB0aGUgcHJvcGVyeSBvdmVycmlkaW5nIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gdGhlIG9yaWdpbmFsIG9iamVjdCBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShzb3VyY2UsIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGZwL25vLW11dGF0aW5nLW1ldGhvZHMgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvdXJjZSwga2V5LCBPYmplY3QuYXNzaWduKHtcbiAgICB2YWx1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sIG9wdGlvbnMpKTtcbiAgLyogZXNsaW50LWVuYWJsZSBmcC9uby1tdXRhdGluZy1tZXRob2RzICovXG5cbiAgcmV0dXJuIHNvdXJjZTtcbn1cbi8qKlxuICogRGVmaW5lIG11bHRpcGxlIHByb3BlcnRpZXMgb24gYSB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gICB7T2JqZWN0fSBzb3VyY2UgLSBvYmplY3Qgd2hlcmUgdGhlIG5ldyBwcm9wZXJ0aWVzIHdpbGwgYmUgc2V0XG4gKiBAcGFyYW0gICB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gb2JqZWN0IGNvbnRhaW5pbmcgYXMga2V5IHBhaXIgdGhlIGtleSArIHZhbHVlIHByb3BlcnRpZXNcbiAqIEBwYXJhbSAgIHtPYmplY3R9IG9wdGlvbnMgLSBzZXQgdGhlIHByb3Blcnkgb3ZlcnJpZGluZyB0aGUgZGVmYXVsdCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgb3JpZ2luYWwgb2JqZWN0IG1vZGlmaWVkXG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhzb3VyY2UsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykuZm9yRWFjaChfcmVmID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICBkZWZpbmVQcm9wZXJ0eShzb3VyY2UsIGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuICB9KTtcbiAgcmV0dXJuIHNvdXJjZTtcbn1cbi8qKlxuICogRGVmaW5lIGRlZmF1bHQgcHJvcGVydGllcyBpZiB0aGV5IGRvbid0IGV4aXN0IG9uIHRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0gICB7T2JqZWN0fSBzb3VyY2UgLSBvYmplY3QgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGRlZmF1bHQgcHJvcGVydGllc1xuICogQHBhcmFtICAge09iamVjdH0gZGVmYXVsdHMgLSBvYmplY3QgY29udGFpbmluZyBhZGRpdGlvbmFsIG9wdGlvbmFsIGtleXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBvcmlnaW5hbCBvYmplY3QgcmVjZWl2ZWQgZW5oYW5jZWRcbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVEZWZhdWx0cyhzb3VyY2UsIGRlZmF1bHRzKSB7XG4gIE9iamVjdC5lbnRyaWVzKGRlZmF1bHRzKS5mb3JFYWNoKF9yZWYyID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjI7XG4gICAgaWYgKCFzb3VyY2Vba2V5XSkgc291cmNlW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBzb3VyY2U7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW55IERPTSBub2RlL3MgdG8gYSBsb29wYWJsZSBhcnJheVxuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudHxOb2RlTGlzdCB9IGVscyAtIHNpbmdsZSBodG1sIGVsZW1lbnQgb3IgYSBub2RlIGxpc3RcbiAqIEByZXR1cm5zIHsgQXJyYXkgfSBhbHdheXMgYSBsb29wYWJsZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZG9tVG9BcnJheShlbHMpIHtcbiAgLy8gY2FuIHRoaXMgb2JqZWN0IGJlIGFscmVhZHkgbG9vcGVkP1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZWxzKSkge1xuICAgIC8vIGlzIGl0IGEgbm9kZSBsaXN0P1xuICAgIGlmICgvXlxcW29iamVjdCAoSFRNTENvbGxlY3Rpb258Tm9kZUxpc3R8T2JqZWN0KVxcXSQvLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVscykpICYmIHR5cGVvZiBlbHMubGVuZ3RoID09PSAnbnVtYmVyJykgcmV0dXJuIEFycmF5LmZyb20oZWxzKTtlbHNlIC8vIGlmIGl0J3MgYSBzaW5nbGUgbm9kZVxuICAgICAgLy8gaXQgd2lsbCBiZSByZXR1cm5lZCBhcyBcImFycmF5XCIgd2l0aCBvbmUgc2luZ2xlIGVudHJ5XG4gICAgICByZXR1cm4gW2Vsc107XG4gIH0gLy8gdGhpcyBvYmplY3QgY291bGQgYmUgbG9vcGVkIG91dCBvZiB0aGUgYm94XG5cblxuICByZXR1cm4gZWxzO1xufVxuXG4vKipcbiAqIFNpbXBsZSBoZWxwZXIgdG8gZmluZCBET00gbm9kZXMgcmV0dXJuaW5nIHRoZW0gYXMgYXJyYXkgbGlrZSBsb29wYWJsZSBvYmplY3RcbiAqIEBwYXJhbSAgIHsgc3RyaW5nfERPTU5vZGVMaXN0IH0gc2VsZWN0b3IgLSBlaXRoZXIgdGhlIHF1ZXJ5IG9yIHRoZSBET00gbm9kZXMgdG8gYXJyYWlmeVxuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9ICAgICAgICBjdHggICAgICAtIGNvbnRleHQgZGVmaW5pbmcgd2hlcmUgdGhlIHF1ZXJ5IHdpbGwgc2VhcmNoIGZvciB0aGUgRE9NIG5vZGVzXG4gKiBAcmV0dXJucyB7IEFycmF5IH0gRE9NIG5vZGVzIGZvdW5kIGFzIGFycmF5XG4gKi9cblxuZnVuY3Rpb24gJChzZWxlY3RvciwgY3R4KSB7XG4gIHJldHVybiBkb21Ub0FycmF5KHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycgPyAoY3R4IHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSA6IHNlbGVjdG9yKTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIHJldHVybiB2YWx1ZXMsIGluIGNhc2Ugb2YgYSBzaW5nbGUgdmFsdWUgd2UgYXZvaWQgdG8gcmV0dXJuIGFuIGFycmF5XG4gKiBAcGFyYW0gICB7IEFycmF5IH0gdmFsdWVzIC0gbGlzdCBvZiB2YWx1ZXMgd2Ugd2FudCB0byByZXR1cm5cbiAqIEByZXR1cm5zIHsgQXJyYXl8c3RyaW5nfGJvb2xlYW4gfSBlaXRoZXIgdGhlIHdob2xlIGxpc3Qgb2YgdmFsdWVzIG9yIHRoZSBzaW5nbGUgb25lIGZvdW5kXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNvbnN0IG5vcm1hbGl6ZSA9IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID09PSAxID8gdmFsdWVzWzBdIDogdmFsdWVzO1xuLyoqXG4gKiBQYXJzZSBhbGwgdGhlIG5vZGVzIHJlY2VpdmVkIHRvIGdldC9yZW1vdmUvY2hlY2sgdGhlaXIgYXR0cmlidXRlc1xuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudHxOb2RlTGlzdHxBcnJheSB9IGVscyAgICAtIERPTSBub2RlL3MgdG8gcGFyc2VcbiAqIEBwYXJhbSAgIHsgc3RyaW5nfEFycmF5IH0gICAgICAgICAgICAgICBuYW1lICAgLSBuYW1lIG9yIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtICAgeyBzdHJpbmcgfSAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCAtIG1ldGhvZCB0aGF0IHdpbGwgYmUgdXNlZCB0byBwYXJzZSB0aGUgYXR0cmlidXRlc1xuICogQHJldHVybnMgeyBBcnJheXxzdHJpbmcgfSByZXN1bHQgb2YgdGhlIHBhcnNpbmcgaW4gYSBsaXN0IG9yIGEgc2luZ2xlIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VOb2RlcyhlbHMsIG5hbWUsIG1ldGhvZCkge1xuICBjb25zdCBuYW1lcyA9IHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyA/IFtuYW1lXSA6IG5hbWU7XG4gIHJldHVybiBub3JtYWxpemUoZG9tVG9BcnJheShlbHMpLm1hcChlbCA9PiB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZShuYW1lcy5tYXAobiA9PiBlbFttZXRob2RdKG4pKSk7XG4gIH0pKTtcbn1cbi8qKlxuICogU2V0IGFueSBhdHRyaWJ1dGUgb24gYSBzaW5nbGUgb3IgYSBsaXN0IG9mIERPTSBub2Rlc1xuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudHxOb2RlTGlzdHxBcnJheSB9IGVscyAgIC0gRE9NIG5vZGUvcyB0byBwYXJzZVxuICogQHBhcmFtICAgeyBzdHJpbmd8T2JqZWN0IH0gICAgICAgICAgICAgIG5hbWUgIC0gZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gc2V0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhIGxpc3Qgb2YgcHJvcGVydGllcyBhcyBvYmplY3Qga2V5IC0gdmFsdWVcbiAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gICAgICAgICAgICAgICAgICAgICB2YWx1ZSAtIHRoZSBuZXcgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyB7IEhUTUxFbGVtZW50fE5vZGVMaXN0fEFycmF5IH0gdGhlIG9yaWdpbmFsIGFycmF5IG9mIGVsZW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQgeyBzZXQgfSBmcm9tICdiaWFuY28uYXR0cidcbiAqXG4gKiBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKVxuICpcbiAqIHNldChpbWcsICd3aWR0aCcsIDEwMClcbiAqXG4gKiAvLyBvciBhbHNvXG4gKiBzZXQoaW1nLCB7XG4gKiAgIHdpZHRoOiAzMDAsXG4gKiAgIGhlaWdodDogMzAwXG4gKiB9KVxuICpcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChlbHMsIG5hbWUsIHZhbHVlKSB7XG4gIGNvbnN0IGF0dHJzID0gdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnID8gbmFtZSA6IHtcbiAgICBbbmFtZV06IHZhbHVlXG4gIH07XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xuICBkb21Ub0FycmF5KGVscykuZm9yRWFjaChlbCA9PiB7XG4gICAgcHJvcHMuZm9yRWFjaChwcm9wID0+IGVsLnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyc1twcm9wXSkpO1xuICB9KTtcbiAgcmV0dXJuIGVscztcbn1cbi8qKlxuICogR2V0IGFueSBhdHRyaWJ1dGUgZnJvbSBhIHNpbmdsZSBvciBhIGxpc3Qgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50fE5vZGVMaXN0fEFycmF5IH0gZWxzICAgLSBET00gbm9kZS9zIHRvIHBhcnNlXG4gKiBAcGFyYW0gICB7IHN0cmluZ3xBcnJheSB9ICAgICAgICAgICAgICAgbmFtZSAgLSBuYW1lIG9yIGxpc3Qgb2YgYXR0cmlidXRlcyB0byBnZXRcbiAqIEByZXR1cm5zIHsgQXJyYXl8c3RyaW5nIH0gbGlzdCBvZiB0aGUgYXR0cmlidXRlcyBmb3VuZFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IHsgZ2V0IH0gZnJvbSAnYmlhbmNvLmF0dHInXG4gKlxuICogY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAqXG4gKiBnZXQoaW1nLCAnd2lkdGgnKSAvLyA9PiAnMjAwJ1xuICpcbiAqIC8vIG9yIGFsc29cbiAqIGdldChpbWcsIFsnd2lkdGgnLCAnaGVpZ2h0J10pIC8vID0+IFsnMjAwJywgJzMwMCddXG4gKlxuICogLy8gb3IgYWxzb1xuICogZ2V0KFtpbWcxLCBpbWcyXSwgWyd3aWR0aCcsICdoZWlnaHQnXSkgLy8gPT4gW1snMjAwJywgJzMwMCddLCBbJzUwMCcsICcyMDAnXV1cbiAqL1xuXG5mdW5jdGlvbiBnZXQoZWxzLCBuYW1lKSB7XG4gIHJldHVybiBwYXJzZU5vZGVzKGVscywgbmFtZSwgJ2dldEF0dHJpYnV0ZScpO1xufVxuXG5jb25zdCBDU1NfQllfTkFNRSA9IG5ldyBNYXAoKTtcbmNvbnN0IFNUWUxFX05PREVfU0VMRUNUT1IgPSAnc3R5bGVbcmlvdF0nOyAvLyBtZW1vaXplZCBjdXJyaWVkIGZ1bmN0aW9uXG5cbmNvbnN0IGdldFN0eWxlTm9kZSA9IChzdHlsZSA9PiB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgLy8gbGF6eSBldmFsdWF0aW9uOlxuICAgIC8vIGlmIHRoaXMgZnVuY3Rpb24gd2FzIGFscmVhZHkgY2FsbGVkIGJlZm9yZVxuICAgIC8vIHdlIHJldHVybiBpdHMgY2FjaGVkIHJlc3VsdFxuICAgIGlmIChzdHlsZSkgcmV0dXJuIHN0eWxlOyAvLyBjcmVhdGUgYSBuZXcgc3R5bGUgZWxlbWVudCBvciB1c2UgYW4gZXhpc3Rpbmcgb25lXG4gICAgLy8gYW5kIGNhY2hlIGl0IGludGVybmFsbHlcblxuICAgIHN0eWxlID0gJChTVFlMRV9OT0RFX1NFTEVDVE9SKVswXSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHNldChzdHlsZSwgJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgaWYgKCFzdHlsZS5wYXJlbnROb2RlKSBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG59KSgpO1xuLyoqXG4gKiBPYmplY3QgdGhhdCB3aWxsIGJlIHVzZWQgdG8gaW5qZWN0IGFuZCBtYW5hZ2UgdGhlIGNzcyBvZiBldmVyeSB0YWcgaW5zdGFuY2VcbiAqL1xuXG5cbnZhciBjc3NNYW5hZ2VyID0ge1xuICBDU1NfQllfTkFNRSxcblxuICAvKipcbiAgICogU2F2ZSBhIHRhZyBzdHlsZSB0byBiZSBsYXRlciBpbmplY3RlZCBpbnRvIERPTVxuICAgKiBAcGFyYW0geyBzdHJpbmcgfSBuYW1lIC0gaWYgaXQncyBwYXNzZWQgd2Ugd2lsbCBtYXAgdGhlIGNzcyB0byBhIHRhZ25hbWVcbiAgICogQHBhcmFtIHsgc3RyaW5nIH0gY3NzIC0gY3NzIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzZWxmXG4gICAqL1xuICBhZGQobmFtZSwgY3NzKSB7XG4gICAgaWYgKCFDU1NfQllfTkFNRS5oYXMobmFtZSkpIHtcbiAgICAgIENTU19CWV9OQU1FLnNldChuYW1lLCBjc3MpO1xuICAgICAgdGhpcy5pbmplY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogSW5qZWN0IGFsbCBwcmV2aW91c2x5IHNhdmVkIHRhZyBzdHlsZXMgaW50byBET01cbiAgICogaW5uZXJIVE1MIHNlZW1zIHNsb3c6IGh0dHA6Ly9qc3BlcmYuY29tL3Jpb3QtaW5zZXJ0LXN0eWxlXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHNlbGZcbiAgICovXG4gIGluamVjdCgpIHtcbiAgICBnZXRTdHlsZU5vZGUoKS5pbm5lckhUTUwgPSBbLi4uQ1NTX0JZX05BTUUudmFsdWVzKCldLmpvaW4oJ1xcbicpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB0YWcgc3R5bGUgZnJvbSB0aGUgRE9NXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGEgcmVnaXN0ZXJlZCB0YWduYW1lXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHNlbGZcbiAgICovXG4gIHJlbW92ZShuYW1lKSB7XG4gICAgaWYgKENTU19CWV9OQU1FLmhhcyhuYW1lKSkge1xuICAgICAgQ1NTX0JZX05BTUUuZGVsZXRlKG5hbWUpO1xuICAgICAgdGhpcy5pbmplY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGN1cnJ5IGFueSBqYXZhc2NyaXB0IG1ldGhvZFxuICogQHBhcmFtICAge0Z1bmN0aW9ufSAgZm4gLSB0aGUgdGFyZ2V0IGZ1bmN0aW9uIHdlIHdhbnQgdG8gY3VycnlcbiAqIEBwYXJhbSAgIHsuLi5bYXJnc119IGFjYyAtIGluaXRpYWwgYXJndW1lbnRzXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258Kn0gaXQgd2lsbCByZXR1cm4gYSBmdW5jdGlvbiB1bnRpbCB0aGUgdGFyZ2V0IGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCByZWNlaXZlIGFsbCBvZiBpdHMgYXJndW1lbnRzXG4gKi9cbmZ1bmN0aW9uIGN1cnJ5KGZuKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhY2MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFjY1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGFyZ3MgPSBbLi4uYWNjLCAuLi5hcmdzXTtcbiAgICByZXR1cm4gYXJncy5sZW5ndGggPCBmbi5sZW5ndGggPyBjdXJyeShmbiwgLi4uYXJncykgOiBmbiguLi5hcmdzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRhZyBuYW1lIG9mIGFueSBET00gbm9kZVxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gRE9NIG5vZGUgd2Ugd2FudCB0byBpbnNwZWN0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBuYW1lIHRvIGlkZW50aWZ5IHRoaXMgZG9tIG5vZGUgaW4gcmlvdFxuICovXG5cbmZ1bmN0aW9uIGdldE5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0KGVsZW1lbnQsIElTX0RJUkVDVElWRSkgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG59XG5cbmNvbnN0IENPTVBPTkVOVF9DT1JFX0hFTFBFUlMgPSBPYmplY3QuZnJlZXplKHtcbiAgLy8gY29tcG9uZW50IGhlbHBlcnNcbiAgJChzZWxlY3Rvcikge1xuICAgIHJldHVybiAkKHNlbGVjdG9yLCB0aGlzLnJvb3QpWzBdO1xuICB9LFxuXG4gICQkKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuICQoc2VsZWN0b3IsIHRoaXMucm9vdCk7XG4gIH1cblxufSk7XG5jb25zdCBQVVJFX0NPTVBPTkVOVF9BUEkgPSBPYmplY3QuZnJlZXplKHtcbiAgW01PVU5UX01FVEhPRF9LRVldOiBub29wLFxuICBbVVBEQVRFX01FVEhPRF9LRVldOiBub29wLFxuICBbVU5NT1VOVF9NRVRIT0RfS0VZXTogbm9vcFxufSk7XG5jb25zdCBDT01QT05FTlRfTElGRUNZQ0xFX01FVEhPRFMgPSBPYmplY3QuZnJlZXplKHtcbiAgW1NIT1VMRF9VUERBVEVfS0VZXTogbm9vcCxcbiAgW09OX0JFRk9SRV9NT1VOVF9LRVldOiBub29wLFxuICBbT05fTU9VTlRFRF9LRVldOiBub29wLFxuICBbT05fQkVGT1JFX1VQREFURV9LRVldOiBub29wLFxuICBbT05fVVBEQVRFRF9LRVldOiBub29wLFxuICBbT05fQkVGT1JFX1VOTU9VTlRfS0VZXTogbm9vcCxcbiAgW09OX1VOTU9VTlRFRF9LRVldOiBub29wXG59KTtcbmNvbnN0IE1PQ0tFRF9URU1QTEFURV9JTlRFUkZBQ0UgPSBPYmplY3QuYXNzaWduKHt9LCBQVVJFX0NPTVBPTkVOVF9BUEksIHtcbiAgY2xvbmU6IG5vb3AsXG4gIGNyZWF0ZURPTTogbm9vcFxufSk7XG4vKipcbiAqIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBmb3IgdGhlIHJlY3Vyc2l2ZSBjb21wb25lbnRzXG4gKiBAcGFyYW0gIHtSaW90Q29tcG9uZW50U2hlbGx9IGNvbXBvbmVudFNoZWxsIC0gcmlvdCBjb21waWxlciBnZW5lcmF0ZWQgb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjb21wb25lbnQgbGlrZSBpbnRlcmZhY2VcbiAqL1xuXG5jb25zdCBtZW1vaXplZENyZWF0ZUNvbXBvbmVudCA9IG1lbW9pemUoY3JlYXRlQ29tcG9uZW50KTtcbi8qKlxuICogRXZhbHVhdGUgdGhlIGNvbXBvbmVudCBwcm9wZXJ0aWVzIGVpdGhlciBmcm9tIGl0cyByZWFsIGF0dHJpYnV0ZXMgb3IgZnJvbSBpdHMgaW5pdGlhbCB1c2VyIHByb3BlcnRpZXNcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGNvbXBvbmVudCByb290XG4gKiBAcGFyYW0gICB7T2JqZWN0fSAgaW5pdGlhbFByb3BzIC0gaW5pdGlhbCBwcm9wc1xuICogQHJldHVybnMge09iamVjdH0gY29tcG9uZW50IHByb3BzIGtleSB2YWx1ZSBwYWlyc1xuICovXG5cbmZ1bmN0aW9uIGV2YWx1YXRlSW5pdGlhbFByb3BzKGVsZW1lbnQsIGluaXRpYWxQcm9wcykge1xuICBpZiAoaW5pdGlhbFByb3BzID09PSB2b2lkIDApIHtcbiAgICBpbml0aWFsUHJvcHMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBET01hdHRyaWJ1dGVzVG9PYmplY3QoZWxlbWVudCksIGNhbGxPckFzc2lnbihpbml0aWFsUHJvcHMpKTtcbn1cbi8qKlxuICogQmluZCBhIERPTSBub2RlIHRvIGl0cyBjb21wb25lbnQgb2JqZWN0XG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IG5vZGUgLSBodG1sIG5vZGUgbW91bnRlZFxuICogQHBhcmFtICAge09iamVjdH0gY29tcG9uZW50IC0gUmlvdC5qcyBjb21wb25lbnQgb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgY29tcG9uZW50IG9iamVjdCByZWNlaXZlZCBhcyBzZWNvbmQgYXJndW1lbnRcbiAqL1xuXG5cbmNvbnN0IGJpbmRET01Ob2RlVG9Db21wb25lbnRPYmplY3QgPSAobm9kZSwgY29tcG9uZW50KSA9PiBub2RlW0RPTV9DT01QT05FTlRfSU5TVEFOQ0VfUFJPUEVSVFkkMV0gPSBjb21wb25lbnQ7XG4vKipcbiAqIFdyYXAgdGhlIFJpb3QuanMgY29yZSBBUEkgbWV0aG9kcyB1c2luZyBhIG1hcHBpbmcgZnVuY3Rpb25cbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gbWFwRnVuY3Rpb24gLSBsaWZ0aW5nIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhbiBvYmplY3QgaGF2aW5nIHRoZSB7IG1vdW50LCB1cGRhdGUsIHVubW91bnQgfSBmdW5jdGlvbnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvcmVBUElNZXRob2RzKG1hcEZ1bmN0aW9uKSB7XG4gIHJldHVybiBbTU9VTlRfTUVUSE9EX0tFWSwgVVBEQVRFX01FVEhPRF9LRVksIFVOTU9VTlRfTUVUSE9EX0tFWV0ucmVkdWNlKChhY2MsIG1ldGhvZCkgPT4ge1xuICAgIGFjY1ttZXRob2RdID0gbWFwRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBjb21wb25lbnQgdGVtcGxhdGVzIG9ubHkgb25jZVxuICogQHBhcmFtICAge0Z1bmN0aW9ufSB0ZW1wbGF0ZSAtIGNvbXBvbmVudCB0ZW1wbGF0ZSBjcmVhdGlvbiBmdW5jdGlvblxuICogQHBhcmFtICAge1Jpb3RDb21wb25lbnRTaGVsbH0gY29tcG9uZW50U2hlbGwgLSByaW90IGNvbXBpbGVyIGdlbmVyYXRlZCBvYmplY3RcbiAqIEByZXR1cm5zIHtUZW1wbGF0ZUNodW5rfSB0ZW1wbGF0ZSBjaHVuayBvYmplY3RcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbXBvbmVudFRlbXBsYXRlRmFjdG9yeSh0ZW1wbGF0ZSwgY29tcG9uZW50U2hlbGwpIHtcbiAgY29uc3QgY29tcG9uZW50cyA9IGNyZWF0ZVN1YmNvbXBvbmVudHMoY29tcG9uZW50U2hlbGwuZXhwb3J0cyA/IGNvbXBvbmVudFNoZWxsLmV4cG9ydHMuY29tcG9uZW50cyA6IHt9KTtcbiAgcmV0dXJuIHRlbXBsYXRlKGNyZWF0ZSwgZXhwcmVzc2lvblR5cGVzLCBiaW5kaW5nVHlwZXMsIG5hbWUgPT4ge1xuICAgIC8vIGltcHJvdmUgc3VwcG9ydCBmb3IgcmVjdXJzaXZlIGNvbXBvbmVudHNcbiAgICBpZiAobmFtZSA9PT0gY29tcG9uZW50U2hlbGwubmFtZSkgcmV0dXJuIG1lbW9pemVkQ3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudFNoZWxsKTsgLy8gcmV0dXJuIHRoZSByZWdpc3RlcmVkIGNvbXBvbmVudHNcblxuICAgIHJldHVybiBjb21wb25lbnRzW25hbWVdIHx8IENPTVBPTkVOVFNfSU1QTEVNRU5UQVRJT05fTUFQJDEuZ2V0KG5hbWUpO1xuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcHVyZSBjb21wb25lbnRcbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gcHVyZUZhY3RvcnlGdW5jdGlvbiAtIHB1cmUgY29tcG9uZW50IGZhY3RvcnkgZnVuY3Rpb25cbiAqIEBwYXJhbSAgIHtBcnJheX0gb3B0aW9ucy5zbG90cyAtIGNvbXBvbmVudCBzbG90c1xuICogQHBhcmFtICAge0FycmF5fSBvcHRpb25zLmF0dHJpYnV0ZXMgLSBjb21wb25lbnQgYXR0cmlidXRlc1xuICogQHBhcmFtICAge0FycmF5fSBvcHRpb25zLnRlbXBsYXRlIC0gdGVtcGxhdGUgZmFjdG9yeSBmdW5jdGlvblxuICogQHBhcmFtICAge0FycmF5fSBvcHRpb25zLnRlbXBsYXRlIC0gdGVtcGxhdGUgZmFjdG9yeSBmdW5jdGlvblxuICogQHBhcmFtICAge2FueX0gb3B0aW9ucy5wcm9wcyAtIGluaXRpYWwgY29tcG9uZW50IHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IHB1cmUgY29tcG9uZW50IG9iamVjdFxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlUHVyZUNvbXBvbmVudChwdXJlRmFjdG9yeUZ1bmN0aW9uLCBfcmVmKSB7XG4gIGxldCB7XG4gICAgc2xvdHMsXG4gICAgYXR0cmlidXRlcyxcbiAgICBwcm9wcyxcbiAgICBjc3MsXG4gICAgdGVtcGxhdGVcbiAgfSA9IF9yZWY7XG4gIGlmICh0ZW1wbGF0ZSkgcGFuaWMoJ1B1cmUgY29tcG9uZW50cyBjYW4gbm90IGhhdmUgaHRtbCcpO1xuICBpZiAoY3NzKSBwYW5pYygnUHVyZSBjb21wb25lbnRzIGRvIG5vdCBoYXZlIGNzcycpO1xuICBjb25zdCBjb21wb25lbnQgPSBkZWZpbmVEZWZhdWx0cyhwdXJlRmFjdG9yeUZ1bmN0aW9uKHtcbiAgICBzbG90cyxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIHByb3BzXG4gIH0pLCBQVVJFX0NPTVBPTkVOVF9BUEkpO1xuICByZXR1cm4gY3JlYXRlQ29yZUFQSU1ldGhvZHMobWV0aG9kID0+IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgLy8gaW50ZXJjZXB0IHRoZSBtb3VudCBjYWxscyB0byBiaW5kIHRoZSBET00gbm9kZSB0byB0aGUgcHVyZSBvYmplY3QgY3JlYXRlZFxuICAgIC8vIHNlZSBhbHNvIGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L3Jpb3QvaXNzdWVzLzI4MDZcbiAgICBpZiAobWV0aG9kID09PSBNT1VOVF9NRVRIT0RfS0VZKSB7XG4gICAgICBjb25zdCBbZWxdID0gYXJnczsgLy8gbWFyayB0aGlzIG5vZGUgYXMgcHVyZSBlbGVtZW50XG5cbiAgICAgIGVsW0lTX1BVUkVfU1lNQk9MXSA9IHRydWU7XG4gICAgICBiaW5kRE9NTm9kZVRvQ29tcG9uZW50T2JqZWN0KGVsLCBjb21wb25lbnQpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFttZXRob2RdKC4uLmFyZ3MpO1xuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgdGhlIGNvbXBvbmVudCBpbnRlcmZhY2UgbmVlZGVkIGZvciB0aGUgQHJpb3Rqcy9kb20tYmluZGluZ3MgdGFnIGJpbmRpbmdzXG4gKiBAcGFyYW0gICB7UmlvdENvbXBvbmVudFNoZWxsfSBjb21wb25lbnRTaGVsbCAtIHJpb3QgY29tcGlsZXIgZ2VuZXJhdGVkIG9iamVjdFxuICogQHBhcmFtICAge3N0cmluZ30gY29tcG9uZW50U2hlbGwuY3NzIC0gY29tcG9uZW50IGNzc1xuICogQHBhcmFtICAge0Z1bmN0aW9ufSBjb21wb25lbnRTaGVsbC50ZW1wbGF0ZSAtIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXR1cm4gdGhlIGRvbS1iaW5kaW5ncyB0ZW1wbGF0ZSBmdW5jdGlvblxuICogQHBhcmFtICAge09iamVjdH0gY29tcG9uZW50U2hlbGwuZXhwb3J0cyAtIGNvbXBvbmVudCBpbnRlcmZhY2VcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IGNvbXBvbmVudFNoZWxsLm5hbWUgLSBjb21wb25lbnQgbmFtZVxuICogQHJldHVybnMge09iamVjdH0gY29tcG9uZW50IGxpa2UgaW50ZXJmYWNlXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQoY29tcG9uZW50U2hlbGwpIHtcbiAgY29uc3Qge1xuICAgIGNzcyxcbiAgICB0ZW1wbGF0ZSxcbiAgICBleHBvcnRzLFxuICAgIG5hbWVcbiAgfSA9IGNvbXBvbmVudFNoZWxsO1xuICBjb25zdCB0ZW1wbGF0ZUZuID0gdGVtcGxhdGUgPyBjb21wb25lbnRUZW1wbGF0ZUZhY3RvcnkodGVtcGxhdGUsIGNvbXBvbmVudFNoZWxsKSA6IE1PQ0tFRF9URU1QTEFURV9JTlRFUkZBQ0U7XG4gIHJldHVybiBfcmVmMiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHNsb3RzLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIHByb3BzXG4gICAgfSA9IF9yZWYyO1xuICAgIC8vIHB1cmUgY29tcG9uZW50cyByZW5kZXJpbmcgd2lsbCBiZSBtYW5hZ2VkIGJ5IHRoZSBlbmQgdXNlclxuICAgIGlmIChleHBvcnRzICYmIGV4cG9ydHNbSVNfUFVSRV9TWU1CT0xdKSByZXR1cm4gY3JlYXRlUHVyZUNvbXBvbmVudChleHBvcnRzLCB7XG4gICAgICBzbG90cyxcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBwcm9wcyxcbiAgICAgIGNzcyxcbiAgICAgIHRlbXBsYXRlXG4gICAgfSk7XG4gICAgY29uc3QgY29tcG9uZW50QVBJID0gY2FsbE9yQXNzaWduKGV4cG9ydHMpIHx8IHt9O1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGRlZmluZUNvbXBvbmVudCh7XG4gICAgICBjc3MsXG4gICAgICB0ZW1wbGF0ZTogdGVtcGxhdGVGbixcbiAgICAgIGNvbXBvbmVudEFQSSxcbiAgICAgIG5hbWVcbiAgICB9KSh7XG4gICAgICBzbG90cyxcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBwcm9wc1xuICAgIH0pOyAvLyBub3RpY2UgdGhhdCBmb3IgdGhlIGNvbXBvbmVudHMgY3JlYXRlIHZpYSB0YWcgYmluZGluZ1xuICAgIC8vIHdlIG5lZWQgdG8gaW52ZXJ0IHRoZSBtb3VudCAoc3RhdGUvcGFyZW50U2NvcGUpIGFyZ3VtZW50c1xuICAgIC8vIHRoZSB0ZW1wbGF0ZSBiaW5kaW5ncyB3aWxsIG9ubHkgZm9yd2FyZCB0aGUgcGFyZW50U2NvcGUgdXBkYXRlc1xuICAgIC8vIGFuZCBuZXZlciBkZWFsIHdpdGggdGhlIGNvbXBvbmVudCBzdGF0ZVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1vdW50KGVsZW1lbnQsIHBhcmVudFNjb3BlLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50Lm1vdW50KGVsZW1lbnQsIHN0YXRlLCBwYXJlbnRTY29wZSk7XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGUocGFyZW50U2NvcGUsIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQudXBkYXRlKHN0YXRlLCBwYXJlbnRTY29wZSk7XG4gICAgICB9LFxuXG4gICAgICB1bm1vdW50KHByZXNlcnZlUm9vdCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50LnVubW91bnQocHJlc2VydmVSb290KTtcbiAgICAgIH1cblxuICAgIH07XG4gIH07XG59XG4vKipcbiAqIENvbXBvbmVudCBkZWZpbml0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBpbXBsZW1lbnRhdGlvbiAtIHRoZSBjb21wb25lbiBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIGdlbmVyYXRlZCB2aWEgY29tcGlsZXJcbiAqIEBwYXJhbSAgIHtPYmplY3R9IGNvbXBvbmVudCAtIHRoZSBjb21wb25lbnQgaW5pdGlhbCBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhIG5ldyBjb21wb25lbnQgaW1wbGVtZW50YXRpb24gb2JqZWN0XG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KF9yZWYzKSB7XG4gIGxldCB7XG4gICAgY3NzLFxuICAgIHRlbXBsYXRlLFxuICAgIGNvbXBvbmVudEFQSSxcbiAgICBuYW1lXG4gIH0gPSBfcmVmMztcbiAgLy8gYWRkIHRoZSBjb21wb25lbnQgY3NzIGludG8gdGhlIERPTVxuICBpZiAoY3NzICYmIG5hbWUpIGNzc01hbmFnZXIuYWRkKG5hbWUsIGNzcyk7XG4gIHJldHVybiBjdXJyeShlbmhhbmNlQ29tcG9uZW50QVBJKShkZWZpbmVQcm9wZXJ0aWVzKCAvLyBzZXQgdGhlIGNvbXBvbmVudCBkZWZhdWx0cyB3aXRob3V0IG92ZXJyaWRpbmcgdGhlIG9yaWdpbmFsIGNvbXBvbmVudCBBUElcbiAgZGVmaW5lRGVmYXVsdHMoY29tcG9uZW50QVBJLCBPYmplY3QuYXNzaWduKHt9LCBDT01QT05FTlRfTElGRUNZQ0xFX01FVEhPRFMsIHtcbiAgICBbUFJPUFNfS0VZXToge30sXG4gICAgW1NUQVRFX0tFWV06IHt9XG4gIH0pKSwgT2JqZWN0LmFzc2lnbih7XG4gICAgLy8gZGVmaW5lZCBkdXJpbmcgdGhlIGNvbXBvbmVudCBjcmVhdGlvblxuICAgIFtTTE9UU19LRVldOiBudWxsLFxuICAgIFtST09UX0tFWV06IG51bGxcbiAgfSwgQ09NUE9ORU5UX0NPUkVfSEVMUEVSUywge1xuICAgIG5hbWUsXG4gICAgY3NzLFxuICAgIHRlbXBsYXRlXG4gIH0pKSk7XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgYmluZGluZ3MgdG8gdXBkYXRlIHRoZSBjb21wb25lbnQgYXR0cmlidXRlc1xuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBub2RlIC0gbm9kZSB3aGVyZSB3ZSB3aWxsIGJpbmQgdGhlIGV4cHJlc3Npb25zXG4gKiBAcGFyYW0gICB7QXJyYXl9IGF0dHJpYnV0ZXMgLSBsaXN0IG9mIGF0dHJpYnV0ZSBiaW5kaW5nc1xuICogQHJldHVybnMge1RlbXBsYXRlQ2h1bmt9IC0gdGVtcGxhdGUgYmluZGluZ3Mgb2JqZWN0XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlQmluZGluZ3Mobm9kZSwgYXR0cmlidXRlcykge1xuICBpZiAoYXR0cmlidXRlcyA9PT0gdm9pZCAwKSB7XG4gICAgYXR0cmlidXRlcyA9IFtdO1xuICB9XG5cbiAgY29uc3QgZXhwcmVzc2lvbnMgPSBhdHRyaWJ1dGVzLm1hcChhID0+IGNyZWF0ZSQ0KG5vZGUsIGEpKTtcbiAgY29uc3QgYmluZGluZyA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihiaW5kaW5nLCBPYmplY3QuYXNzaWduKHtcbiAgICBleHByZXNzaW9uc1xuICB9LCBjcmVhdGVDb3JlQVBJTWV0aG9kcyhtZXRob2QgPT4gc2NvcGUgPT4ge1xuICAgIGV4cHJlc3Npb25zLmZvckVhY2goZSA9PiBlW21ldGhvZF0oc2NvcGUpKTtcbiAgICByZXR1cm4gYmluZGluZztcbiAgfSkpKTtcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBzdWJjb21wb25lbnRzIHRoYXQgY2FuIGJlIGluY2x1ZGVkIGluc2lkZSBhIHRhZyBpbiBydW50aW1lXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBjb21wb25lbnRzIC0gY29tcG9uZW50cyBpbXBvcnRlZCBpbiBydW50aW1lXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhbGwgdGhlIGNvbXBvbmVudHMgdHJhbnNmb3JtZWQgaW50byBSaW90LkNvbXBvbmVudCBmYWN0b3J5IGZ1bmN0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlU3ViY29tcG9uZW50cyhjb21wb25lbnRzKSB7XG4gIGlmIChjb21wb25lbnRzID09PSB2b2lkIDApIHtcbiAgICBjb21wb25lbnRzID0ge307XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoY2FsbE9yQXNzaWduKGNvbXBvbmVudHMpKS5yZWR1Y2UoKGFjYywgX3JlZjQpID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjQ7XG4gICAgYWNjW2NhbWVsVG9EYXNoQ2FzZShrZXkpXSA9IGNyZWF0ZUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuLyoqXG4gKiBSdW4gdGhlIGNvbXBvbmVudCBpbnN0YW5jZSB0aHJvdWdoIGFsbCB0aGUgcGx1Z2lucyBzZXQgYnkgdGhlIHVzZXJcbiAqIEBwYXJhbSAgIHtPYmplY3R9IGNvbXBvbmVudCAtIGNvbXBvbmVudCBpbnN0YW5jZVxuICogQHJldHVybnMge09iamVjdH0gdGhlIGNvbXBvbmVudCBlbmhhbmNlZCBieSB0aGUgcGx1Z2luc1xuICovXG5cblxuZnVuY3Rpb24gcnVuUGx1Z2lucyhjb21wb25lbnQpIHtcbiAgcmV0dXJuIFsuLi5QTFVHSU5TX1NFVCQxXS5yZWR1Y2UoKGMsIGZuKSA9PiBmbihjKSB8fCBjLCBjb21wb25lbnQpO1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBjb21wb25lbnQgY3VycmVudCBzdGF0ZSBtZXJnaW5nIGl0IHdpdGggaXRzIHByZXZpb3VzIHN0YXRlXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBvbGRTdGF0ZSAtIHByZXZpb3VzIHN0YXRlIG9iamVjdFxuICogQHBhcmFtICAge09iamVjdH0gbmV3U3RhdGUgLSBuZXcgc3RhdGUgZ2l2ZW50IHRvIHRoZSBgdXBkYXRlYCBjYWxsXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXcgb2JqZWN0IHN0YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBjb21wdXRlU3RhdGUob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvbGRTdGF0ZSwgY2FsbE9yQXNzaWduKG5ld1N0YXRlKSk7XG59XG4vKipcbiAqIEFkZCBldmVudHVhbGx5IHRoZSBcImlzXCIgYXR0cmlidXRlIHRvIGxpbmsgdGhpcyBET00gbm9kZSB0byBpdHMgY3NzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gdGFyZ2V0IHJvb3Qgbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSBjb21wb25lbnQgbW91bnRlZFxuICogQHJldHVybnMge3VuZGVmaW5lZH0gaXQncyBhIHZvaWQgZnVuY3Rpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZENzc0hvb2soZWxlbWVudCwgbmFtZSkge1xuICBpZiAoZ2V0TmFtZShlbGVtZW50KSAhPT0gbmFtZSkge1xuICAgIHNldChlbGVtZW50LCBJU19ESVJFQ1RJVkUsIG5hbWUpO1xuICB9XG59XG4vKipcbiAqIENvbXBvbmVudCBjcmVhdGlvbiBmYWN0b3J5IGZ1bmN0aW9uIHRoYXQgd2lsbCBlbmhhbmNlIHRoZSB1c2VyIHByb3ZpZGVkIEFQSVxuICogQHBhcmFtICAge09iamVjdH0gY29tcG9uZW50IC0gYSBjb21wb25lbnQgaW1wbGVtZW50YXRpb24gcHJldmlvdXNseSBkZWZpbmVkXG4gKiBAcGFyYW0gICB7QXJyYXl9IG9wdGlvbnMuc2xvdHMgLSBjb21wb25lbnQgc2xvdHMgZ2VuZXJhdGVkIHZpYSByaW90IGNvbXBpbGVyXG4gKiBAcGFyYW0gICB7QXJyYXl9IG9wdGlvbnMuYXR0cmlidXRlcyAtIGF0dHJpYnV0ZSBleHByZXNzaW9ucyBnZW5lcmF0ZWQgdmlhIHJpb3QgY29tcGlsZXJcbiAqIEByZXR1cm5zIHtSaW90LkNvbXBvbmVudH0gYSByaW90IGNvbXBvbmVudCBpbnN0YW5jZVxuICovXG5cblxuZnVuY3Rpb24gZW5oYW5jZUNvbXBvbmVudEFQSShjb21wb25lbnQsIF9yZWY1KSB7XG4gIGxldCB7XG4gICAgc2xvdHMsXG4gICAgYXR0cmlidXRlcyxcbiAgICBwcm9wc1xuICB9ID0gX3JlZjU7XG4gIHJldHVybiBhdXRvYmluZE1ldGhvZHMocnVuUGx1Z2lucyhkZWZpbmVQcm9wZXJ0aWVzKGlzT2JqZWN0KGNvbXBvbmVudCkgPyBPYmplY3QuY3JlYXRlKGNvbXBvbmVudCkgOiBjb21wb25lbnQsIHtcbiAgICBtb3VudChlbGVtZW50LCBzdGF0ZSwgcGFyZW50U2NvcGUpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHN0YXRlID0ge307XG4gICAgICB9XG5cbiAgICAgIHRoaXNbUEFSRU5UX0tFWV9TWU1CT0xdID0gcGFyZW50U2NvcGU7XG4gICAgICB0aGlzW0FUVFJJQlVURVNfS0VZX1NZTUJPTF0gPSBjcmVhdGVBdHRyaWJ1dGVCaW5kaW5ncyhlbGVtZW50LCBhdHRyaWJ1dGVzKS5tb3VudChwYXJlbnRTY29wZSk7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBQUk9QU19LRVksIE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgZXZhbHVhdGVJbml0aWFsUHJvcHMoZWxlbWVudCwgcHJvcHMpLCBldmFsdWF0ZUF0dHJpYnV0ZUV4cHJlc3Npb25zKHRoaXNbQVRUUklCVVRFU19LRVlfU1lNQk9MXS5leHByZXNzaW9ucykpKSk7XG4gICAgICB0aGlzW1NUQVRFX0tFWV0gPSBjb21wdXRlU3RhdGUodGhpc1tTVEFURV9LRVldLCBzdGF0ZSk7XG4gICAgICB0aGlzW1RFTVBMQVRFX0tFWV9TWU1CT0xdID0gdGhpcy50ZW1wbGF0ZS5jcmVhdGVET00oZWxlbWVudCkuY2xvbmUoKTsgLy8gbGluayB0aGlzIG9iamVjdCB0byB0aGUgRE9NIG5vZGVcblxuICAgICAgYmluZERPTU5vZGVUb0NvbXBvbmVudE9iamVjdChlbGVtZW50LCB0aGlzKTsgLy8gYWRkIGV2ZW50dWFsbHkgdGhlICdpcycgYXR0cmlidXRlXG5cbiAgICAgIGNvbXBvbmVudC5uYW1lICYmIGFkZENzc0hvb2soZWxlbWVudCwgY29tcG9uZW50Lm5hbWUpOyAvLyBkZWZpbmUgdGhlIHJvb3QgZWxlbWVudFxuXG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBST09UX0tFWSwgZWxlbWVudCk7IC8vIGRlZmluZSB0aGUgc2xvdHMgYXJyYXlcblxuICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgU0xPVFNfS0VZLCBzbG90cyk7IC8vIGJlZm9yZSBtb3VudCBsaWZlY3ljbGUgZXZlbnRcblxuICAgICAgdGhpc1tPTl9CRUZPUkVfTU9VTlRfS0VZXSh0aGlzW1BST1BTX0tFWV0sIHRoaXNbU1RBVEVfS0VZXSk7IC8vIG1vdW50IHRoZSB0ZW1wbGF0ZVxuXG4gICAgICB0aGlzW1RFTVBMQVRFX0tFWV9TWU1CT0xdLm1vdW50KGVsZW1lbnQsIHRoaXMsIHBhcmVudFNjb3BlKTtcbiAgICAgIHRoaXNbT05fTU9VTlRFRF9LRVldKHRoaXNbUFJPUFNfS0VZXSwgdGhpc1tTVEFURV9LRVldKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB1cGRhdGUoc3RhdGUsIHBhcmVudFNjb3BlKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBzdGF0ZSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50U2NvcGUpIHtcbiAgICAgICAgdGhpc1tQQVJFTlRfS0VZX1NZTUJPTF0gPSBwYXJlbnRTY29wZTtcbiAgICAgICAgdGhpc1tBVFRSSUJVVEVTX0tFWV9TWU1CT0xdLnVwZGF0ZShwYXJlbnRTY29wZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld1Byb3BzID0gZXZhbHVhdGVBdHRyaWJ1dGVFeHByZXNzaW9ucyh0aGlzW0FUVFJJQlVURVNfS0VZX1NZTUJPTF0uZXhwcmVzc2lvbnMpO1xuICAgICAgaWYgKHRoaXNbU0hPVUxEX1VQREFURV9LRVldKG5ld1Byb3BzLCB0aGlzW1BST1BTX0tFWV0pID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgUFJPUFNfS0VZLCBPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oe30sIHRoaXNbUFJPUFNfS0VZXSwgbmV3UHJvcHMpKSk7XG4gICAgICB0aGlzW1NUQVRFX0tFWV0gPSBjb21wdXRlU3RhdGUodGhpc1tTVEFURV9LRVldLCBzdGF0ZSk7XG4gICAgICB0aGlzW09OX0JFRk9SRV9VUERBVEVfS0VZXSh0aGlzW1BST1BTX0tFWV0sIHRoaXNbU1RBVEVfS0VZXSk7IC8vIGF2b2lkaW5nIHJlY3Vyc2l2ZSB1cGRhdGVzXG4gICAgICAvLyBzZWUgYWxzbyBodHRwczovL2dpdGh1Yi5jb20vcmlvdC9yaW90L2lzc3Vlcy8yODk1XG5cbiAgICAgIGlmICghdGhpc1tJU19DT01QT05FTlRfVVBEQVRJTkddKSB7XG4gICAgICAgIHRoaXNbSVNfQ09NUE9ORU5UX1VQREFUSU5HXSA9IHRydWU7XG4gICAgICAgIHRoaXNbVEVNUExBVEVfS0VZX1NZTUJPTF0udXBkYXRlKHRoaXMsIHRoaXNbUEFSRU5UX0tFWV9TWU1CT0xdKTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tPTl9VUERBVEVEX0tFWV0odGhpc1tQUk9QU19LRVldLCB0aGlzW1NUQVRFX0tFWV0pO1xuICAgICAgdGhpc1tJU19DT01QT05FTlRfVVBEQVRJTkddID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdW5tb3VudChwcmVzZXJ2ZVJvb3QpIHtcbiAgICAgIHRoaXNbT05fQkVGT1JFX1VOTU9VTlRfS0VZXSh0aGlzW1BST1BTX0tFWV0sIHRoaXNbU1RBVEVfS0VZXSk7XG4gICAgICB0aGlzW0FUVFJJQlVURVNfS0VZX1NZTUJPTF0udW5tb3VudCgpOyAvLyBpZiB0aGUgcHJlc2VydmVSb290IGlzIG51bGwgdGhlIHRlbXBsYXRlIGh0bWwgd2lsbCBiZSBsZWZ0IHVudG91Y2hlZFxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHRoZSBET00gY2xlYW51cCB3aWxsIGhhcHBlbiBkaWZmZXJlbnRseSBmcm9tIGEgcGFyZW50IG5vZGVcblxuICAgICAgdGhpc1tURU1QTEFURV9LRVlfU1lNQk9MXS51bm1vdW50KHRoaXMsIHRoaXNbUEFSRU5UX0tFWV9TWU1CT0xdLCBwcmVzZXJ2ZVJvb3QgPT09IG51bGwgPyBudWxsIDogIXByZXNlcnZlUm9vdCk7XG4gICAgICB0aGlzW09OX1VOTU9VTlRFRF9LRVldKHRoaXNbUFJPUFNfS0VZXSwgdGhpc1tTVEFURV9LRVldKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICB9KSksIE9iamVjdC5rZXlzKGNvbXBvbmVudCkuZmlsdGVyKHByb3AgPT4gaXNGdW5jdGlvbihjb21wb25lbnRbcHJvcF0pKSk7XG59XG4vKipcbiAqIENvbXBvbmVudCBpbml0aWFsaXphdGlvbiBmdW5jdGlvbiBzdGFydGluZyBmcm9tIGEgRE9NIG5vZGVcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gdXBncmFkZVxuICogQHBhcmFtICAge09iamVjdH0gaW5pdGlhbFByb3BzIC0gaW5pdGlhbCBjb21wb25lbnQgcHJvcGVydGllc1xuICogQHBhcmFtICAge3N0cmluZ30gY29tcG9uZW50TmFtZSAtIGNvbXBvbmVudCBpZFxuICogQHJldHVybnMge09iamVjdH0gYSBuZXcgY29tcG9uZW50IGluc3RhbmNlIGJvdW5kIHRvIGEgRE9NIG5vZGVcbiAqL1xuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudChlbGVtZW50LCBpbml0aWFsUHJvcHMsIGNvbXBvbmVudE5hbWUpIHtcbiAgY29uc3QgbmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgZ2V0TmFtZShlbGVtZW50KTtcbiAgaWYgKCFDT01QT05FTlRTX0lNUExFTUVOVEFUSU9OX01BUCQxLmhhcyhuYW1lKSkgcGFuaWMoYFRoZSBjb21wb25lbnQgbmFtZWQgXCIke25hbWV9XCIgd2FzIG5ldmVyIHJlZ2lzdGVyZWRgKTtcbiAgY29uc3QgY29tcG9uZW50ID0gQ09NUE9ORU5UU19JTVBMRU1FTlRBVElPTl9NQVAkMS5nZXQobmFtZSkoe1xuICAgIHByb3BzOiBpbml0aWFsUHJvcHNcbiAgfSk7XG4gIHJldHVybiBjb21wb25lbnQubW91bnQoZWxlbWVudCk7XG59XG5cbi8qKlxuICogU2ltaWxhciB0byBjb21wb3NlIGJ1dCBwZXJmb3JtcyBmcm9tIGxlZnQtdG8tcmlnaHQgZnVuY3Rpb24gY29tcG9zaXRpb24uPGJyLz5cbiAqIHtAbGluayBodHRwczovLzMwc2Vjb25kc29mY29kZS5vcmcvZnVuY3Rpb24jY29tcG9zZXJpZ2h0IHNlZSBhbHNvfVxuICogQHBhcmFtICAgey4uLltmdW5jdGlvbl19IGZucykgLSBsaXN0IG9mIHVuYXJ5IGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7Kn0gcmVzdWx0IG9mIHRoZSBjb21wdXRhdGlvblxuICovXG4vKipcbiAqIFBlcmZvcm1zIHJpZ2h0LXRvLWxlZnQgZnVuY3Rpb24gY29tcG9zaXRpb24uPGJyLz5cbiAqIFVzZSBBcnJheS5wcm90b3R5cGUucmVkdWNlKCkgdG8gcGVyZm9ybSByaWdodC10by1sZWZ0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uLjxici8+XG4gKiBUaGUgbGFzdCAocmlnaHRtb3N0KSBmdW5jdGlvbiBjYW4gYWNjZXB0IG9uZSBvciBtb3JlIGFyZ3VtZW50czsgdGhlIHJlbWFpbmluZyBmdW5jdGlvbnMgbXVzdCBiZSB1bmFyeS48YnIvPlxuICoge0BsaW5rIGh0dHBzOi8vMzBzZWNvbmRzb2Zjb2RlLm9yZy9mdW5jdGlvbiNjb21wb3NlIG9yaWdpbmFsIHNvdXJjZSBjb2RlfVxuICogQHBhcmFtICAgey4uLltmdW5jdGlvbl19IGZucykgLSBsaXN0IG9mIHVuYXJ5IGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7Kn0gcmVzdWx0IG9mIHRoZSBjb21wdXRhdGlvblxuICovXG5cbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgZm5zID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgZm5zW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICByZXR1cm4gZm5zLnJlZHVjZSgoZiwgZykgPT4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmKGcoLi4uYXJndW1lbnRzKSk7XG4gIH0pO1xufVxuXG5jb25zdCB7XG4gIERPTV9DT01QT05FTlRfSU5TVEFOQ0VfUFJPUEVSVFksXG4gIENPTVBPTkVOVFNfSU1QTEVNRU5UQVRJT05fTUFQLFxuICBQTFVHSU5TX1NFVFxufSA9IGdsb2JhbHM7XG4vKipcbiAqIFJpb3QgcHVibGljIGFwaVxuICovXG5cbi8qKlxuICogUmVnaXN0ZXIgYSBjdXN0b20gdGFnIGJ5IG5hbWVcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWUgLSBjb21wb25lbnQgbmFtZVxuICogQHBhcmFtICAge09iamVjdH0gaW1wbGVtZW50YXRpb24gLSB0YWcgaW1wbGVtZW50YXRpb25cbiAqIEByZXR1cm5zIHtNYXB9IG1hcCBjb250YWluaW5nIGFsbCB0aGUgY29tcG9uZW50cyBpbXBsZW1lbnRhdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiByZWdpc3RlcihuYW1lLCBfcmVmKSB7XG4gIGxldCB7XG4gICAgY3NzLFxuICAgIHRlbXBsYXRlLFxuICAgIGV4cG9ydHNcbiAgfSA9IF9yZWY7XG4gIGlmIChDT01QT05FTlRTX0lNUExFTUVOVEFUSU9OX01BUC5oYXMobmFtZSkpIHBhbmljKGBUaGUgY29tcG9uZW50IFwiJHtuYW1lfVwiIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWRgKTtcbiAgQ09NUE9ORU5UU19JTVBMRU1FTlRBVElPTl9NQVAuc2V0KG5hbWUsIGNyZWF0ZUNvbXBvbmVudCh7XG4gICAgbmFtZSxcbiAgICBjc3MsXG4gICAgdGVtcGxhdGUsXG4gICAgZXhwb3J0c1xuICB9KSk7XG4gIHJldHVybiBDT01QT05FTlRTX0lNUExFTUVOVEFUSU9OX01BUDtcbn1cbi8qKlxuICogVW5yZWdpc3RlciBhIHJpb3Qgd2ViIGNvbXBvbmVudFxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZSAtIGNvbXBvbmVudCBuYW1lXG4gKiBAcmV0dXJucyB7TWFwfSBtYXAgY29udGFpbmluZyBhbGwgdGhlIGNvbXBvbmVudHMgaW1wbGVtZW50YXRpb25zXG4gKi9cblxuZnVuY3Rpb24gdW5yZWdpc3RlcihuYW1lKSB7XG4gIGlmICghQ09NUE9ORU5UU19JTVBMRU1FTlRBVElPTl9NQVAuaGFzKG5hbWUpKSBwYW5pYyhgVGhlIGNvbXBvbmVudCBcIiR7bmFtZX1cIiB3YXMgbmV2ZXIgcmVnaXN0ZXJlZGApO1xuICBDT01QT05FTlRTX0lNUExFTUVOVEFUSU9OX01BUC5kZWxldGUobmFtZSk7XG4gIGNzc01hbmFnZXIucmVtb3ZlKG5hbWUpO1xuICByZXR1cm4gQ09NUE9ORU5UU19JTVBMRU1FTlRBVElPTl9NQVA7XG59XG4vKipcbiAqIE1vdW50aW5nIGZ1bmN0aW9uIHRoYXQgd2lsbCB3b3JrIG9ubHkgZm9yIHRoZSBjb21wb25lbnRzIHRoYXQgd2VyZSBnbG9iYWxseSByZWdpc3RlcmVkXG4gKiBAcGFyYW0gICB7c3RyaW5nfEhUTUxFbGVtZW50fSBzZWxlY3RvciAtIHF1ZXJ5IGZvciB0aGUgc2VsZWN0aW9uIG9yIGEgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSAgIHtPYmplY3R9IGluaXRpYWxQcm9wcyAtIHRoZSBpbml0aWFsIGNvbXBvbmVudCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lIC0gb3B0aW9uYWwgY29tcG9uZW50IG5hbWVcbiAqIEByZXR1cm5zIHtBcnJheX0gbGlzdCBvZiByaW90IGNvbXBvbmVudHNcbiAqL1xuXG5mdW5jdGlvbiBtb3VudChzZWxlY3RvciwgaW5pdGlhbFByb3BzLCBuYW1lKSB7XG4gIHJldHVybiAkKHNlbGVjdG9yKS5tYXAoZWxlbWVudCA9PiBtb3VudENvbXBvbmVudChlbGVtZW50LCBpbml0aWFsUHJvcHMsIG5hbWUpKTtcbn1cbi8qKlxuICogU3dlZXQgdW5tb3VudGluZyBoZWxwZXIgZnVuY3Rpb24gZm9yIHRoZSBET00gbm9kZSBtb3VudGVkIG1hbnVhbGx5IGJ5IHRoZSB1c2VyXG4gKiBAcGFyYW0gICB7c3RyaW5nfEhUTUxFbGVtZW50fSBzZWxlY3RvciAtIHF1ZXJ5IGZvciB0aGUgc2VsZWN0aW9uIG9yIGEgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSAgIHtib29sZWFufG51bGx9IGtlZXBSb290RWxlbWVudCAtIGlmIHRydWUga2VlcCB0aGUgcm9vdCBlbGVtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl9IGxpc3Qgb2Ygbm9kZXMgdW5tb3VudGVkXG4gKi9cblxuZnVuY3Rpb24gdW5tb3VudChzZWxlY3Rvciwga2VlcFJvb3RFbGVtZW50KSB7XG4gIHJldHVybiAkKHNlbGVjdG9yKS5tYXAoZWxlbWVudCA9PiB7XG4gICAgaWYgKGVsZW1lbnRbRE9NX0NPTVBPTkVOVF9JTlNUQU5DRV9QUk9QRVJUWV0pIHtcbiAgICAgIGVsZW1lbnRbRE9NX0NPTVBPTkVOVF9JTlNUQU5DRV9QUk9QRVJUWV0udW5tb3VudChrZWVwUm9vdEVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9KTtcbn1cbi8qKlxuICogRGVmaW5lIGEgcmlvdCBwbHVnaW5cbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gcGx1Z2luIC0gZnVuY3Rpb24gdGhhdCB3aWxsIHJlY2VpdmUgYWxsIHRoZSBjb21wb25lbnRzIGNyZWF0ZWRcbiAqIEByZXR1cm5zIHtTZXR9IHRoZSBzZXQgY29udGFpbmluZyBhbGwgdGhlIHBsdWdpbnMgaW5zdGFsbGVkXG4gKi9cblxuZnVuY3Rpb24gaW5zdGFsbChwbHVnaW4pIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKHBsdWdpbikpIHBhbmljKCdQbHVnaW5zIG11c3QgYmUgb2YgdHlwZSBmdW5jdGlvbicpO1xuICBpZiAoUExVR0lOU19TRVQuaGFzKHBsdWdpbikpIHBhbmljKCdUaGlzIHBsdWdpbiB3YXMgYWxyZWFkeSBpbnN0YWxsZWQnKTtcbiAgUExVR0lOU19TRVQuYWRkKHBsdWdpbik7XG4gIHJldHVybiBQTFVHSU5TX1NFVDtcbn1cbi8qKlxuICogVW5pbnN0YWxsIGEgcmlvdCBwbHVnaW5cbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gcGx1Z2luIC0gcGx1Z2luIHByZXZpb3VzbHkgaW5zdGFsbGVkXG4gKiBAcmV0dXJucyB7U2V0fSB0aGUgc2V0IGNvbnRhaW5pbmcgYWxsIHRoZSBwbHVnaW5zIGluc3RhbGxlZFxuICovXG5cbmZ1bmN0aW9uIHVuaW5zdGFsbChwbHVnaW4pIHtcbiAgaWYgKCFQTFVHSU5TX1NFVC5oYXMocGx1Z2luKSkgcGFuaWMoJ1RoaXMgcGx1Z2luIHdhcyBuZXZlciBpbnN0YWxsZWQnKTtcbiAgUExVR0lOU19TRVQuZGVsZXRlKHBsdWdpbik7XG4gIHJldHVybiBQTFVHSU5TX1NFVDtcbn1cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBjcmVhdGUgY29tcG9uZW50IHdpdGhvdXQgcmVseWluZyBvbiB0aGUgcmVnaXN0ZXJlZCBvbmVzXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBpbXBsZW1lbnRhdGlvbiAtIGNvbXBvbmVudCBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybnMge0Z1bmN0aW9ufSBmdW5jdGlvbiB0aGF0IHdpbGwgYWxsb3cgeW91IHRvIG1vdW50IGEgcmlvdCBjb21wb25lbnQgb24gYSBET00gbm9kZVxuICovXG5cbmZ1bmN0aW9uIGNvbXBvbmVudChpbXBsZW1lbnRhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGVsLCBwcm9wcywgX3RlbXApIHtcbiAgICBsZXQge1xuICAgICAgc2xvdHMsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgcGFyZW50U2NvcGVcbiAgICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gICAgcmV0dXJuIGNvbXBvc2UoYyA9PiBjLm1vdW50KGVsLCBwYXJlbnRTY29wZSksIGMgPT4gYyh7XG4gICAgICBwcm9wcyxcbiAgICAgIHNsb3RzLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH0pLCBjcmVhdGVDb21wb25lbnQpKGltcGxlbWVudGF0aW9uKTtcbiAgfTtcbn1cbi8qKlxuICogTGlmdCBhIHJpb3QgY29tcG9uZW50IEludGVyZmFjZSBpbnRvIGEgcHVyZSByaW90IG9iamVjdFxuICogQHBhcmFtICAge0Z1bmN0aW9ufSBmdW5jIC0gUmlvdFB1cmVDb21wb25lbnQgZmFjdG9yeSBmdW5jdGlvblxuICogQHJldHVybnMge0Z1bmN0aW9ufSB0aGUgbGlmdGVkIG9yaWdpbmFsIGZ1bmN0aW9uIHJlY2VpdmVkIGFzIGFyZ3VtZW50XG4gKi9cblxuZnVuY3Rpb24gcHVyZShmdW5jKSB7XG4gIGlmICghaXNGdW5jdGlvbihmdW5jKSkgcGFuaWMoJ3Jpb3QucHVyZSBhY2NlcHRzIG9ubHkgYXJndW1lbnRzIG9mIHR5cGUgXCJmdW5jdGlvblwiJyk7XG4gIGZ1bmNbSVNfUFVSRV9TWU1CT0xdID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmM7XG59XG4vKiogQHR5cGUge3N0cmluZ30gY3VycmVudCByaW90IHZlcnNpb24gKi9cblxuY29uc3QgdmVyc2lvbiA9ICd2NS40LjUnOyAvLyBleHBvc2Ugc29tZSBpbnRlcm5hbCBzdHVmZiB0aGF0IG1pZ2h0IGJlIHVzZWQgZnJvbSBleHRlcm5hbCB0b29sc1xuXG5jb25zdCBfXyA9IHtcbiAgY3NzTWFuYWdlcixcbiAgRE9NQmluZGluZ3MsXG4gIGNyZWF0ZUNvbXBvbmVudCxcbiAgZGVmaW5lQ29tcG9uZW50LFxuICBnbG9iYWxzXG59O1xuXG5leHBvcnQgeyBfXywgY29tcG9uZW50LCBpbnN0YWxsLCBtb3VudCwgcHVyZSwgcmVnaXN0ZXIsIHVuaW5zdGFsbCwgdW5tb3VudCwgdW5yZWdpc3RlciwgdmVyc2lvbiB9O1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG4vLyBwcm90b3R5cGUgY2xhc3MgZm9yIGhhc2ggZnVuY3Rpb25zXG5mdW5jdGlvbiBIYXNoIChibG9ja1NpemUsIGZpbmFsU2l6ZSkge1xuICB0aGlzLl9ibG9jayA9IEJ1ZmZlci5hbGxvYyhibG9ja1NpemUpXG4gIHRoaXMuX2ZpbmFsU2l6ZSA9IGZpbmFsU2l6ZVxuICB0aGlzLl9ibG9ja1NpemUgPSBibG9ja1NpemVcbiAgdGhpcy5fbGVuID0gMFxufVxuXG5IYXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmMgPSBlbmMgfHwgJ3V0ZjgnXG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuYylcbiAgfVxuXG4gIHZhciBibG9jayA9IHRoaXMuX2Jsb2NrXG4gIHZhciBibG9ja1NpemUgPSB0aGlzLl9ibG9ja1NpemVcbiAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoXG4gIHZhciBhY2N1bSA9IHRoaXMuX2xlblxuXG4gIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGxlbmd0aDspIHtcbiAgICB2YXIgYXNzaWduZWQgPSBhY2N1bSAlIGJsb2NrU2l6ZVxuICAgIHZhciByZW1haW5kZXIgPSBNYXRoLm1pbihsZW5ndGggLSBvZmZzZXQsIGJsb2NrU2l6ZSAtIGFzc2lnbmVkKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1haW5kZXI7IGkrKykge1xuICAgICAgYmxvY2tbYXNzaWduZWQgKyBpXSA9IGRhdGFbb2Zmc2V0ICsgaV1cbiAgICB9XG5cbiAgICBhY2N1bSArPSByZW1haW5kZXJcbiAgICBvZmZzZXQgKz0gcmVtYWluZGVyXG5cbiAgICBpZiAoKGFjY3VtICUgYmxvY2tTaXplKSA9PT0gMCkge1xuICAgICAgdGhpcy5fdXBkYXRlKGJsb2NrKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2xlbiArPSBsZW5ndGhcbiAgcmV0dXJuIHRoaXNcbn1cblxuSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICB2YXIgcmVtID0gdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplXG5cbiAgdGhpcy5fYmxvY2tbcmVtXSA9IDB4ODBcblxuICAvLyB6ZXJvIChyZW0gKyAxKSB0cmFpbGluZyBiaXRzLCB3aGVyZSAocmVtICsgMSkgaXMgdGhlIHNtYWxsZXN0XG4gIC8vIG5vbi1uZWdhdGl2ZSBzb2x1dGlvbiB0byB0aGUgZXF1YXRpb24gKGxlbmd0aCArIDEgKyAocmVtICsgMSkpID09PSBmaW5hbFNpemUgbW9kIGJsb2NrU2l6ZVxuICB0aGlzLl9ibG9jay5maWxsKDAsIHJlbSArIDEpXG5cbiAgaWYgKHJlbSA+PSB0aGlzLl9maW5hbFNpemUpIHtcbiAgICB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spXG4gICAgdGhpcy5fYmxvY2suZmlsbCgwKVxuICB9XG5cbiAgdmFyIGJpdHMgPSB0aGlzLl9sZW4gKiA4XG5cbiAgLy8gdWludDMyXG4gIGlmIChiaXRzIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkJFKGJpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDQpXG5cbiAgLy8gdWludDY0XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxvd0JpdHMgPSAoYml0cyAmIDB4ZmZmZmZmZmYpID4+PiAwXG4gICAgdmFyIGhpZ2hCaXRzID0gKGJpdHMgLSBsb3dCaXRzKSAvIDB4MTAwMDAwMDAwXG5cbiAgICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkJFKGhpZ2hCaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA4KVxuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUobG93Qml0cywgdGhpcy5fYmxvY2tTaXplIC0gNClcbiAgfVxuXG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcbiAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoKClcblxuICByZXR1cm4gZW5jID8gaGFzaC50b1N0cmluZyhlbmMpIDogaGFzaFxufVxuXG5IYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ191cGRhdGUgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzcycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaFxuIiwiLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgSyA9IFtcbiAgMHg0MjhBMkY5OCwgMHg3MTM3NDQ5MSwgMHhCNUMwRkJDRiwgMHhFOUI1REJBNSxcbiAgMHgzOTU2QzI1QiwgMHg1OUYxMTFGMSwgMHg5MjNGODJBNCwgMHhBQjFDNUVENSxcbiAgMHhEODA3QUE5OCwgMHgxMjgzNUIwMSwgMHgyNDMxODVCRSwgMHg1NTBDN0RDMyxcbiAgMHg3MkJFNUQ3NCwgMHg4MERFQjFGRSwgMHg5QkRDMDZBNywgMHhDMTlCRjE3NCxcbiAgMHhFNDlCNjlDMSwgMHhFRkJFNDc4NiwgMHgwRkMxOURDNiwgMHgyNDBDQTFDQyxcbiAgMHgyREU5MkM2RiwgMHg0QTc0ODRBQSwgMHg1Q0IwQTlEQywgMHg3NkY5ODhEQSxcbiAgMHg5ODNFNTE1MiwgMHhBODMxQzY2RCwgMHhCMDAzMjdDOCwgMHhCRjU5N0ZDNyxcbiAgMHhDNkUwMEJGMywgMHhENUE3OTE0NywgMHgwNkNBNjM1MSwgMHgxNDI5Mjk2NyxcbiAgMHgyN0I3MEE4NSwgMHgyRTFCMjEzOCwgMHg0RDJDNkRGQywgMHg1MzM4MEQxMyxcbiAgMHg2NTBBNzM1NCwgMHg3NjZBMEFCQiwgMHg4MUMyQzkyRSwgMHg5MjcyMkM4NSxcbiAgMHhBMkJGRThBMSwgMHhBODFBNjY0QiwgMHhDMjRCOEI3MCwgMHhDNzZDNTFBMyxcbiAgMHhEMTkyRTgxOSwgMHhENjk5MDYyNCwgMHhGNDBFMzU4NSwgMHgxMDZBQTA3MCxcbiAgMHgxOUE0QzExNiwgMHgxRTM3NkMwOCwgMHgyNzQ4Nzc0QywgMHgzNEIwQkNCNSxcbiAgMHgzOTFDMENCMywgMHg0RUQ4QUE0QSwgMHg1QjlDQ0E0RiwgMHg2ODJFNkZGMyxcbiAgMHg3NDhGODJFRSwgMHg3OEE1NjM2RiwgMHg4NEM4NzgxNCwgMHg4Q0M3MDIwOCxcbiAgMHg5MEJFRkZGQSwgMHhBNDUwNkNFQiwgMHhCRUY5QTNGNywgMHhDNjcxNzhGMlxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg2NClcblxuZnVuY3Rpb24gU2hhMjU2ICgpIHtcbiAgdGhpcy5pbml0KClcblxuICB0aGlzLl93ID0gVyAvLyBuZXcgQXJyYXkoNjQpXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMjU2LCBIYXNoKVxuXG5TaGEyNTYucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDZhMDllNjY3XG4gIHRoaXMuX2IgPSAweGJiNjdhZTg1XG4gIHRoaXMuX2MgPSAweDNjNmVmMzcyXG4gIHRoaXMuX2QgPSAweGE1NGZmNTNhXG4gIHRoaXMuX2UgPSAweDUxMGU1MjdmXG4gIHRoaXMuX2YgPSAweDliMDU2ODhjXG4gIHRoaXMuX2cgPSAweDFmODNkOWFiXG4gIHRoaXMuX2ggPSAweDViZTBjZDE5XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gY2ggKHgsIHksIHopIHtcbiAgcmV0dXJuIHogXiAoeCAmICh5IF4geikpXG59XG5cbmZ1bmN0aW9uIG1haiAoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSB8ICh6ICYgKHggfCB5KSlcbn1cblxuZnVuY3Rpb24gc2lnbWEwICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gMiB8IHggPDwgMzApIF4gKHggPj4+IDEzIHwgeCA8PCAxOSkgXiAoeCA+Pj4gMjIgfCB4IDw8IDEwKVxufVxuXG5mdW5jdGlvbiBzaWdtYTEgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiA2IHwgeCA8PCAyNikgXiAoeCA+Pj4gMTEgfCB4IDw8IDIxKSBeICh4ID4+PiAyNSB8IHggPDwgNylcbn1cblxuZnVuY3Rpb24gZ2FtbWEwICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gNyB8IHggPDwgMjUpIF4gKHggPj4+IDE4IHwgeCA8PCAxNCkgXiAoeCA+Pj4gMylcbn1cblxuZnVuY3Rpb24gZ2FtbWExICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gMTcgfCB4IDw8IDE1KSBeICh4ID4+PiAxOSB8IHggPDwgMTMpIF4gKHggPj4+IDEwKVxufVxuXG5TaGEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcbiAgdmFyIGYgPSB0aGlzLl9mIHwgMFxuICB2YXIgZyA9IHRoaXMuX2cgfCAwXG4gIHZhciBoID0gdGhpcy5faCB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDY0OyArK2kpIFdbaV0gPSAoZ2FtbWExKFdbaSAtIDJdKSArIFdbaSAtIDddICsgZ2FtbWEwKFdbaSAtIDE1XSkgKyBXW2kgLSAxNl0pIHwgMFxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgNjQ7ICsraikge1xuICAgIHZhciBUMSA9IChoICsgc2lnbWExKGUpICsgY2goZSwgZiwgZykgKyBLW2pdICsgV1tqXSkgfCAwXG4gICAgdmFyIFQyID0gKHNpZ21hMChhKSArIG1haihhLCBiLCBjKSkgfCAwXG5cbiAgICBoID0gZ1xuICAgIGcgPSBmXG4gICAgZiA9IGVcbiAgICBlID0gKGQgKyBUMSkgfCAwXG4gICAgZCA9IGNcbiAgICBjID0gYlxuICAgIGIgPSBhXG4gICAgYSA9IChUMSArIFQyKSB8IDBcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbiAgdGhpcy5fZiA9IChmICsgdGhpcy5fZikgfCAwXG4gIHRoaXMuX2cgPSAoZyArIHRoaXMuX2cpIHwgMFxuICB0aGlzLl9oID0gKGggKyB0aGlzLl9oKSB8IDBcbn1cblxuU2hhMjU2LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMzIpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2gsIDI4KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjU2XG4iLCIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qIFVBUGFyc2VyLmpzIHYwLjcuMzJcbiAgIENvcHlyaWdodCDCqSAyMDEyLTIwMjEgRmFpc2FsIFNhbG1hbiA8ZkBmYWlzYWxtYW4uY29tPlxuICAgTUlUIExpY2Vuc2UgKi8vKlxuICAgRGV0ZWN0IEJyb3dzZXIsIEVuZ2luZSwgT1MsIENQVSwgYW5kIERldmljZSB0eXBlL21vZGVsIGZyb20gVXNlci1BZ2VudCBkYXRhLlxuICAgU3VwcG9ydHMgYnJvd3NlciAmIG5vZGUuanMgZW52aXJvbm1lbnQuIFxuICAgRGVtbyAgIDogaHR0cHM6Ly9mYWlzYWxtYW4uZ2l0aHViLmlvL3VhLXBhcnNlci1qc1xuICAgU291cmNlIDogaHR0cHM6Ly9naXRodWIuY29tL2ZhaXNhbG1hbi91YS1wYXJzZXItanMgKi9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4oZnVuY3Rpb24gKHdpbmRvdywgdW5kZWZpbmVkKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLy8vLy8vLy8vLy8vL1xuICAgIC8vIENvbnN0YW50c1xuICAgIC8vLy8vLy8vLy8vLy9cblxuXG4gICAgdmFyIExJQlZFUlNJT04gID0gJzAuNy4zMicsXG4gICAgICAgIEVNUFRZICAgICAgID0gJycsXG4gICAgICAgIFVOS05PV04gICAgID0gJz8nLFxuICAgICAgICBGVU5DX1RZUEUgICA9ICdmdW5jdGlvbicsXG4gICAgICAgIFVOREVGX1RZUEUgID0gJ3VuZGVmaW5lZCcsXG4gICAgICAgIE9CSl9UWVBFICAgID0gJ29iamVjdCcsXG4gICAgICAgIFNUUl9UWVBFICAgID0gJ3N0cmluZycsXG4gICAgICAgIE1BSk9SICAgICAgID0gJ21ham9yJyxcbiAgICAgICAgTU9ERUwgICAgICAgPSAnbW9kZWwnLFxuICAgICAgICBOQU1FICAgICAgICA9ICduYW1lJyxcbiAgICAgICAgVFlQRSAgICAgICAgPSAndHlwZScsXG4gICAgICAgIFZFTkRPUiAgICAgID0gJ3ZlbmRvcicsXG4gICAgICAgIFZFUlNJT04gICAgID0gJ3ZlcnNpb24nLFxuICAgICAgICBBUkNISVRFQ1RVUkU9ICdhcmNoaXRlY3R1cmUnLFxuICAgICAgICBDT05TT0xFICAgICA9ICdjb25zb2xlJyxcbiAgICAgICAgTU9CSUxFICAgICAgPSAnbW9iaWxlJyxcbiAgICAgICAgVEFCTEVUICAgICAgPSAndGFibGV0JyxcbiAgICAgICAgU01BUlRUViAgICAgPSAnc21hcnR0dicsXG4gICAgICAgIFdFQVJBQkxFICAgID0gJ3dlYXJhYmxlJyxcbiAgICAgICAgRU1CRURERUQgICAgPSAnZW1iZWRkZWQnLFxuICAgICAgICBVQV9NQVhfTEVOR1RIID0gMzUwO1xuXG4gICAgdmFyIEFNQVpPTiAgPSAnQW1hem9uJyxcbiAgICAgICAgQVBQTEUgICA9ICdBcHBsZScsXG4gICAgICAgIEFTVVMgICAgPSAnQVNVUycsXG4gICAgICAgIEJMQUNLQkVSUlkgPSAnQmxhY2tCZXJyeScsXG4gICAgICAgIEJST1dTRVIgPSAnQnJvd3NlcicsXG4gICAgICAgIENIUk9NRSAgPSAnQ2hyb21lJyxcbiAgICAgICAgRURHRSAgICA9ICdFZGdlJyxcbiAgICAgICAgRklSRUZPWCA9ICdGaXJlZm94JyxcbiAgICAgICAgR09PR0xFICA9ICdHb29nbGUnLFxuICAgICAgICBIVUFXRUkgID0gJ0h1YXdlaScsXG4gICAgICAgIExHICAgICAgPSAnTEcnLFxuICAgICAgICBNSUNST1NPRlQgPSAnTWljcm9zb2Z0JyxcbiAgICAgICAgTU9UT1JPTEEgID0gJ01vdG9yb2xhJyxcbiAgICAgICAgT1BFUkEgICA9ICdPcGVyYScsXG4gICAgICAgIFNBTVNVTkcgPSAnU2Ftc3VuZycsXG4gICAgICAgIFNIQVJQICAgPSAnU2hhcnAnLFxuICAgICAgICBTT05ZICAgID0gJ1NvbnknLFxuICAgICAgICBYSUFPTUkgID0gJ1hpYW9taScsXG4gICAgICAgIFpFQlJBICAgPSAnWmVicmEnLFxuICAgICAgICBGQUNFQk9PSyAgID0gJ0ZhY2Vib29rJztcblxuICAgIC8vLy8vLy8vLy8vXG4gICAgLy8gSGVscGVyXG4gICAgLy8vLy8vLy8vL1xuXG4gICAgdmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChyZWdleGVzLCBleHRlbnNpb25zKSB7XG4gICAgICAgICAgICB2YXIgbWVyZ2VkUmVnZXhlcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiByZWdleGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnNbaV0gJiYgZXh0ZW5zaW9uc1tpXS5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFJlZ2V4ZXNbaV0gPSBleHRlbnNpb25zW2ldLmNvbmNhdChyZWdleGVzW2ldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRSZWdleGVzW2ldID0gcmVnZXhlc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkUmVnZXhlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyaXplID0gZnVuY3Rpb24gKGFycikge1xuICAgICAgICAgICAgdmFyIGVudW1zID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZW51bXNbYXJyW2ldLnRvVXBwZXJDYXNlKCldID0gYXJyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVudW1zO1xuICAgICAgICB9LFxuICAgICAgICBoYXMgPSBmdW5jdGlvbiAoc3RyMSwgc3RyMikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBzdHIxID09PSBTVFJfVFlQRSA/IGxvd2VyaXplKHN0cjIpLmluZGV4T2YobG93ZXJpemUoc3RyMSkpICE9PSAtMSA6IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBsb3dlcml6ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFqb3JpemUgPSBmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZih2ZXJzaW9uKSA9PT0gU1RSX1RZUEUgPyB2ZXJzaW9uLnJlcGxhY2UoL1teXFxkXFwuXS9nLCBFTVBUWSkuc3BsaXQoJy4nKVswXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgdHJpbSA9IGZ1bmN0aW9uIChzdHIsIGxlbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihzdHIpID09PSBTVFJfVFlQRSkge1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eXFxzXFxzKi8sIEVNUFRZKS5yZXBsYWNlKC9cXHNcXHMqJC8sIEVNUFRZKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mKGxlbikgPT09IFVOREVGX1RZUEUgPyBzdHIgOiBzdHIuc3Vic3RyaW5nKDAsIFVBX01BWF9MRU5HVEgpO1xuICAgICAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBNYXAgaGVscGVyXG4gICAgLy8vLy8vLy8vLy8vLy9cblxuICAgIHZhciByZ3hNYXBwZXIgPSBmdW5jdGlvbiAodWEsIGFycmF5cykge1xuXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGosIGssIHAsIHEsIG1hdGNoZXMsIG1hdGNoO1xuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggYWxsIHJlZ2V4ZXMgbWFwc1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBhcnJheXMubGVuZ3RoICYmICFtYXRjaGVzKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVnZXggPSBhcnJheXNbaV0sICAgICAgIC8vIGV2ZW4gc2VxdWVuY2UgKDAsMiw0LC4uKVxuICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IGFycmF5c1tpICsgMV07ICAgLy8gb2RkIHNlcXVlbmNlICgxLDMsNSwuLilcbiAgICAgICAgICAgICAgICBqID0gayA9IDA7XG5cbiAgICAgICAgICAgICAgICAvLyB0cnkgbWF0Y2hpbmcgdWFzdHJpbmcgd2l0aCByZWdleGVzXG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCByZWdleC5sZW5ndGggJiYgIW1hdGNoZXMpIHtcblxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gcmVnZXhbaisrXS5leGVjKHVhKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoISFtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoZXNbKytrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gcHJvcHNbcF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZ2l2ZW4gcHJvcGVydHkgaXMgYWN0dWFsbHkgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHEgPT09IE9CSl9UWVBFICYmIHEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcVsxXSA9PSBGVU5DX1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ24gbW9kaWZpZWQgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gcVsxXS5jYWxsKHRoaXMsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzaWduIGdpdmVuIHZhbHVlLCBpZ25vcmUgcmVnZXggbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gcVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgd2hldGhlciBmdW5jdGlvbiBvciByZWdleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBxWzFdID09PSBGVU5DX1RZUEUgJiYgIShxWzFdLmV4ZWMgJiYgcVsxXS50ZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgZnVuY3Rpb24gKHVzdWFsbHkgc3RyaW5nIG1hcHBlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gbWF0Y2ggPyBxWzFdLmNhbGwodGhpcywgbWF0Y2gsIHFbMl0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzYW5pdGl6ZSBtYXRjaCB1c2luZyBnaXZlbiByZWdleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcVswXV0gPSBtYXRjaCA/IG1hdGNoLnJlcGxhY2UocVsxXSwgcVsyXSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gbWF0Y2ggPyBxWzNdLmNhbGwodGhpcywgbWF0Y2gucmVwbGFjZShxWzFdLCBxWzJdKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FdID0gbWF0Y2ggPyBtYXRjaCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0ck1hcHBlciA9IGZ1bmN0aW9uIChzdHIsIG1hcCkge1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIG1hcCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgdmFsdWUgaXMgYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hcFtpXSA9PT0gT0JKX1RZUEUgJiYgbWFwW2ldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXBbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXMobWFwW2ldW2pdLCBzdHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpID09PSBVTktOT1dOKSA/IHVuZGVmaW5lZCA6IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhcyhtYXBbaV0sIHN0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpID09PSBVTktOT1dOKSA/IHVuZGVmaW5lZCA6IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gU3RyaW5nIG1hcFxuICAgIC8vLy8vLy8vLy8vLy8vXG5cbiAgICAvLyBTYWZhcmkgPCAzLjBcbiAgICB2YXIgb2xkU2FmYXJpTWFwID0ge1xuICAgICAgICAgICAgJzEuMCcgICA6ICcvOCcsXG4gICAgICAgICAgICAnMS4yJyAgIDogJy8xJyxcbiAgICAgICAgICAgICcxLjMnICAgOiAnLzMnLFxuICAgICAgICAgICAgJzIuMCcgICA6ICcvNDEyJyxcbiAgICAgICAgICAgICcyLjAuMicgOiAnLzQxNicsXG4gICAgICAgICAgICAnMi4wLjMnIDogJy80MTcnLFxuICAgICAgICAgICAgJzIuMC40JyA6ICcvNDE5JyxcbiAgICAgICAgICAgICc/JyAgICAgOiAnLydcbiAgICAgICAgfSxcbiAgICAgICAgd2luZG93c1ZlcnNpb25NYXAgPSB7XG4gICAgICAgICAgICAnTUUnICAgICAgICA6ICc0LjkwJyxcbiAgICAgICAgICAgICdOVCAzLjExJyAgIDogJ05UMy41MScsXG4gICAgICAgICAgICAnTlQgNC4wJyAgICA6ICdOVDQuMCcsXG4gICAgICAgICAgICAnMjAwMCcgICAgICA6ICdOVCA1LjAnLFxuICAgICAgICAgICAgJ1hQJyAgICAgICAgOiBbJ05UIDUuMScsICdOVCA1LjInXSxcbiAgICAgICAgICAgICdWaXN0YScgICAgIDogJ05UIDYuMCcsXG4gICAgICAgICAgICAnNycgICAgICAgICA6ICdOVCA2LjEnLFxuICAgICAgICAgICAgJzgnICAgICAgICAgOiAnTlQgNi4yJyxcbiAgICAgICAgICAgICc4LjEnICAgICAgIDogJ05UIDYuMycsXG4gICAgICAgICAgICAnMTAnICAgICAgICA6IFsnTlQgNi40JywgJ05UIDEwLjAnXSxcbiAgICAgICAgICAgICdSVCcgICAgICAgIDogJ0FSTSdcbiAgICB9O1xuXG4gICAgLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBSZWdleCBtYXBcbiAgICAvLy8vLy8vLy8vLy8vXG5cbiAgICB2YXIgcmVnZXhlcyA9IHtcblxuICAgICAgICBicm93c2VyIDogW1tcblxuICAgICAgICAgICAgL1xcYig/OmNybW98Y3Jpb3MpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lIGZvciBBbmRyb2lkL2lPU1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnQ2hyb21lJ11dLCBbXG4gICAgICAgICAgICAvZWRnKD86ZXxpb3N8YSk/XFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBFZGdlXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdFZGdlJ11dLCBbXG5cbiAgICAgICAgICAgIC8vIFByZXN0byBiYXNlZFxuICAgICAgICAgICAgLyhvcGVyYSBtaW5pKVxcLyhbLVxcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSBNaW5pXG4gICAgICAgICAgICAvKG9wZXJhIFttb2JpbGV0YWJdezMsNn0pXFxiLit2ZXJzaW9uXFwvKFstXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAvLyBPcGVyYSBNb2JpL1RhYmxldFxuICAgICAgICAgICAgLyhvcGVyYSkoPzouK3ZlcnNpb25cXC98W1xcLyBdKykoW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmFcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgL29waW9zW1xcLyBdKyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSBtaW5pIG9uIGlwaG9uZSA+PSA4LjBcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgT1BFUkErJyBNaW5pJ11dLCBbXG4gICAgICAgICAgICAvXFxib3ByXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSBXZWJraXRcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgT1BFUkFdXSwgW1xuXG4gICAgICAgICAgICAvLyBNaXhlZFxuICAgICAgICAgICAgLyhraW5kbGUpXFwvKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLaW5kbGVcbiAgICAgICAgICAgIC8obHVuYXNjYXBlfG1heHRob258bmV0ZnJvbnR8amFzbWluZXxibGF6ZXIpW1xcLyBdPyhbXFx3XFwuXSopL2ksICAgICAgLy8gTHVuYXNjYXBlL01heHRob24vTmV0ZnJvbnQvSmFzbWluZS9CbGF6ZXJcbiAgICAgICAgICAgIC8vIFRyaWRlbnQgYmFzZWRcbiAgICAgICAgICAgIC8oYXZhbnQgfGllbW9iaWxlfHNsaW0pKD86YnJvd3Nlcik/W1xcLyBdPyhbXFx3XFwuXSopL2ksICAgICAgICAgICAgICAgLy8gQXZhbnQvSUVNb2JpbGUvU2xpbUJyb3dzZXJcbiAgICAgICAgICAgIC8oYmE/aWR1YnJvd3NlcilbXFwvIF0/KFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmFpZHUgQnJvd3NlclxuICAgICAgICAgICAgLyg/Om1zfFxcKCkoaWUpIChbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnRlcm5ldCBFeHBsb3JlclxuXG4gICAgICAgICAgICAvLyBXZWJraXQvS0hUTUwgYmFzZWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsb2NrL1JvY2tNZWx0L01pZG9yaS9FcGlwaGFueS9TaWxrL1NreWZpcmUvQm9sdC9Jcm9uL0lyaWRpdW0vUGhhbnRvbUpTL0Jvd3Nlci9RdXBaaWxsYS9GYWxrb25cbiAgICAgICAgICAgIC8oZmxvY2t8cm9ja21lbHR8bWlkb3JpfGVwaXBoYW55fHNpbGt8c2t5ZmlyZXxvdmlicm93c2VyfGJvbHR8aXJvbnx2aXZhbGRpfGlyaWRpdW18cGhhbnRvbWpzfGJvd3NlcnxxdWFya3xxdXB6aWxsYXxmYWxrb258cmVrb25xfHB1ZmZpbnxicmF2ZXx3aGFsZXxxcWJyb3dzZXJsaXRlfHFxfGR1Y2tkdWNrZ28pXFwvKFstXFx3XFwuXSspL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJla29ucS9QdWZmaW4vQnJhdmUvV2hhbGUvUVFCcm93c2VyTGl0ZS9RUSwgYWthIFNob3VRXG4gICAgICAgICAgICAvKHdlaWJvKV9fKFtcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2VpYm9cbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgLyg/OlxcYnVjPyA/YnJvd3NlcnwoPzpqdWMuKyl1Y3dlYilbXFwvIF0/KFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgLy8gVUNCcm93c2VyXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdVQycrQlJPV1NFUl1dLCBbXG4gICAgICAgICAgICAvbWljcm9tLitcXGJxYmNvcmVcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZUNoYXQgRGVza3RvcCBmb3IgV2luZG93cyBCdWlsdC1pbiBCcm93c2VyXG4gICAgICAgICAgICAvXFxicWJjb3JlXFwvKFtcXHdcXC5dKykuK21pY3JvbS9pXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdXZUNoYXQoV2luKSBEZXNrdG9wJ11dLCBbXG4gICAgICAgICAgICAvbWljcm9tZXNzZW5nZXJcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlQ2hhdFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnV2VDaGF0J11dLCBbXG4gICAgICAgICAgICAva29ucXVlcm9yXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtvbnF1ZXJvclxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnS29ucXVlcm9yJ11dLCBbXG4gICAgICAgICAgICAvdHJpZGVudC4rcnZbOiBdKFtcXHdcXC5dezEsOX0pXFxiLitsaWtlIGdlY2tvL2kgICAgICAgICAgICAgICAgICAgICAgIC8vIElFMTFcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0lFJ11dLCBbXG4gICAgICAgICAgICAveWFicm93c2VyXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFlhbmRleFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnWWFuZGV4J11dLCBbXG4gICAgICAgICAgICAvKGF2YXN0fGF2ZylcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF2YXN0L0FWRyBTZWN1cmUgQnJvd3NlclxuICAgICAgICAgICAgXSwgW1tOQU1FLCAvKC4rKS8sICckMSBTZWN1cmUgJytCUk9XU0VSXSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC9cXGJmb2N1c1xcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggRm9jdXNcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgRklSRUZPWCsnIEZvY3VzJ11dLCBbXG4gICAgICAgICAgICAvXFxib3B0XFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSBUb3VjaFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBPUEVSQSsnIFRvdWNoJ11dLCBbXG4gICAgICAgICAgICAvY29jX2NvY1xcdytcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb2MgQ29jIEJyb3dzZXJcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0NvYyBDb2MnXV0sIFtcbiAgICAgICAgICAgIC9kb2xmaW5cXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9scGhpblxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnRG9scGhpbiddXSwgW1xuICAgICAgICAgICAgL2NvYXN0XFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSBDb2FzdFxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCBPUEVSQSsnIENvYXN0J11dLCBbXG4gICAgICAgICAgICAvbWl1aWJyb3dzZXJcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1JVUkgQnJvd3NlclxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnTUlVSSAnK0JST1dTRVJdXSwgW1xuICAgICAgICAgICAgL2Z4aW9zXFwvKFstXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IGZvciBpT1NcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgRklSRUZPWF1dLCBbXG4gICAgICAgICAgICAvXFxicWlodXwocWk/aG8/bz98MzYwKWJyb3dzZXIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzNjBcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJzM2MCAnK0JST1dTRVJdXSwgW1xuICAgICAgICAgICAgLyhvY3VsdXN8c2Ftc3VuZ3xzYWlsZmlzaHxodWF3ZWkpYnJvd3NlclxcLyhbXFx3XFwuXSspL2lcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgLyguKykvLCAnJDEgJytCUk9XU0VSXSwgVkVSU0lPTl0sIFsgICAgICAgICAgICAgICAgICAgICAgLy8gT2N1bHVzL1NhbXN1bmcvU2FpbGZpc2gvSHVhd2VpIEJyb3dzZXJcbiAgICAgICAgICAgIC8oY29tb2RvX2RyYWdvbilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tb2RvIERyYWdvblxuICAgICAgICAgICAgXSwgW1tOQU1FLCAvXy9nLCAnICddLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgLyhlbGVjdHJvbilcXC8oW1xcd1xcLl0rKSBzYWZhcmkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbGVjdHJvbi1iYXNlZCBBcHBcbiAgICAgICAgICAgIC8odGVzbGEpKD86IHF0Y2FyYnJvd3NlcnxcXC8oMjBcXGRcXGRcXC5bLVxcd1xcLl0rKSkvaSwgICAgICAgICAgICAgICAgICAgLy8gVGVzbGFcbiAgICAgICAgICAgIC9tPyhxcWJyb3dzZXJ8YmFpZHVib3hhcHB8MjM0NUV4cGxvcmVyKVtcXC8gXT8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgLy8gUVFCcm93c2VyL0JhaWR1IEFwcC8yMzQ1IEJyb3dzZXJcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgLyhtZXRhc3IpW1xcLyBdPyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb3VHb3VCcm93c2VyXG4gICAgICAgICAgICAvKGxiYnJvd3NlcikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpZUJhbyBCcm93c2VyXG4gICAgICAgICAgICAvXFxbKGxpbmtlZGluKWFwcFxcXS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGlua2VkSW4gQXBwIGZvciBpT1MgJiBBbmRyb2lkXG4gICAgICAgICAgICBdLCBbTkFNRV0sIFtcblxuICAgICAgICAgICAgLy8gV2ViVmlld1xuICAgICAgICAgICAgLygoPzpmYmFuXFwvZmJpb3N8ZmJfaWFiXFwvZmI0YSkoPyEuK2ZiYXYpfDtmYmF2XFwvKFtcXHdcXC5dKyk7KS9pICAgICAgIC8vIEZhY2Vib29rIEFwcCBmb3IgaU9TICYgQW5kcm9pZFxuICAgICAgICAgICAgXSwgW1tOQU1FLCBGQUNFQk9PS10sIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvc2FmYXJpIChsaW5lKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpbmUgQXBwIGZvciBpT1NcbiAgICAgICAgICAgIC9cXGIobGluZSlcXC8oW1xcd1xcLl0rKVxcL2lhYi9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIEFwcCBmb3IgQW5kcm9pZFxuICAgICAgICAgICAgLyhjaHJvbWl1bXxpbnN0YWdyYW0pW1xcLyBdKFstXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWl1bS9JbnN0YWdyYW1cbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgL1xcYmdzYVxcLyhbXFx3XFwuXSspIC4qc2FmYXJpXFwvL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSBTZWFyY2ggQXBwbGlhbmNlIG9uIGlPU1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnR1NBJ11dLCBbXG5cbiAgICAgICAgICAgIC9oZWFkbGVzc2Nocm9tZSg/OlxcLyhbXFx3XFwuXSspfCApL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lIEhlYWRsZXNzXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIENIUk9NRSsnIEhlYWRsZXNzJ11dLCBbXG5cbiAgICAgICAgICAgIC8gd3ZcXCkuKyhjaHJvbWUpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9tZSBXZWJWaWV3XG4gICAgICAgICAgICBdLCBbW05BTUUsIENIUk9NRSsnIFdlYlZpZXcnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgL2Ryb2lkLisgdmVyc2lvblxcLyhbXFx3XFwuXSspXFxiLisoPzptb2JpbGUgc2FmYXJpfHNhZmFyaSkvaSAgICAgICAgICAgLy8gQW5kcm9pZCBCcm93c2VyXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdBbmRyb2lkICcrQlJPV1NFUl1dLCBbXG5cbiAgICAgICAgICAgIC8oY2hyb21lfG9tbml3ZWJ8YXJvcmF8W3RpemVub2thXXs1fSA/YnJvd3NlcilcXC92PyhbXFx3XFwuXSspL2kgICAgICAgLy8gQ2hyb21lL09tbmlXZWIvQXJvcmEvVGl6ZW4vTm9raWFcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvdmVyc2lvblxcLyhbXFx3XFwuXFwsXSspIC4qbW9iaWxlXFwvXFx3KyAoc2FmYXJpKS9pICAgICAgICAgICAgICAgICAgICAgIC8vIE1vYmlsZSBTYWZhcmlcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ01vYmlsZSBTYWZhcmknXV0sIFtcbiAgICAgICAgICAgIC92ZXJzaW9uXFwvKFtcXHcoXFwufFxcLCldKykgLioobW9iaWxlID9zYWZhcml8c2FmYXJpKS9pICAgICAgICAgICAgICAgIC8vIFNhZmFyaSAmIFNhZmFyaSBNb2JpbGVcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBOQU1FXSwgW1xuICAgICAgICAgICAgL3dlYmtpdC4rPyhtb2JpbGUgP3NhZmFyaXxzYWZhcmkpKFxcL1tcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPCAzLjBcbiAgICAgICAgICAgIF0sIFtOQU1FLCBbVkVSU0lPTiwgc3RyTWFwcGVyLCBvbGRTYWZhcmlNYXBdXSwgW1xuXG4gICAgICAgICAgICAvKHdlYmtpdHxraHRtbClcXC8oW1xcd1xcLl0rKS9pXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLy8gR2Vja28gYmFzZWRcbiAgICAgICAgICAgIC8obmF2aWdhdG9yfG5ldHNjYXBlXFxkPylcXC8oWy1cXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHNjYXBlXG4gICAgICAgICAgICBdLCBbW05BTUUsICdOZXRzY2FwZSddLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgL21vYmlsZSB2cjsgcnY6KFtcXHdcXC5dKylcXCkuK2ZpcmVmb3gvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IFJlYWxpdHlcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgRklSRUZPWCsnIFJlYWxpdHknXV0sIFtcbiAgICAgICAgICAgIC9la2lvaGYuKyhmbG93KVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmxvd1xuICAgICAgICAgICAgLyhzd2lmdGZveCkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTd2lmdGZveFxuICAgICAgICAgICAgLyhpY2VkcmFnb258aWNld2Vhc2VsfGNhbWlub3xjaGltZXJhfGZlbm5lY3xtYWVtbyBicm93c2VyfG1pbmltb3xjb25rZXJvcnxrbGFyKVtcXC8gXT8oW1xcd1xcLlxcK10rKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJY2VEcmFnb24vSWNld2Vhc2VsL0NhbWluby9DaGltZXJhL0Zlbm5lYy9NYWVtby9NaW5pbW8vQ29ua2Vyb3IvS2xhclxuICAgICAgICAgICAgLyhzZWFtb25rZXl8ay1tZWxlb258aWNlY2F0fGljZWFwZXxmaXJlYmlyZHxwaG9lbml4fHBhbGVtb29ufGJhc2lsaXNrfHdhdGVyZm94KVxcLyhbLVxcd1xcLl0rKSQvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveC9TZWFNb25rZXkvSy1NZWxlb24vSWNlQ2F0L0ljZUFwZS9GaXJlYmlyZC9QaG9lbml4XG4gICAgICAgICAgICAvKGZpcmVmb3gpXFwvKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyIEZpcmVmb3gtYmFzZWRcbiAgICAgICAgICAgIC8obW96aWxsYSlcXC8oW1xcd1xcLl0rKSAuK3J2XFw6LitnZWNrb1xcL1xcZCsvaSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW96aWxsYVxuXG4gICAgICAgICAgICAvLyBPdGhlclxuICAgICAgICAgICAgLyhwb2xhcmlzfGx5bnh8ZGlsbG98aWNhYnxkb3Jpc3xhbWF5YXx3M218bmV0c3VyZnxzbGVpcG5pcnxvYmlnb3xtb3NhaWN8KD86Z298aWNlfHVwKVtcXC4gXT9icm93c2VyKVstXFwvIF0/dj8oW1xcd1xcLl0rKS9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQb2xhcmlzL0x5bngvRGlsbG8vaUNhYi9Eb3Jpcy9BbWF5YS93M20vTmV0U3VyZi9TbGVpcG5pci9PYmlnby9Nb3NhaWMvR28vSUNFL1VQLkJyb3dzZXJcbiAgICAgICAgICAgIC8obGlua3MpIFxcKChbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGlua3NcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXVxuICAgICAgICBdLFxuXG4gICAgICAgIGNwdSA6IFtbXG5cbiAgICAgICAgICAgIC8oPzooYW1kfHgoPzooPzo4Nnw2NClbLV9dKT98d293fHdpbik2NClbO1xcKV0vaSAgICAgICAgICAgICAgICAgICAgIC8vIEFNRDY0ICh4NjQpXG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgJ2FtZDY0J11dLCBbXG5cbiAgICAgICAgICAgIC8oaWEzMig/PTspKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUEzMiAocXVpY2t0aW1lKVxuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsIGxvd2VyaXplXV0sIFtcblxuICAgICAgICAgICAgLygoPzppWzM0Nl18eCk4NilbO1xcKV0vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUEzMiAoeDg2KVxuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsICdpYTMyJ11dLCBbXG5cbiAgICAgICAgICAgIC9cXGIoYWFyY2g2NHxhcm0odj84ZT9sP3xfPzY0KSlcXGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFSTTY0XG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgJ2FybTY0J11dLCBbXG5cbiAgICAgICAgICAgIC9cXGIoYXJtKD86dls2N10pP2h0P24/W2ZsXXA/KVxcYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBUk1IRlxuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsICdhcm1oZiddXSwgW1xuXG4gICAgICAgICAgICAvLyBQb2NrZXRQQyBtaXN0YWtlbmx5IGlkZW50aWZpZWQgYXMgUG93ZXJQQ1xuICAgICAgICAgICAgL3dpbmRvd3MgKGNlfG1vYmlsZSk7IHBwYzsvaVxuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsICdhcm0nXV0sIFtcblxuICAgICAgICAgICAgLygoPzpwcGN8cG93ZXJwYykoPzo2NCk/KSg/OiBtYWN8O3xcXCkpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG93ZXJQQ1xuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsIC9vd2VyLywgRU1QVFksIGxvd2VyaXplXV0sIFtcblxuICAgICAgICAgICAgLyhzdW40XFx3KVs7XFwpXS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNQQVJDXG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgJ3NwYXJjJ11dLCBbXG5cbiAgICAgICAgICAgIC8oKD86YXZyMzJ8aWE2NCg/PTspKXw2OGsoPz1cXCkpfFxcYmFybSg/PXYoPzpbMS03XXxbNS03XTEpbD98O3xlYWJpKXwoPz1hdG1lbCApYXZyfCg/OmlyaXh8bWlwc3xzcGFyYykoPzo2NCk/XFxifHBhLXJpc2MpL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUE2NCwgNjhLLCBBUk0vNjQsIEFWUi8zMiwgSVJJWC82NCwgTUlQUy82NCwgU1BBUkMvNjQsIFBBLVJJU0NcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCBsb3dlcml6ZV1dXG4gICAgICAgIF0sXG5cbiAgICAgICAgZGV2aWNlIDogW1tcblxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIE1PQklMRVMgJiBUQUJMRVRTXG4gICAgICAgICAgICAvLyBPcmRlcmVkIGJ5IHBvcHVsYXJpdHlcbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgICAgLy8gU2Ftc3VuZ1xuICAgICAgICAgICAgL1xcYihzY2gtaVs4OV0wXFxkfHNody1tMzgwc3xzbS1bcHR4XVxcd3syLDR9fGd0LVtwbl1cXGR7Miw0fXxzZ2gtdDhbNTZdOXxuZXh1cyAxMCkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBTQU1TVU5HXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKCg/OnNbY2dwXWh8Z3R8c20pLVxcdyt8Z2FsYXh5IG5leHVzKS9pLFxuICAgICAgICAgICAgL3NhbXN1bmdbLSBdKFstXFx3XSspL2ksXG4gICAgICAgICAgICAvc2VjLShzZ2hcXHcrKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFNBTVNVTkddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gQXBwbGVcbiAgICAgICAgICAgIC9cXCgoaXAoPzpob25lfG9kKVtcXHcgXSopOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpUG9kL2lQaG9uZVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBBUFBMRV0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcKChpcGFkKTtbLVxcd1xcKSw7IF0rYXBwbGUvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpUGFkXG4gICAgICAgICAgICAvYXBwbGVjb3JlbWVkaWFcXC9bXFx3XFwuXSsgXFwoKGlwYWQpL2ksXG4gICAgICAgICAgICAvXFxiKGlwYWQpXFxkXFxkPyxcXGRcXGQ/WztcXF1dLitpb3MvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBBUFBMRV0sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvLyBIdWF3ZWlcbiAgICAgICAgICAgIC9cXGIoKD86YWdbcnNdWzIzXT98YmFoMj98c2h0P3xidHYpLWE/W2x3XVxcZHsyfSlcXGIoPyEuK2RcXC9zKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEhVQVdFSV0sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyg/Omh1YXdlaXxob25vcikoWy1cXHcgXSspWztcXCldL2ksXG4gICAgICAgICAgICAvXFxiKG5leHVzIDZwfFxcd3syLDR9ZT8tW2F0dV0/W2xuXVtcXGR4XVswMTIzNTljXVthZG5dPylcXGIoPyEuK2RcXC9zKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEhVQVdFSV0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBYaWFvbWlcbiAgICAgICAgICAgIC9cXGIocG9jb1tcXHcgXSspKD86IGJ1aXxcXCkpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWGlhb21pIFBPQ09cbiAgICAgICAgICAgIC9cXGI7IChcXHcrKSBidWlsZFxcL2htXFwxL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFhpYW9taSBIb25nbWkgJ251bWVyaWMnIG1vZGVsc1xuICAgICAgICAgICAgL1xcYihobVstXyBdP25vdGU/W18gXT8oPzpcXGRcXHcpPykgYnVpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBYaWFvbWkgSG9uZ21pXG4gICAgICAgICAgICAvXFxiKHJlZG1pW1xcLV8gXT8oPzpub3RlfGspP1tcXHdfIF0rKSg/OiBidWl8XFwpKS9pLCAgICAgICAgICAgICAgICAgICAvLyBYaWFvbWkgUmVkbWlcbiAgICAgICAgICAgIC9cXGIobWlbLV8gXT8oPzphXFxkfG9uZXxvbmVbXyBdcGx1c3xub3RlIGx0ZXxtYXh8Y2MpP1tfIF0/KD86XFxkP1xcdz8pW18gXT8oPzpwbHVzfHNlfGxpdGUpPykoPzogYnVpfFxcKSkvaSAvLyBYaWFvbWkgTWlcbiAgICAgICAgICAgIF0sIFtbTU9ERUwsIC9fL2csICcgJ10sIFtWRU5ET1IsIFhJQU9NSV0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcYihtaVstXyBdPyg/OnBhZCkoPzpbXFx3XyBdKykpKD86IGJ1aXxcXCkpL2kgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaSBQYWQgdGFibGV0c1xuICAgICAgICAgICAgXSxbW01PREVMLCAvXy9nLCAnICddLCBbVkVORE9SLCBYSUFPTUldLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgLy8gT1BQT1xuICAgICAgICAgICAgLzsgKFxcdyspIGJ1aS4rIG9wcG8vaSxcbiAgICAgICAgICAgIC9cXGIoY3BoWzEyXVxcZHszfXxwKD86YWZ8Y1thbF18ZFxcd3xlW2FyXSlbbXRdXFxkMHx4OTAwN3xhMTAxb3ApXFxiL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ09QUE8nXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIFZpdm9cbiAgICAgICAgICAgIC92aXZvIChcXHcrKSg/OiBidWl8XFwpKS9pLFxuICAgICAgICAgICAgL1xcYih2WzEyXVxcZHszfVxcdz9bYXRdKSg/OiBidWl8OykvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnVml2byddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gUmVhbG1lXG4gICAgICAgICAgICAvXFxiKHJteFsxMl1cXGR7M30pKD86IGJ1aXw7fFxcKSkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnUmVhbG1lJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBNb3Rvcm9sYVxuICAgICAgICAgICAgL1xcYihtaWxlc3RvbmV8ZHJvaWQoPzpbMi00eF18ICg/OmJpb25pY3x4Mnxwcm98cmF6cikpPzo/KCA0Zyk/KVxcYltcXHcgXStidWlsZFxcLy9pLFxuICAgICAgICAgICAgL1xcYm1vdCg/Om9yb2xhKT9bLSBdKFxcdyopL2ksXG4gICAgICAgICAgICAvKCg/Om1vdG9bXFx3XFwoXFwpIF0rfHh0XFxkezMsNH18bmV4dXMgNikoPz0gYnVpfFxcKSkpL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgTU9UT1JPTEFdLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9cXGIobXo2MFxcZHx4b29tWzIgXXswLDJ9KSBidWlsZFxcLy9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIE1PVE9ST0xBXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8vIExHXG4gICAgICAgICAgICAvKCg/PWxnKT9bdmxda1xcLT9cXGR7M30pIGJ1aXwgM1xcLlstXFx3OyBdezEwfWxnPy0oWzA2Y3Y5XXszLDR9KS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIExHXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvKGxtKD86LT9mMTAwW252XT98LVtcXHdcXC5dKykoPz0gYnVpfFxcKSl8bmV4dXMgWzQ1XSkvaSxcbiAgICAgICAgICAgIC9cXGJsZ1stZTtcXC8gXSsoKD8hYnJvd3NlcnxuZXRjYXN0fGFuZHJvaWQgdHYpXFx3KykvaSxcbiAgICAgICAgICAgIC9cXGJsZy0/KFtcXGRcXHddKykgYnVpL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgTEddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gTGVub3ZvXG4gICAgICAgICAgICAvKGlkZWF0YWJbLVxcdyBdKykvaSxcbiAgICAgICAgICAgIC9sZW5vdm8gPyhzWzU2XTAwMFstXFx3XSt8dGFiKD86W1xcdyBdKyl8eXRbLVxcZFxcd117Nn18dGJbLVxcZFxcd117Nn0pL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0xlbm92byddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgLy8gTm9raWFcbiAgICAgICAgICAgIC8oPzptYWVtb3xub2tpYSkuKihuOTAwfGx1bWlhIFxcZCspL2ksXG4gICAgICAgICAgICAvbm9raWFbLV8gXT8oWy1cXHdcXC5dKikvaVxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgL18vZywgJyAnXSwgW1ZFTkRPUiwgJ05va2lhJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBHb29nbGVcbiAgICAgICAgICAgIC8ocGl4ZWwgYylcXGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSBQaXhlbCBDXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEdPT0dMRV0sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL2Ryb2lkLis7IChwaXhlbFtcXGRheGwgXXswLDZ9KSg/OiBidWl8XFwpKS9pICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSBQaXhlbFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBHT09HTEVdLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gU29ueVxuICAgICAgICAgICAgL2Ryb2lkLisgKGE/XFxkWzAtMl17Mn1zb3xbYy1nXVxcZHs0fXxzb1stZ2xdXFx3K3x4cS1hXFx3WzQtN11bMTJdKSg/PSBidWl8XFwpLitjaHJvbWVcXC8oPyFbMS02XXswLDF9XFxkXFwuKSkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBTT05ZXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvc29ueSB0YWJsZXQgW3BzXS9pLFxuICAgICAgICAgICAgL1xcYig/OnNvbnkpP3NncFxcdysoPzogYnVpfFxcKSkvaVxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgJ1hwZXJpYSBUYWJsZXQnXSwgW1ZFTkRPUiwgU09OWV0sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvLyBPbmVQbHVzXG4gICAgICAgICAgICAvIChrYjIwMDV8aW4yMFsxMl01fGJlMjBbMTJdWzU5XSlcXGIvaSxcbiAgICAgICAgICAgIC8oPzpvbmUpPyg/OnBsdXMpPyAoYVxcZDBcXGRcXGQpKD86IGJ8XFwpKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdPbmVQbHVzJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBBbWF6b25cbiAgICAgICAgICAgIC8oYWxleGEpd2VibS9pLFxuICAgICAgICAgICAgLyhrZlthLXpdezJ9d2kpKCBidWl8XFwpKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2luZGxlIEZpcmUgd2l0aG91dCBTaWxrXG4gICAgICAgICAgICAvKGtmW2Etel0rKSggYnVpfFxcKSkuK3NpbGtcXC8vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2luZGxlIEZpcmUgSERcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgQU1BWk9OXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvKCg/OnNkfGtmKVswMzQ5aGlqb3JzdHV3XSspKCBidWl8XFwpKS4rc2lsa1xcLy9pICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZSBQaG9uZVxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgLyguKykvZywgJ0ZpcmUgUGhvbmUgJDEnXSwgW1ZFTkRPUiwgQU1BWk9OXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIEJsYWNrQmVycnlcbiAgICAgICAgICAgIC8ocGxheWJvb2spO1stXFx3XFwpLDsgXSsocmltKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFja0JlcnJ5IFBsYXlCb29rXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFZFTkRPUiwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKCg/OmJiW2EtZl18c3RbaHZdKTEwMC1cXGQpL2ksXG4gICAgICAgICAgICAvXFwoYmIxMDsgKFxcdyspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2tCZXJyeSAxMFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBCTEFDS0JFUlJZXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIEFzdXNcbiAgICAgICAgICAgIC8oPzpcXGJ8YXN1c18pKHRyYW5zZm9bcHJpbWUgXXs0LDEwfSBcXHcrfGVlZXBjfHNsaWRlciBcXHcrfG5leHVzIDd8cGFkZm9uZXxwMDBbY2pdKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEFTVVNdLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8gKHpbYmVzXTZbMDI3XVswMTJdW2ttXVtsc118emVuZm9uZSBcXGRcXHc/KVxcYi9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEFTVVNdLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLy8gSFRDXG4gICAgICAgICAgICAvKG5leHVzIDkpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhUQyBOZXh1cyA5XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdIVEMnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvKGh0YylbLTtfIF17MSwyfShbXFx3IF0rKD89XFwpfCBidWkpfFxcdyspL2ksICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhUQ1xuXG4gICAgICAgICAgICAvLyBaVEVcbiAgICAgICAgICAgIC8oenRlKVstIF0oW1xcdyBdKz8pKD86IGJ1aXxcXC98XFwpKS9pLFxuICAgICAgICAgICAgLyhhbGNhdGVsfGdlZWtzcGhvbmV8bmV4aWFufHBhbmFzb25pY3xzb255KD8hLWJyYSkpWy1fIF0/KFstXFx3XSopL2kgICAgICAgICAvLyBBbGNhdGVsL0dlZWtzUGhvbmUvTmV4aWFuL1BhbmFzb25pYy9Tb255XG4gICAgICAgICAgICBdLCBbVkVORE9SLCBbTU9ERUwsIC9fL2csICcgJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLyBBY2VyXG4gICAgICAgICAgICAvZHJvaWQuKzsgKFthYl1bMS03XS0/WzAxNzhhXVxcZFxcZD8pL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0FjZXInXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8vIE1laXp1XG4gICAgICAgICAgICAvZHJvaWQuKzsgKG1bMS01XSBub3RlKSBidWkvaSxcbiAgICAgICAgICAgIC9cXGJtei0oWy1cXHddezIsfSkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTWVpenUnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIFNoYXJwXG4gICAgICAgICAgICAvXFxiKHNoLT9bYWx0dnpdP1xcZFxcZFthLWVrbV0/KS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFNIQVJQXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8vIE1JWEVEXG4gICAgICAgICAgICAvKGJsYWNrYmVycnl8YmVucXxwYWxtKD89XFwtKXxzb255ZXJpY3Nzb258YWNlcnxhc3VzfGRlbGx8bWVpenV8bW90b3JvbGF8cG9seXRyb24pWy1fIF0/KFstXFx3XSopL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrQmVycnkvQmVuUS9QYWxtL1NvbnktRXJpY3Nzb24vQWNlci9Bc3VzL0RlbGwvTWVpenUvTW90b3JvbGEvUG9seXRyb25cbiAgICAgICAgICAgIC8oaHApIChbXFx3IF0rXFx3KS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIUCBpUEFRXG4gICAgICAgICAgICAvKGFzdXMpLT8oXFx3KykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3VzXG4gICAgICAgICAgICAvKG1pY3Jvc29mdCk7IChsdW1pYVtcXHcgXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaWNyb3NvZnQgTHVtaWFcbiAgICAgICAgICAgIC8obGVub3ZvKVstXyBdPyhbLVxcd10rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlbm92b1xuICAgICAgICAgICAgLyhqb2xsYSkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKb2xsYVxuICAgICAgICAgICAgLyhvcHBvKSA/KFtcXHcgXSspIGJ1aS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT1BQT1xuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvKGFyY2hvcykgKGdhbWVwYWQyPykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFyY2hvc1xuICAgICAgICAgICAgLyhocCkuKyh0b3VjaHBhZCg/IS4rdGFibGV0KXx0YWJsZXQpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIUCBUb3VjaFBhZFxuICAgICAgICAgICAgLyhraW5kbGUpXFwvKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLaW5kbGVcbiAgICAgICAgICAgIC8obm9vaylbXFx3IF0rYnVpbGRcXC8oXFx3KykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9va1xuICAgICAgICAgICAgLyhkZWxsKSAoc3RyZWFba3ByXFxkIF0qW1xcZGtvXSkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGwgU3RyZWFrXG4gICAgICAgICAgICAvKGxlWy0gXStwYW4pWy0gXSsoXFx3ezEsOX0pIGJ1aS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZSBQYW4gVGFibGV0c1xuICAgICAgICAgICAgLyh0cmluaXR5KVstIF0qKHRcXGR7M30pIGJ1aS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpbml0eSBUYWJsZXRzXG4gICAgICAgICAgICAvKGdpZ2FzZXQpWy0gXSsocVxcd3sxLDl9KSBidWkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHaWdhc2V0IFRhYmxldHNcbiAgICAgICAgICAgIC8odm9kYWZvbmUpIChbXFx3IF0rKSg/OlxcKXwgYnVpKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWb2RhZm9uZVxuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvKHN1cmZhY2UgZHVvKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cmZhY2UgRHVvXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIE1JQ1JPU09GVF0sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL2Ryb2lkIFtcXGRcXC5dKzsgKGZwXFxkdT8pKD86IGJ8XFwpKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFpcnBob25lXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdGYWlycGhvbmUnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvKHUzMDRhYSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFUJlRcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0FUJlQnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvXFxic2llLShcXHcqKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2llbWVuc1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnU2llbWVucyddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9cXGIocmN0XFx3KykgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSQ0EgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnUkNBJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYih2ZW51ZVtcXGQgXXsyLDd9KSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGwgVmVudWUgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnRGVsbCddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIocSg/Om12fHRhKVxcdyspIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWZXJpem9uIFRhYmxldFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnVmVyaXpvbiddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIoPzpiYXJuZXNbJiBdK25vYmxlIHxibltydF0pKFtcXHdcXCsgXSopIGIvaSAgICAgICAgICAgICAgICAgICAgICAgLy8gQmFybmVzICYgTm9ibGUgVGFibGV0XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdCYXJuZXMgJiBOb2JsZSddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIodG1cXGR7M31cXHcrKSBiL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ051VmlzaW9uJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYihrODgpIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWlRFIEsgU2VyaWVzIFRhYmxldFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnWlRFJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYihueFxcZHszfWopIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFpURSBOdWJpYVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnWlRFJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcYihnZW5cXGR7M30pIGIuKzQ5aC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3aXNzIEdFTiBNb2JpbGVcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1N3aXNzJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcYih6dXJcXGR7M30pIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3aXNzIFpVUiBUYWJsZXRcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1N3aXNzJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL1xcYigoemVraSk/dGIuKlxcYikgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFpla2kgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnWmVraSddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIoW3lyXVxcZHsyfSkgYi9pLFxuICAgICAgICAgICAgL1xcYihkcmFnb25bLSBdK3RvdWNoIHxkdCkoXFx3ezV9KSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERyYWdvbiBUb3VjaCBUYWJsZXRcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnRHJhZ29uIFRvdWNoJ10sIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIobnMtP1xcd3swLDl9KSBiL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnNpZ25pYSBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdJbnNpZ25pYSddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIoKG54YXxuZXh0KS0/XFx3ezAsOX0pIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXh0Qm9vayBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdOZXh0Qm9vayddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9cXGIoeHRyZW1lXFxfKT8odigxWzA0NV18MlswMTVdfFszNDY5XTB8N1swNV0pKSBiL2kgICAgICAgICAgICAgICAgICAvLyBWb2ljZSBYdHJlbWUgUGhvbmVzXG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ1ZvaWNlJ10sIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9cXGIobHZ0ZWxcXC0pPyh2MVsxMl0pIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMdlRlbCBQaG9uZXNcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnTHZUZWwnXSwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL1xcYihwaC0xKSAvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXNzZW50aWFsIFBILTFcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0Vzc2VudGlhbCddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9cXGIodigxMDBtZHw3MDBuYXw3MDExfDkxN2cpLipcXGIpIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnZpemVuIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0Vudml6ZW4nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKHRyaW9bLVxcd1xcLiBdKykgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hY2hTcGVlZCBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdNYWNoU3BlZWQnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxidHVfKDE0OTEpIGIvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3RvciBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdSb3RvciddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8oc2hpZWxkW1xcdyBdKykgYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE52aWRpYSBTaGllbGQgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTnZpZGlhJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgLyhzcHJpbnQpIChcXHcrKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ByaW50IFBob25lc1xuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgLyhraW5cXC5bb25ldHddezN9KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWljcm9zb2Z0IEtpblxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgL1xcLi9nLCAnICddLCBbVkVORE9SLCBNSUNST1NPRlRdLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9kcm9pZC4rOyAoY2M2NjY2P3xldDVbMTZdfG1jWzIzOV1bMjNdeD98dmM4WzAzXXg/KVxcKS9pICAgICAgICAgICAgIC8vIFplYnJhXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFpFQlJBXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvZHJvaWQuKzsgKGVjMzB8cHMyMHx0Y1syLThdXFxkW2t4XSlcXCkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBaRUJSQV0sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBDT05TT0xFU1xuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAvKG91eWEpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE91eWFcbiAgICAgICAgICAgIC8obmludGVuZG8pIChbd2lkczN1dGNoXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmludGVuZG9cbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgQ09OU09MRV1dLCBbXG4gICAgICAgICAgICAvZHJvaWQuKzsgKHNoaWVsZCkgYnVpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE52aWRpYVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTnZpZGlhJ10sIFtUWVBFLCBDT05TT0xFXV0sIFtcbiAgICAgICAgICAgIC8ocGxheXN0YXRpb24gWzM0NXBvcnRhYmxldmldKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxheXN0YXRpb25cbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgU09OWV0sIFtUWVBFLCBDT05TT0xFXV0sIFtcbiAgICAgICAgICAgIC9cXGIoeGJveCg/OiBvbmUpPyg/ITsgeGJveCkpW1xcKTsgXS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaWNyb3NvZnQgWGJveFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBNSUNST1NPRlRdLCBbVFlQRSwgQ09OU09MRV1dLCBbXG5cbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIFNNQVJUVFZTXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICAgIC9zbWFydC10di4rKHNhbXN1bmcpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2Ftc3VuZ1xuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuICAgICAgICAgICAgL2hiYnR2LittYXBsZTsoXFxkKykvaVxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgL14vLCAnU21hcnRUViddLCBbVkVORE9SLCBTQU1TVU5HXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuICAgICAgICAgICAgLyhudXg7IG5ldGNhc3QuK3NtYXJ0dHZ8bGcgKG5ldGNhc3RcXC50di0yMDFcXGR8YW5kcm9pZCB0dikpL2kgICAgICAgIC8vIExHIFNtYXJ0VFZcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCBMR10sIFtUWVBFLCBTTUFSVFRWXV0sIFtcbiAgICAgICAgICAgIC8oYXBwbGUpID90di9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbGUgVFZcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIFtNT0RFTCwgQVBQTEUrJyBUViddLCBbVFlQRSwgU01BUlRUVl1dLCBbXG4gICAgICAgICAgICAvY3JrZXkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSBDaHJvbWVjYXN0XG4gICAgICAgICAgICBdLCBbW01PREVMLCBDSFJPTUUrJ2Nhc3QnXSwgW1ZFTkRPUiwgR09PR0xFXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuICAgICAgICAgICAgL2Ryb2lkLithZnQoXFx3KSggYnVpfFxcKSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgVFZcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgQU1BWk9OXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuICAgICAgICAgICAgL1xcKGR0dltcXCk7XS4rKGFxdW9zKS9pLFxuICAgICAgICAgICAgLyhhcXVvcy10dltcXHcgXSspXFwpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYXJwXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFNIQVJQXSwgW1RZUEUsIFNNQVJUVFZdXSxbXG4gICAgICAgICAgICAvKGJyYXZpYVtcXHcgXSspKCBidWl8XFwpKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbnlcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgU09OWV0sIFtUWVBFLCBTTUFSVFRWXV0sIFtcbiAgICAgICAgICAgIC8obWl0di1cXHd7NX0pIGJ1aS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFhpYW9taVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCBYSUFPTUldLCBbVFlQRSwgU01BUlRUVl1dLCBbXG4gICAgICAgICAgICAvXFxiKHJva3UpW1xcZHhdKltcXClcXC9dKCg/OmR2cC0pP1tcXGRcXC5dKikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJva3VcbiAgICAgICAgICAgIC9oYmJ0dlxcL1xcZCtcXC5cXGQrXFwuXFxkKyArXFwoW1xcdyBdKjsgKihcXHdbXjtdKik7KFteO10qKS9pICAgICAgICAgICAgICAgLy8gSGJiVFYgZGV2aWNlc1xuICAgICAgICAgICAgXSwgW1tWRU5ET1IsIHRyaW1dLCBbTU9ERUwsIHRyaW1dLCBbVFlQRSwgU01BUlRUVl1dLCBbXG4gICAgICAgICAgICAvXFxiKGFuZHJvaWQgdHZ8c21hcnRbLSBdP3R2fG9wZXJhIHR2fHR2OyBydjopXFxiL2kgICAgICAgICAgICAgICAgICAgLy8gU21hcnRUViBmcm9tIFVuaWRlbnRpZmllZCBWZW5kb3JzXG4gICAgICAgICAgICBdLCBbW1RZUEUsIFNNQVJUVFZdXSwgW1xuXG4gICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAvLyBXRUFSQUJMRVNcbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgICAgLygocGViYmxlKSlhcHAvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQZWJibGVcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgV0VBUkFCTEVdXSwgW1xuICAgICAgICAgICAgL2Ryb2lkLis7IChnbGFzcykgXFxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29vZ2xlIEdsYXNzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEdPT0dMRV0sIFtUWVBFLCBXRUFSQUJMRV1dLCBbXG4gICAgICAgICAgICAvZHJvaWQuKzsgKHd0NjM/MHsyLDN9KVxcKS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIFpFQlJBXSwgW1RZUEUsIFdFQVJBQkxFXV0sIFtcbiAgICAgICAgICAgIC8ocXVlc3QoIDIpPykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2N1bHVzIFF1ZXN0XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsIEZBQ0VCT09LXSwgW1RZUEUsIFdFQVJBQkxFXV0sIFtcblxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgLy8gRU1CRURERURcbiAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgICAgLyh0ZXNsYSkoPzogcXRjYXJicm93c2VyfFxcL1stXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUZXNsYVxuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgW1RZUEUsIEVNQkVEREVEXV0sIFtcblxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIE1JWEVEIChHRU5FUklDKVxuICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAvZHJvaWQgLis/OyAoW147XSs/KSg/OiBidWl8XFwpIGFwcGxldykuKz8gbW9iaWxlIHNhZmFyaS9pICAgICAgICAgICAvLyBBbmRyb2lkIFBob25lcyBmcm9tIFVuaWRlbnRpZmllZCBWZW5kb3JzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgL2Ryb2lkIC4rPzsgKFteO10rPykoPzogYnVpfFxcKSBhcHBsZXcpLis/KD8hIG1vYmlsZSkgc2FmYXJpL2kgICAgICAgLy8gQW5kcm9pZCBUYWJsZXRzIGZyb20gVW5pZGVudGlmaWVkIFZlbmRvcnNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvXFxiKCh0YWJsZXR8dGFiKVs7XFwvXXxmb2N1c1xcL1xcZCg/IS4rbW9iaWxlKSkvaSAgICAgICAgICAgICAgICAgICAgICAvLyBVbmlkZW50aWZpYWJsZSBUYWJsZXRcbiAgICAgICAgICAgIF0sIFtbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8ocGhvbmV8bW9iaWxlKD86WztcXC9dfCBbIFxcd1xcL1xcLl0qc2FmYXJpKXxwZGEoPz0uK3dpbmRvd3MgY2UpKS9pICAgIC8vIFVuaWRlbnRpZmlhYmxlIE1vYmlsZVxuICAgICAgICAgICAgXSwgW1tUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgLyhhbmRyb2lkWy1cXHdcXC4gXXswLDl9KTsuK2J1aWwvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyaWMgQW5kcm9pZCBEZXZpY2VcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0dlbmVyaWMnXV1cbiAgICAgICAgXSxcblxuICAgICAgICBlbmdpbmUgOiBbW1xuXG4gICAgICAgICAgICAvd2luZG93cy4rIGVkZ2VcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWRnZUhUTUxcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgRURHRSsnSFRNTCddXSwgW1xuXG4gICAgICAgICAgICAvd2Via2l0XFwvNTM3XFwuMzYuK2Nocm9tZVxcLyg/ITI3KShbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxpbmtcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0JsaW5rJ11dLCBbXG5cbiAgICAgICAgICAgIC8ocHJlc3RvKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlc3RvXG4gICAgICAgICAgICAvKHdlYmtpdHx0cmlkZW50fG5ldGZyb250fG5ldHN1cmZ8YW1heWF8bHlueHx3M218Z29hbm5hKVxcLyhbXFx3XFwuXSspL2ksIC8vIFdlYktpdC9UcmlkZW50L05ldEZyb250L05ldFN1cmYvQW1heWEvTHlueC93M20vR29hbm5hXG4gICAgICAgICAgICAvZWtpb2goZmxvdylcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsb3dcbiAgICAgICAgICAgIC8oa2h0bWx8dGFzbWFufGxpbmtzKVtcXC8gXVxcKD8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtIVE1ML1Rhc21hbi9MaW5rc1xuICAgICAgICAgICAgLyhpY2FiKVtcXC8gXShbMjNdXFwuW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaUNhYlxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC9ydlxcOihbXFx3XFwuXXsxLDl9KVxcYi4rKGdlY2tvKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlY2tvXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgTkFNRV1cbiAgICAgICAgXSxcblxuICAgICAgICBvcyA6IFtbXG5cbiAgICAgICAgICAgIC8vIFdpbmRvd3NcbiAgICAgICAgICAgIC9taWNyb3NvZnQgKHdpbmRvd3MpICh2aXN0YXx4cCkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2luZG93cyAoaVR1bmVzKVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvKHdpbmRvd3MpIG50IDZcXC4yOyAoYXJtKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaW5kb3dzIFJUXG4gICAgICAgICAgICAvKHdpbmRvd3MgKD86cGhvbmUoPzogb3MpP3xtb2JpbGUpKVtcXC8gXT8oW1xcZFxcLlxcdyBdKikvaSwgICAgICAgICAgICAvLyBXaW5kb3dzIFBob25lXG4gICAgICAgICAgICAvKHdpbmRvd3MpW1xcLyBdPyhbbnRjZVxcZFxcLiBdK1xcdykoPyEuK3hib3gpL2lcbiAgICAgICAgICAgIF0sIFtOQU1FLCBbVkVSU0lPTiwgc3RyTWFwcGVyLCB3aW5kb3dzVmVyc2lvbk1hcF1dLCBbXG4gICAgICAgICAgICAvKHdpbig/PTN8OXxuKXx3aW4gOXggKShbbnRcXGRcXC5dKykvaVxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnV2luZG93cyddLCBbVkVSU0lPTiwgc3RyTWFwcGVyLCB3aW5kb3dzVmVyc2lvbk1hcF1dLCBbXG5cbiAgICAgICAgICAgIC8vIGlPUy9tYWNPU1xuICAgICAgICAgICAgL2lwW2hvbmVhZF17Miw0fVxcYig/Oi4qb3MgKFtcXHddKykgbGlrZSBtYWN8OyBvcGVyYSkvaSwgICAgICAgICAgICAgIC8vIGlPU1xuICAgICAgICAgICAgL2NmbmV0d29ya1xcLy4rZGFyd2luL2lcbiAgICAgICAgICAgIF0sIFtbVkVSU0lPTiwgL18vZywgJy4nXSwgW05BTUUsICdpT1MnXV0sIFtcbiAgICAgICAgICAgIC8obWFjIG9zIHgpID8oW1xcd1xcLiBdKikvaSxcbiAgICAgICAgICAgIC8obWFjaW50b3NofG1hY19wb3dlcnBjXFxiKSg/IS4raGFpa3UpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hYyBPU1xuICAgICAgICAgICAgXSwgW1tOQU1FLCAnTWFjIE9TJ10sIFtWRVJTSU9OLCAvXy9nLCAnLiddXSwgW1xuXG4gICAgICAgICAgICAvLyBNb2JpbGUgT1Nlc1xuICAgICAgICAgICAgL2Ryb2lkIChbXFx3XFwuXSspXFxiLisoYW5kcm9pZFstIF14ODZ8aGFybW9ueW9zKS9pICAgICAgICAgICAgICAgICAgICAvLyBBbmRyb2lkLXg4Ni9IYXJtb255T1NcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBOQU1FXSwgWyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW5kcm9pZC9XZWJPUy9RTlgvQmFkYS9SSU0vTWFlbW8vTWVlR28vU2FpbGZpc2ggT1NcbiAgICAgICAgICAgIC8oYW5kcm9pZHx3ZWJvc3xxbnh8YmFkYXxyaW0gdGFibGV0IG9zfG1hZW1vfG1lZWdvfHNhaWxmaXNoKVstXFwvIF0/KFtcXHdcXC5dKikvaSxcbiAgICAgICAgICAgIC8oYmxhY2tiZXJyeSlcXHcqXFwvKFtcXHdcXC5dKikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrYmVycnlcbiAgICAgICAgICAgIC8odGl6ZW58a2Fpb3MpW1xcLyBdKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGl6ZW4vS2FpT1NcbiAgICAgICAgICAgIC9cXCgoc2VyaWVzNDApOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlcmllcyA0MFxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvXFwoYmIoMTApOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGFja0JlcnJ5IDEwXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIEJMQUNLQkVSUlldXSwgW1xuICAgICAgICAgICAgLyg/OnN5bWJpYW4gP29zfHN5bWJvc3xzNjAoPz07KXxzZXJpZXM2MClbLVxcLyBdPyhbXFx3XFwuXSopL2kgICAgICAgICAvLyBTeW1iaWFuXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdTeW1iaWFuJ11dLCBbXG4gICAgICAgICAgICAvbW96aWxsYVxcL1tcXGRcXC5dKyBcXCgoPzptb2JpbGV8dGFibGV0fHR2fG1vYmlsZTsgW1xcdyBdKyk7IHJ2Oi4rIGdlY2tvXFwvKFtcXHdcXC5dKykvaSAvLyBGaXJlZm94IE9TXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsIEZJUkVGT1grJyBPUyddXSwgW1xuICAgICAgICAgICAgL3dlYjBzOy4rcnQodHYpL2ksXG4gICAgICAgICAgICAvXFxiKD86aHApP3dvcyg/OmJyb3dzZXIpP1xcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZWJPU1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnd2ViT1MnXV0sIFtcblxuICAgICAgICAgICAgLy8gR29vZ2xlIENocm9tZWNhc3RcbiAgICAgICAgICAgIC9jcmtleVxcLyhbXFxkXFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29vZ2xlIENocm9tZWNhc3RcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgQ0hST01FKydjYXN0J11dLCBbXG4gICAgICAgICAgICAvKGNyb3MpIFtcXHddKyAoW1xcd1xcLl0rXFx3KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWl1bSBPU1xuICAgICAgICAgICAgXSwgW1tOQU1FLCAnQ2hyb21pdW0gT1MnXSwgVkVSU0lPTl0sW1xuXG4gICAgICAgICAgICAvLyBDb25zb2xlXG4gICAgICAgICAgICAvKG5pbnRlbmRvfHBsYXlzdGF0aW9uKSAoW3dpZHMzNDVwb3J0YWJsZXZ1Y2hdKykvaSwgICAgICAgICAgICAgICAgIC8vIE5pbnRlbmRvL1BsYXlzdGF0aW9uXG4gICAgICAgICAgICAvKHhib3gpOyAreGJveCAoW15cXCk7XSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaWNyb3NvZnQgWGJveCAoMzYwLCBPbmUsIFgsIFMsIFNlcmllcyBYLCBTZXJpZXMgUylcblxuICAgICAgICAgICAgLy8gT3RoZXJcbiAgICAgICAgICAgIC9cXGIoam9saXxwYWxtKVxcYiA/KD86b3MpP1xcLz8oW1xcd1xcLl0qKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKb2xpL1BhbG1cbiAgICAgICAgICAgIC8obWludClbXFwvXFwoXFwpIF0/KFxcdyopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pbnRcbiAgICAgICAgICAgIC8obWFnZWlhfHZlY3RvcmxpbnV4KVs7IF0vaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFnZWlhL1ZlY3RvckxpbnV4XG4gICAgICAgICAgICAvKFtreGxuXT91YnVudHV8ZGViaWFufHN1c2V8b3BlbnN1c2V8Z2VudG9vfGFyY2goPz0gbGludXgpfHNsYWNrd2FyZXxmZWRvcmF8bWFuZHJpdmF8Y2VudG9zfHBjbGludXhvc3xyZWQgP2hhdHx6ZW53YWxrfGxpbnB1c3xyYXNwYmlhbnxwbGFuIDl8bWluaXh8cmlzYyBvc3xjb250aWtpfGRlZXBpbnxtYW5qYXJvfGVsZW1lbnRhcnkgb3N8c2FiYXlvbnxsaW5zcGlyZSkoPzogZ251XFwvbGludXgpPyg/OiBlbnRlcnByaXNlKT8oPzpbLSBdbGludXgpPyg/Oi1nbnUpP1stXFwvIF0/KD8hY2hyb218cGFja2FnZSkoWy1cXHdcXC5dKikvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVWJ1bnR1L0RlYmlhbi9TVVNFL0dlbnRvby9BcmNoL1NsYWNrd2FyZS9GZWRvcmEvTWFuZHJpdmEvQ2VudE9TL1BDTGludXhPUy9SZWRIYXQvWmVud2Fsay9MaW5wdXMvUmFzcGJpYW4vUGxhbjkvTWluaXgvUklTQ09TL0NvbnRpa2kvRGVlcGluL01hbmphcm8vZWxlbWVudGFyeS9TYWJheW9uL0xpbnNwaXJlXG4gICAgICAgICAgICAvKGh1cmR8bGludXgpID8oW1xcd1xcLl0qKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSHVyZC9MaW51eFxuICAgICAgICAgICAgLyhnbnUpID8oW1xcd1xcLl0qKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdOVVxuICAgICAgICAgICAgL1xcYihbLWZyZW50b3BjZ2hzXXswLDV9YnNkfGRyYWdvbmZseSlbXFwvIF0/KD8hYW1kfFtpeDM0Nl17MSwyfTg2KShbXFx3XFwuXSopL2ksIC8vIEZyZWVCU0QvTmV0QlNEL09wZW5CU0QvUEMtQlNEL0dob3N0QlNEL0RyYWdvbkZseVxuICAgICAgICAgICAgLyhoYWlrdSkgKFxcdyspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFpa3VcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgLyhzdW5vcykgPyhbXFx3XFwuXFxkXSopL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb2xhcmlzXG4gICAgICAgICAgICBdLCBbW05BTUUsICdTb2xhcmlzJ10sIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvKCg/Om9wZW4pP3NvbGFyaXMpWy1cXC8gXT8oW1xcd1xcLl0qKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbGFyaXNcbiAgICAgICAgICAgIC8oYWl4KSAoKFxcZCkoPz1cXC58XFwpfCApW1xcd1xcLl0pKi9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBSVhcbiAgICAgICAgICAgIC9cXGIoYmVvc3xvc1xcLzJ8YW1pZ2Fvc3xtb3JwaG9zfG9wZW52bXN8ZnVjaHNpYXxocC11eCkvaSwgICAgICAgICAgICAvLyBCZU9TL09TMi9BbWlnYU9TL01vcnBoT1MvT3BlblZNUy9GdWNoc2lhL0hQLVVYXG4gICAgICAgICAgICAvKHVuaXgpID8oW1xcd1xcLl0qKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVU5JWFxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dXG4gICAgICAgIF1cbiAgICB9O1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBDb25zdHJ1Y3RvclxuICAgIC8vLy8vLy8vLy8vLy8vLy9cblxuICAgIHZhciBVQVBhcnNlciA9IGZ1bmN0aW9uICh1YSwgZXh0ZW5zaW9ucykge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdWEgPT09IE9CSl9UWVBFKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zID0gdWE7XG4gICAgICAgICAgICB1YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVQVBhcnNlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVUFQYXJzZXIodWEsIGV4dGVuc2lvbnMpLmdldFJlc3VsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF91YSA9IHVhIHx8ICgodHlwZW9mIHdpbmRvdyAhPT0gVU5ERUZfVFlQRSAmJiB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSA/IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IDogRU1QVFkpO1xuICAgICAgICB2YXIgX3JneG1hcCA9IGV4dGVuc2lvbnMgPyBleHRlbmQocmVnZXhlcywgZXh0ZW5zaW9ucykgOiByZWdleGVzO1xuXG4gICAgICAgIHRoaXMuZ2V0QnJvd3NlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYnJvd3NlciA9IHt9O1xuICAgICAgICAgICAgX2Jyb3dzZXJbTkFNRV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBfYnJvd3NlcltWRVJTSU9OXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJneE1hcHBlci5jYWxsKF9icm93c2VyLCBfdWEsIF9yZ3htYXAuYnJvd3Nlcik7XG4gICAgICAgICAgICBfYnJvd3Nlci5tYWpvciA9IG1ham9yaXplKF9icm93c2VyLnZlcnNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIF9icm93c2VyO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENQVSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfY3B1ID0ge307XG4gICAgICAgICAgICBfY3B1W0FSQ0hJVEVDVFVSRV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZ3hNYXBwZXIuY2FsbChfY3B1LCBfdWEsIF9yZ3htYXAuY3B1KTtcbiAgICAgICAgICAgIHJldHVybiBfY3B1O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldERldmljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfZGV2aWNlID0ge307XG4gICAgICAgICAgICBfZGV2aWNlW1ZFTkRPUl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBfZGV2aWNlW01PREVMXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIF9kZXZpY2VbVFlQRV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZ3hNYXBwZXIuY2FsbChfZGV2aWNlLCBfdWEsIF9yZ3htYXAuZGV2aWNlKTtcbiAgICAgICAgICAgIHJldHVybiBfZGV2aWNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfZW5naW5lID0ge307XG4gICAgICAgICAgICBfZW5naW5lW05BTUVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgX2VuZ2luZVtWRVJTSU9OXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJneE1hcHBlci5jYWxsKF9lbmdpbmUsIF91YSwgX3JneG1hcC5lbmdpbmUpO1xuICAgICAgICAgICAgcmV0dXJuIF9lbmdpbmU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0T1MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX29zID0ge307XG4gICAgICAgICAgICBfb3NbTkFNRV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBfb3NbVkVSU0lPTl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZ3hNYXBwZXIuY2FsbChfb3MsIF91YSwgX3JneG1hcC5vcyk7XG4gICAgICAgICAgICByZXR1cm4gX29zO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdWEgICAgICA6IHRoaXMuZ2V0VUEoKSxcbiAgICAgICAgICAgICAgICBicm93c2VyIDogdGhpcy5nZXRCcm93c2VyKCksXG4gICAgICAgICAgICAgICAgZW5naW5lICA6IHRoaXMuZ2V0RW5naW5lKCksXG4gICAgICAgICAgICAgICAgb3MgICAgICA6IHRoaXMuZ2V0T1MoKSxcbiAgICAgICAgICAgICAgICBkZXZpY2UgIDogdGhpcy5nZXREZXZpY2UoKSxcbiAgICAgICAgICAgICAgICBjcHUgICAgIDogdGhpcy5nZXRDUFUoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRVQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdWE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0VUEgPSBmdW5jdGlvbiAodWEpIHtcbiAgICAgICAgICAgIF91YSA9ICh0eXBlb2YgdWEgPT09IFNUUl9UWVBFICYmIHVhLmxlbmd0aCA+IFVBX01BWF9MRU5HVEgpID8gdHJpbSh1YSwgVUFfTUFYX0xFTkdUSCkgOiB1YTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFVBKF91YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBVQVBhcnNlci5WRVJTSU9OID0gTElCVkVSU0lPTjtcbiAgICBVQVBhcnNlci5CUk9XU0VSID0gIGVudW1lcml6ZShbTkFNRSwgVkVSU0lPTiwgTUFKT1JdKTtcbiAgICBVQVBhcnNlci5DUFUgPSBlbnVtZXJpemUoW0FSQ0hJVEVDVFVSRV0pO1xuICAgIFVBUGFyc2VyLkRFVklDRSA9IGVudW1lcml6ZShbTU9ERUwsIFZFTkRPUiwgVFlQRSwgQ09OU09MRSwgTU9CSUxFLCBTTUFSVFRWLCBUQUJMRVQsIFdFQVJBQkxFLCBFTUJFRERFRF0pO1xuICAgIFVBUGFyc2VyLkVOR0lORSA9IFVBUGFyc2VyLk9TID0gZW51bWVyaXplKFtOQU1FLCBWRVJTSU9OXSk7XG5cbiAgICAvLy8vLy8vLy8vL1xuICAgIC8vIEV4cG9ydFxuICAgIC8vLy8vLy8vLy9cblxuICAgIC8vIGNoZWNrIGpzIGVudmlyb25tZW50XG4gICAgaWYgKHR5cGVvZihleHBvcnRzKSAhPT0gVU5ERUZfVFlQRSkge1xuICAgICAgICAvLyBub2RlanMgZW52XG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSBVTkRFRl9UWVBFICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBVQVBhcnNlcjtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLlVBUGFyc2VyID0gVUFQYXJzZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVxdWlyZWpzIGVudiAob3B0aW9uYWwpXG4gICAgICAgIGlmICh0eXBlb2YoZGVmaW5lKSA9PT0gRlVOQ19UWVBFICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFVBUGFyc2VyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gVU5ERUZfVFlQRSkge1xuICAgICAgICAgICAgLy8gYnJvd3NlciBlbnZcbiAgICAgICAgICAgIHdpbmRvdy5VQVBhcnNlciA9IFVBUGFyc2VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8galF1ZXJ5L1plcHRvIHNwZWNpZmljIChvcHRpb25hbClcbiAgICAvLyBOb3RlOlxuICAgIC8vICAgSW4gQU1EIGVudiB0aGUgZ2xvYmFsIHNjb3BlIHNob3VsZCBiZSBrZXB0IGNsZWFuLCBidXQgalF1ZXJ5IGlzIGFuIGV4Y2VwdGlvbi5cbiAgICAvLyAgIGpRdWVyeSBhbHdheXMgZXhwb3J0cyB0byBnbG9iYWwgc2NvcGUsIHVubGVzcyBqUXVlcnkubm9Db25mbGljdCh0cnVlKSBpcyB1c2VkLFxuICAgIC8vICAgYW5kIHdlIHNob3VsZCBjYXRjaCB0aGF0LlxuICAgIHZhciAkID0gdHlwZW9mIHdpbmRvdyAhPT0gVU5ERUZfVFlQRSAmJiAod2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG8pO1xuICAgIGlmICgkICYmICEkLnVhKSB7XG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgVUFQYXJzZXIoKTtcbiAgICAgICAgJC51YSA9IHBhcnNlci5nZXRSZXN1bHQoKTtcbiAgICAgICAgJC51YS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VyLmdldFVBKCk7XG4gICAgICAgIH07XG4gICAgICAgICQudWEuc2V0ID0gZnVuY3Rpb24gKHVhKSB7XG4gICAgICAgICAgICBwYXJzZXIuc2V0VUEodWEpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlci5nZXRSZXN1bHQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgJC51YVtwcm9wXSA9IHJlc3VsdFtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbn0pKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnID8gd2luZG93IDogdGhpcyk7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiX193ZWJwYWNrX3JlcXVpcmVfXy5hbWRPID0ge307IiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJ2YXIgc2NyaXB0VXJsO1xuaWYgKF9fd2VicGFja19yZXF1aXJlX18uZy5pbXBvcnRTY3JpcHRzKSBzY3JpcHRVcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcubG9jYXRpb24gKyBcIlwiO1xudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmRvY3VtZW50O1xuaWYgKCFzY3JpcHRVcmwgJiYgZG9jdW1lbnQpIHtcblx0aWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpXG5cdFx0c2NyaXB0VXJsID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmNcblx0aWYgKCFzY3JpcHRVcmwpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGlmKHNjcmlwdHMubGVuZ3RoKSBzY3JpcHRVcmwgPSBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV0uc3JjXG5cdH1cbn1cbi8vIFdoZW4gc3VwcG9ydGluZyBicm93c2VycyB3aGVyZSBhbiBhdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIHlvdSBtdXN0IHNwZWNpZnkgYW4gb3V0cHV0LnB1YmxpY1BhdGggbWFudWFsbHkgdmlhIGNvbmZpZ3VyYXRpb25cbi8vIG9yIHBhc3MgYW4gZW1wdHkgc3RyaW5nIChcIlwiKSBhbmQgc2V0IHRoZSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyB2YXJpYWJsZSBmcm9tIHlvdXIgY29kZSB0byB1c2UgeW91ciBvd24gbG9naWMuXG5pZiAoIXNjcmlwdFVybCkgdGhyb3cgbmV3IEVycm9yKFwiQXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG5zY3JpcHRVcmwgPSBzY3JpcHRVcmwucmVwbGFjZSgvIy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCIvXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gc2NyaXB0VXJsOyIsIi8vIEFzc2V0c1xuaW1wb3J0IFwiLi9hc3NldHMvaW1hZ2VzL29icy1jcmVhdGUtdGV4dC1zb3VyY2UucG5nXCI7XG5pbXBvcnQgXCIuL2Fzc2V0cy9pbWFnZXMvb2JzLXdlYnNvY2tldC1jb25uZWN0aW9uLnBuZ1wiO1xuXG5pbXBvcnQgYm9vdHN0cmFwIGZyb20gXCJib290c3RyYXAubmF0aXZlXCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCAqIGFzIHJpb3QgZnJvbSBcInJpb3RcIjtcbmltcG9ydCBIb21lVmlldyBmcm9tIFwiLi92aWV3cy9Ib21lVmlldy50YWcuaHRtbFwiO1xuXG5yaW90LnJlZ2lzdGVyKFwiaG9tZXZpZXdcIiwgSG9tZVZpZXcpO1xucmlvdC5tb3VudChcImhvbWV2aWV3XCIpO1xuIl0sIm5hbWVzIjpbIkhvbWVNb2RlbCIsImlzUnVubmluZyIsImVycm9yTWVzc2FnZSIsImhvbWVNb2RlbCIsIm9uTW91bnRlZCIsImlzU3VwcG9ydGVkIiwidXBkYXRlIiwib25Ub2dnbGVTdGFydFN0b3BCdXR0b24iLCJzdG9wIiwic3RhcnQiLCJ0aGVuIiwiY29uc29sZSIsImxvZyIsImVyciIsImVycm9yIiwibGFuZyIsInNjb3BlIiwiZSIsInRhcmdldCIsInZhbHVlIiwid2Vic29ja2V0QWRkcmVzcyIsIndlYnNvY2tldFBhc3N3b3JkIiwic291cmNlTmFtZSIsInNvdXJjZVR5cGUiLCJtYXhSb3dzIiwibWF4Q29scyIsInN0cnMiLCJsaW5lcyIsIm1hcCIsInMiLCJzcGxpdGxpbmVzIiwiZmxhdCIsInNsaWNlIiwiTWF0aCIsIm1heCIsImxlbmd0aCIsImpvaW4iLCJzdHIiLCJjdXJyTGluZSIsInRyaW0iLCJzcGxpdCIsImZvckVhY2giLCJ3ZCIsInNwbGl0Y2hhcndpc2UiLCJwb3AiLCJuZXdMaW5lIiwicHVzaCIsInN1YnN0cmluZyIsIlVBUGFyc2VyIiwiT0JTUmVwb3NpdG9yeSIsIlNwZWVjaFJlY29nbml0aW9uTW9kZWwiLCJGb3JtYXRNb2RlbCIsIm9ic1JlcG9zaXRvcnkiLCJ1YVBhcnNlciIsInNwZWVjaFJlY29nbml0aW9uTW9kZWwiLCJmb3JtYXRNb2RlbCIsImdldERlZmF1bHRMYW5ndWFnZSIsImdldERlZmF1bHRTb3VyY2VUeXBlIiwiZml4ZWRUcmFuc2NyaXB0cyIsIndpbmRvdyIsIm5hdmlnYXRvciIsImxhbmd1YWdlcyIsImxhbmd1YWdlIiwidXNlckxhbmd1YWdlIiwiYnJvd3Nlckxhbmd1YWdlIiwib3MiLCJnZXRPUyIsIm5hbWUiLCJjb25uZWN0IiwiYWRkcmVzcyIsInBhc3N3b3JkIiwic2V0VGV4dCIsImV2ZW50IiwidHJhbnNjcmlwdHMiLCJpc0ZpbmFsIiwidHJhbnNjcmlwdCIsInRleHQiLCJmb3JtYXQiLCJkaXNjb25uZWN0Iiwid2Via2l0U3BlZWNoUmVjb2duaXRpb24iLCJTcGVlY2hSZWNvZ25pdGlvbiIsIm9ucmVzdWx0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJlbmdpbmUiLCJjb250aW51b3VzIiwiaW50ZXJpbVJlc3VsdHMiLCJtYXhBbHRlcm5hdGl2ZXMiLCJtb2RlbCIsIm9uc3RhcnQiLCJvbmVuZCIsIm9uZXJyb3IiLCJpIiwicmVzdWx0SW5kZXgiLCJyZXN1bHRzIiwiY29uZmlkZW5jZSIsIk9CU1dlYlNvY2tldCIsIndlYnNvY2tldCIsImNvbm5JbmZvIiwic2V0VGV4dEdESVBsdXMiLCJzZXRUZXh0RnJlZXR5cGUyIiwic2VuZCIsImJvb3RzdHJhcCIsInJpb3QiLCJIb21lVmlldyIsInJlZ2lzdGVyIiwibW91bnQiXSwic291cmNlUm9vdCI6IiJ9