/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/views/HomeView.tag.html":
/*!*************************************!*\
  !*** ./src/views/HomeView.tag.html ***!
  \*************************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_exports__, __webpack_require__.r, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _models_HomeModel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/HomeModel.js */ "./src/models/HomeModel.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  'css': null,
  'exports': {
    isRunning: false,
    errorMessage: null,
    homeModel: new _models_HomeModel_js__WEBPACK_IMPORTED_MODULE_0__.default(),
    onMounted: function onMounted() {
      if (!this.homeModel.isSupported) {
        this.errorMessage = "Speech recognition is not supported on this browser. Use Google Chrome 33+ or Edge 79+ please.";
        this.update();
      }
    },
    onToggleStartStopButton: function onToggleStartStopButton() {
      var _this = this;

      this.errorMessage = null;

      if (this.isRunning) {
        this.homeModel.stop();
        this.isRunning = false;
        this.update();
      } else {
        this.homeModel.start().then(function () {
          _this.isRunning = true;

          _this.update();
        })["catch"](function (err) {
          console.log(err);
          _this.errorMessage = err.error;

          _this.update();
        });
      }
    }
  },
  'template': function template(_template, expressionTypes, bindingTypes, getComponent) {
    return _template('<div class="container"><div class="jumbotron"><h1>OBS Transcript</h1><p>Automatic transcript by speech recognition for OBS Studio.</p><section><div class="row"><div class="col-md-4"><div class="input-group"><span class="input-group-addon">Language</span><input expr0="expr0" type="text" class="form-control" placeholder="Language"/></div></div><div class="col-md-2"><input expr1="expr1" type="button"/></div></div></section></div><div class="row"><div class="col-md-12"><div expr2="expr2" class="alert alert-danger" role="alert"></div></div></div><section><h3>1. Enable OBS WebSocket</h3><div class="row"><div class="col-md-7"><p>\n            Install <a href="https://github.com/Palakis/obs-websocket/releases">obs-websocket</a> 4.8 or above, and\n            open "WebSocket Server Settings" dialog under OBS\' "Tools" menu.\n            After activation of OBS WebSocket Server, copy the WebSocket settings into the following text boxes.\n          </p><p><label>Address</label><div class="input-group"><span class="input-group-addon">ws://</span><input expr3="expr3" type="text" class="form-control" placeholder="Host:Port"/></div></p><p><label>Password</label><input expr4="expr4" type="password" class="form-control" placeholder="Password"/></p></div><div class="col-md-5 right-image"><image src="images/obs-websocket-connection.png" width="350"></image></div></div></section><section><h3>2. Create a text source</h3><div class="row"><div class="col-md-7"><p>\n            Add "Text (GDI+)" on Windows, or "Text (FreeType 2)" on Mac OS X or Linux to OBS\' "Sources".\n          </p><p><div class="row"><div class="col-md-6"><label>Source name</label><input expr5="expr5" type="text" class="form-control" placeholder="Text source"/></div><div class="col-md-6"><label>Source type</label><select expr6="expr6" class="form-control"><option expr7="expr7" value="0">Text (GDI+) [Windows]</option><option expr8="expr8" value="1">Text (FreeType 2) [Mac/Linux]</option></select></div></div></p><p><div class="row"><div class="col-md-6"><label>The number of lines</label><input expr9="expr9" type="text" class="form-control"/></div><div class="col-md-6"><label>The number of characters per line</label><input expr10="expr10" type="text" class="form-control"/></div></div></p></div><div class="col-md-5 right-image"><image src="images/obs-create-text-source.png" width="350"></image></div></div></section></div>', [{
      'redundantAttribute': 'expr0',
      'selector': '[expr0]',
      'expressions': [{
        'type': expressionTypes.VALUE,
        'evaluate': function evaluate(scope) {
          return scope.homeModel.lang;
        }
      }, {
        'type': expressionTypes.EVENT,
        'name': 'oninput',
        'evaluate': function evaluate(scope) {
          return function (e) {
            return scope.homeModel.lang = e.target.value;
          };
        }
      }, {
        'type': expressionTypes.ATTRIBUTE,
        'name': 'disabled',
        'evaluate': function evaluate(scope) {
          return scope.isRunning;
        }
      }]
    }, {
      'redundantAttribute': 'expr1',
      'selector': '[expr1]',
      'expressions': [{
        'type': expressionTypes.ATTRIBUTE,
        'name': 'class',
        'evaluate': function evaluate(scope) {
          return ['btn ', scope.isRunning ? 'btn-danger' : 'btn-success'].join('');
        }
      }, {
        'type': expressionTypes.VALUE,
        'evaluate': function evaluate(scope) {
          return scope.isRunning ? 'Stop' : 'Start';
        }
      }, {
        'type': expressionTypes.EVENT,
        'name': 'onclick',
        'evaluate': function evaluate(scope) {
          return scope.onToggleStartStopButton;
        }
      }, {
        'type': expressionTypes.ATTRIBUTE,
        'name': 'disabled',
        'evaluate': function evaluate(scope) {
          return !scope.homeModel.isSupported;
        }
      }]
    }, {
      'type': bindingTypes.IF,
      'evaluate': function evaluate(scope) {
        return scope.errorMessage;
      },
      'redundantAttribute': 'expr2',
      'selector': '[expr2]',
      'template': _template('<strong>Error</strong> ', [{
        'expressions': [{
          'type': expressionTypes.TEXT,
          'childNodeIndex': 1,
          'evaluate': function evaluate(scope) {
            return [': ', scope.errorMessage].join('');
          }
        }]
      }])
    }, {
      'redundantAttribute': 'expr3',
      'selector': '[expr3]',
      'expressions': [{
        'type': expressionTypes.VALUE,
        'evaluate': function evaluate(scope) {
          return scope.homeModel.websocketAddress;
        }
      }, {
        'type': expressionTypes.EVENT,
        'name': 'oninput',
        'evaluate': function evaluate(scope) {
          return function (e) {
            return scope.homeModel.websocketAddress = e.target.value;
          };
        }
      }, {
        'type': expressionTypes.ATTRIBUTE,
        'name': 'disabled',
        'evaluate': function evaluate(scope) {
          return scope.isRunning;
        }
      }]
    }, {
      'redundantAttribute': 'expr4',
      'selector': '[expr4]',
      'expressions': [{
        'type': expressionTypes.VALUE,
        'evaluate': function evaluate(scope) {
          return scope.homeModel.websocketPassword;
        }
      }, {
        'type': expressionTypes.EVENT,
        'name': 'oninput',
        'evaluate': function evaluate(scope) {
          return function (e) {
            return scope.homeModel.websocketPassword = e.target.value;
          };
        }
      }, {
        'type': expressionTypes.ATTRIBUTE,
        'name': 'disabled',
        'evaluate': function evaluate(scope) {
          return scope.isRunning;
        }
      }]
    }, {
      'redundantAttribute': 'expr5',
      'selector': '[expr5]',
      'expressions': [{
        'type': expressionTypes.VALUE,
        'evaluate': function evaluate(scope) {
          return scope.homeModel.sourceName;
        }
      }, {
        'type': expressionTypes.EVENT,
        'name': 'oninput',
        'evaluate': function evaluate(scope) {
          return function (e) {
            return scope.homeModel.sourceName = e.target.value;
          };
        }
      }, {
        'type': expressionTypes.ATTRIBUTE,
        'name': 'disabled',
        'evaluate': function evaluate(scope) {
          return scope.isRunning;
        }
      }]
    }, {
      'redundantAttribute': 'expr6',
      'selector': '[expr6]',
      'expressions': [{
        'type': expressionTypes.EVENT,
        'name': 'oninput',
        'evaluate': function evaluate(scope) {
          return function (e) {
            return scope.homeModel.sourceType = e.target.value;
          };
        }
      }, {
        'type': expressionTypes.ATTRIBUTE,
        'name': 'disabled',
        'evaluate': function evaluate(scope) {
          return scope.isRunning;
        }
      }]
    }, {
      'redundantAttribute': 'expr7',
      'selector': '[expr7]',
      'expressions': [{
        'type': expressionTypes.ATTRIBUTE,
        'name': 'selected',
        'evaluate': function evaluate(scope) {
          return scope.homeModel.sourceType == 0;
        }
      }]
    }, {
      'redundantAttribute': 'expr8',
      'selector': '[expr8]',
      'expressions': [{
        'type': expressionTypes.ATTRIBUTE,
        'name': 'selected',
        'evaluate': function evaluate(scope) {
          return scope.homeModel.sourceType == 1;
        }
      }]
    }, {
      'redundantAttribute': 'expr9',
      'selector': '[expr9]',
      'expressions': [{
        'type': expressionTypes.VALUE,
        'evaluate': function evaluate(scope) {
          return scope.homeModel.maxRows;
        }
      }, {
        'type': expressionTypes.EVENT,
        'name': 'oninput',
        'evaluate': function evaluate(scope) {
          return function (e) {
            return scope.homeModel.maxRows = e.target.value;
          };
        }
      }]
    }, {
      'redundantAttribute': 'expr10',
      'selector': '[expr10]',
      'expressions': [{
        'type': expressionTypes.VALUE,
        'evaluate': function evaluate(scope) {
          return scope.homeModel.maxCols;
        }
      }, {
        'type': expressionTypes.EVENT,
        'name': 'oninput',
        'evaluate': function evaluate(scope) {
          return function (e) {
            return scope.homeModel.maxCols = e.target.value;
          };
        }
      }]
    }]);
  },
  'name': 'homeview'
});
;

(function () {
  if (false) { var component, hotReload; }
})();

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! namespace exports */
/*! exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _assets_images_obs_create_text_source_png__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assets/images/obs-create-text-source.png */ "./src/assets/images/obs-create-text-source.png");
/* harmony import */ var _assets_images_obs_websocket_connection_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assets/images/obs-websocket-connection.png */ "./src/assets/images/obs-websocket-connection.png");
/* harmony import */ var bootstrap_native__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bootstrap.native */ "./node_modules/bootstrap.native/dist/bootstrap-native.esm.js");
/* harmony import */ var riot__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! riot */ "./node_modules/riot/riot.esm.js");
/* harmony import */ var _views_HomeView_tag_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./views/HomeView.tag.html */ "./src/views/HomeView.tag.html");
// Assets


 // eslint-disable-line no-unused-vars



riot__WEBPACK_IMPORTED_MODULE_4__.register("homeview", _views_HomeView_tag_html__WEBPACK_IMPORTED_MODULE_3__.default);
riot__WEBPACK_IMPORTED_MODULE_4__.mount("homeview");

/***/ }),

/***/ "./src/models/FormatModel.js":
/*!***********************************!*\
  !*** ./src/models/FormatModel.js ***!
  \***********************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ _default
/* harmony export */ });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _default = /*#__PURE__*/function () {
  function _default() {
    _classCallCheck(this, _default);
  }

  _createClass(_default, [{
    key: "format",

    /**
     * Formats a given string.
     */
    value: function format(strs, maxRows, maxCols) {
      var _this = this;

      var lines = strs.map(function (s) {
        return _this.splitlines(s, maxCols);
      }).flat();
      return lines.slice(Math.max(0, lines.length - maxRows)).join("\n");
    }
    /**
     * Splits a given string into lines of maximum length `maxCols`.
     */

  }, {
    key: "splitlines",
    value: function splitlines(str, maxCols) {
      var _this2 = this;

      var lines = [];
      var currLine = "";
      str.split(/ /).forEach(function (wd) {
        if (currLine.length == 0) {
          lines = _this2.splitcharwise(lines, wd, maxCols);
          currLine = lines.pop();
        } else {
          var newLine = currLine + " " + wd;

          if (newLine.length <= maxCols) {
            currLine = newLine;
          } else if (wd.length <= maxCols) {
            lines.push(currLine);
            currLine = wd;
          } else {
            lines = _this2.splitcharwise(lines, newLine, maxCols);
            currLine = lines.pop();
          }
        }
      });

      if (currLine.length > 0) {
        lines.push(currLine);
      }

      return lines;
    }
    /**
     * Splits a given string into substrings of maximum length `maxCols`,
     * and appends the substrings into `lines`.
     */

  }, {
    key: "splitcharwise",
    value: function splitcharwise(lines, str, maxCols) {
      while (str.length > maxCols) {
        lines.push(str.substring(0, maxCols));
        str = str.substring(maxCols);
      }

      if (str.length > 0) {
        lines.push(str);
      }

      return lines;
    }
  }]);

  return _default;
}();



/***/ }),

/***/ "./src/models/HomeModel.js":
/*!*********************************!*\
  !*** ./src/models/HomeModel.js ***!
  \*********************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.n, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ _default
/* harmony export */ });
/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ua-parser-js */ "./node_modules/ua-parser-js/src/ua-parser.js");
/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ua_parser_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _repositories_OBSRepository_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../repositories/OBSRepository.js */ "./src/repositories/OBSRepository.js");
/* harmony import */ var _models_SpeechRecognitionModel_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../models/SpeechRecognitionModel.js */ "./src/models/SpeechRecognitionModel.js");
/* harmony import */ var _models_FormatModel_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../models/FormatModel.js */ "./src/models/FormatModel.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }






var _default = /*#__PURE__*/function () {
  function _default() {
    _classCallCheck(this, _default);

    this.obsRepository = new _repositories_OBSRepository_js__WEBPACK_IMPORTED_MODULE_1__.default();
    this.uaParser = new (ua_parser_js__WEBPACK_IMPORTED_MODULE_0___default())();
    this.speechRecognitionModel = new _models_SpeechRecognitionModel_js__WEBPACK_IMPORTED_MODULE_2__.default();
    this.formatModel = new _models_FormatModel_js__WEBPACK_IMPORTED_MODULE_3__.default();
    this.lang = this.getDefaultLanguage();
    this.websocketAddress = "localhost:4444";
    this.websocketPassword = null;
    this.sourceName = "my_transcript_src";
    this.sourceType = this.getDefaultSourceType();
    this.maxRows = 3;
    this.maxCols = 20;
    this.fixedTranscripts = [];
  }

  _createClass(_default, [{
    key: "isSupported",
    value: function isSupported() {
      return this.speechRecognitionModel.isSupported();
    }
  }, {
    key: "getDefaultLanguage",
    value: function getDefaultLanguage() {
      return window.navigator.languages && window.navigator.languages[0] || window.navigator.language || window.navigator.userLanguage || window.navigator.browserLanguage || "en";
    }
  }, {
    key: "getDefaultSourceType",
    value: function getDefaultSourceType() {
      var os = this.uaParser.getOS();
      return os.name === "Windows" ? 0 : 1;
    }
  }, {
    key: "start",
    value: function start() {
      var _this = this;

      return this.obsRepository.connect({
        address: this.websocketAddress,
        password: this.websocketPassword
      }).then(function () {
        return _this.obsRepository.setText(_this.sourceType, _this.sourceName, "") // Validates sourceType and sourceName
        .then(function () {
          return _this.speechRecognitionModel.start(_this.lang, function (event) {
            console.log(event);
            var transcripts;

            if (event.isFinal) {
              _this.fixedTranscripts.push(event.transcript);

              transcripts = _this.fixedTranscripts;
            } else {
              transcripts = [].concat(_toConsumableArray(_this.fixedTranscripts), [event.transcript]);
            }

            var text = _this.formatModel.format(transcripts, _this.maxRows, _this.maxCols);

            _this.obsRepository.setText(_this.sourceType, _this.sourceName, text);
          });
        })["catch"](function (err) {
          _this.stop(); // close connection if failed.


          throw err;
        });
      });
    }
  }, {
    key: "stop",
    value: function stop() {
      this.speechRecognitionModel.stop();
      this.obsRepository.disconnect();
    }
  }]);

  return _default;
}();



/***/ }),

/***/ "./src/models/SpeechRecognitionModel.js":
/*!**********************************************!*\
  !*** ./src/models/SpeechRecognitionModel.js ***!
  \**********************************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ _default
/* harmony export */ });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _default = /*#__PURE__*/function () {
  function _default() {
    _classCallCheck(this, _default);
  }

  _createClass(_default, [{
    key: "isSupported",
    value: function isSupported() {
      return !!(webkitSpeechRecognition || SpeechRecognition);
    }
  }, {
    key: "start",
    value: function start(lang, onresult) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (webkitSpeechRecognition) {
          _this.engine = new webkitSpeechRecognition();
        } else if (SpeechRecognition) {
          _this.engine = new SpeechRecognition();
        }

        _this.engine.lang = lang;
        _this.engine.continuous = true;
        _this.engine.interimResults = true;
        _this.engine.maxAlternatives = 1;
        _this.engine.onstart = resolve;

        _this.engine.onend = function () {
          if (_this.isRunning) _this.engine.start();
        };

        _this.engine.onerror = reject;

        _this.engine.onresult = function (event) {
          for (var i = event.resultIndex; i < event.results.length; ++i) {
            onresult({
              "isFinal": event.results[i].isFinal,
              "transcript": event.results[i][0].transcript,
              "confidence": event.results[i][0].confidence
            });
          }
        };

        _this.engine.start();
      });
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this.engine) {
        this.engine.stop();
        this.engine = null;
      }
    }
  }]);

  return _default;
}();



/***/ }),

/***/ "./src/repositories/OBSRepository.js":
/*!*******************************************!*\
  !*** ./src/repositories/OBSRepository.js ***!
  \*******************************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.n, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ _default
/* harmony export */ });
/* harmony import */ var obs_websocket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! obs-websocket-js */ "./node_modules/obs-websocket-js/lib/index.js");
/* harmony import */ var obs_websocket_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(obs_websocket_js__WEBPACK_IMPORTED_MODULE_0__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var _default = /*#__PURE__*/function () {
  function _default() {
    _classCallCheck(this, _default);

    this.websocket = new (obs_websocket_js__WEBPACK_IMPORTED_MODULE_0___default())();
  }

  _createClass(_default, [{
    key: "connect",
    value: function connect(connInfo) {
      return this.websocket.connect(connInfo);
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      return this.websocket.disconnect();
    }
  }, {
    key: "setText",
    value: function setText(sourceType, sourceName, text) {
      if (sourceType == 0) {
        return this.setTextGDIPlus(sourceName, text);
      } else {
        return this.setTextFreetype2(sourceName, text);
      }
    }
  }, {
    key: "setTextGDIPlus",
    value: function setTextGDIPlus(sourceName, text) {
      return this.websocket.send("SetTextGDIPlusProperties", {
        "source": sourceName,
        "text": text
      });
    }
  }, {
    key: "setTextFreetype2",
    value: function setTextFreetype2(sourceName, text) {
      return this.websocket.send("SetTextFreetype2Properties", {
        "source": sourceName,
        "text": text
      });
    }
  }]);

  return _default;
}();



/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! default exports */
/*! export byteLength [provided] [no usage info] [missing usage info prevents renaming] */
/*! export fromByteArray [provided] [no usage info] [missing usage info prevents renaming] */
/*! export toByteArray [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/bootstrap.native/dist/bootstrap-native.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/bootstrap.native/dist/bootstrap-native.esm.js ***!
  \********************************************************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__.r, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/*!
  * Native JavaScript for Bootstrap v3.0.13 (https://thednp.github.io/bootstrap.native/)
  * Copyright 2015-2020 © dnp_theme
  * Licensed under MIT (https://github.com/thednp/bootstrap.native/blob/master/LICENSE)
  */
var transitionEndEvent = 'webkitTransition' in document.head.style ? 'webkitTransitionEnd' : 'transitionend';

var supportTransition = 'webkitTransition' in document.head.style || 'transition' in document.head.style;

var transitionDuration = 'webkitTransition' in document.head.style ? 'webkitTransitionDuration' : 'transitionDuration';

var transitionProperty = 'webkitTransition' in document.head.style ? 'webkitTransitionProperty' : 'transitionProperty';

function getElementTransitionDuration(element) {
  var computedStyle = getComputedStyle(element),
      property = computedStyle[transitionProperty],
      duration = supportTransition && property && property !== 'none'
               ? parseFloat(computedStyle[transitionDuration]) : 0;
  return !isNaN(duration) ? duration * 1000 : 0;
}

function emulateTransitionEnd(element,handler){
  var called = 0, duration = getElementTransitionDuration(element);
  duration ? element.addEventListener( transitionEndEvent, function transitionEndWrapper(e){
              !called && handler(e), called = 1;
              element.removeEventListener( transitionEndEvent, transitionEndWrapper);
            })
           : setTimeout(function() { !called && handler(), called = 1; }, 17);
}

function queryElement(selector, parent) {
  var lookUp = parent && parent instanceof Element ? parent : document;
  return selector instanceof Element ? selector : lookUp.querySelector(selector);
}

function bootstrapCustomEvent(eventName, componentName, related) {
  var OriginalCustomEvent = new CustomEvent( eventName + '.bs.' + componentName, {cancelable: true});
  OriginalCustomEvent.relatedTarget = related;
  return OriginalCustomEvent;
}

function dispatchCustomEvent(customEvent){
  this && this.dispatchEvent(customEvent);
}

function Alert(element) {
  var self = this,
    alert,
    closeCustomEvent = bootstrapCustomEvent('close','alert'),
    closedCustomEvent = bootstrapCustomEvent('closed','alert');
  function triggerHandler() {
    alert.classList.contains('fade') ? emulateTransitionEnd(alert,transitionEndHandler) : transitionEndHandler();
  }
  function toggleEvents(action){
    action = action ? 'addEventListener' : 'removeEventListener';
    element[action]('click',clickHandler,false);
  }
  function clickHandler(e) {
    alert = e && e.target.closest(".alert");
    element = queryElement('[data-dismiss="alert"]',alert);
    element && alert && (element === e.target || element.contains(e.target)) && self.close();
  }
  function transitionEndHandler() {
    toggleEvents();
    alert.parentNode.removeChild(alert);
    dispatchCustomEvent.call(alert,closedCustomEvent);
  }
  self.close = function () {
    if ( alert && element && alert.classList.contains('show') ) {
      dispatchCustomEvent.call(alert,closeCustomEvent);
      if ( closeCustomEvent.defaultPrevented ) { return; }
      self.dispose();
      alert.classList.remove('show');
      triggerHandler();
    }
  };
  self.dispose = function () {
    toggleEvents();
    delete element.Alert;
  };
  element = queryElement(element);
  alert = element.closest('.alert');
  element.Alert && element.Alert.dispose();
  if ( !element.Alert ) {
    toggleEvents(1);
  }
  self.element = element;
  element.Alert = self;
}

function Button(element) {
  var self = this, labels,
      changeCustomEvent = bootstrapCustomEvent('change', 'button');
  function toggle(e) {
    var input,
        label = e.target.tagName === 'LABEL' ? e.target
              : e.target.closest('LABEL') ? e.target.closest('LABEL') : null;
    input = label && label.getElementsByTagName('INPUT')[0];
    if ( !input ) { return; }
    dispatchCustomEvent.call(input, changeCustomEvent);
    dispatchCustomEvent.call(element, changeCustomEvent);
    if ( input.type === 'checkbox' ) {
      if ( changeCustomEvent.defaultPrevented ) { return; }
      if ( !input.checked ) {
        label.classList.add('active');
        input.getAttribute('checked');
        input.setAttribute('checked','checked');
        input.checked = true;
      } else {
        label.classList.remove('active');
        input.getAttribute('checked');
        input.removeAttribute('checked');
        input.checked = false;
      }
      if (!element.toggled) {
        element.toggled = true;
      }
    }
    if ( input.type === 'radio' && !element.toggled ) {
      if ( changeCustomEvent.defaultPrevented ) { return; }
      if ( !input.checked || (e.screenX === 0 && e.screenY == 0) ) {
        label.classList.add('active');
        label.classList.add('focus');
        input.setAttribute('checked','checked');
        input.checked = true;
        element.toggled = true;
        Array.from(labels).map(function (otherLabel){
          var otherInput = otherLabel.getElementsByTagName('INPUT')[0];
          if ( otherLabel !== label && otherLabel.classList.contains('active') )  {
            dispatchCustomEvent.call(otherInput, changeCustomEvent);
            otherLabel.classList.remove('active');
            otherInput.removeAttribute('checked');
            otherInput.checked = false;
          }
        });
      }
    }
    setTimeout( function () { element.toggled = false; }, 50 );
  }
  function keyHandler(e) {
    var key = e.which || e.keyCode;
    key === 32 && e.target === document.activeElement && toggle(e);
  }
  function preventScroll(e) {
    var key = e.which || e.keyCode;
    key === 32 && e.preventDefault();
  }
  function focusToggle(e) {
    if (e.target.tagName === 'INPUT' ) {
      var action = e.type === 'focusin' ? 'add' : 'remove';
      e.target.closest('.btn').classList[action]('focus');
    }
  }
  function toggleEvents(action) {
    action = action ? 'addEventListener' : 'removeEventListener';
    element[action]('click',toggle,false );
    element[action]('keyup',keyHandler,false), element[action]('keydown',preventScroll,false);
    element[action]('focusin',focusToggle,false), element[action]('focusout',focusToggle,false);
  }
  self.dispose = function () {
    toggleEvents();
    delete element.Button;
  };
  element = queryElement(element);
  element.Button && element.Button.dispose();
  labels = element.getElementsByClassName('btn');
  if (!labels.length) { return; }
  if ( !element.Button ) {
    toggleEvents(1);
  }
  element.toggled = false;
  element.Button = self;
  Array.from(labels).map(function (btn){
    !btn.classList.contains('active')
      && queryElement('input:checked',btn)
      && btn.classList.add('active');
    btn.classList.contains('active')
      && !queryElement('input:checked',btn)
      && btn.classList.remove('active');
  });
}

var mouseHoverEvents = ('onmouseleave' in document) ? [ 'mouseenter', 'mouseleave'] : [ 'mouseover', 'mouseout' ];

var supportPassive = (function () {
  var result = false;
  try {
    var opts = Object.defineProperty({}, 'passive', {
      get: function() {
        result = true;
      }
    });
    document.addEventListener('DOMContentLoaded', function wrap(){
      document.removeEventListener('DOMContentLoaded', wrap, opts);
    }, opts);
  } catch (e) {}
  return result;
})();

var passiveHandler = supportPassive ? { passive: true } : false;

function isElementInScrollRange(element) {
  var bcr = element.getBoundingClientRect(),
      viewportHeight = window.innerHeight || document.documentElement.clientHeight;
  return bcr.top <= viewportHeight && bcr.bottom >= 0;
}

function Carousel (element,options) {
  options = options || {};
  var self = this,
    vars, ops,
    slideCustomEvent, slidCustomEvent,
    slides, leftArrow, rightArrow, indicator, indicators;
  function pauseHandler() {
    if ( ops.interval !==false && !element.classList.contains('paused') ) {
      element.classList.add('paused');
      !vars.isSliding && ( clearInterval(vars.timer), vars.timer = null );
    }
  }
  function resumeHandler() {
    if ( ops.interval !== false && element.classList.contains('paused') ) {
      element.classList.remove('paused');
      !vars.isSliding && ( clearInterval(vars.timer), vars.timer = null );
      !vars.isSliding && self.cycle();
    }
  }
  function indicatorHandler(e) {
    e.preventDefault();
    if (vars.isSliding) { return; }
    var eventTarget = e.target;
    if ( eventTarget && !eventTarget.classList.contains('active') && eventTarget.getAttribute('data-slide-to') ) {
      vars.index = parseInt( eventTarget.getAttribute('data-slide-to'));
    } else { return false; }
    self.slideTo( vars.index );
  }
  function controlsHandler(e) {
    e.preventDefault();
    if (vars.isSliding) { return; }
    var eventTarget = e.currentTarget || e.srcElement;
    if ( eventTarget === rightArrow ) {
      vars.index++;
    } else if ( eventTarget === leftArrow ) {
      vars.index--;
    }
    self.slideTo( vars.index );
  }
  function keyHandler(ref) {
    var which = ref.which;
    if (vars.isSliding) { return; }
    switch (which) {
      case 39:
        vars.index++;
        break;
      case 37:
        vars.index--;
        break;
      default: return;
    }
    self.slideTo( vars.index );
  }
  function toggleEvents(action) {
    action = action ? 'addEventListener' : 'removeEventListener';
    if ( ops.pause && ops.interval ) {
      element[action]( mouseHoverEvents[0], pauseHandler, false );
      element[action]( mouseHoverEvents[1], resumeHandler, false );
      element[action]( 'touchstart', pauseHandler, passiveHandler );
      element[action]( 'touchend', resumeHandler, passiveHandler );
    }
    ops.touch && slides.length > 1 && element[action]( 'touchstart', touchDownHandler, passiveHandler );
    rightArrow && rightArrow[action]( 'click', controlsHandler,false );
    leftArrow && leftArrow[action]( 'click', controlsHandler,false );
    indicator && indicator[action]( 'click', indicatorHandler,false );
    ops.keyboard && window[action]( 'keydown', keyHandler,false );
  }
  function toggleTouchEvents(action) {
    action = action ? 'addEventListener' : 'removeEventListener';
    element[action]( 'touchmove', touchMoveHandler, passiveHandler );
    element[action]( 'touchend', touchEndHandler, passiveHandler );
  }
  function touchDownHandler(e) {
    if ( vars.isTouch ) { return; }
    vars.touchPosition.startX = e.changedTouches[0].pageX;
    if ( element.contains(e.target) ) {
      vars.isTouch = true;
      toggleTouchEvents(1);
    }
  }
  function touchMoveHandler(e) {
    if ( !vars.isTouch ) { e.preventDefault(); return; }
    vars.touchPosition.currentX = e.changedTouches[0].pageX;
    if ( e.type === 'touchmove' && e.changedTouches.length > 1 ) {
      e.preventDefault();
      return false;
    }
  }
  function touchEndHandler (e) {
    if ( !vars.isTouch || vars.isSliding ) { return }
    vars.touchPosition.endX = vars.touchPosition.currentX || e.changedTouches[0].pageX;
    if ( vars.isTouch ) {
      if ( (!element.contains(e.target) || !element.contains(e.relatedTarget) )
          && Math.abs(vars.touchPosition.startX - vars.touchPosition.endX) < 75 ) {
        return false;
      } else {
        if ( vars.touchPosition.currentX < vars.touchPosition.startX ) {
          vars.index++;
        } else if ( vars.touchPosition.currentX > vars.touchPosition.startX ) {
          vars.index--;
        }
        vars.isTouch = false;
        self.slideTo(vars.index);
      }
      toggleTouchEvents();
    }
  }
  function setActivePage(pageIndex) {
    Array.from(indicators).map(function (x){x.classList.remove('active');});
    indicators[pageIndex] && indicators[pageIndex].classList.add('active');
  }
  function transitionEndHandler(e){
    if (vars.touchPosition){
      var next = vars.index,
          timeout = e && e.target !== slides[next] ? e.elapsedTime*1000+100 : 20,
          activeItem = self.getActiveIndex(),
          orientation = vars.direction === 'left' ? 'next' : 'prev';
      vars.isSliding && setTimeout(function () {
        if (vars.touchPosition){
          vars.isSliding = false;
          slides[next].classList.add('active');
          slides[activeItem].classList.remove('active');
          slides[next].classList.remove(("carousel-item-" + orientation));
          slides[next].classList.remove(("carousel-item-" + (vars.direction)));
          slides[activeItem].classList.remove(("carousel-item-" + (vars.direction)));
          dispatchCustomEvent.call(element, slidCustomEvent);
          if ( !document.hidden && ops.interval && !element.classList.contains('paused') ) {
            self.cycle();
          }
        }
      }, timeout);
    }
  }
  self.cycle = function () {
    if (vars.timer) {
      clearInterval(vars.timer);
      vars.timer = null;
    }
    vars.timer = setInterval(function () {
      var idx = vars.index || self.getActiveIndex();
      isElementInScrollRange(element) && (idx++, self.slideTo( idx ) );
    }, ops.interval);
  };
  self.slideTo = function (next) {
    if (vars.isSliding) { return; }
    var activeItem = self.getActiveIndex(), orientation;
    if ( activeItem === next ) {
      return;
    } else if  ( (activeItem < next ) || (activeItem === 0 && next === slides.length -1 ) ) {
      vars.direction = 'left';
    } else if  ( (activeItem > next) || (activeItem === slides.length - 1 && next === 0 ) ) {
      vars.direction = 'right';
    }
    if ( next < 0 ) { next = slides.length - 1; }
    else if ( next >= slides.length ){ next = 0; }
    orientation = vars.direction === 'left' ? 'next' : 'prev';
    slideCustomEvent = bootstrapCustomEvent('slide', 'carousel', slides[next]);
    slidCustomEvent = bootstrapCustomEvent('slid', 'carousel', slides[next]);
    dispatchCustomEvent.call(element, slideCustomEvent);
    if (slideCustomEvent.defaultPrevented) { return; }
    vars.index = next;
    vars.isSliding = true;
    clearInterval(vars.timer);
    vars.timer = null;
    setActivePage( next );
    if ( getElementTransitionDuration(slides[next]) && element.classList.contains('slide') ) {
      slides[next].classList.add(("carousel-item-" + orientation));
      slides[next].offsetWidth;
      slides[next].classList.add(("carousel-item-" + (vars.direction)));
      slides[activeItem].classList.add(("carousel-item-" + (vars.direction)));
      emulateTransitionEnd(slides[next], transitionEndHandler);
    } else {
      slides[next].classList.add('active');
      slides[next].offsetWidth;
      slides[activeItem].classList.remove('active');
      setTimeout(function () {
        vars.isSliding = false;
        if ( ops.interval && element && !element.classList.contains('paused') ) {
          self.cycle();
        }
        dispatchCustomEvent.call(element, slidCustomEvent);
      }, 100 );
    }
  };
  self.getActiveIndex = function () { return Array.from(slides).indexOf(element.getElementsByClassName('carousel-item active')[0]) || 0; };
  self.dispose = function () {
    var itemClasses = ['left','right','prev','next'];
    Array.from(slides).map(function (slide,idx) {
      slide.classList.contains('active') && setActivePage( idx );
      itemClasses.map(function (cls) { return slide.classList.remove(("carousel-item-" + cls)); });
    });
    clearInterval(vars.timer);
    toggleEvents();
    vars = {};
    ops = {};
    delete element.Carousel;
  };
  element = queryElement( element );
  element.Carousel && element.Carousel.dispose();
  slides = element.getElementsByClassName('carousel-item');
  leftArrow = element.getElementsByClassName('carousel-control-prev')[0];
  rightArrow = element.getElementsByClassName('carousel-control-next')[0];
  indicator = element.getElementsByClassName('carousel-indicators')[0];
  indicators = indicator && indicator.getElementsByTagName( "LI" ) || [];
  if (slides.length < 2) { return }
  var
    intervalAttribute = element.getAttribute('data-interval'),
    intervalData = intervalAttribute === 'false' ? 0 : parseInt(intervalAttribute),
    touchData = element.getAttribute('data-touch') === 'false' ? 0 : 1,
    pauseData = element.getAttribute('data-pause') === 'hover' || false,
    keyboardData = element.getAttribute('data-keyboard') === 'true' || false,
    intervalOption = options.interval,
    touchOption = options.touch;
  ops = {};
  ops.keyboard = options.keyboard === true || keyboardData;
  ops.pause = (options.pause === 'hover' || pauseData) ? 'hover' : false;
  ops.touch = touchOption || touchData;
  ops.interval = typeof intervalOption === 'number' ? intervalOption
              : intervalOption === false || intervalData === 0 || intervalData === false ? 0
              : isNaN(intervalData) ? 5000
              : intervalData;
  if (self.getActiveIndex()<0) {
    slides.length && slides[0].classList.add('active');
    indicators.length && setActivePage(0);
  }
  vars = {};
  vars.direction = 'left';
  vars.index = 0;
  vars.timer = null;
  vars.isSliding = false;
  vars.isTouch = false;
  vars.touchPosition = {
    startX : 0,
    currentX : 0,
    endX : 0
  };
  toggleEvents(1);
  if ( ops.interval ){ self.cycle(); }
  element.Carousel = self;
}

function Collapse(element,options) {
  options = options || {};
  var self = this;
  var accordion = null,
      collapse = null,
      activeCollapse,
      activeElement,
      showCustomEvent,
      shownCustomEvent,
      hideCustomEvent,
      hiddenCustomEvent;
  function openAction(collapseElement, toggle) {
    dispatchCustomEvent.call(collapseElement, showCustomEvent);
    if ( showCustomEvent.defaultPrevented ) { return; }
    collapseElement.isAnimating = true;
    collapseElement.classList.add('collapsing');
    collapseElement.classList.remove('collapse');
    collapseElement.style.height = (collapseElement.scrollHeight) + "px";
    emulateTransitionEnd(collapseElement, function () {
      collapseElement.isAnimating = false;
      collapseElement.setAttribute('aria-expanded','true');
      toggle.setAttribute('aria-expanded','true');
      collapseElement.classList.remove('collapsing');
      collapseElement.classList.add('collapse');
      collapseElement.classList.add('show');
      collapseElement.style.height = '';
      dispatchCustomEvent.call(collapseElement, shownCustomEvent);
    });
  }
  function closeAction(collapseElement, toggle) {
    dispatchCustomEvent.call(collapseElement, hideCustomEvent);
    if ( hideCustomEvent.defaultPrevented ) { return; }
    collapseElement.isAnimating = true;
    collapseElement.style.height = (collapseElement.scrollHeight) + "px";
    collapseElement.classList.remove('collapse');
    collapseElement.classList.remove('show');
    collapseElement.classList.add('collapsing');
    collapseElement.offsetWidth;
    collapseElement.style.height = '0px';
    emulateTransitionEnd(collapseElement, function () {
      collapseElement.isAnimating = false;
      collapseElement.setAttribute('aria-expanded','false');
      toggle.setAttribute('aria-expanded','false');
      collapseElement.classList.remove('collapsing');
      collapseElement.classList.add('collapse');
      collapseElement.style.height = '';
      dispatchCustomEvent.call(collapseElement, hiddenCustomEvent);
    });
  }
  self.toggle = function (e) {
    if (e && e.target.tagName === 'A' || element.tagName === 'A') {e.preventDefault();}
    if (element.contains(e.target) || e.target === element) {
      if (!collapse.classList.contains('show')) { self.show(); }
      else { self.hide(); }
    }
  };
  self.hide = function () {
    if ( collapse.isAnimating ) { return; }
    closeAction(collapse,element);
    element.classList.add('collapsed');
  };
  self.show = function () {
    if ( accordion ) {
      activeCollapse = accordion.getElementsByClassName("collapse show")[0];
      activeElement = activeCollapse && (queryElement(("[data-target=\"#" + (activeCollapse.id) + "\"]"),accordion)
                    || queryElement(("[href=\"#" + (activeCollapse.id) + "\"]"),accordion) );
    }
    if ( !collapse.isAnimating ) {
      if ( activeElement && activeCollapse !== collapse ) {
        closeAction(activeCollapse,activeElement);
        activeElement.classList.add('collapsed');
      }
      openAction(collapse,element);
      element.classList.remove('collapsed');
    }
  };
  self.dispose = function () {
    element.removeEventListener('click',self.toggle,false);
    delete element.Collapse;
  };
    element = queryElement(element);
    element.Collapse && element.Collapse.dispose();
    var accordionData = element.getAttribute('data-parent');
    showCustomEvent = bootstrapCustomEvent('show', 'collapse');
    shownCustomEvent = bootstrapCustomEvent('shown', 'collapse');
    hideCustomEvent = bootstrapCustomEvent('hide', 'collapse');
    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'collapse');
    collapse = queryElement(options.target || element.getAttribute('data-target') || element.getAttribute('href'));
    collapse.isAnimating = false;
    accordion = element.closest(options.parent || accordionData);
    if ( !element.Collapse ) {
      element.addEventListener('click',self.toggle,false);
    }
    element.Collapse = self;
}

function setFocus (element){
  element.focus ? element.focus() : element.setActive();
}

function Dropdown(element,option) {
  var self = this,
      showCustomEvent,
      shownCustomEvent,
      hideCustomEvent,
      hiddenCustomEvent,
      relatedTarget = null,
      parent, menu, menuItems = [],
      persist;
  function preventEmptyAnchor(anchor) {
    (anchor.href && anchor.href.slice(-1) === '#' || anchor.parentNode && anchor.parentNode.href
      && anchor.parentNode.href.slice(-1) === '#') && this.preventDefault();
  }
  function toggleDismiss() {
    var action = element.open ? 'addEventListener' : 'removeEventListener';
    document[action]('click',dismissHandler,false);
    document[action]('keydown',preventScroll,false);
    document[action]('keyup',keyHandler,false);
    document[action]('focus',dismissHandler,false);
  }
  function dismissHandler(e) {
    var eventTarget = e.target,
          hasData = eventTarget && (eventTarget.getAttribute('data-toggle')
                                || eventTarget.parentNode && eventTarget.parentNode.getAttribute
                                && eventTarget.parentNode.getAttribute('data-toggle'));
    if ( e.type === 'focus' && (eventTarget === element || eventTarget === menu || menu.contains(eventTarget) ) ) {
      return;
    }
    if ( (eventTarget === menu || menu.contains(eventTarget)) && (persist || hasData) ) { return; }
    else {
      relatedTarget = eventTarget === element || element.contains(eventTarget) ? element : null;
      self.hide();
    }
    preventEmptyAnchor.call(e,eventTarget);
  }
  function clickHandler(e) {
    relatedTarget = element;
    self.show();
    preventEmptyAnchor.call(e,e.target);
  }
  function preventScroll(e) {
    var key = e.which || e.keyCode;
    if( key === 38 || key === 40 ) { e.preventDefault(); }
  }
  function keyHandler(e) {
    var key = e.which || e.keyCode,
        activeItem = document.activeElement,
        isSameElement = activeItem === element,
        isInsideMenu = menu.contains(activeItem),
        isMenuItem = activeItem.parentNode === menu || activeItem.parentNode.parentNode === menu,
        idx = menuItems.indexOf(activeItem);
    if ( isMenuItem ) {
      idx = isSameElement ? 0
                          : key === 38 ? (idx>1?idx-1:0)
                          : key === 40 ? (idx<menuItems.length-1?idx+1:idx) : idx;
      menuItems[idx] && setFocus(menuItems[idx]);
    }
    if ( (menuItems.length && isMenuItem
          || !menuItems.length && (isInsideMenu || isSameElement)
          || !isInsideMenu )
          && element.open && key === 27
    ) {
      self.toggle();
      relatedTarget = null;
    }
  }
  self.show = function () {
    showCustomEvent = bootstrapCustomEvent('show', 'dropdown', relatedTarget);
    dispatchCustomEvent.call(parent, showCustomEvent);
    if ( showCustomEvent.defaultPrevented ) { return; }
    menu.classList.add('show');
    parent.classList.add('show');
    element.setAttribute('aria-expanded',true);
    element.open = true;
    element.removeEventListener('click',clickHandler,false);
    setTimeout(function () {
      setFocus( menu.getElementsByTagName('INPUT')[0] || element );
      toggleDismiss();
      shownCustomEvent = bootstrapCustomEvent( 'shown', 'dropdown', relatedTarget);
      dispatchCustomEvent.call(parent, shownCustomEvent);
    },1);
  };
  self.hide = function () {
    hideCustomEvent = bootstrapCustomEvent('hide', 'dropdown', relatedTarget);
    dispatchCustomEvent.call(parent, hideCustomEvent);
    if ( hideCustomEvent.defaultPrevented ) { return; }
    menu.classList.remove('show');
    parent.classList.remove('show');
    element.setAttribute('aria-expanded',false);
    element.open = false;
    toggleDismiss();
    setFocus(element);
    setTimeout(function () {
      element.Dropdown && element.addEventListener('click',clickHandler,false);
    },1);
    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'dropdown', relatedTarget);
    dispatchCustomEvent.call(parent, hiddenCustomEvent);
  };
  self.toggle = function () {
    if (parent.classList.contains('show') && element.open) { self.hide(); }
    else { self.show(); }
  };
  self.dispose = function () {
    if (parent.classList.contains('show') && element.open) { self.hide(); }
    element.removeEventListener('click',clickHandler,false);
    delete element.Dropdown;
  };
  element = queryElement(element);
  element.Dropdown && element.Dropdown.dispose();
  parent = element.parentNode;
  menu = queryElement('.dropdown-menu', parent);
  Array.from(menu.children).map(function (child){
    child.children.length && (child.children[0].tagName === 'A' && menuItems.push(child.children[0]));
    child.tagName === 'A' && menuItems.push(child);
  });
  if ( !element.Dropdown ) {
    !('tabindex' in menu) && menu.setAttribute('tabindex', '0');
    element.addEventListener('click',clickHandler,false);
  }
  persist = option === true || element.getAttribute('data-persist') === 'true' || false;
  element.open = false;
  element.Dropdown = self;
}

function Modal(element,options) {
  options = options || {};
  var self = this, modal,
    showCustomEvent,
    shownCustomEvent,
    hideCustomEvent,
    hiddenCustomEvent,
    relatedTarget = null,
    scrollBarWidth,
    overlay,
    overlayDelay,
    fixedItems,
    ops = {};
  function setScrollbar() {
    var openModal = document.body.classList.contains('modal-open'),
        bodyPad = parseInt(getComputedStyle(document.body).paddingRight),
        bodyOverflow = document.documentElement.clientHeight !== document.documentElement.scrollHeight
                    || document.body.clientHeight !== document.body.scrollHeight,
        modalOverflow = modal.clientHeight !== modal.scrollHeight;
    scrollBarWidth = measureScrollbar();
    modal.style.paddingRight = !modalOverflow && scrollBarWidth ? (scrollBarWidth + "px") : '';
    document.body.style.paddingRight = modalOverflow || bodyOverflow ? ((bodyPad + (openModal ? 0:scrollBarWidth)) + "px") : '';
    fixedItems.length && fixedItems.map(function (fixed){
      var itemPad = getComputedStyle(fixed).paddingRight;
      fixed.style.paddingRight = modalOverflow || bodyOverflow ? ((parseInt(itemPad) + (openModal?0:scrollBarWidth)) + "px") : ((parseInt(itemPad)) + "px");
    });
  }
  function resetScrollbar() {
    document.body.style.paddingRight = '';
    modal.style.paddingRight = '';
    fixedItems.length && fixedItems.map(function (fixed){
      fixed.style.paddingRight = '';
    });
  }
  function measureScrollbar() {
    var scrollDiv = document.createElement('div'), widthValue;
    scrollDiv.className = 'modal-scrollbar-measure';
    document.body.appendChild(scrollDiv);
    widthValue = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    return widthValue;
  }
  function createOverlay() {
    var newOverlay = document.createElement('div');
    overlay = queryElement('.modal-backdrop');
    if ( overlay === null ) {
      newOverlay.setAttribute('class', 'modal-backdrop' + (ops.animation ? ' fade' : ''));
      overlay = newOverlay;
      document.body.appendChild(overlay);
    }
    return overlay;
  }
  function removeOverlay () {
    overlay = queryElement('.modal-backdrop');
    if ( overlay && !document.getElementsByClassName('modal show')[0] ) {
      document.body.removeChild(overlay); overlay = null;
    }
    overlay === null && (document.body.classList.remove('modal-open'), resetScrollbar());
  }
  function toggleEvents(action) {
    action = action ? 'addEventListener' : 'removeEventListener';
    window[action]( 'resize', self.update, passiveHandler);
    modal[action]( 'click',dismissHandler,false);
    document[action]( 'keydown',keyHandler,false);
  }
  function beforeShow() {
    modal.style.display = 'block';
    setScrollbar();
    !document.getElementsByClassName('modal show')[0] && document.body.classList.add('modal-open');
    modal.classList.add('show');
    modal.setAttribute('aria-hidden', false);
    modal.classList.contains('fade') ? emulateTransitionEnd(modal, triggerShow) : triggerShow();
  }
  function triggerShow() {
    setFocus(modal);
    modal.isAnimating = false;
    toggleEvents(1);
    shownCustomEvent = bootstrapCustomEvent('shown', 'modal', relatedTarget);
    dispatchCustomEvent.call(modal, shownCustomEvent);
  }
  function triggerHide(force) {
    modal.style.display = '';
    element && (setFocus(element));
    overlay = queryElement('.modal-backdrop');
    if (force !== 1 && overlay && overlay.classList.contains('show') && !document.getElementsByClassName('modal show')[0]) {
      overlay.classList.remove('show');
      emulateTransitionEnd(overlay,removeOverlay);
    } else {
      removeOverlay();
    }
    toggleEvents();
    modal.isAnimating = false;
    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'modal');
    dispatchCustomEvent.call(modal, hiddenCustomEvent);
  }
  function clickHandler(e) {
    if ( modal.isAnimating ) { return; }
    var clickTarget = e.target,
        modalID = "#" + (modal.getAttribute('id')),
        targetAttrValue = clickTarget.getAttribute('data-target') || clickTarget.getAttribute('href'),
        elemAttrValue = element.getAttribute('data-target') || element.getAttribute('href');
    if ( !modal.classList.contains('show')
        && (clickTarget === element && targetAttrValue === modalID
        || element.contains(clickTarget) && elemAttrValue === modalID) ) {
      modal.modalTrigger = element;
      relatedTarget = element;
      self.show();
      e.preventDefault();
    }
  }
  function keyHandler(ref) {
    var which = ref.which;
    if (!modal.isAnimating && ops.keyboard && which == 27 && modal.classList.contains('show') ) {
      self.hide();
    }
  }
  function dismissHandler(e) {
    if ( modal.isAnimating ) { return; }
    var clickTarget = e.target,
        hasData = clickTarget.getAttribute('data-dismiss') === 'modal',
        parentWithData = clickTarget.closest('[data-dismiss="modal"]');
    if ( modal.classList.contains('show') && ( parentWithData || hasData
        || clickTarget === modal && ops.backdrop !== 'static' ) ) {
      self.hide(); relatedTarget = null;
      e.preventDefault();
    }
  }
  self.toggle = function () {
    if ( modal.classList.contains('show') ) {self.hide();} else {self.show();}
  };
  self.show = function () {
    if (modal.classList.contains('show') && !!modal.isAnimating ) {return}
    showCustomEvent = bootstrapCustomEvent('show', 'modal', relatedTarget);
    dispatchCustomEvent.call(modal, showCustomEvent);
    if ( showCustomEvent.defaultPrevented ) { return; }
    modal.isAnimating = true;
    var currentOpen = document.getElementsByClassName('modal show')[0];
    if (currentOpen && currentOpen !== modal) {
      currentOpen.modalTrigger && currentOpen.modalTrigger.Modal.hide();
      currentOpen.Modal && currentOpen.Modal.hide();
    }
    if ( ops.backdrop ) {
      overlay = createOverlay();
    }
    if ( overlay && !currentOpen && !overlay.classList.contains('show') ) {
      overlay.offsetWidth;
      overlayDelay = getElementTransitionDuration(overlay);
      overlay.classList.add('show');
    }
    !currentOpen ? setTimeout( beforeShow, overlay && overlayDelay ? overlayDelay:0 ) : beforeShow();
  };
  self.hide = function (force) {
    if ( !modal.classList.contains('show') ) {return}
    hideCustomEvent = bootstrapCustomEvent( 'hide', 'modal');
    dispatchCustomEvent.call(modal, hideCustomEvent);
    if ( hideCustomEvent.defaultPrevented ) { return; }
    modal.isAnimating = true;
    modal.classList.remove('show');
    modal.setAttribute('aria-hidden', true);
    modal.classList.contains('fade') && force !== 1 ? emulateTransitionEnd(modal, triggerHide) : triggerHide();
  };
  self.setContent = function (content) {
    queryElement('.modal-content',modal).innerHTML = content;
  };
  self.update = function () {
    if (modal.classList.contains('show')) {
      setScrollbar();
    }
  };
  self.dispose = function () {
    self.hide(1);
    if (element) {element.removeEventListener('click',clickHandler,false); delete element.Modal; }
    else {delete modal.Modal;}
  };
  element = queryElement(element);
  var checkModal = queryElement( element.getAttribute('data-target') || element.getAttribute('href') );
  modal = element.classList.contains('modal') ? element : checkModal;
  fixedItems = Array.from(document.getElementsByClassName('fixed-top'))
                    .concat(Array.from(document.getElementsByClassName('fixed-bottom')));
  if ( element.classList.contains('modal') ) { element = null; }
  element && element.Modal && element.Modal.dispose();
  modal && modal.Modal && modal.Modal.dispose();
  ops.keyboard = options.keyboard === false || modal.getAttribute('data-keyboard') === 'false' ? false : true;
  ops.backdrop = options.backdrop === 'static' || modal.getAttribute('data-backdrop') === 'static' ? 'static' : true;
  ops.backdrop = options.backdrop === false || modal.getAttribute('data-backdrop') === 'false' ? false : ops.backdrop;
  ops.animation = modal.classList.contains('fade') ? true : false;
  ops.content = options.content;
  modal.isAnimating = false;
  if ( element && !element.Modal ) {
    element.addEventListener('click',clickHandler,false);
  }
  if ( ops.content ) {
    self.setContent( ops.content.trim() );
  }
  if (element) {
    modal.modalTrigger = element;
    element.Modal = self;
  } else {
    modal.Modal = self;
  }
}

var mouseClickEvents = { down: 'mousedown', up: 'mouseup' };

function getScroll() {
  return {
    y : window.pageYOffset || document.documentElement.scrollTop,
    x : window.pageXOffset || document.documentElement.scrollLeft
  }
}

function styleTip(link,element,position,parent) {
  var tipPositions = /\b(top|bottom|left|right)+/,
      elementDimensions = { w : element.offsetWidth, h: element.offsetHeight },
      windowWidth = (document.documentElement.clientWidth || document.body.clientWidth),
      windowHeight = (document.documentElement.clientHeight || document.body.clientHeight),
      rect = link.getBoundingClientRect(),
      scroll = parent === document.body ? getScroll() : { x: parent.offsetLeft + parent.scrollLeft, y: parent.offsetTop + parent.scrollTop },
      linkDimensions = { w: rect.right - rect.left, h: rect.bottom - rect.top },
      isPopover = element.classList.contains('popover'),
      arrow = element.getElementsByClassName('arrow')[0],
      halfTopExceed = rect.top + linkDimensions.h/2 - elementDimensions.h/2 < 0,
      halfLeftExceed = rect.left + linkDimensions.w/2 - elementDimensions.w/2 < 0,
      halfRightExceed = rect.left + elementDimensions.w/2 + linkDimensions.w/2 >= windowWidth,
      halfBottomExceed = rect.top + elementDimensions.h/2 + linkDimensions.h/2 >= windowHeight,
      topExceed = rect.top - elementDimensions.h < 0,
      leftExceed = rect.left - elementDimensions.w < 0,
      bottomExceed = rect.top + elementDimensions.h + linkDimensions.h >= windowHeight,
      rightExceed = rect.left + elementDimensions.w + linkDimensions.w >= windowWidth;
  position = (position === 'left' || position === 'right') && leftExceed && rightExceed ? 'top' : position;
  position = position === 'top' && topExceed ? 'bottom' : position;
  position = position === 'bottom' && bottomExceed ? 'top' : position;
  position = position === 'left' && leftExceed ? 'right' : position;
  position = position === 'right' && rightExceed ? 'left' : position;
  var topPosition,
    leftPosition,
    arrowTop,
    arrowLeft,
    arrowWidth,
    arrowHeight;
  element.className.indexOf(position) === -1 && (element.className = element.className.replace(tipPositions,position));
  arrowWidth = arrow.offsetWidth; arrowHeight = arrow.offsetHeight;
  if ( position === 'left' || position === 'right' ) {
    if ( position === 'left' ) {
      leftPosition = rect.left + scroll.x - elementDimensions.w - ( isPopover ? arrowWidth : 0 );
    } else {
      leftPosition = rect.left + scroll.x + linkDimensions.w;
    }
    if (halfTopExceed) {
      topPosition = rect.top + scroll.y;
      arrowTop = linkDimensions.h/2 - arrowWidth;
    } else if (halfBottomExceed) {
      topPosition = rect.top + scroll.y - elementDimensions.h + linkDimensions.h;
      arrowTop = elementDimensions.h - linkDimensions.h/2 - arrowWidth;
    } else {
      topPosition = rect.top + scroll.y - elementDimensions.h/2 + linkDimensions.h/2;
      arrowTop = elementDimensions.h/2 - (isPopover ? arrowHeight*0.9 : arrowHeight/2);
    }
  } else if ( position === 'top' || position === 'bottom' ) {
    if ( position === 'top') {
      topPosition =  rect.top + scroll.y - elementDimensions.h - ( isPopover ? arrowHeight : 0 );
    } else {
      topPosition = rect.top + scroll.y + linkDimensions.h;
    }
    if (halfLeftExceed) {
      leftPosition = 0;
      arrowLeft = rect.left + linkDimensions.w/2 - arrowWidth;
    } else if (halfRightExceed) {
      leftPosition = windowWidth - elementDimensions.w*1.01;
      arrowLeft = elementDimensions.w - ( windowWidth - rect.left ) + linkDimensions.w/2 - arrowWidth/2;
    } else {
      leftPosition = rect.left + scroll.x - elementDimensions.w/2 + linkDimensions.w/2;
      arrowLeft = elementDimensions.w/2 - ( isPopover ? arrowWidth : arrowWidth/2 );
    }
  }
  element.style.top = topPosition + 'px';
  element.style.left = leftPosition + 'px';
  arrowTop && (arrow.style.top = arrowTop + 'px');
  arrowLeft && (arrow.style.left = arrowLeft + 'px');
}

function Popover(element,options) {
  options = options || {};
  var self = this;
  var popover = null,
      timer = 0,
      isIphone = /(iPhone|iPod|iPad)/.test(navigator.userAgent),
      titleString,
      contentString,
      ops = {};
  var triggerData,
      animationData,
      placementData,
      dismissibleData,
      delayData,
      containerData,
      closeBtn,
      showCustomEvent,
      shownCustomEvent,
      hideCustomEvent,
      hiddenCustomEvent,
      containerElement,
      containerDataElement,
      modal,
      navbarFixedTop,
      navbarFixedBottom,
      placementClass;
  function dismissibleHandler(e) {
    if (popover !== null && e.target === queryElement('.close',popover)) {
      self.hide();
    }
  }
  function getContents() {
    return {
      0 : options.title || element.getAttribute('data-title') || null,
      1 : options.content || element.getAttribute('data-content') || null
    }
  }
  function removePopover() {
    ops.container.removeChild(popover);
    timer = null; popover = null;
  }
  function createPopover() {
    titleString = getContents()[0] || null;
    contentString = getContents()[1];
    contentString = !!contentString ? contentString.trim() : null;
    popover = document.createElement('div');
    var popoverArrow = document.createElement('div');
    popoverArrow.classList.add('arrow');
    popover.appendChild(popoverArrow);
    if ( contentString !== null && ops.template === null ) {
      popover.setAttribute('role','tooltip');
      if (titleString !== null) {
        var popoverTitle = document.createElement('h3');
        popoverTitle.classList.add('popover-header');
        popoverTitle.innerHTML = ops.dismissible ? titleString + closeBtn : titleString;
        popover.appendChild(popoverTitle);
      }
      var popoverBodyMarkup = document.createElement('div');
      popoverBodyMarkup.classList.add('popover-body');
      popoverBodyMarkup.innerHTML = ops.dismissible && titleString === null ? contentString + closeBtn : contentString;
      popover.appendChild(popoverBodyMarkup);
    } else {
      var popoverTemplate = document.createElement('div');
      popoverTemplate.innerHTML = ops.template.trim();
      popover.className = popoverTemplate.firstChild.className;
      popover.innerHTML = popoverTemplate.firstChild.innerHTML;
      var popoverHeader = queryElement('.popover-header',popover),
          popoverBody = queryElement('.popover-body',popover);
      titleString && popoverHeader && (popoverHeader.innerHTML = titleString.trim());
      contentString && popoverBody && (popoverBody.innerHTML = contentString.trim());
    }
    ops.container.appendChild(popover);
    popover.style.display = 'block';
    !popover.classList.contains( 'popover') && popover.classList.add('popover');
    !popover.classList.contains( ops.animation) && popover.classList.add(ops.animation);
    !popover.classList.contains( placementClass) && popover.classList.add(placementClass);
  }
  function showPopover() {
    !popover.classList.contains('show') && ( popover.classList.add('show') );
  }
  function updatePopover() {
    styleTip(element, popover, ops.placement, ops.container);
  }
  function forceFocus () {
    if (popover === null) { element.focus(); }
  }
  function toggleEvents(action) {
    action = action ? 'addEventListener' : 'removeEventListener';
    if (ops.trigger === 'hover') {
      element[action]( mouseClickEvents.down, self.show );
      element[action]( mouseHoverEvents[0], self.show );
      if (!ops.dismissible) { element[action]( mouseHoverEvents[1], self.hide ); }
    } else if ('click' == ops.trigger) {
      element[action]( ops.trigger, self.toggle );
    } else if ('focus' == ops.trigger) {
      isIphone && element[action]( 'click', forceFocus, false );
      element[action]( ops.trigger, self.toggle );
    }
  }
  function touchHandler(e){
    if ( popover && popover.contains(e.target) || e.target === element || element.contains(e.target)) ; else {
      self.hide();
    }
  }
  function dismissHandlerToggle(action) {
    action = action ? 'addEventListener' : 'removeEventListener';
    if (ops.dismissible) {
      document[action]('click', dismissibleHandler, false );
    } else {
      'focus' == ops.trigger && element[action]( 'blur', self.hide );
      'hover' == ops.trigger && document[action]( 'touchstart', touchHandler, passiveHandler );
    }
    window[action]('resize', self.hide, passiveHandler );
  }
  function showTrigger() {
    dismissHandlerToggle(1);
    dispatchCustomEvent.call(element, shownCustomEvent);
  }
  function hideTrigger() {
    dismissHandlerToggle();
    removePopover();
    dispatchCustomEvent.call(element, hiddenCustomEvent);
  }
  self.toggle = function () {
    if (popover === null) { self.show(); }
    else { self.hide(); }
  };
  self.show = function () {
    clearTimeout(timer);
    timer = setTimeout( function () {
      if (popover === null) {
        dispatchCustomEvent.call(element, showCustomEvent);
        if ( showCustomEvent.defaultPrevented ) { return; }
        createPopover();
        updatePopover();
        showPopover();
        !!ops.animation ? emulateTransitionEnd(popover, showTrigger) : showTrigger();
      }
    }, 20 );
  };
  self.hide = function () {
    clearTimeout(timer);
    timer = setTimeout( function () {
      if (popover && popover !== null && popover.classList.contains('show')) {
        dispatchCustomEvent.call(element, hideCustomEvent);
        if ( hideCustomEvent.defaultPrevented ) { return; }
        popover.classList.remove('show');
        !!ops.animation ? emulateTransitionEnd(popover, hideTrigger) : hideTrigger();
      }
    }, ops.delay );
  };
  self.dispose = function () {
    self.hide();
    toggleEvents();
    delete element.Popover;
  };
  element = queryElement(element);
  element.Popover && element.Popover.dispose();
  triggerData = element.getAttribute('data-trigger');
  animationData = element.getAttribute('data-animation');
  placementData = element.getAttribute('data-placement');
  dismissibleData = element.getAttribute('data-dismissible');
  delayData = element.getAttribute('data-delay');
  containerData = element.getAttribute('data-container');
  closeBtn = '<button type="button" class="close">×</button>';
  showCustomEvent = bootstrapCustomEvent('show', 'popover');
  shownCustomEvent = bootstrapCustomEvent('shown', 'popover');
  hideCustomEvent = bootstrapCustomEvent('hide', 'popover');
  hiddenCustomEvent = bootstrapCustomEvent('hidden', 'popover');
  containerElement = queryElement(options.container);
  containerDataElement = queryElement(containerData);
  modal = element.closest('.modal');
  navbarFixedTop = element.closest('.fixed-top');
  navbarFixedBottom = element.closest('.fixed-bottom');
  ops.template = options.template ? options.template : null;
  ops.trigger = options.trigger ? options.trigger : triggerData || 'hover';
  ops.animation = options.animation && options.animation !== 'fade' ? options.animation : animationData || 'fade';
  ops.placement = options.placement ? options.placement : placementData || 'top';
  ops.delay = parseInt(options.delay || delayData) || 200;
  ops.dismissible = options.dismissible || dismissibleData === 'true' ? true : false;
  ops.container = containerElement ? containerElement
                          : containerDataElement ? containerDataElement
                          : navbarFixedTop ? navbarFixedTop
                          : navbarFixedBottom ? navbarFixedBottom
                          : modal ? modal : document.body;
  placementClass = "bs-popover-" + (ops.placement);
  var popoverContents = getContents();
  titleString = popoverContents[0];
  contentString = popoverContents[1];
  if ( !contentString && !ops.template ) { return; }
  if ( !element.Popover ) {
    toggleEvents(1);
  }
  element.Popover = self;
}

function ScrollSpy(element,options) {
  options = options || {};
  var self = this,
    vars,
    targetData,
    offsetData,
    spyTarget,
    scrollTarget,
    ops = {};
  function updateTargets(){
    var links = spyTarget.getElementsByTagName('A');
    if (vars.length !== links.length) {
      vars.items = [];
      vars.targets = [];
      Array.from(links).map(function (link){
        var href = link.getAttribute('href'),
          targetItem = href && href.charAt(0) === '#' && href.slice(-1) !== '#' && queryElement(href);
        if ( targetItem ) {
          vars.items.push(link);
          vars.targets.push(targetItem);
        }
      });
      vars.length = links.length;
    }
  }
  function updateItem(index) {
    var item = vars.items[index],
      targetItem = vars.targets[index],
      dropmenu = item.classList.contains('dropdown-item') && item.closest('.dropdown-menu'),
      dropLink = dropmenu && dropmenu.previousElementSibling,
      nextSibling = item.nextElementSibling,
      activeSibling = nextSibling && nextSibling.getElementsByClassName('active').length,
      targetRect = vars.isWindow && targetItem.getBoundingClientRect(),
      isActive = item.classList.contains('active') || false,
      topEdge = (vars.isWindow ? targetRect.top + vars.scrollOffset : targetItem.offsetTop) - ops.offset,
      bottomEdge = vars.isWindow ? targetRect.bottom + vars.scrollOffset - ops.offset
                 : vars.targets[index+1] ? vars.targets[index+1].offsetTop - ops.offset
                 : element.scrollHeight,
      inside = activeSibling || vars.scrollOffset >= topEdge && bottomEdge > vars.scrollOffset;
     if ( !isActive && inside ) {
      item.classList.add('active');
      if (dropLink && !dropLink.classList.contains('active') ) {
        dropLink.classList.add('active');
      }
      dispatchCustomEvent.call(element, bootstrapCustomEvent( 'activate', 'scrollspy', vars.items[index]));
    } else if ( isActive && !inside ) {
      item.classList.remove('active');
      if (dropLink && dropLink.classList.contains('active') && !item.parentNode.getElementsByClassName('active').length ) {
        dropLink.classList.remove('active');
      }
    } else if ( isActive && inside || !inside && !isActive ) {
      return;
    }
  }
  function updateItems() {
    updateTargets();
    vars.scrollOffset = vars.isWindow ? getScroll().y : element.scrollTop;
    vars.items.map(function (l,idx){ return updateItem(idx); });
  }
  function toggleEvents(action) {
    action = action ? 'addEventListener' : 'removeEventListener';
    scrollTarget[action]('scroll', self.refresh, passiveHandler );
    window[action]( 'resize', self.refresh, passiveHandler );
  }
  self.refresh = function () {
    updateItems();
  };
  self.dispose = function () {
    toggleEvents();
    delete element.ScrollSpy;
  };
  element = queryElement(element);
  element.ScrollSpy && element.ScrollSpy.dispose();
  targetData = element.getAttribute('data-target');
  offsetData = element.getAttribute('data-offset');
  spyTarget = queryElement(options.target || targetData);
  scrollTarget = element.offsetHeight < element.scrollHeight ? element : window;
  if (!spyTarget) { return }
  ops.target = spyTarget;
  ops.offset = parseInt(options.offset || offsetData) || 10;
  vars = {};
  vars.length = 0;
  vars.items = [];
  vars.targets = [];
  vars.isWindow = scrollTarget === window;
  if ( !element.ScrollSpy ) {
    toggleEvents(1);
  }
  self.refresh();
  element.ScrollSpy = self;
}

function Tab(element,options) {
  options = options || {};
  var self = this,
    heightData,
    tabs, dropdown,
    showCustomEvent,
    shownCustomEvent,
    hideCustomEvent,
    hiddenCustomEvent,
    next,
    tabsContentContainer = false,
    activeTab,
    activeContent,
    nextContent,
    containerHeight,
    equalContents,
    nextHeight,
    animateHeight;
  function triggerEnd() {
    tabsContentContainer.style.height = '';
    tabsContentContainer.classList.remove('collapsing');
    tabs.isAnimating = false;
  }
  function triggerShow() {
    if (tabsContentContainer) {
      if ( equalContents ) {
        triggerEnd();
      } else {
        setTimeout(function () {
          tabsContentContainer.style.height = nextHeight + "px";
          tabsContentContainer.offsetWidth;
          emulateTransitionEnd(tabsContentContainer, triggerEnd);
        },50);
      }
    } else {
      tabs.isAnimating = false;
    }
    shownCustomEvent = bootstrapCustomEvent('shown', 'tab', activeTab);
    dispatchCustomEvent.call(next, shownCustomEvent);
  }
  function triggerHide() {
    if (tabsContentContainer) {
      activeContent.style.float = 'left';
      nextContent.style.float = 'left';
      containerHeight = activeContent.scrollHeight;
    }
    showCustomEvent = bootstrapCustomEvent('show', 'tab', activeTab);
    hiddenCustomEvent = bootstrapCustomEvent('hidden', 'tab', next);
    dispatchCustomEvent.call(next, showCustomEvent);
    if ( showCustomEvent.defaultPrevented ) { return; }
    nextContent.classList.add('active');
    activeContent.classList.remove('active');
    if (tabsContentContainer) {
      nextHeight = nextContent.scrollHeight;
      equalContents = nextHeight === containerHeight;
      tabsContentContainer.classList.add('collapsing');
      tabsContentContainer.style.height = containerHeight + "px";
      tabsContentContainer.offsetHeight;
      activeContent.style.float = '';
      nextContent.style.float = '';
    }
    if ( nextContent.classList.contains('fade') ) {
      setTimeout(function () {
        nextContent.classList.add('show');
        emulateTransitionEnd(nextContent,triggerShow);
      },20);
    } else { triggerShow(); }
    dispatchCustomEvent.call(activeTab, hiddenCustomEvent);
  }
  function getActiveTab() {
    var activeTabs = tabs.getElementsByClassName('active'), activeTab;
    if ( activeTabs.length === 1 && !activeTabs[0].parentNode.classList.contains('dropdown') ) {
      activeTab = activeTabs[0];
    } else if ( activeTabs.length > 1 ) {
      activeTab = activeTabs[activeTabs.length-1];
    }
    return activeTab;
  }
  function getActiveContent() { return queryElement(getActiveTab().getAttribute('href')) }
  function clickHandler(e) {
    e.preventDefault();
    next = e.currentTarget;
    !tabs.isAnimating && self.show();
  }
  self.show = function () {
    next = next || element;
    if (!next.classList.contains('active')) {
      nextContent = queryElement(next.getAttribute('href'));
      activeTab = getActiveTab();
      activeContent = getActiveContent();
      hideCustomEvent = bootstrapCustomEvent( 'hide', 'tab', next);
      dispatchCustomEvent.call(activeTab, hideCustomEvent);
      if (hideCustomEvent.defaultPrevented) { return; }
      tabs.isAnimating = true;
      activeTab.classList.remove('active');
      activeTab.setAttribute('aria-selected','false');
      next.classList.add('active');
      next.setAttribute('aria-selected','true');
      if ( dropdown ) {
        if ( !element.parentNode.classList.contains('dropdown-menu') ) {
          if (dropdown.classList.contains('active')) { dropdown.classList.remove('active'); }
        } else {
          if (!dropdown.classList.contains('active')) { dropdown.classList.add('active'); }
        }
      }
      if (activeContent.classList.contains('fade')) {
        activeContent.classList.remove('show');
        emulateTransitionEnd(activeContent, triggerHide);
      } else { triggerHide(); }
    }
  };
  self.dispose = function () {
    element.removeEventListener('click',clickHandler,false);
    delete element.Tab;
  };
  element = queryElement(element);
  element.Tab && element.Tab.dispose();
  heightData = element.getAttribute('data-height');
  tabs = element.closest('.nav');
  dropdown = tabs && queryElement('.dropdown-toggle',tabs);
  animateHeight = !supportTransition || (options.height === false || heightData === 'false') ? false : true;
  tabs.isAnimating = false;
  if ( !element.Tab ) {
    element.addEventListener('click',clickHandler,false);
  }
  if (animateHeight) { tabsContentContainer = getActiveContent().parentNode; }
  element.Tab = self;
}

function Toast(element,options) {
  options = options || {};
  var self = this,
      toast, timer = 0,
      animationData,
      autohideData,
      delayData,
      showCustomEvent,
      hideCustomEvent,
      shownCustomEvent,
      hiddenCustomEvent,
      ops = {};
  function showComplete() {
    toast.classList.remove( 'showing' );
    toast.classList.add( 'show' );
    dispatchCustomEvent.call(toast,shownCustomEvent);
    if (ops.autohide) { self.hide(); }
  }
  function hideComplete() {
    toast.classList.add( 'hide' );
    dispatchCustomEvent.call(toast,hiddenCustomEvent);
  }
  function close () {
    toast.classList.remove('show' );
    ops.animation ? emulateTransitionEnd(toast, hideComplete) : hideComplete();
  }
  function disposeComplete() {
    clearTimeout(timer);
    element.removeEventListener('click',self.hide,false);
    delete element.Toast;
  }
  self.show = function () {
    if (toast && !toast.classList.contains('show')) {
      dispatchCustomEvent.call(toast,showCustomEvent);
      if (showCustomEvent.defaultPrevented) { return; }
      ops.animation && toast.classList.add( 'fade' );
      toast.classList.remove('hide' );
      toast.offsetWidth;
      toast.classList.add('showing' );
      ops.animation ? emulateTransitionEnd(toast, showComplete) : showComplete();
    }
  };
  self.hide = function (noTimer) {
    if (toast && toast.classList.contains('show')) {
      dispatchCustomEvent.call(toast,hideCustomEvent);
      if(hideCustomEvent.defaultPrevented) { return; }
      noTimer ? close() : (timer = setTimeout( close, ops.delay));
    }
  };
  self.dispose = function () {
    ops.animation ? emulateTransitionEnd(toast, disposeComplete) : disposeComplete();
  };
  element = queryElement(element);
  element.Toast && element.Toast.dispose();
  toast = element.closest('.toast');
  animationData = element.getAttribute('data-animation');
  autohideData = element.getAttribute('data-autohide');
  delayData = element.getAttribute('data-delay');
  showCustomEvent = bootstrapCustomEvent('show', 'toast');
  hideCustomEvent = bootstrapCustomEvent('hide', 'toast');
  shownCustomEvent = bootstrapCustomEvent('shown', 'toast');
  hiddenCustomEvent = bootstrapCustomEvent('hidden', 'toast');
  ops.animation = options.animation === false || animationData === 'false' ? 0 : 1;
  ops.autohide = options.autohide === false || autohideData === 'false' ? 0 : 1;
  ops.delay = parseInt(options.delay || delayData) || 500;
  if ( !element.Toast ) {
    element.addEventListener('click',self.hide,false);
  }
  element.Toast = self;
}

function Tooltip(element,options) {
  options = options || {};
  var self = this,
      tooltip = null, timer = 0, titleString,
      animationData,
      placementData,
      delayData,
      containerData,
      showCustomEvent,
      shownCustomEvent,
      hideCustomEvent,
      hiddenCustomEvent,
      containerElement,
      containerDataElement,
      modal,
      navbarFixedTop,
      navbarFixedBottom,
      placementClass,
      ops = {};
  function getTitle() {
    return element.getAttribute('title')
        || element.getAttribute('data-title')
        || element.getAttribute('data-original-title')
  }
  function removeToolTip() {
    ops.container.removeChild(tooltip);
    tooltip = null; timer = null;
  }
  function createToolTip() {
    titleString = getTitle();
    if ( titleString ) {
      tooltip = document.createElement('div');
      if (ops.template) {
        var tooltipMarkup = document.createElement('div');
        tooltipMarkup.innerHTML = ops.template.trim();
        tooltip.className = tooltipMarkup.firstChild.className;
        tooltip.innerHTML = tooltipMarkup.firstChild.innerHTML;
        queryElement('.tooltip-inner',tooltip).innerHTML = titleString.trim();
      } else {
        var tooltipArrow = document.createElement('div');
        tooltipArrow.classList.add('arrow');
        tooltip.appendChild(tooltipArrow);
        var tooltipInner = document.createElement('div');
        tooltipInner.classList.add('tooltip-inner');
        tooltip.appendChild(tooltipInner);
        tooltipInner.innerHTML = titleString;
      }
      tooltip.style.left = '0';
      tooltip.style.top = '0';
      tooltip.setAttribute('role','tooltip');
      !tooltip.classList.contains('tooltip') && tooltip.classList.add('tooltip');
      !tooltip.classList.contains(ops.animation) && tooltip.classList.add(ops.animation);
      !tooltip.classList.contains(placementClass) && tooltip.classList.add(placementClass);
      ops.container.appendChild(tooltip);
    }
  }
  function updateTooltip() {
    styleTip(element, tooltip, ops.placement, ops.container);
  }
  function showTooltip() {
    !tooltip.classList.contains('show') && ( tooltip.classList.add('show') );
  }
  function touchHandler(e){
    if ( tooltip && tooltip.contains(e.target) || e.target === element || element.contains(e.target)) ; else {
      self.hide();
    }
  }
  function toggleAction(action){
    action = action ? 'addEventListener' : 'removeEventListener';
    document[action]( 'touchstart', touchHandler, passiveHandler );
    window[action]( 'resize', self.hide, passiveHandler );
  }
  function showAction() {
    toggleAction(1);
    dispatchCustomEvent.call(element, shownCustomEvent);
  }
  function hideAction() {
    toggleAction();
    removeToolTip();
    dispatchCustomEvent.call(element, hiddenCustomEvent);
  }
  function toggleEvents(action) {
    action = action ? 'addEventListener' : 'removeEventListener';
    element[action](mouseClickEvents.down, self.show,false);
    element[action](mouseHoverEvents[0], self.show,false);
    element[action](mouseHoverEvents[1], self.hide,false);
  }
  self.show = function () {
    clearTimeout(timer);
    timer = setTimeout( function () {
      if (tooltip === null) {
        dispatchCustomEvent.call(element, showCustomEvent);
        if (showCustomEvent.defaultPrevented) { return; }
        if(createToolTip() !== false) {
          updateTooltip();
          showTooltip();
          !!ops.animation ? emulateTransitionEnd(tooltip, showAction) : showAction();
        }
      }
    }, 20 );
  };
  self.hide = function () {
    clearTimeout(timer);
    timer = setTimeout( function () {
      if (tooltip && tooltip.classList.contains('show')) {
        dispatchCustomEvent.call(element, hideCustomEvent);
        if (hideCustomEvent.defaultPrevented) { return; }
        tooltip.classList.remove('show');
        !!ops.animation ? emulateTransitionEnd(tooltip, hideAction) : hideAction();
      }
    }, ops.delay);
  };
  self.toggle = function () {
    if (!tooltip) { self.show(); }
    else { self.hide(); }
  };
  self.dispose = function () {
    toggleEvents();
    self.hide();
    element.setAttribute('title', element.getAttribute('data-original-title'));
    element.removeAttribute('data-original-title');
    delete element.Tooltip;
  };
  element = queryElement(element);
  element.Tooltip && element.Tooltip.dispose();
  animationData = element.getAttribute('data-animation');
  placementData = element.getAttribute('data-placement');
  delayData = element.getAttribute('data-delay');
  containerData = element.getAttribute('data-container');
  showCustomEvent = bootstrapCustomEvent('show', 'tooltip');
  shownCustomEvent = bootstrapCustomEvent('shown', 'tooltip');
  hideCustomEvent = bootstrapCustomEvent('hide', 'tooltip');
  hiddenCustomEvent = bootstrapCustomEvent('hidden', 'tooltip');
  containerElement = queryElement(options.container);
  containerDataElement = queryElement(containerData);
  modal = element.closest('.modal');
  navbarFixedTop = element.closest('.fixed-top');
  navbarFixedBottom = element.closest('.fixed-bottom');
  ops.animation = options.animation && options.animation !== 'fade' ? options.animation : animationData || 'fade';
  ops.placement = options.placement ? options.placement : placementData || 'top';
  ops.template = options.template ? options.template : null;
  ops.delay = parseInt(options.delay || delayData) || 200;
  ops.container = containerElement ? containerElement
                          : containerDataElement ? containerDataElement
                          : navbarFixedTop ? navbarFixedTop
                          : navbarFixedBottom ? navbarFixedBottom
                          : modal ? modal : document.body;
  placementClass = "bs-tooltip-" + (ops.placement);
  titleString = getTitle();
  if ( !titleString ) { return; }
  if (!element.Tooltip) {
    element.setAttribute('data-original-title',titleString);
    element.removeAttribute('title');
    toggleEvents(1);
  }
  element.Tooltip = self;
}

var componentsInit = {};

function initializeDataAPI( Constructor, collection ){
  Array.from(collection).map(function (x){ return new Constructor(x); });
}
function initCallback(lookUp){
  lookUp = lookUp || document;
  for (var component in componentsInit) {
    initializeDataAPI( componentsInit[component][0], lookUp.querySelectorAll (componentsInit[component][1]) );
  }
}

componentsInit.Alert = [ Alert, '[data-dismiss="alert"]'];
componentsInit.Button = [ Button, '[data-toggle="buttons"]' ];
componentsInit.Carousel = [ Carousel, '[data-ride="carousel"]' ];
componentsInit.Collapse = [ Collapse, '[data-toggle="collapse"]' ];
componentsInit.Dropdown = [ Dropdown, '[data-toggle="dropdown"]'];
componentsInit.Modal = [ Modal, '[data-toggle="modal"]' ];
componentsInit.Popover = [ Popover, '[data-toggle="popover"],[data-tip="popover"]' ];
componentsInit.ScrollSpy = [ ScrollSpy, '[data-spy="scroll"]' ];
componentsInit.Tab = [ Tab, '[data-toggle="tab"]' ];
componentsInit.Toast = [ Toast, '[data-dismiss="toast"]' ];
componentsInit.Tooltip = [ Tooltip, '[data-toggle="tooltip"],[data-tip="tooltip"]' ];
document.body ? initCallback() : document.addEventListener( 'DOMContentLoaded', function initWrapper(){
	initCallback();
	document.removeEventListener('DOMContentLoaded',initWrapper,false);
}, false );

function removeElementDataAPI( ConstructorName, collection ){
  Array.from(collection).map(function (x){ return x[ConstructorName].dispose(); });
}
function removeDataAPI(lookUp) {
  lookUp = lookUp || document;
  for (var component in componentsInit) {
    removeElementDataAPI( component, lookUp.querySelectorAll (componentsInit[component][1]) );
  }
}

var version = "3.0.13";

var index = {
  Alert: Alert,
  Button: Button,
  Carousel: Carousel,
  Collapse: Collapse,
  Dropdown: Dropdown,
  Modal: Modal,
  Popover: Popover,
  ScrollSpy: ScrollSpy,
  Tab: Tab,
  Toast: Toast,
  Tooltip: Tooltip,
  initCallback: initCallback,
  removeDataAPI: removeDataAPI,
  componentsInit: componentsInit,
  Version: version
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! default exports */
/*! export Buffer [provided] [no usage info] [missing usage info prevents renaming] */
/*! export INSPECT_MAX_BYTES [provided] [no usage info] [missing usage info prevents renaming] */
/*! export SlowBuffer [provided] [no usage info] [missing usage info prevents renaming] */
/*! export kMaxLength [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__, __webpack_require__.g, __webpack_require__.* */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = __webpack_require__.g.TYPED_ARRAY_SUPPORT !== undefined
  ? __webpack_require__.g.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, module, __webpack_require__ */
/*! CommonJS bailout: module.exports.humanize(...) prevents optimization as module.exports is passed as call context at 142:8-31 */
/*! CommonJS bailout: exports is used directly at 245:37-44 */
/*! CommonJS bailout: module.exports is used directly at 245:0-14 */
/*! CommonJS bailout: module.exports is used directly at 247:21-35 */
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/*! CommonJS bailout: module.exports is used directly at 264:0-14 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/*! CommonJS bailout: module.exports is used directly at 56:0-14 */
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };
    var errorListener;

    // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.
    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}


/***/ }),

/***/ "./src/assets/images/obs-create-text-source.png":
/*!******************************************************!*\
  !*** ./src/assets/images/obs-create-text-source.png ***!
  \******************************************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__.r, __webpack_require__.p, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "images/obs-create-text-source.png");

/***/ }),

/***/ "./src/assets/images/obs-websocket-connection.png":
/*!********************************************************!*\
  !*** ./src/assets/images/obs-websocket-connection.png ***!
  \********************************************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__.r, __webpack_require__.p, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "images/obs-websocket-connection.png");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! default exports */
/*! export read [provided] [no usage info] [missing usage info prevents renaming] */
/*! export write [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/*! CommonJS bailout: module.exports is used directly at 3:2-16 */
/*! CommonJS bailout: module.exports is used directly at 18:2-16 */
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/*! CommonJS bailout: module.exports is used directly at 3:0-14 */
/***/ ((module) => {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/isomorphic-ws/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/isomorphic-ws/browser.js ***!
  \***********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__.g, __webpack_require__.* */
/*! CommonJS bailout: module.exports is used directly at 17:0-14 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js

var ws = null

if (typeof WebSocket !== 'undefined') {
  ws = WebSocket
} else if (typeof MozWebSocket !== 'undefined') {
  ws = MozWebSocket
} else if (typeof __webpack_require__.g !== 'undefined') {
  ws = __webpack_require__.g.WebSocket || __webpack_require__.g.MozWebSocket
} else if (typeof window !== 'undefined') {
  ws = window.WebSocket || window.MozWebSocket
} else if (typeof self !== 'undefined') {
  ws = self.WebSocket || self.MozWebSocket
}

module.exports = ws


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/*! CommonJS bailout: module.exports is used directly at 26:0-14 */
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/obs-websocket-js/lib/OBSWebSocket.js":
/*!***********************************************************!*\
  !*** ./node_modules/obs-websocket-js/lib/OBSWebSocket.js ***!
  \***********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/*! CommonJS bailout: module.exports is used directly at 93:0-14 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Socket = __webpack_require__(/*! ./Socket */ "./node_modules/obs-websocket-js/lib/Socket.js");
const Status = __webpack_require__(/*! ./Status */ "./node_modules/obs-websocket-js/lib/Status.js");
const debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('obs-websocket-js:Core');

let requestCounter = 0;

function generateMessageId() {
  return String(requestCounter++);
}

class OBSWebSocket extends Socket {
  /**
   * Generic Socket request method. Returns a promise.
   * Generates a messageId internally and will override any passed in the args.
   * Note that the requestType here is pre-marshaling and currently must match exactly what the websocket plugin is expecting.
   *
   * @param  {String}   requestType obs-websocket plugin expected request type.
   * @param  {Object}   [args={}]   request arguments.
   * @return {Promise}              Promise, passes the plugin response object.
   */
  send(requestType, args = {}) {
    args = args || {};

    return new Promise((resolve, reject) => {
      const messageId = generateMessageId();
      let rejectReason;

      if (!requestType) {
        rejectReason = Status.REQUEST_TYPE_NOT_SPECIFIED;
      }

      if (!this._connected) {
        rejectReason = Status.NOT_CONNECTED;
      }

      // Assign a temporary event listener for this particular messageId to uniquely identify the response.
      this.once(`obs:internal:message:id-${messageId}`, (err, data) => {
        if (err) {
          debug('[send:reject] %o', err);
          reject(err);
        } else {
          debug('[send:resolve] %o', data);
          resolve(data);
        }
      });

      // If we don't have a reason to fail fast, send the request to the socket.
      if (!rejectReason) {
        args['request-type'] = requestType;
        args['message-id'] = messageId;

        // Submit the request to the websocket.
        debug('[send] %s %s %o', messageId, requestType, args);
        try {
          this._socket.send(JSON.stringify(args));
        } catch (_) {
          // TODO: Consider inspecting the exception thrown to gleam some relevant info and pass that on.
          rejectReason = Status.SOCKET_EXCEPTION;
        }
      }

      // If the socket call was unsuccessful or bypassed, simulate its resolution.
      if (rejectReason) {
        this.emit(`obs:internal:message:id-${messageId}`, rejectReason);
      }
    });
  }

  /**
   * Generic Socket request method. Handles callbacks.
   * Internally calls `send` (which is promise-based). See `send`'s docs for more details.
   *
   * @param  {String}   requestType obs-websocket plugin expected request type.
   * @param  {Object}   [args={}]   request arguments.
   * @param  {Function} callback    Optional. callback(err, data)
   */
  sendCallback(requestType, args = {}, callback) { // eslint-disable-line default-param-last
    // Allow the `args` argument to be omitted.
    if (callback === undefined && typeof args === 'function') {
      callback = args;
      args = {};
    }

    // Perform the actual request, using `send`.
    this.send(requestType, args).then((...response) => {
      callback(null, ...response);
    }).catch(error => {
      callback(error);
    });
  }
}

module.exports = OBSWebSocket;


/***/ }),

/***/ "./node_modules/obs-websocket-js/lib/Socket.js":
/*!*****************************************************!*\
  !*** ./node_modules/obs-websocket-js/lib/Socket.js ***!
  \*****************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/*! CommonJS bailout: module.exports is used directly at 179:0-14 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const WebSocket = __webpack_require__(/*! isomorphic-ws */ "./node_modules/isomorphic-ws/browser.js");
const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const hash = __webpack_require__(/*! ./util/authenticationHashing */ "./node_modules/obs-websocket-js/lib/util/authenticationHashing.js");
const Status = __webpack_require__(/*! ./Status */ "./node_modules/obs-websocket-js/lib/Status.js");
const debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('obs-websocket-js:Socket');
const logAmbiguousError = __webpack_require__(/*! ./util/logAmbiguousError */ "./node_modules/obs-websocket-js/lib/util/logAmbiguousError.js");
const camelCaseKeys = __webpack_require__(/*! ./util/camelCaseKeys */ "./node_modules/obs-websocket-js/lib/util/camelCaseKeys.js");

class Socket extends EventEmitter {
  constructor() {
    super();
    this._connected = false;
    this._socket = undefined;

    const originalEmit = this.emit;
    this.emit = function (...args) {
      debug('[emit] %s err: %o data: %o', ...args);
      originalEmit.apply(this, args);
    };
  }

  async connect(args = {}) {
    args = args || {};
    const address = args.address || 'localhost:4444';

    if (this._socket) {
      try {
        // Blindly try to close the socket.
        // Don't care if its already closed.
        // We just don't want any sockets to leak.
        this._socket.close();
      } catch (error) {
        // These errors are probably safe to ignore, but debug log them just in case.
        debug('Failed to close previous WebSocket:', error.message);
      }
    }

    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      try {
        await this._connect(address, Boolean(args.secure));
        await this._authenticate(args.password);
        resolve();
      } catch (err) {
        this._socket.close();
        this._connected = false;
        logAmbiguousError(debug, 'Connection failed:', err);
        reject(err);
      }
    });
  }

  /**
   * Opens a WebSocket connection to an obs-websocket server, but does not attempt any authentication.
   *
   * @param {String} address url without ws:// or wss:// prefix.
   * @param {Boolean} secure whether to us ws:// or wss://
   * @returns {Promise}
   * @private
   * @return {Promise} on attempted creation of WebSocket connection.
   */
  async _connect(address, secure) {
    return new Promise((resolve, reject) => {
      let settled = false;

      debug('Attempting to connect to: %s (secure: %s)', address, secure);
      this._socket = new WebSocket((secure ? 'wss://' : 'ws://') + address);

      // We only handle the initial connection error.
      // Beyond that, the consumer is responsible for adding their own generic `error` event listener.
      // FIXME: Unsure how best to expose additional information about the WebSocket error.
      this._socket.onerror = err => {
        if (settled) {
          logAmbiguousError(debug, 'Unknown Socket Error', err);
          this.emit('error', err);
          return;
        }

        settled = true;
        logAmbiguousError(debug, 'Websocket Connection failed:', err);
        reject(Status.CONNECTION_ERROR);
      };

      this._socket.onopen = () => {
        if (settled) {
          return;
        }

        this._connected = true;
        settled = true;

        debug('Connection opened: %s', address);
        this.emit('ConnectionOpened');
        resolve();
      };

      // Looks like this should be bound. We don't technically cancel the connection when the authentication fails.
      this._socket.onclose = () => {
        this._connected = false;
        debug('Connection closed: %s', address);
        this.emit('ConnectionClosed');
      };

      // This handler must be present before we can call _authenticate.
      this._socket.onmessage = msg => {
        debug('[OnMessage]: %o', msg);
        const message = camelCaseKeys(JSON.parse(msg.data));
        let err;
        let data;

        if (message.status === 'error') {
          err = message;
        } else {
          data = message;
        }

        // Emit the message with ID if available, otherwise try to find a non-messageId driven event.
        if (message.messageId) {
          this.emit(`obs:internal:message:id-${message.messageId}`, err, data);
        } else if (message.updateType) {
          this.emit(message.updateType, data);
        } else {
          logAmbiguousError(debug, 'Unrecognized Socket Message:', message);
          this.emit('message', message);
        }
      };
    });
  }

  /**
   * Authenticates to an obs-websocket server. Must already have an active connection before calling this method.
   *
   * @param {String} [password=''] authentication string.
   * @private
   * @return {Promise} on resolution of authentication call.
   */
  async _authenticate(password = '') {
    if (!this._connected) {
      throw Status.NOT_CONNECTED;
    }

    const auth = await this.send('GetAuthRequired');

    if (!auth.authRequired) {
      debug('Authentication not Required');
      this.emit('AuthenticationSuccess');
      return Status.AUTH_NOT_REQUIRED;
    }

    try {
      await this.send('Authenticate', {
        auth: hash(auth.salt, auth.challenge, password)
      });
    } catch (e) {
      debug('Authentication Failure %o', e);
      this.emit('AuthenticationFailure');
      throw e;
    }

    debug('Authentication Success');
    this.emit('AuthenticationSuccess');
  }

  /**
   * Close and disconnect the WebSocket connection.
   * FIXME: this should support a callback and return a Promise to match the connect method.
   *
   * @function
   * @category request
   */
  disconnect() {
    debug('Disconnect requested.');
    if (this._socket) {
      this._socket.close();
    }
  }
}

module.exports = Socket;


/***/ }),

/***/ "./node_modules/obs-websocket-js/lib/Status.js":
/*!*****************************************************!*\
  !*** ./node_modules/obs-websocket-js/lib/Status.js ***!
  \*****************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/*! CommonJS bailout: module.exports is used directly at 1:0-14 */
/***/ ((module) => {

module.exports = {
  NOT_CONNECTED: {
    status: 'error',
    description: 'There is no Socket connection available.'
  },
  CONNECTION_ERROR: {
    status: 'error',
    description: 'Connection error.'
  },
  SOCKET_EXCEPTION: {
    status: 'error',
    description: 'An exception occurred from the underlying WebSocket.'
  },
  AUTH_NOT_REQUIRED: {
    status: 'ok',
    description: 'Authentication is not required.'
  },
  REQUEST_TYPE_NOT_SPECIFIED: {
    status: 'error',
    description: 'A Request Type was not specified.'
  },

  init() {
    for (const key in this) {
      if ({}.hasOwnProperty.call(this, key)) {
        // Assign a value to 'code' identified by the status' key.
        this[key].code = key;

        // Assign a value to 'error' if one is not already defined.
        if (this[key].status === 'error' && !this[key].error) {
          this[key].error = this[key].description;
        }
      }
    }

    delete this.init;
    return this;
  }
}.init();


/***/ }),

/***/ "./node_modules/obs-websocket-js/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/obs-websocket-js/lib/index.js ***!
  \****************************************************/
/*! dynamic exports */
/*! export __esModule [maybe provided (runtime-defined)] [no usage info] [provision prevents renaming (no use info)] -> ./node_modules/obs-websocket-js/lib/OBSWebSocket.js .__esModule */
/*! other exports [maybe provided (runtime-defined)] [no usage info] -> ./node_modules/obs-websocket-js/lib/OBSWebSocket.js */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./OBSWebSocket.js */ "./node_modules/obs-websocket-js/lib/OBSWebSocket.js");


/***/ }),

/***/ "./node_modules/obs-websocket-js/lib/util/authenticationHashing.js":
/*!*************************************************************************!*\
  !*** ./node_modules/obs-websocket-js/lib/util/authenticationHashing.js ***!
  \*************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/*! CommonJS bailout: module.exports is used directly at 12:0-14 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SHA256 = __webpack_require__(/*! sha.js/sha256 */ "./node_modules/sha.js/sha256.js");

/**
 * SHA256 Hashing.
 *
 * @param  {String} [salt=''] salt.
 * @param  {String} [challenge=''] challenge.
 * @param  {String} msg Message to encode.
 * @return {String} sha256 encoded string.
 */
// eslint-disable-next-line default-param-last
module.exports = function (salt = '', challenge = '', msg) {
  const hash = new SHA256()
    .update(msg)
    .update(salt)
    .digest('base64');

  const resp = new SHA256()
    .update(hash)
    .update(challenge)
    .digest('base64');

  return resp;
};


/***/ }),

/***/ "./node_modules/obs-websocket-js/lib/util/camelCaseKeys.js":
/*!*****************************************************************!*\
  !*** ./node_modules/obs-websocket-js/lib/util/camelCaseKeys.js ***!
  \*****************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/*! CommonJS bailout: module.exports is used directly at 8:0-14 */
/***/ ((module) => {

/**
 * Converts kebab-case to camelCase.
 * Retains the original kebab-case entries.
 *
 * @param {Object} [obj={}] Keyed object.
 * @return {Object} Keyed object with added camelCased keys.
 */
module.exports = function (obj) {
  obj = obj || {};
  for (const key in obj) {
    if (!{}.hasOwnProperty.call(obj, key)) {
      continue;
    }

    const camelCasedKey = key.replace(/-([a-z])/gi, ($0, $1) => {
      return $1.toUpperCase();
    });
    obj[camelCasedKey] = obj[key];
  }

  return obj;
};


/***/ }),

/***/ "./node_modules/obs-websocket-js/lib/util/logAmbiguousError.js":
/*!*********************************************************************!*\
  !*** ./node_modules/obs-websocket-js/lib/util/logAmbiguousError.js ***!
  \*********************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/*! CommonJS bailout: module.exports is used directly at 10:0-14 */
/***/ ((module) => {

/**
 * Disambiguates an "error" and formats it nicely for `debug` output.
 * Particularly useful when dealing with error response objects from obs-websocket,
 * which are not actual Error-type errors, but simply Objects.
 *
 * @param {Object} debug A `debug` instance.
 * @param {String} prefix A string to print in front of the formatted error.
 * @param {Object|Error} error An error of ambiguous type that you wish to log to `debug`. Can be an Error, Object, or String.
 */
module.exports = function (debug, prefix, error) {
  if (error && error.stack) {
    debug(`${prefix}\n %O`, error.stack);
  } else if (typeof error === 'object') {
    debug(`${prefix} %o`, error);
  } else {
    debug(`${prefix} %s`, error);
  }
};


/***/ }),

/***/ "./node_modules/riot/riot.esm.js":
/*!***************************************!*\
  !*** ./node_modules/riot/riot.esm.js ***!
  \***************************************/
/*! namespace exports */
/*! export __ [provided] [no usage info] [missing usage info prevents renaming] */
/*! export component [provided] [no usage info] [missing usage info prevents renaming] */
/*! export install [provided] [no usage info] [missing usage info prevents renaming] */
/*! export mount [provided] [no usage info] [missing usage info prevents renaming] */
/*! export pure [provided] [no usage info] [missing usage info prevents renaming] */
/*! export register [provided] [no usage info] [missing usage info prevents renaming] */
/*! export uninstall [provided] [no usage info] [missing usage info prevents renaming] */
/*! export unmount [provided] [no usage info] [missing usage info prevents renaming] */
/*! export unregister [provided] [no usage info] [missing usage info prevents renaming] */
/*! export version [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__": () => /* binding */ __,
/* harmony export */   "component": () => /* binding */ component,
/* harmony export */   "install": () => /* binding */ install,
/* harmony export */   "mount": () => /* binding */ mount,
/* harmony export */   "pure": () => /* binding */ pure,
/* harmony export */   "register": () => /* binding */ register,
/* harmony export */   "uninstall": () => /* binding */ uninstall,
/* harmony export */   "unmount": () => /* binding */ unmount,
/* harmony export */   "unregister": () => /* binding */ unregister,
/* harmony export */   "version": () => /* binding */ version
/* harmony export */ });
/* Riot v5.0.0, @license MIT */
/**
 * Convert a string from camel case to dash-case
 * @param   {string} string - probably a component tag name
 * @returns {string} component name normalized
 */
function camelToDashCase(string) {
  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
/**
 * Convert a string containing dashes to camel case
 * @param   {string} string - input string
 * @returns {string} my-string -> myString
 */

function dashToCamelCase(string) {
  return string.replace(/-(\w)/g, (_, c) => c.toUpperCase());
}

/**
 * Get all the element attributes as object
 * @param   {HTMLElement} element - DOM node we want to parse
 * @returns {Object} all the attributes found as a key value pairs
 */

function DOMattributesToObject(element) {
  return Array.from(element.attributes).reduce((acc, attribute) => {
    acc[dashToCamelCase(attribute.name)] = attribute.value;
    return acc;
  }, {});
}
/**
 * Move all the child nodes from a source tag to another
 * @param   {HTMLElement} source - source node
 * @param   {HTMLElement} target - target node
 * @returns {undefined} it's a void method ¯\_(ツ)_/¯
 */
// Ignore this helper because it's needed only for svg tags

function moveChildren(source, target) {
  if (source.firstChild) {
    target.appendChild(source.firstChild);
    moveChildren(source, target);
  }
}
/**
 * Remove the child nodes from any DOM node
 * @param   {HTMLElement} node - target node
 * @returns {undefined}
 */

function cleanNode(node) {
  clearChildren(node.childNodes);
}
/**
 * Clear multiple children in a node
 * @param   {HTMLElement[]} children - direct children nodes
 * @returns {undefined}
 */

function clearChildren(children) {
  Array.from(children).forEach(removeChild);
}
/**
 * Remove a node
 * @param {HTMLElement}node - node to remove
 * @returns {undefined}
 */

const removeChild = node => node && node.parentNode && node.parentNode.removeChild(node);
/**
 * Insert before a node
 * @param {HTMLElement} newNode - node to insert
 * @param {HTMLElement} refNode - ref child
 * @returns {undefined}
 */

const insertBefore = (newNode, refNode) => refNode && refNode.parentNode && refNode.parentNode.insertBefore(newNode, refNode);
/**
 * Replace a node
 * @param {HTMLElement} newNode - new node to add to the DOM
 * @param {HTMLElement} replaced - node to replace
 * @returns {undefined}
 */

const replaceChild = (newNode, replaced) => replaced && replaced.parentNode && replaced.parentNode.replaceChild(newNode, replaced);

const EACH = 0;
const IF = 1;
const SIMPLE = 2;
const TAG = 3;
const SLOT = 4;
var bindingTypes = {
  EACH,
  IF,
  SIMPLE,
  TAG,
  SLOT
};

const ATTRIBUTE = 0;
const EVENT = 1;
const TEXT = 2;
const VALUE = 3;
var expressionTypes = {
  ATTRIBUTE,
  EVENT,
  TEXT,
  VALUE
};

/**
 * Create the template meta object in case of <template> fragments
 * @param   {TemplateChunk} componentTemplate - template chunk object
 * @returns {Object} the meta property that will be passed to the mount function of the TemplateChunk
 */
function createTemplateMeta(componentTemplate) {
  const fragment = componentTemplate.dom.cloneNode(true);
  return {
    avoidDOMInjection: true,
    fragment,
    children: Array.from(fragment.childNodes)
  };
}

/**
 * Quick type checking
 * @param   {*} element - anything
 * @param   {string} type - type definition
 * @returns {boolean} true if the type corresponds
 */
function checkType(element, type) {
  return typeof element === type;
}
/**
 * Check if an element is part of an svg
 * @param   {HTMLElement}  el - element to check
 * @returns {boolean} true if we are in an svg context
 */

function isSvg(el) {
  const owner = el.ownerSVGElement;
  return !!owner || owner === null;
}
/**
 * Check if an element is a template tag
 * @param   {HTMLElement}  el - element to check
 * @returns {boolean} true if it's a <template>
 */

function isTemplate(el) {
  return !isNil(el.content);
}
/**
 * Check that will be passed if its argument is a function
 * @param   {*} value - value to check
 * @returns {boolean} - true if the value is a function
 */

function isFunction(value) {
  return checkType(value, 'function');
}
/**
 * Check if a value is a Boolean
 * @param   {*}  value - anything
 * @returns {boolean} true only for the value is a boolean
 */

function isBoolean(value) {
  return checkType(value, 'boolean');
}
/**
 * Check if a value is an Object
 * @param   {*}  value - anything
 * @returns {boolean} true only for the value is an object
 */

function isObject(value) {
  return !isNil(value) && checkType(value, 'object');
}
/**
 * Check if a value is null or undefined
 * @param   {*}  value - anything
 * @returns {boolean} true only for the 'undefined' and 'null' types
 */

function isNil(value) {
  return value === null || value === undefined;
}

/**
 * ISC License
 *
 * Copyright (c) 2020, Andrea Giammarchi, @WebReflection
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
// fork of https://github.com/WebReflection/udomdiff version 1.1.0
// due to https://github.com/WebReflection/udomdiff/pull/2

/* eslint-disable */

/**
 * @param {Node} parentNode The container where children live
 * @param {Node[]} a The list of current/live children
 * @param {Node[]} b The list of future children
 * @param {(entry: Node, action: number) => Node} get
 * The callback invoked per each entry related DOM operation.
 * @param {Node} [before] The optional node used as anchor to insert before.
 * @returns {Node[]} The same list of future children.
 */

var udomdiff = ((parentNode, a, b, get, before) => {
  const bLength = b.length;
  let aEnd = a.length;
  let bEnd = bLength;
  let aStart = 0;
  let bStart = 0;
  let map = null;

  while (aStart < aEnd || bStart < bEnd) {
    // append head, tail, or nodes in between: fast path
    if (aEnd === aStart) {
      // we could be in a situation where the rest of nodes that
      // need to be added are not at the end, and in such case
      // the node to `insertBefore`, if the index is more than 0
      // must be retrieved, otherwise it's gonna be the first item.
      const node = bEnd < bLength ? bStart ? get(b[bStart - 1], -0).nextSibling : get(b[bEnd - bStart], 0) : before;

      while (bStart < bEnd) insertBefore(get(b[bStart++], 1), node);
    } // remove head or tail: fast path
    else if (bEnd === bStart) {
        while (aStart < aEnd) {
          // remove the node only if it's unknown or not live
          if (!map || !map.has(a[aStart])) removeChild(get(a[aStart], -1));
          aStart++;
        }
      } // same node: fast path
      else if (a[aStart] === b[bStart]) {
          aStart++;
          bStart++;
        } // same tail: fast path
        else if (a[aEnd - 1] === b[bEnd - 1]) {
            aEnd--;
            bEnd--;
          } // The once here single last swap "fast path" has been removed in v1.1.0
          // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85
          // reverse swap: also fast path
          else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
              // this is a "shrink" operation that could happen in these cases:
              // [1, 2, 3, 4, 5]
              // [1, 4, 3, 2, 5]
              // or asymmetric too
              // [1, 2, 3, 4, 5]
              // [1, 2, 3, 5, 6, 4]
              const node = get(a[--aEnd], -1).nextSibling;
              insertBefore(get(b[bStart++], 1), get(a[aStart++], -1).nextSibling);
              insertBefore(get(b[--bEnd], 1), node); // mark the future index as identical (yeah, it's dirty, but cheap 👍)
              // The main reason to do this, is that when a[aEnd] will be reached,
              // the loop will likely be on the fast path, as identical to b[bEnd].
              // In the best case scenario, the next loop will skip the tail,
              // but in the worst one, this node will be considered as already
              // processed, bailing out pretty quickly from the map index check

              a[aEnd] = b[bEnd];
            } // map based fallback, "slow" path
            else {
                // the map requires an O(bEnd - bStart) operation once
                // to store all future nodes indexes for later purposes.
                // In the worst case scenario, this is a full O(N) cost,
                // and such scenario happens at least when all nodes are different,
                // but also if both first and last items of the lists are different
                if (!map) {
                  map = new Map();
                  let i = bStart;

                  while (i < bEnd) map.set(b[i], i++);
                } // if it's a future node, hence it needs some handling


                if (map.has(a[aStart])) {
                  // grab the index of such node, 'cause it might have been processed
                  const index = map.get(a[aStart]); // if it's not already processed, look on demand for the next LCS

                  if (bStart < index && index < bEnd) {
                    let i = aStart; // counts the amount of nodes that are the same in the future

                    let sequence = 1;

                    while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence) sequence++; // effort decision here: if the sequence is longer than replaces
                    // needed to reach such sequence, which would brings again this loop
                    // to the fast path, prepend the difference before a sequence,
                    // and move only the future list index forward, so that aStart
                    // and bStart will be aligned again, hence on the fast path.
                    // An example considering aStart and bStart are both 0:
                    // a: [1, 2, 3, 4]
                    // b: [7, 1, 2, 3, 6]
                    // this would place 7 before 1 and, from that time on, 1, 2, and 3
                    // will be processed at zero cost


                    if (sequence > index - bStart) {
                      const node = get(a[aStart], 0);

                      while (bStart < index) insertBefore(get(b[bStart++], 1), node);
                    } // if the effort wasn't good enough, fallback to a replace,
                    // moving both source and target indexes forward, hoping that some
                    // similar node will be found later on, to go back to the fast path
                    else {
                        replaceChild(get(b[bStart++], 1), get(a[aStart++], -1));
                      }
                  } // otherwise move the source forward, 'cause there's nothing to do
                  else aStart++;
                } // this node has no meaning in the future list, so it's more than safe
                // to remove it, and check the next live node out instead, meaning
                // that only the live list index should be forwarded
                else removeChild(get(a[aStart++], -1));
              }
  }

  return b;
});

const UNMOUNT_SCOPE = Symbol('unmount');
const EachBinding = Object.seal({
  // dynamic binding properties
  // childrenMap: null,
  // node: null,
  // root: null,
  // condition: null,
  // evaluate: null,
  // template: null,
  // isTemplateTag: false,
  nodes: [],

  // getKey: null,
  // indexName: null,
  // itemName: null,
  // afterPlaceholder: null,
  // placeholder: null,
  // API methods
  mount(scope, parentScope) {
    return this.update(scope, parentScope);
  },

  update(scope, parentScope) {
    const {
      placeholder,
      nodes,
      childrenMap
    } = this;
    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);
    const items = collection ? Array.from(collection) : [];
    const parent = placeholder.parentNode; // prepare the diffing

    const {
      newChildrenMap,
      batches,
      futureNodes
    } = createPatch(items, scope, parentScope, this); // patch the DOM only if there are new nodes

    udomdiff(parent, nodes, futureNodes, patch(Array.from(childrenMap.values()), parentScope), placeholder); // trigger the mounts and the updates

    batches.forEach(fn => fn()); // update the children map

    this.childrenMap = newChildrenMap;
    this.nodes = futureNodes;
    return this;
  },

  unmount(scope, parentScope) {
    this.update(UNMOUNT_SCOPE, parentScope);
    return this;
  }

});
/**
 * Patch the DOM while diffing
 * @param   {TemplateChunk[]} redundant - redundant tepmplate chunks
 * @param   {*} parentScope - scope of the parent template
 * @returns {Function} patch function used by domdiff
 */

function patch(redundant, parentScope) {
  return (item, info) => {
    if (info < 0) {
      const element = redundant.pop();

      if (element) {
        const {
          template,
          context
        } = element; // notice that we pass null as last argument because
        // the root node and its children will be removed by domdiff

        template.unmount(context, parentScope, null);
      }
    }

    return item;
  };
}
/**
 * Check whether a template must be filtered from a loop
 * @param   {Function} condition - filter function
 * @param   {Object} context - argument passed to the filter function
 * @returns {boolean} true if this item should be skipped
 */


function mustFilterItem(condition, context) {
  return condition ? Boolean(condition(context)) === false : false;
}
/**
 * Extend the scope of the looped template
 * @param   {Object} scope - current template scope
 * @param   {string} options.itemName - key to identify the looped item in the new context
 * @param   {string} options.indexName - key to identify the index of the looped item
 * @param   {number} options.index - current index
 * @param   {*} options.item - collection item looped
 * @returns {Object} enhanced scope object
 */


function extendScope(scope, _ref) {
  let {
    itemName,
    indexName,
    index,
    item
  } = _ref;
  scope[itemName] = item;
  if (indexName) scope[indexName] = index;
  return scope;
}
/**
 * Loop the current template items
 * @param   {Array} items - expression collection value
 * @param   {*} scope - template scope
 * @param   {*} parentScope - scope of the parent template
 * @param   {EeachBinding} binding - each binding object instance
 * @returns {Object} data
 * @returns {Map} data.newChildrenMap - a Map containing the new children template structure
 * @returns {Array} data.batches - array containing the template lifecycle functions to trigger
 * @returns {Array} data.futureNodes - array containing the nodes we need to diff
 */


function createPatch(items, scope, parentScope, binding) {
  const {
    condition,
    template,
    childrenMap,
    itemName,
    getKey,
    indexName,
    root,
    isTemplateTag
  } = binding;
  const newChildrenMap = new Map();
  const batches = [];
  const futureNodes = [];
  items.forEach((item, index) => {
    const context = extendScope(Object.create(scope), {
      itemName,
      indexName,
      index,
      item
    });
    const key = getKey ? getKey(context) : index;
    const oldItem = childrenMap.get(key);

    if (mustFilterItem(condition, context)) {
      return;
    }

    const componentTemplate = oldItem ? oldItem.template : template.clone();
    const el = oldItem ? componentTemplate.el : root.cloneNode();
    const mustMount = !oldItem;
    const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : {};

    if (mustMount) {
      batches.push(() => componentTemplate.mount(el, context, parentScope, meta));
    } else {
      batches.push(() => componentTemplate.update(context, parentScope));
    } // create the collection of nodes to update or to add
    // in case of template tags we need to add all its children nodes


    if (isTemplateTag) {
      const children = meta.children || componentTemplate.children;
      futureNodes.push(...children);
    } else {
      futureNodes.push(el);
    } // delete the old item from the children map


    childrenMap.delete(key); // update the children map

    newChildrenMap.set(key, {
      template: componentTemplate,
      context,
      index
    });
  });
  return {
    newChildrenMap,
    batches,
    futureNodes
  };
}

function create(node, _ref2) {
  let {
    evaluate,
    condition,
    itemName,
    indexName,
    getKey,
    template
  } = _ref2;
  const placeholder = document.createTextNode('');
  const root = node.cloneNode();
  insertBefore(placeholder, node);
  removeChild(node);
  return Object.assign({}, EachBinding, {
    childrenMap: new Map(),
    node,
    root,
    condition,
    evaluate,
    isTemplateTag: isTemplate(root),
    template: template.createDOM(node),
    getKey,
    indexName,
    itemName,
    placeholder
  });
}

/**
 * Binding responsible for the `if` directive
 */

const IfBinding = Object.seal({
  // dynamic binding properties
  // node: null,
  // evaluate: null,
  // isTemplateTag: false,
  // placeholder: null,
  // template: null,
  // API methods
  mount(scope, parentScope) {
    return this.update(scope, parentScope);
  },

  update(scope, parentScope) {
    const value = !!this.evaluate(scope);
    const mustMount = !this.value && value;
    const mustUnmount = this.value && !value;

    const mount = () => {
      const pristine = this.node.cloneNode();
      insertBefore(pristine, this.placeholder);
      this.template = this.template.clone();
      this.template.mount(pristine, scope, parentScope);
    };

    switch (true) {
      case mustMount:
        mount();
        break;

      case mustUnmount:
        this.unmount(scope);
        break;

      default:
        if (value) this.template.update(scope, parentScope);
    }

    this.value = value;
    return this;
  },

  unmount(scope, parentScope) {
    this.template.unmount(scope, parentScope, true);
    return this;
  }

});
function create$1(node, _ref) {
  let {
    evaluate,
    template
  } = _ref;
  const placeholder = document.createTextNode('');
  insertBefore(placeholder, node);
  removeChild(node);
  return Object.assign({}, IfBinding, {
    node,
    evaluate,
    placeholder,
    template: template.createDOM(node)
  });
}

/**
 * Throw an error with a descriptive message
 * @param   { string } message - error message
 * @returns { undefined } hoppla.. at this point the program should stop working
 */

function panic(message) {
  throw new Error(message);
}
/**
 * Returns the memoized (cached) function.
 * // borrowed from https://www.30secondsofcode.org/js/s/memoize
 * @param {Function} fn - function to memoize
 * @returns {Function} memoize function
 */

function memoize(fn) {
  const cache = new Map();

  const cached = val => {
    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);
  };

  cached.cache = cache;
  return cached;
}
/**
 * Evaluate a list of attribute expressions
 * @param   {Array} attributes - attribute expressions generated by the riot compiler
 * @returns {Object} key value pairs with the result of the computation
 */

function evaluateAttributeExpressions(attributes) {
  return attributes.reduce((acc, attribute) => {
    const {
      value,
      type
    } = attribute;

    switch (true) {
      // spread attribute
      case !attribute.name && type === ATTRIBUTE:
        return Object.assign({}, acc, value);
      // value attribute

      case type === VALUE:
        acc.value = attribute.value;
        break;
      // normal attributes

      default:
        acc[dashToCamelCase(attribute.name)] = attribute.value;
    }

    return acc;
  }, {});
}

const REMOVE_ATTRIBUTE = 'removeAttribute';
const SET_ATTIBUTE = 'setAttribute';
const ElementProto = typeof Element === 'undefined' ? {} : Element.prototype;
const isNativeHtmlProperty = memoize(name => ElementProto.hasOwnProperty(name)); // eslint-disable-line

/**
 * Add all the attributes provided
 * @param   {HTMLElement} node - target node
 * @param   {Object} attributes - object containing the attributes names and values
 * @returns {undefined} sorry it's a void function :(
 */

function setAllAttributes(node, attributes) {
  Object.entries(attributes).forEach((_ref) => {
    let [name, value] = _ref;
    return attributeExpression(node, {
      name
    }, value);
  });
}
/**
 * Remove all the attributes provided
 * @param   {HTMLElement} node - target node
 * @param   {Object} newAttributes - object containing all the new attribute names
 * @param   {Object} oldAttributes - object containing all the old attribute names
 * @returns {undefined} sorry it's a void function :(
 */


function removeAllAttributes(node, newAttributes, oldAttributes) {
  const newKeys = newAttributes ? Object.keys(newAttributes) : [];
  Object.keys(oldAttributes).filter(name => !newKeys.includes(name)).forEach(attribute => node.removeAttribute(attribute));
}
/**
 * This methods handles the DOM attributes updates
 * @param   {HTMLElement} node - target node
 * @param   {Object} expression - expression object
 * @param   {string} expression.name - attribute name
 * @param   {*} value - new expression value
 * @param   {*} oldValue - the old expression cached value
 * @returns {undefined}
 */


function attributeExpression(node, _ref2, value, oldValue) {
  let {
    name
  } = _ref2;

  // is it a spread operator? {...attributes}
  if (!name) {
    if (oldValue) {
      // remove all the old attributes
      removeAllAttributes(node, value, oldValue);
    } // is the value still truthy?


    if (value) {
      setAllAttributes(node, value);
    }

    return;
  } // handle boolean attributes


  if (!isNativeHtmlProperty(name) && (isBoolean(value) || isObject(value) || isFunction(value))) {
    node[name] = value;
  }

  node[getMethod(value)](name, normalizeValue(name, value));
}
/**
 * Get the attribute modifier method
 * @param   {*} value - if truthy we return `setAttribute` othewise `removeAttribute`
 * @returns {string} the node attribute modifier method name
 */

function getMethod(value) {
  return isNil(value) || value === false || value === '' || isObject(value) || isFunction(value) ? REMOVE_ATTRIBUTE : SET_ATTIBUTE;
}
/**
 * Get the value as string
 * @param   {string} name - attribute name
 * @param   {*} value - user input value
 * @returns {string} input value as string
 */


function normalizeValue(name, value) {
  // be sure that expressions like selected={ true } will be always rendered as selected='selected'
  if (value === true) return name;
  return value;
}

const RE_EVENTS_PREFIX = /^on/;

const getCallbackAndOptions = value => Array.isArray(value) ? value : [value, false]; // see also https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38


const EventListener = {
  handleEvent(event) {
    this[event.type](event);
  }

};
const ListenersWeakMap = new WeakMap();

const createListener = node => {
  const listener = Object.create(EventListener);
  ListenersWeakMap.set(node, listener);
  return listener;
};
/**
 * Set a new event listener
 * @param   {HTMLElement} node - target node
 * @param   {Object} expression - expression object
 * @param   {string} expression.name - event name
 * @param   {*} value - new expression value
 * @returns {value} the callback just received
 */


function eventExpression(node, _ref, value) {
  let {
    name
  } = _ref;
  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, '');
  const eventListener = ListenersWeakMap.get(node) || createListener(node);
  const [callback, options] = getCallbackAndOptions(value);
  const handler = eventListener[normalizedEventName];
  const mustRemoveEvent = handler && !callback;
  const mustAddEvent = callback && !handler;

  if (mustRemoveEvent) {
    node.removeEventListener(normalizedEventName, eventListener);
  }

  if (mustAddEvent) {
    node.addEventListener(normalizedEventName, eventListener, options);
  }

  eventListener[normalizedEventName] = callback;
}

/**
 * Normalize the user value in order to render a empty string in case of falsy values
 * @param   {*} value - user input value
 * @returns {string} hopefully a string
 */

function normalizeStringValue(value) {
  return isNil(value) ? '' : value;
}

/**
 * Get the the target text node to update or create one from of a comment node
 * @param   {HTMLElement} node - any html element containing childNodes
 * @param   {number} childNodeIndex - index of the text node in the childNodes list
 * @returns {HTMLTextNode} the text node to update
 */

const getTextNode = (node, childNodeIndex) => {
  const target = node.childNodes[childNodeIndex];

  if (target.nodeType === Node.COMMENT_NODE) {
    const textNode = document.createTextNode('');
    node.replaceChild(textNode, target);
    return textNode;
  }

  return target;
};
/**
 * This methods handles a simple text expression update
 * @param   {HTMLElement} node - target node
 * @param   {Object} data - expression object
 * @param   {*} value - new expression value
 * @returns {undefined}
 */

function textExpression(node, data, value) {
  node.data = normalizeStringValue(value);
}

/**
 * This methods handles the input fileds value updates
 * @param   {HTMLElement} node - target node
 * @param   {Object} expression - expression object
 * @param   {*} value - new expression value
 * @returns {undefined}
 */

function valueExpression(node, expression, value) {
  node.value = normalizeStringValue(value);
}

var expressions = {
  [ATTRIBUTE]: attributeExpression,
  [EVENT]: eventExpression,
  [TEXT]: textExpression,
  [VALUE]: valueExpression
};

const Expression = Object.seal({
  // Static props
  // node: null,
  // value: null,
  // API methods

  /**
   * Mount the expression evaluating its initial value
   * @param   {*} scope - argument passed to the expression to evaluate its current values
   * @returns {Expression} self
   */
  mount(scope) {
    // hopefully a pure function
    this.value = this.evaluate(scope); // IO() DOM updates

    apply(this, this.value);
    return this;
  },

  /**
   * Update the expression if its value changed
   * @param   {*} scope - argument passed to the expression to evaluate its current values
   * @returns {Expression} self
   */
  update(scope) {
    // pure function
    const value = this.evaluate(scope);

    if (this.value !== value) {
      // IO() DOM updates
      apply(this, value);
      this.value = value;
    }

    return this;
  },

  /**
   * Expression teardown method
   * @returns {Expression} self
   */
  unmount() {
    // unmount only the event handling expressions
    if (this.type === EVENT) apply(this, null);
    return this;
  }

});
/**
 * IO() function to handle the DOM updates
 * @param {Expression} expression - expression object
 * @param {*} value - current expression value
 * @returns {undefined}
 */

function apply(expression, value) {
  return expressions[expression.type](expression.node, expression, value, expression.value);
}

function create$2(node, data) {
  return Object.assign({}, Expression, data, {
    node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node
  });
}

/**
 * Create a flat object having as keys a list of methods that if dispatched will propagate
 * on the whole collection
 * @param   {Array} collection - collection to iterate
 * @param   {Array<string>} methods - methods to execute on each item of the collection
 * @param   {*} context - context returned by the new methods created
 * @returns {Object} a new object to simplify the the nested methods dispatching
 */
function flattenCollectionMethods(collection, methods, context) {
  return methods.reduce((acc, method) => {
    return Object.assign({}, acc, {
      [method]: scope => {
        return collection.map(item => item[method](scope)) && context;
      }
    });
  }, {});
}

function create$3(node, _ref) {
  let {
    expressions
  } = _ref;
  return Object.assign({}, flattenCollectionMethods(expressions.map(expression => create$2(node, expression)), ['mount', 'update', 'unmount']));
}

// Riot.js constants that can be used accross more modules
const COMPONENTS_IMPLEMENTATION_MAP = new Map(),
      DOM_COMPONENT_INSTANCE_PROPERTY = Symbol('riot-component'),
      PLUGINS_SET = new Set(),
      IS_DIRECTIVE = 'is',
      VALUE_ATTRIBUTE = 'value',
      MOUNT_METHOD_KEY = 'mount',
      UPDATE_METHOD_KEY = 'update',
      UNMOUNT_METHOD_KEY = 'unmount',
      SHOULD_UPDATE_KEY = 'shouldUpdate',
      ON_BEFORE_MOUNT_KEY = 'onBeforeMount',
      ON_MOUNTED_KEY = 'onMounted',
      ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',
      ON_UPDATED_KEY = 'onUpdated',
      ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',
      ON_UNMOUNTED_KEY = 'onUnmounted',
      PROPS_KEY = 'props',
      STATE_KEY = 'state',
      SLOTS_KEY = 'slots',
      ROOT_KEY = 'root',
      IS_PURE_SYMBOL = Symbol.for('pure'),
      PARENT_KEY_SYMBOL = Symbol('parent'),
      ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),
      TEMPLATE_KEY_SYMBOL = Symbol('template');

var globals = /*#__PURE__*/Object.freeze({
  __proto__: null,
  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP,
  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY,
  PLUGINS_SET: PLUGINS_SET,
  IS_DIRECTIVE: IS_DIRECTIVE,
  VALUE_ATTRIBUTE: VALUE_ATTRIBUTE,
  MOUNT_METHOD_KEY: MOUNT_METHOD_KEY,
  UPDATE_METHOD_KEY: UPDATE_METHOD_KEY,
  UNMOUNT_METHOD_KEY: UNMOUNT_METHOD_KEY,
  SHOULD_UPDATE_KEY: SHOULD_UPDATE_KEY,
  ON_BEFORE_MOUNT_KEY: ON_BEFORE_MOUNT_KEY,
  ON_MOUNTED_KEY: ON_MOUNTED_KEY,
  ON_BEFORE_UPDATE_KEY: ON_BEFORE_UPDATE_KEY,
  ON_UPDATED_KEY: ON_UPDATED_KEY,
  ON_BEFORE_UNMOUNT_KEY: ON_BEFORE_UNMOUNT_KEY,
  ON_UNMOUNTED_KEY: ON_UNMOUNTED_KEY,
  PROPS_KEY: PROPS_KEY,
  STATE_KEY: STATE_KEY,
  SLOTS_KEY: SLOTS_KEY,
  ROOT_KEY: ROOT_KEY,
  IS_PURE_SYMBOL: IS_PURE_SYMBOL,
  PARENT_KEY_SYMBOL: PARENT_KEY_SYMBOL,
  ATTRIBUTES_KEY_SYMBOL: ATTRIBUTES_KEY_SYMBOL,
  TEMPLATE_KEY_SYMBOL: TEMPLATE_KEY_SYMBOL
});

function extendParentScope(attributes, scope, parentScope) {
  if (!attributes || !attributes.length) return parentScope;
  const expressions = attributes.map(attr => Object.assign({}, attr, {
    value: attr.evaluate(scope)
  }));
  return Object.assign(Object.create(parentScope || null), evaluateAttributeExpressions(expressions));
} // this function is only meant to fix an edge case
// https://github.com/riot/riot/issues/2842


const getRealParent = (scope, parentScope) => scope[PARENT_KEY_SYMBOL] || parentScope;

const SlotBinding = Object.seal({
  // dynamic binding properties
  // node: null,
  // name: null,
  attributes: [],

  // template: null,
  getTemplateScope(scope, parentScope) {
    return extendParentScope(this.attributes, scope, parentScope);
  },

  // API methods
  mount(scope, parentScope) {
    const templateData = scope.slots ? scope.slots.find((_ref) => {
      let {
        id
      } = _ref;
      return id === this.name;
    }) : false;
    const {
      parentNode
    } = this.node;
    const realParent = getRealParent(scope, parentScope);
    this.template = templateData && create$6(templateData.html, templateData.bindings).createDOM(parentNode);

    if (this.template) {
      this.template.mount(this.node, this.getTemplateScope(scope, realParent), realParent);
      this.template.children = moveSlotInnerContent(this.node);
    }

    removeChild(this.node);
    return this;
  },

  update(scope, parentScope) {
    if (this.template) {
      const realParent = getRealParent(scope, parentScope);
      this.template.update(this.getTemplateScope(scope, realParent), realParent);
    }

    return this;
  },

  unmount(scope, parentScope, mustRemoveRoot) {
    if (this.template) {
      this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot);
    }

    return this;
  }

});
/**
 * Move the inner content of the slots outside of them
 * @param   {HTMLElement} slot - slot node
 * @param   {HTMLElement} children - array to fill with the child nodes detected
 * @returns {HTMLElement[]} list of the node moved
 */

function moveSlotInnerContent(slot, children) {
  if (children === void 0) {
    children = [];
  }

  const child = slot.firstChild;

  if (child) {
    insertBefore(child, slot);
    return [child, ...moveSlotInnerContent(slot)];
  }

  return children;
}
/**
 * Create a single slot binding
 * @param   {HTMLElement} node - slot node
 * @param   {string} options.name - slot id
 * @returns {Object} Slot binding object
 */


function createSlot(node, _ref2) {
  let {
    name,
    attributes
  } = _ref2;
  return Object.assign({}, SlotBinding, {
    attributes,
    node,
    name
  });
}

/**
 * Create a new tag object if it was registered before, otherwise fallback to the simple
 * template chunk
 * @param   {Function} component - component factory function
 * @param   {Array<Object>} slots - array containing the slots markup
 * @param   {Array} attributes - dynamic attributes that will be received by the tag element
 * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback
 */

function getTag(component, slots, attributes) {
  if (slots === void 0) {
    slots = [];
  }

  if (attributes === void 0) {
    attributes = [];
  }

  // if this tag was registered before we will return its implementation
  if (component) {
    return component({
      slots,
      attributes
    });
  } // otherwise we return a template chunk


  return create$6(slotsToMarkup(slots), [...slotBindings(slots), {
    // the attributes should be registered as binding
    // if we fallback to a normal template chunk
    expressions: attributes.map(attr => {
      return Object.assign({
        type: ATTRIBUTE
      }, attr);
    })
  }]);
}
/**
 * Merge all the slots bindings into a single array
 * @param   {Array<Object>} slots - slots collection
 * @returns {Array<Bindings>} flatten bindings array
 */


function slotBindings(slots) {
  return slots.reduce((acc, _ref) => {
    let {
      bindings
    } = _ref;
    return acc.concat(bindings);
  }, []);
}
/**
 * Merge all the slots together in a single markup string
 * @param   {Array<Object>} slots - slots collection
 * @returns {string} markup of all the slots in a single string
 */


function slotsToMarkup(slots) {
  return slots.reduce((acc, slot) => {
    return acc + slot.html;
  }, '');
}

const TagBinding = Object.seal({
  // dynamic binding properties
  // node: null,
  // evaluate: null,
  // name: null,
  // slots: null,
  // tag: null,
  // attributes: null,
  // getComponent: null,
  mount(scope) {
    return this.update(scope);
  },

  update(scope, parentScope) {
    const name = this.evaluate(scope); // simple update

    if (name === this.name) {
      this.tag.update(scope);
    } else {
      // unmount the old tag if it exists
      this.unmount(scope, parentScope, true); // mount the new tag

      this.name = name;
      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);
      this.tag.mount(this.node, scope);
    }

    return this;
  },

  unmount(scope, parentScope, keepRootTag) {
    if (this.tag) {
      // keep the root tag
      this.tag.unmount(keepRootTag);
    }

    return this;
  }

});
function create$4(node, _ref2) {
  let {
    evaluate,
    getComponent,
    slots,
    attributes
  } = _ref2;
  return Object.assign({}, TagBinding, {
    node,
    evaluate,
    slots,
    attributes,
    getComponent
  });
}

var bindings = {
  [IF]: create$1,
  [SIMPLE]: create$3,
  [EACH]: create,
  [TAG]: create$4,
  [SLOT]: createSlot
};

/**
 * Text expressions in a template tag will get childNodeIndex value normalized
 * depending on the position of the <template> tag offset
 * @param   {Expression[]} expressions - riot expressions array
 * @param   {number} textExpressionsOffset - offset of the <template> tag
 * @returns {Expression[]} expressions containing the text expressions normalized
 */

function fixTextExpressionsOffset(expressions, textExpressionsOffset) {
  return expressions.map(e => e.type === TEXT ? Object.assign({}, e, {
    childNodeIndex: e.childNodeIndex + textExpressionsOffset
  }) : e);
}
/**
 * Bind a new expression object to a DOM node
 * @param   {HTMLElement} root - DOM node where to bind the expression
 * @param   {Object} binding - binding data
 * @param   {number|null} templateTagOffset - if it's defined we need to fix the text expressions childNodeIndex offset
 * @returns {Binding} Binding object
 */


function create$5(root, binding, templateTagOffset) {
  const {
    selector,
    type,
    redundantAttribute,
    expressions
  } = binding; // find the node to apply the bindings

  const node = selector ? root.querySelector(selector) : root; // remove eventually additional attributes created only to select this node

  if (redundantAttribute) node.removeAttribute(redundantAttribute);
  const bindingExpressions = expressions || []; // init the binding

  return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {
    expressions: templateTagOffset && !selector ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset) : bindingExpressions
  }));
}

function createHTMLTree(html, root) {
  const template = isTemplate(root) ? root : document.createElement('template');
  template.innerHTML = html;
  return template.content;
} // for svg nodes we need a bit more work


function createSVGTree(html, container) {
  // create the SVGNode
  const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${html}</svg>`, 'application/xml').documentElement, true);
  return svgNode;
}
/**
 * Create the DOM that will be injected
 * @param {Object} root - DOM node to find out the context where the fragment will be created
 * @param   {string} html - DOM to create as string
 * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment
 */


function createDOMTree(root, html) {
  if (isSvg(root)) return createSVGTree(html, root);
  return createHTMLTree(html, root);
}

/**
 * Inject the DOM tree into a target node
 * @param   {HTMLElement} el - target element
 * @param   {HTMLFragment|SVGElement} dom - dom tree to inject
 * @returns {undefined}
 */

function injectDOM(el, dom) {
  switch (true) {
    case isSvg(el):
      moveChildren(dom, el);
      break;

    case isTemplate(el):
      el.parentNode.replaceChild(dom, el);
      break;

    default:
      el.appendChild(dom);
  }
}

/**
 * Create the Template DOM skeleton
 * @param   {HTMLElement} el - root node where the DOM will be injected
 * @param   {string} html - markup that will be injected into the root node
 * @returns {HTMLFragment} fragment that will be injected into the root node
 */

function createTemplateDOM(el, html) {
  return html && (typeof html === 'string' ? createDOMTree(el, html) : html);
}
/**
 * Template Chunk model
 * @type {Object}
 */


const TemplateChunk = Object.freeze({
  // Static props
  // bindings: null,
  // bindingsData: null,
  // html: null,
  // isTemplateTag: false,
  // fragment: null,
  // children: null,
  // dom: null,
  // el: null,

  /**
   * Create the template DOM structure that will be cloned on each mount
   * @param   {HTMLElement} el - the root node
   * @returns {TemplateChunk} self
   */
  createDOM(el) {
    // make sure that the DOM gets created before cloning the template
    this.dom = this.dom || createTemplateDOM(el, this.html);
    return this;
  },

  // API methods

  /**
   * Attach the template to a DOM node
   * @param   {HTMLElement} el - target DOM node
   * @param   {*} scope - template data
   * @param   {*} parentScope - scope of the parent template tag
   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops
   * @returns {TemplateChunk} self
   */
  mount(el, scope, parentScope, meta) {
    if (meta === void 0) {
      meta = {};
    }

    if (!el) throw new Error('Please provide DOM node to mount properly your template');
    if (this.el) this.unmount(scope); // <template> tags require a bit more work
    // the template fragment might be already created via meta outside of this call

    const {
      fragment,
      children,
      avoidDOMInjection
    } = meta; // <template> bindings of course can not have a root element
    // so we check the parent node to set the query selector bindings

    const {
      parentNode
    } = children ? children[0] : el;
    const isTemplateTag = isTemplate(el);
    const templateTagOffset = isTemplateTag ? Math.max(Array.from(parentNode.childNodes).indexOf(el), 0) : null;
    this.isTemplateTag = isTemplateTag; // create the DOM if it wasn't created before

    this.createDOM(el);

    if (this.dom) {
      // create the new template dom fragment if it want already passed in via meta
      this.fragment = fragment || this.dom.cloneNode(true);
    } // store root node
    // notice that for template tags the root note will be the parent tag


    this.el = this.isTemplateTag ? parentNode : el; // create the children array only for the <template> fragments

    this.children = this.isTemplateTag ? children || Array.from(this.fragment.childNodes) : null; // inject the DOM into the el only if a fragment is available

    if (!avoidDOMInjection && this.fragment) injectDOM(el, this.fragment); // create the bindings

    this.bindings = this.bindingsData.map(binding => create$5(this.el, binding, templateTagOffset));
    this.bindings.forEach(b => b.mount(scope, parentScope));
    return this;
  },

  /**
   * Update the template with fresh data
   * @param   {*} scope - template data
   * @param   {*} parentScope - scope of the parent template tag
   * @returns {TemplateChunk} self
   */
  update(scope, parentScope) {
    this.bindings.forEach(b => b.update(scope, parentScope));
    return this;
  },

  /**
   * Remove the template from the node where it was initially mounted
   * @param   {*} scope - template data
   * @param   {*} parentScope - scope of the parent template tag
   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,
   * if false or undefined clean the root tag content, if null don't touch the DOM
   * @returns {TemplateChunk} self
   */
  unmount(scope, parentScope, mustRemoveRoot) {
    if (this.el) {
      this.bindings.forEach(b => b.unmount(scope, parentScope, mustRemoveRoot));

      switch (true) {
        // <template> tags should be treated a bit differently
        // we need to clear their children only if it's explicitly required by the caller
        // via mustRemoveRoot !== null
        case this.children && mustRemoveRoot !== null:
          clearChildren(this.children);
          break;
        // remove the root node only if the mustRemoveRoot === true

        case mustRemoveRoot === true:
          removeChild(this.el);
          break;
        // otherwise we clean the node children

        case mustRemoveRoot !== null:
          cleanNode(this.el);
          break;
      }

      this.el = null;
    }

    return this;
  },

  /**
   * Clone the template chunk
   * @returns {TemplateChunk} a clone of this object resetting the this.el property
   */
  clone() {
    return Object.assign({}, this, {
      el: null
    });
  }

});
/**
 * Create a template chunk wiring also the bindings
 * @param   {string|HTMLElement} html - template string
 * @param   {Array} bindings - bindings collection
 * @returns {TemplateChunk} a new TemplateChunk copy
 */

function create$6(html, bindings) {
  if (bindings === void 0) {
    bindings = [];
  }

  return Object.assign({}, TemplateChunk, {
    html,
    bindingsData: bindings
  });
}

/**
 * Method used to bind expressions to a DOM node
 * @param   {string|HTMLElement} html - your static template html structure
 * @param   {Array} bindings - list of the expressions to bind to update the markup
 * @returns {TemplateChunk} a new TemplateChunk object having the `update`,`mount`, `unmount` and `clone` methods
 *
 * @example
 *
 * riotDOMBindings
 *  .template(
 *   `<div expr0><!----></div><div><p expr1><!----><section expr2></section></p>`,
 *   [
 *     {
 *       selector: '[expr0]',
 *       redundantAttribute: 'expr0',
 *       expressions: [
 *         {
 *           type: expressionTypes.TEXT,
 *           childNodeIndex: 0,
 *           evaluate(scope) {
 *             return scope.time;
 *           },
 *         },
 *       ],
 *     },
 *     {
 *       selector: '[expr1]',
 *       redundantAttribute: 'expr1',
 *       expressions: [
 *         {
 *           type: expressionTypes.TEXT,
 *           childNodeIndex: 0,
 *           evaluate(scope) {
 *             return scope.name;
 *           },
 *         },
 *         {
 *           type: 'attribute',
 *           name: 'style',
 *           evaluate(scope) {
 *             return scope.style;
 *           },
 *         },
 *       ],
 *     },
 *     {
 *       selector: '[expr2]',
 *       redundantAttribute: 'expr2',
 *       type: bindingTypes.IF,
 *       evaluate(scope) {
 *         return scope.isVisible;
 *       },
 *       template: riotDOMBindings.template('hello there'),
 *     },
 *   ]
 * )
 */

var DOMBindings = /*#__PURE__*/Object.freeze({
  __proto__: null,
  template: create$6,
  createBinding: create$5,
  createExpression: create$2,
  bindingTypes: bindingTypes,
  expressionTypes: expressionTypes
});

function noop() {
  return this;
}
/**
 * Autobind the methods of a source object to itself
 * @param   {Object} source - probably a riot tag instance
 * @param   {Array<string>} methods - list of the methods to autobind
 * @returns {Object} the original object received
 */

function autobindMethods(source, methods) {
  methods.forEach(method => {
    source[method] = source[method].bind(source);
  });
  return source;
}
/**
 * Call the first argument received only if it's a function otherwise return it as it is
 * @param   {*} source - anything
 * @returns {*} anything
 */

function callOrAssign(source) {
  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;
}

/**
 * Helper function to set an immutable property
 * @param   {Object} source - object where the new property will be set
 * @param   {string} key - object key where the new property will be stored
 * @param   {*} value - value of the new property
 * @param   {Object} options - set the propery overriding the default options
 * @returns {Object} - the original object modified
 */
function defineProperty(source, key, value, options) {
  if (options === void 0) {
    options = {};
  }

  /* eslint-disable fp/no-mutating-methods */
  Object.defineProperty(source, key, Object.assign({
    value,
    enumerable: false,
    writable: false,
    configurable: true
  }, options));
  /* eslint-enable fp/no-mutating-methods */

  return source;
}
/**
 * Define multiple properties on a target object
 * @param   {Object} source - object where the new properties will be set
 * @param   {Object} properties - object containing as key pair the key + value properties
 * @param   {Object} options - set the propery overriding the default options
 * @returns {Object} the original object modified
 */

function defineProperties(source, properties, options) {
  Object.entries(properties).forEach((_ref) => {
    let [key, value] = _ref;
    defineProperty(source, key, value, options);
  });
  return source;
}
/**
 * Define default properties if they don't exist on the source object
 * @param   {Object} source - object that will receive the default properties
 * @param   {Object} defaults - object containing additional optional keys
 * @returns {Object} the original object received enhanced
 */

function defineDefaults(source, defaults) {
  Object.entries(defaults).forEach((_ref2) => {
    let [key, value] = _ref2;
    if (!source[key]) source[key] = value;
  });
  return source;
}

/**
 * Converts any DOM node/s to a loopable array
 * @param   { HTMLElement|NodeList } els - single html element or a node list
 * @returns { Array } always a loopable object
 */
function domToArray(els) {
  // can this object be already looped?
  if (!Array.isArray(els)) {
    // is it a node list?
    if (/^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else // if it's a single node
      // it will be returned as "array" with one single entry
      return [els];
  } // this object could be looped out of the box


  return els;
}

/**
 * Simple helper to find DOM nodes returning them as array like loopable object
 * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify
 * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes
 * @returns { Array } DOM nodes found as array
 */

function $(selector, ctx) {
  return domToArray(typeof selector === 'string' ? (ctx || document).querySelectorAll(selector) : selector);
}

/**
 * Normalize the return values, in case of a single value we avoid to return an array
 * @param   { Array } values - list of values we want to return
 * @returns { Array|string|boolean } either the whole list of values or the single one found
 * @private
 */

const normalize = values => values.length === 1 ? values[0] : values;
/**
 * Parse all the nodes received to get/remove/check their attributes
 * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse
 * @param   { string|Array }               name   - name or list of attributes
 * @param   { string }                     method - method that will be used to parse the attributes
 * @returns { Array|string } result of the parsing in a list or a single value
 * @private
 */


function parseNodes(els, name, method) {
  const names = typeof name === 'string' ? [name] : name;
  return normalize(domToArray(els).map(el => {
    return normalize(names.map(n => el[method](n)));
  }));
}
/**
 * Set any attribute on a single or a list of DOM nodes
 * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse
 * @param   { string|Object }              name  - either the name of the attribute to set
 *                                                 or a list of properties as object key - value
 * @param   { string }                     value - the new value of the attribute (optional)
 * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function
 *
 * @example
 *
 * import { set } from 'bianco.attr'
 *
 * const img = document.createElement('img')
 *
 * set(img, 'width', 100)
 *
 * // or also
 * set(img, {
 *   width: 300,
 *   height: 300
 * })
 *
 */


function set(els, name, value) {
  const attrs = typeof name === 'object' ? name : {
    [name]: value
  };
  const props = Object.keys(attrs);
  domToArray(els).forEach(el => {
    props.forEach(prop => el.setAttribute(prop, attrs[prop]));
  });
  return els;
}
/**
 * Get any attribute from a single or a list of DOM nodes
 * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse
 * @param   { string|Array }               name  - name or list of attributes to get
 * @returns { Array|string } list of the attributes found
 *
 * @example
 *
 * import { get } from 'bianco.attr'
 *
 * const img = document.createElement('img')
 *
 * get(img, 'width') // => '200'
 *
 * // or also
 * get(img, ['width', 'height']) // => ['200', '300']
 *
 * // or also
 * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]
 */

function get(els, name) {
  return parseNodes(els, name, 'getAttribute');
}

const CSS_BY_NAME = new Map();
const STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function

const getStyleNode = (style => {
  return () => {
    // lazy evaluation:
    // if this function was already called before
    // we return its cached result
    if (style) return style; // create a new style element or use an existing one
    // and cache it internally

    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');
    set(style, 'type', 'text/css');
    /* istanbul ignore next */

    if (!style.parentNode) document.head.appendChild(style);
    return style;
  };
})();
/**
 * Object that will be used to inject and manage the css of every tag instance
 */


var cssManager = {
  CSS_BY_NAME,

  /**
   * Save a tag style to be later injected into DOM
   * @param { string } name - if it's passed we will map the css to a tagname
   * @param { string } css - css string
   * @returns {Object} self
   */
  add(name, css) {
    if (!CSS_BY_NAME.has(name)) {
      CSS_BY_NAME.set(name, css);
      this.inject();
    }

    return this;
  },

  /**
   * Inject all previously saved tag styles into DOM
   * innerHTML seems slow: http://jsperf.com/riot-insert-style
   * @returns {Object} self
   */
  inject() {
    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\n');
    return this;
  },

  /**
   * Remove a tag style from the DOM
   * @param {string} name a registered tagname
   * @returns {Object} self
   */
  remove(name) {
    if (CSS_BY_NAME.has(name)) {
      CSS_BY_NAME.delete(name);
      this.inject();
    }

    return this;
  }

};

/**
 * Function to curry any javascript method
 * @param   {Function}  fn - the target function we want to curry
 * @param   {...[args]} acc - initial arguments
 * @returns {Function|*} it will return a function until the target function
 *                       will receive all of its arguments
 */
function curry(fn) {
  for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    acc[_key - 1] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args = [...acc, ...args];
    return args.length < fn.length ? curry(fn, ...args) : fn(...args);
  };
}

/**
 * Get the tag name of any DOM node
 * @param   {HTMLElement} element - DOM node we want to inspect
 * @returns {string} name to identify this dom node in riot
 */

function getName(element) {
  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();
}

const COMPONENT_CORE_HELPERS = Object.freeze({
  // component helpers
  $(selector) {
    return $(selector, this.root)[0];
  },

  $$(selector) {
    return $(selector, this.root);
  }

});
const PURE_COMPONENT_API = Object.freeze({
  [MOUNT_METHOD_KEY]: noop,
  [UPDATE_METHOD_KEY]: noop,
  [UNMOUNT_METHOD_KEY]: noop
});
const COMPONENT_LIFECYCLE_METHODS = Object.freeze({
  [SHOULD_UPDATE_KEY]: noop,
  [ON_BEFORE_MOUNT_KEY]: noop,
  [ON_MOUNTED_KEY]: noop,
  [ON_BEFORE_UPDATE_KEY]: noop,
  [ON_UPDATED_KEY]: noop,
  [ON_BEFORE_UNMOUNT_KEY]: noop,
  [ON_UNMOUNTED_KEY]: noop
});
const MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {
  clone: noop,
  createDOM: noop
});
/**
 * Evaluate the component properties either from its real attributes or from its initial user properties
 * @param   {HTMLElement} element - component root
 * @param   {Object}  initialProps - initial props
 * @returns {Object} component props key value pairs
 */

function evaluateInitialProps(element, initialProps) {
  if (initialProps === void 0) {
    initialProps = {};
  }

  return Object.assign({}, DOMattributesToObject(element), callOrAssign(initialProps));
}
/**
 * Bind a DOM node to its component object
 * @param   {HTMLElement} node - html node mounted
 * @param   {Object} component - Riot.js component object
 * @returns {Object} the component object received as second argument
 */


const bindDOMNodeToComponentObject = (node, component) => node[DOM_COMPONENT_INSTANCE_PROPERTY] = component;
/**
 * Wrap the Riot.js core API methods using a mapping function
 * @param   {Function} mapFunction - lifting function
 * @returns {Object} an object having the { mount, update, unmount } functions
 */


function createCoreAPIMethods(mapFunction) {
  return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {
    acc[method] = mapFunction(method);
    return acc;
  }, {});
}
/**
 * Factory function to create the component templates only once
 * @param   {Function} template - component template creation function
 * @param   {Object} components - object containing the nested components
 * @returns {TemplateChunk} template chunk object
 */


function componentTemplateFactory(template, components) {
  return template(create$6, expressionTypes, bindingTypes, name => {
    return components[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name);
  });
}
/**
 * Create a pure component
 * @param   {Function} pureFactoryFunction - pure component factory function
 * @param   {Array} options.slots - component slots
 * @param   {Array} options.attributes - component attributes
 * @param   {Array} options.template - template factory function
 * @param   {Array} options.template - template factory function
 * @param   {any} options.props - initial component properties
 * @returns {Object} pure component object
 */


function createPureComponent(pureFactoryFunction, _ref) {
  let {
    slots,
    attributes,
    props,
    css,
    template
  } = _ref;
  if (template) panic('Pure components can not have html');
  if (css) panic('Pure components do not have css');
  const component = defineDefaults(pureFactoryFunction({
    slots,
    attributes,
    props
  }), PURE_COMPONENT_API);
  return createCoreAPIMethods(method => function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // intercept the mount calls to bind the DOM node to the pure object created
    // see also https://github.com/riot/riot/issues/2806
    if (method === MOUNT_METHOD_KEY) {
      const [el] = args;
      bindDOMNodeToComponentObject(el, component);
    }

    component[method](...args);
    return component;
  });
}
/**
 * Create the component interface needed for the @riotjs/dom-bindings tag bindings
 * @param   {string} options.css - component css
 * @param   {Function} options.template - functon that will return the dom-bindings template function
 * @param   {Object} options.exports - component interface
 * @param   {string} options.name - component name
 * @returns {Object} component like interface
 */


function createComponent(_ref2) {
  let {
    css,
    template,
    exports,
    name
  } = _ref2;
  const templateFn = template ? componentTemplateFactory(template, exports ? createSubcomponents(exports.components) : {}) : MOCKED_TEMPLATE_INTERFACE;
  return (_ref3) => {
    let {
      slots,
      attributes,
      props
    } = _ref3;
    // pure components rendering will be managed by the end user
    if (exports && exports[IS_PURE_SYMBOL]) return createPureComponent(exports, {
      slots,
      attributes,
      props,
      css,
      template
    });
    const componentAPI = callOrAssign(exports) || {};
    const component = defineComponent({
      css,
      template: templateFn,
      componentAPI,
      name
    })({
      slots,
      attributes,
      props
    }); // notice that for the components create via tag binding
    // we need to invert the mount (state/parentScope) arguments
    // the template bindings will only forward the parentScope updates
    // and never deal with the component state

    return {
      mount(element, parentScope, state) {
        return component.mount(element, state, parentScope);
      },

      update(parentScope, state) {
        return component.update(state, parentScope);
      },

      unmount(preserveRoot) {
        return component.unmount(preserveRoot);
      }

    };
  };
}
/**
 * Component definition function
 * @param   {Object} implementation - the componen implementation will be generated via compiler
 * @param   {Object} component - the component initial properties
 * @returns {Object} a new component implementation object
 */

function defineComponent(_ref4) {
  let {
    css,
    template,
    componentAPI,
    name
  } = _ref4;
  // add the component css into the DOM
  if (css && name) cssManager.add(name, css);
  return curry(enhanceComponentAPI)(defineProperties( // set the component defaults without overriding the original component API
  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {
    [STATE_KEY]: {}
  })), Object.assign({
    // defined during the component creation
    [SLOTS_KEY]: null,
    [ROOT_KEY]: null
  }, COMPONENT_CORE_HELPERS, {
    name,
    css,
    template
  })));
}
/**
 * Create the bindings to update the component attributes
 * @param   {HTMLElement} node - node where we will bind the expressions
 * @param   {Array} attributes - list of attribute bindings
 * @returns {TemplateChunk} - template bindings object
 */

function createAttributeBindings(node, attributes) {
  if (attributes === void 0) {
    attributes = [];
  }

  const expressions = attributes.map(a => create$2(node, a));
  const binding = {};
  return Object.assign(binding, Object.assign({
    expressions
  }, createCoreAPIMethods(method => scope => {
    expressions.forEach(e => e[method](scope));
    return binding;
  })));
}
/**
 * Create the subcomponents that can be included inside a tag in runtime
 * @param   {Object} components - components imported in runtime
 * @returns {Object} all the components transformed into Riot.Component factory functions
 */


function createSubcomponents(components) {
  if (components === void 0) {
    components = {};
  }

  return Object.entries(callOrAssign(components)).reduce((acc, _ref5) => {
    let [key, value] = _ref5;
    acc[camelToDashCase(key)] = createComponent(value);
    return acc;
  }, {});
}
/**
 * Run the component instance through all the plugins set by the user
 * @param   {Object} component - component instance
 * @returns {Object} the component enhanced by the plugins
 */


function runPlugins(component) {
  return [...PLUGINS_SET].reduce((c, fn) => fn(c) || c, component);
}
/**
 * Compute the component current state merging it with its previous state
 * @param   {Object} oldState - previous state object
 * @param   {Object} newState - new state givent to the `update` call
 * @returns {Object} new object state
 */


function computeState(oldState, newState) {
  return Object.assign({}, oldState, callOrAssign(newState));
}
/**
 * Add eventually the "is" attribute to link this DOM node to its css
 * @param {HTMLElement} element - target root node
 * @param {string} name - name of the component mounted
 * @returns {undefined} it's a void function
 */


function addCssHook(element, name) {
  if (getName(element) !== name) {
    set(element, IS_DIRECTIVE, name);
  }
}
/**
 * Component creation factory function that will enhance the user provided API
 * @param   {Object} component - a component implementation previously defined
 * @param   {Array} options.slots - component slots generated via riot compiler
 * @param   {Array} options.attributes - attribute expressions generated via riot compiler
 * @returns {Riot.Component} a riot component instance
 */


function enhanceComponentAPI(component, _ref6) {
  let {
    slots,
    attributes,
    props
  } = _ref6;
  return autobindMethods(runPlugins(defineProperties(Object.create(component), {
    mount(element, state, parentScope) {
      if (state === void 0) {
        state = {};
      }

      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);
      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, evaluateInitialProps(element, props), evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions))));
      this[STATE_KEY] = computeState(this[STATE_KEY], state);
      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone(); // link this object to the DOM node

      bindDOMNodeToComponentObject(element, this); // add eventually the 'is' attribute

      component.name && addCssHook(element, component.name); // define the root element

      defineProperty(this, ROOT_KEY, element); // define the slots array

      defineProperty(this, SLOTS_KEY, slots); // before mount lifecycle event

      this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);
      this[PARENT_KEY_SYMBOL] = parentScope; // mount the template

      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);
      this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);
      return this;
    },

    update(state, parentScope) {
      if (state === void 0) {
        state = {};
      }

      if (parentScope) {
        this[PARENT_KEY_SYMBOL] = parentScope;
        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);
      }

      const newProps = evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions);
      if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false) return;
      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, this[PROPS_KEY], newProps)));
      this[STATE_KEY] = computeState(this[STATE_KEY], state);
      this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]);
      this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);
      this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);
      return this;
    },

    unmount(preserveRoot) {
      this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);
      this[ATTRIBUTES_KEY_SYMBOL].unmount(); // if the preserveRoot is null the template html will be left untouched
      // in that case the DOM cleanup will happen differently from a parent node

      this[TEMPLATE_KEY_SYMBOL].unmount(this, this[PARENT_KEY_SYMBOL], preserveRoot === null ? null : !preserveRoot);
      this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);
      return this;
    }

  })), Object.keys(component).filter(prop => isFunction(component[prop])));
}
/**
 * Component initialization function starting from a DOM node
 * @param   {HTMLElement} element - element to upgrade
 * @param   {Object} initialProps - initial component properties
 * @param   {string} componentName - component id
 * @returns {Object} a new component instance bound to a DOM node
 */

function mountComponent(element, initialProps, componentName) {
  const name = componentName || getName(element);
  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component named "${name}" was never registered`);
  const component = COMPONENTS_IMPLEMENTATION_MAP.get(name)({
    props: initialProps
  });
  return component.mount(element);
}

/**
 * Similar to compose but performs from left-to-right function composition.<br/>
 * {@link https://30secondsofcode.org/function#composeright see also}
 * @param   {...[function]} fns) - list of unary function
 * @returns {*} result of the computation
 */
/**
 * Performs right-to-left function composition.<br/>
 * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>
 * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>
 * {@link https://30secondsofcode.org/function#compose original source code}
 * @param   {...[function]} fns) - list of unary function
 * @returns {*} result of the computation
 */

function compose() {
  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    fns[_key2] = arguments[_key2];
  }

  return fns.reduce((f, g) => function () {
    return f(g(...arguments));
  });
}

const {
  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,
  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,
  PLUGINS_SET: PLUGINS_SET$1
} = globals;
/**
 * Riot public api
 */

/**
 * Register a custom tag by name
 * @param   {string} name - component name
 * @param   {Object} implementation - tag implementation
 * @returns {Map} map containing all the components implementations
 */

function register(name, _ref) {
  let {
    css,
    template,
    exports
  } = _ref;
  if (COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component "${name}" was already registered`);
  COMPONENTS_IMPLEMENTATION_MAP$1.set(name, createComponent({
    name,
    css,
    template,
    exports
  }));
  return COMPONENTS_IMPLEMENTATION_MAP$1;
}
/**
 * Unregister a riot web component
 * @param   {string} name - component name
 * @returns {Map} map containing all the components implementations
 */

function unregister(name) {
  if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component "${name}" was never registered`);
  COMPONENTS_IMPLEMENTATION_MAP$1.delete(name);
  cssManager.remove(name);
  return COMPONENTS_IMPLEMENTATION_MAP$1;
}
/**
 * Mounting function that will work only for the components that were globally registered
 * @param   {string|HTMLElement} selector - query for the selection or a DOM element
 * @param   {Object} initialProps - the initial component properties
 * @param   {string} name - optional component name
 * @returns {Array} list of nodes upgraded
 */

function mount(selector, initialProps, name) {
  return $(selector).map(element => mountComponent(element, initialProps, name));
}
/**
 * Sweet unmounting helper function for the DOM node mounted manually by the user
 * @param   {string|HTMLElement} selector - query for the selection or a DOM element
 * @param   {boolean|null} keepRootElement - if true keep the root element
 * @returns {Array} list of nodes unmounted
 */

function unmount(selector, keepRootElement) {
  return $(selector).map(element => {
    if (element[DOM_COMPONENT_INSTANCE_PROPERTY$1]) {
      element[DOM_COMPONENT_INSTANCE_PROPERTY$1].unmount(keepRootElement);
    }

    return element;
  });
}
/**
 * Define a riot plugin
 * @param   {Function} plugin - function that will receive all the components created
 * @returns {Set} the set containing all the plugins installed
 */

function install(plugin) {
  if (!isFunction(plugin)) panic('Plugins must be of type function');
  if (PLUGINS_SET$1.has(plugin)) panic('This plugin was already installed');
  PLUGINS_SET$1.add(plugin);
  return PLUGINS_SET$1;
}
/**
 * Uninstall a riot plugin
 * @param   {Function} plugin - plugin previously installed
 * @returns {Set} the set containing all the plugins installed
 */

function uninstall(plugin) {
  if (!PLUGINS_SET$1.has(plugin)) panic('This plugin was never installed');
  PLUGINS_SET$1.delete(plugin);
  return PLUGINS_SET$1;
}
/**
 * Helper method to create component without relying on the registered ones
 * @param   {Object} implementation - component implementation
 * @returns {Function} function that will allow you to mount a riot component on a DOM node
 */

function component(implementation) {
  return function (el, props, _temp) {
    let {
      slots,
      attributes,
      parentScope
    } = _temp === void 0 ? {} : _temp;
    return compose(c => c.mount(el, parentScope), c => c({
      props,
      slots,
      attributes
    }), createComponent)(implementation);
  };
}
/**
 * Lift a riot component Interface into a pure riot object
 * @param   {Function} func - RiotPureComponent factory function
 * @returns {Function} the lifted original function received as argument
 */

function pure(func) {
  if (!isFunction(func)) panic('riot.pure accepts only arguments of type "function"');
  func[IS_PURE_SYMBOL] = true;
  return func;
}
/** @type {string} current riot version */

const version = 'v5.0.0'; // expose some internal stuff that might be used from external tools

const __ = {
  cssManager,
  DOMBindings,
  createComponent,
  defineComponent,
  globals
};




/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_exports__, __webpack_require__ */
/*! CommonJS bailout: module.exports is used directly at 12:2-16 */
/*! CommonJS bailout: exports is used directly at 15:20-27 */
/***/ ((module, exports, __webpack_require__) => {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/sha.js/hash.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/hash.js ***!
  \*************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_require__, module */
/*! CommonJS bailout: module.exports is used directly at 81:0-14 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),

/***/ "./node_modules/sha.js/sha256.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha256.js ***!
  \***************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_require__, module */
/*! CommonJS bailout: module.exports is used directly at 135:0-14 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256


/***/ }),

/***/ "./node_modules/ua-parser-js/src/ua-parser.js":
/*!****************************************************!*\
  !*** ./node_modules/ua-parser-js/src/ua-parser.js ***!
  \****************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, module, top-level-this-exports, __webpack_require__ */
/*! CommonJS bailout: this is used directly at 908:41-45 */
/*! CommonJS bailout: exports is used directly at 869:15-22 */
/*! CommonJS bailout: module.exports is used directly at 871:44-58 */
/*! CommonJS bailout: module.exports is used directly at 872:22-36 */
/*! CommonJS bailout: exports is used directly at 872:12-19 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * UAParser.js v0.7.22
 * Lightweight JavaScript-based User-Agent string parser
 * https://github.com/faisalman/ua-parser-js
 *
 * Copyright © 2012-2019 Faisal Salman <f@faisalman.com>
 * Licensed under MIT License
 */

(function (window, undefined) {

    'use strict';

    //////////////
    // Constants
    /////////////


    var LIBVERSION  = '0.7.22',
        EMPTY       = '',
        UNKNOWN     = '?',
        FUNC_TYPE   = 'function',
        UNDEF_TYPE  = 'undefined',
        OBJ_TYPE    = 'object',
        STR_TYPE    = 'string',
        MAJOR       = 'major', // deprecated
        MODEL       = 'model',
        NAME        = 'name',
        TYPE        = 'type',
        VENDOR      = 'vendor',
        VERSION     = 'version',
        ARCHITECTURE= 'architecture',
        CONSOLE     = 'console',
        MOBILE      = 'mobile',
        TABLET      = 'tablet',
        SMARTTV     = 'smarttv',
        WEARABLE    = 'wearable',
        EMBEDDED    = 'embedded';


    ///////////
    // Helper
    //////////


    var util = {
        extend : function (regexes, extensions) {
            var mergedRegexes = {};
            for (var i in regexes) {
                if (extensions[i] && extensions[i].length % 2 === 0) {
                    mergedRegexes[i] = extensions[i].concat(regexes[i]);
                } else {
                    mergedRegexes[i] = regexes[i];
                }
            }
            return mergedRegexes;
        },
        has : function (str1, str2) {
          if (typeof str1 === "string") {
            return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;
          } else {
            return false;
          }
        },
        lowerize : function (str) {
            return str.toLowerCase();
        },
        major : function (version) {
            return typeof(version) === STR_TYPE ? version.replace(/[^\d\.]/g,'').split(".")[0] : undefined;
        },
        trim : function (str) {
          return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
        }
    };


    ///////////////
    // Map helper
    //////////////


    var mapper = {

        rgx : function (ua, arrays) {

            var i = 0, j, k, p, q, matches, match;

            // loop through all regexes maps
            while (i < arrays.length && !matches) {

                var regex = arrays[i],       // even sequence (0,2,4,..)
                    props = arrays[i + 1];   // odd sequence (1,3,5,..)
                j = k = 0;

                // try matching uastring with regexes
                while (j < regex.length && !matches) {

                    matches = regex[j++].exec(ua);

                    if (!!matches) {
                        for (p = 0; p < props.length; p++) {
                            match = matches[++k];
                            q = props[p];
                            // check if given property is actually array
                            if (typeof q === OBJ_TYPE && q.length > 0) {
                                if (q.length == 2) {
                                    if (typeof q[1] == FUNC_TYPE) {
                                        // assign modified match
                                        this[q[0]] = q[1].call(this, match);
                                    } else {
                                        // assign given value, ignore regex match
                                        this[q[0]] = q[1];
                                    }
                                } else if (q.length == 3) {
                                    // check whether function or regex
                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                        // call function (usually string mapper)
                                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                                    } else {
                                        // sanitize match using given regex
                                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                                    }
                                } else if (q.length == 4) {
                                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                                }
                            } else {
                                this[q] = match ? match : undefined;
                            }
                        }
                    }
                }
                i += 2;
            }
        },

        str : function (str, map) {

            for (var i in map) {
                // check if array
                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                    for (var j = 0; j < map[i].length; j++) {
                        if (util.has(map[i][j], str)) {
                            return (i === UNKNOWN) ? undefined : i;
                        }
                    }
                } else if (util.has(map[i], str)) {
                    return (i === UNKNOWN) ? undefined : i;
                }
            }
            return str;
        }
    };


    ///////////////
    // String map
    //////////////


    var maps = {

        browser : {
            oldsafari : {
                version : {
                    '1.0'   : '/8',
                    '1.2'   : '/1',
                    '1.3'   : '/3',
                    '2.0'   : '/412',
                    '2.0.2' : '/416',
                    '2.0.3' : '/417',
                    '2.0.4' : '/419',
                    '?'     : '/'
                }
            }
        },

        device : {
            amazon : {
                model : {
                    'Fire Phone' : ['SD', 'KF']
                }
            },
            sprint : {
                model : {
                    'Evo Shift 4G' : '7373KT'
                },
                vendor : {
                    'HTC'       : 'APA',
                    'Sprint'    : 'Sprint'
                }
            }
        },

        os : {
            windows : {
                version : {
                    'ME'        : '4.90',
                    'NT 3.11'   : 'NT3.51',
                    'NT 4.0'    : 'NT4.0',
                    '2000'      : 'NT 5.0',
                    'XP'        : ['NT 5.1', 'NT 5.2'],
                    'Vista'     : 'NT 6.0',
                    '7'         : 'NT 6.1',
                    '8'         : 'NT 6.2',
                    '8.1'       : 'NT 6.3',
                    '10'        : ['NT 6.4', 'NT 10.0'],
                    'RT'        : 'ARM'
                }
            }
        }
    };


    //////////////
    // Regex map
    /////////////


    var regexes = {

        browser : [[

            // Presto based
            /(opera\smini)\/([\w\.-]+)/i,                                       // Opera Mini
            /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,                      // Opera Mobi/Tablet
            /(opera).+version\/([\w\.]+)/i,                                     // Opera > 9.80
            /(opera)[\/\s]+([\w\.]+)/i                                          // Opera < 9.80
            ], [NAME, VERSION], [

            /(opios)[\/\s]+([\w\.]+)/i                                          // Opera mini on iphone >= 8.0
            ], [[NAME, 'Opera Mini'], VERSION], [

            /\s(opr)\/([\w\.]+)/i                                               // Opera Webkit
            ], [[NAME, 'Opera'], VERSION], [

            // Mixed
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i,
                                                                                // Lunascape/Maxthon/Netfront/Jasmine/Blazer
            // Trident based
            /(avant\s|iemobile|slim)(?:browser)?[\/\s]?([\w\.]*)/i,
                                                                                // Avant/IEMobile/SlimBrowser
            /(bidubrowser|baidubrowser)[\/\s]?([\w\.]+)/i,                      // Baidu Browser
            /(?:ms|\()(ie)\s([\w\.]+)/i,                                        // Internet Explorer

            // Webkit/KHTML based
            /(rekonq)\/([\w\.]*)/i,                                             // Rekonq
            /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon)\/([\w\.-]+)/i
                                                                                // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
            ], [NAME, VERSION], [

            /(konqueror)\/([\w\.]+)/i                                           // Konqueror
            ], [[NAME, 'Konqueror'], VERSION], [

            /(trident).+rv[:\s]([\w\.]+).+like\sgecko/i                         // IE11
            ], [[NAME, 'IE'], VERSION], [

            /(edge|edgios|edga|edg)\/((\d+)?[\w\.]+)/i                          // Microsoft Edge
            ], [[NAME, 'Edge'], VERSION], [

            /(yabrowser)\/([\w\.]+)/i                                           // Yandex
            ], [[NAME, 'Yandex'], VERSION], [

            /(Avast)\/([\w\.]+)/i                                               // Avast Secure Browser
            ], [[NAME, 'Avast Secure Browser'], VERSION], [

            /(AVG)\/([\w\.]+)/i                                                 // AVG Secure Browser
            ], [[NAME, 'AVG Secure Browser'], VERSION], [

            /(puffin)\/([\w\.]+)/i                                              // Puffin
            ], [[NAME, 'Puffin'], VERSION], [

            /(focus)\/([\w\.]+)/i                                               // Firefox Focus
            ], [[NAME, 'Firefox Focus'], VERSION], [

            /(opt)\/([\w\.]+)/i                                                 // Opera Touch
            ], [[NAME, 'Opera Touch'], VERSION], [

            /((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i         // UCBrowser
            ], [[NAME, 'UCBrowser'], VERSION], [

            /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
            ], [[NAME, /_/g, ' '], VERSION], [

            /(windowswechat qbcore)\/([\w\.]+)/i                                // WeChat Desktop for Windows Built-in Browser
            ], [[NAME, 'WeChat(Win) Desktop'], VERSION], [

            /(micromessenger)\/([\w\.]+)/i                                      // WeChat
            ], [[NAME, 'WeChat'], VERSION], [

            /(brave)\/([\w\.]+)/i                                               // Brave browser
            ], [[NAME, 'Brave'], VERSION], [

            /(qqbrowserlite)\/([\w\.]+)/i                                       // QQBrowserLite
            ], [NAME, VERSION], [

            /(QQ)\/([\d\.]+)/i                                                  // QQ, aka ShouQ
            ], [NAME, VERSION], [

            /m?(qqbrowser)[\/\s]?([\w\.]+)/i                                    // QQBrowser
            ], [NAME, VERSION], [

            /(baiduboxapp)[\/\s]?([\w\.]+)/i                                    // Baidu App
            ], [NAME, VERSION], [

            /(2345Explorer)[\/\s]?([\w\.]+)/i                                   // 2345 Browser
            ], [NAME, VERSION], [

            /(MetaSr)[\/\s]?([\w\.]+)/i                                         // SouGouBrowser
            ], [NAME], [

            /(LBBROWSER)/i                                                      // LieBao Browser
            ], [NAME], [

            /xiaomi\/miuibrowser\/([\w\.]+)/i                                   // MIUI Browser
            ], [VERSION, [NAME, 'MIUI Browser']], [

            /;fbav\/([\w\.]+);/i                                                // Facebook App for iOS & Android
            ], [VERSION, [NAME, 'Facebook']], [

            /safari\s(line)\/([\w\.]+)/i,                                       // Line App for iOS
            /android.+(line)\/([\w\.]+)\/iab/i                                  // Line App for Android
            ], [NAME, VERSION], [

            /headlesschrome(?:\/([\w\.]+)|\s)/i                                 // Chrome Headless
            ], [VERSION, [NAME, 'Chrome Headless']], [

            /\swv\).+(chrome)\/([\w\.]+)/i                                      // Chrome WebView
            ], [[NAME, /(.+)/, '$1 WebView'], VERSION], [

            /((?:oculus|samsung)browser)\/([\w\.]+)/i
            ], [[NAME, /(.+(?:g|us))(.+)/, '$1 $2'], VERSION], [                // Oculus / Samsung Browser

            /android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i        // Android Browser
            ], [VERSION, [NAME, 'Android Browser']], [

            /(sailfishbrowser)\/([\w\.]+)/i                                     // Sailfish Browser
            ], [[NAME, 'Sailfish Browser'], VERSION], [

            /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i
                                                                                // Chrome/OmniWeb/Arora/Tizen/Nokia
            ], [NAME, VERSION], [

            /(dolfin)\/([\w\.]+)/i                                              // Dolphin
            ], [[NAME, 'Dolphin'], VERSION], [

            /(qihu|qhbrowser|qihoobrowser|360browser)/i                         // 360
            ], [[NAME, '360 Browser']], [

            /((?:android.+)crmo|crios)\/([\w\.]+)/i                             // Chrome for Android/iOS
            ], [[NAME, 'Chrome'], VERSION], [

            /(coast)\/([\w\.]+)/i                                               // Opera Coast
            ], [[NAME, 'Opera Coast'], VERSION], [

            /fxios\/([\w\.-]+)/i                                                // Firefox for iOS
            ], [VERSION, [NAME, 'Firefox']], [

            /version\/([\w\.]+).+?mobile\/\w+\s(safari)/i                       // Mobile Safari
            ], [VERSION, [NAME, 'Mobile Safari']], [

            /version\/([\w\.]+).+?(mobile\s?safari|safari)/i                    // Safari & Safari Mobile
            ], [VERSION, NAME], [

            /webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i  // Google Search Appliance on iOS
            ], [[NAME, 'GSA'], VERSION], [

            /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i                     // Safari < 3.0
            ], [NAME, [VERSION, mapper.str, maps.browser.oldsafari.version]], [

            /(webkit|khtml)\/([\w\.]+)/i
            ], [NAME, VERSION], [

            // Gecko based
            /(navigator|netscape)\/([\w\.-]+)/i                                 // Netscape
            ], [[NAME, 'Netscape'], VERSION], [
            /(swiftfox)/i,                                                      // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,
                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i,

                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,                          // Mozilla

            // Other
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,
                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir
            /(links)\s\(([\w\.]+)/i,                                            // Links
            /(gobrowser)\/?([\w\.]*)/i,                                         // GoBrowser
            /(ice\s?browser)\/v?([\w\._]+)/i,                                   // ICE Browser
            /(mosaic)[\/\s]([\w\.]+)/i                                          // Mosaic
            ], [NAME, VERSION]
        ],

        cpu : [[

            /(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i                     // AMD64
            ], [[ARCHITECTURE, 'amd64']], [

            /(ia32(?=;))/i                                                      // IA32 (quicktime)
            ], [[ARCHITECTURE, util.lowerize]], [

            /((?:i[346]|x)86)[;\)]/i                                            // IA32
            ], [[ARCHITECTURE, 'ia32']], [

            // PocketPC mistakenly identified as PowerPC
            /windows\s(ce|mobile);\sppc;/i
            ], [[ARCHITECTURE, 'arm']], [

            /((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i                           // PowerPC
            ], [[ARCHITECTURE, /ower/, '', util.lowerize]], [

            /(sun4\w)[;\)]/i                                                    // SPARC
            ], [[ARCHITECTURE, 'sparc']], [

            /((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+[;l]))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i
                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
            ], [[ARCHITECTURE, util.lowerize]]
        ],

        device : [[

            /\((ipad|playbook);[\w\s\),;-]+(rim|apple)/i                        // iPad/PlayBook
            ], [MODEL, VENDOR, [TYPE, TABLET]], [

            /applecoremedia\/[\w\.]+ \((ipad)/                                  // iPad
            ], [MODEL, [VENDOR, 'Apple'], [TYPE, TABLET]], [

            /(apple\s{0,1}tv)/i                                                 // Apple TV
            ], [[MODEL, 'Apple TV'], [VENDOR, 'Apple'], [TYPE, SMARTTV]], [

            /(archos)\s(gamepad2?)/i,                                           // Archos
            /(hp).+(touchpad)/i,                                                // HP TouchPad
            /(hp).+(tablet)/i,                                                  // HP Tablet
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /\s(nook)[\w\s]+build\/(\w+)/i,                                     // Nook
            /(dell)\s(strea[kpr\s\d]*[\dko])/i                                  // Dell Streak
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /(kf[A-z]+)\sbuild\/.+silk\//i                                      // Kindle Fire HD
            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [
            /(sd|kf)[0349hijorstuw]+\sbuild\/.+silk\//i                         // Fire Phone
            ], [[MODEL, mapper.str, maps.device.amazon.model], [VENDOR, 'Amazon'], [TYPE, MOBILE]], [
            /android.+aft([bms])\sbuild/i                                       // Fire TV
            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, SMARTTV]], [

            /\((ip[honed|\s\w*]+);.+(apple)/i                                   // iPod/iPhone
            ], [MODEL, VENDOR, [TYPE, MOBILE]], [
            /\((ip[honed|\s\w*]+);/i                                            // iPod/iPhone
            ], [MODEL, [VENDOR, 'Apple'], [TYPE, MOBILE]], [

            /(blackberry)[\s-]?(\w+)/i,                                         // BlackBerry
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i,
                                                                                // BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
            /(hp)\s([\w\s]+\w)/i,                                               // HP iPAQ
            /(asus)-?(\w+)/i                                                    // Asus
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /\(bb10;\s(\w+)/i                                                   // BlackBerry 10
            ], [MODEL, [VENDOR, 'BlackBerry'], [TYPE, MOBILE]], [
                                                                                // Asus Tablets
            /android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone|p00c)/i
            ], [MODEL, [VENDOR, 'Asus'], [TYPE, TABLET]], [

            /(sony)\s(tablet\s[ps])\sbuild\//i,                                  // Sony
            /(sony)?(?:sgp.+)\sbuild\//i
            ], [[VENDOR, 'Sony'], [MODEL, 'Xperia Tablet'], [TYPE, TABLET]], [
            /android.+\s([c-g]\d{4}|so[-l]\w+)(?=\sbuild\/|\).+chrome\/(?![1-6]{0,1}\d\.))/i
            ], [MODEL, [VENDOR, 'Sony'], [TYPE, MOBILE]], [

            /\s(ouya)\s/i,                                                      // Ouya
            /(nintendo)\s([wids3u]+)/i                                          // Nintendo
            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [

            /android.+;\s(shield)\sbuild/i                                      // Nvidia
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [

            /(playstation\s[34portablevi]+)/i                                   // Playstation
            ], [MODEL, [VENDOR, 'Sony'], [TYPE, CONSOLE]], [

            /(sprint\s(\w+))/i                                                  // Sprint Phones
            ], [[VENDOR, mapper.str, maps.device.sprint.vendor], [MODEL, mapper.str, maps.device.sprint.model], [TYPE, MOBILE]], [

            /(htc)[;_\s-]+([\w\s]+(?=\)|\sbuild)|\w+)/i,                        // HTC
            /(zte)-(\w*)/i,                                                     // ZTE
            /(alcatel|geeksphone|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i
                                                                                // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

            /(nexus\s9)/i                                                       // HTC Nexus 9
            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [

            /d\/huawei([\w\s-]+)[;\)]/i,
            /(nexus\s6p|vog-l29|ane-lx1|eml-l29|ele-l29)/i                              // Huawei
            ], [MODEL, [VENDOR, 'Huawei'], [TYPE, MOBILE]], [

            /android.+(bah2?-a?[lw]\d{2})/i                                     // Huawei MediaPad
            ], [MODEL, [VENDOR, 'Huawei'], [TYPE, TABLET]], [

            /(microsoft);\s(lumia[\s\w]+)/i                                     // Microsoft Lumia
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /[\s\(;](xbox(?:\sone)?)[\s\);]/i                                   // Microsoft Xbox
            ], [MODEL, [VENDOR, 'Microsoft'], [TYPE, CONSOLE]], [
            /(kin\.[onetw]{3})/i                                                // Microsoft Kin
            ], [[MODEL, /\./g, ' '], [VENDOR, 'Microsoft'], [TYPE, MOBILE]], [

                                                                                // Motorola
            /\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)[\w\s]+build\//i,
            /mot[\s-]?(\w*)/i,
            /(XT\d{3,4}) build\//i,
            /(nexus\s6)/i
            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, MOBILE]], [
            /android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i
            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, TABLET]], [

            /hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i            // HbbTV devices
            ], [[VENDOR, util.trim], [MODEL, util.trim], [TYPE, SMARTTV]], [

            /hbbtv.+maple;(\d+)/i
            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, 'Samsung'], [TYPE, SMARTTV]], [

            /\(dtv[\);].+(aquos)/i                                              // Sharp
            ], [MODEL, [VENDOR, 'Sharp'], [TYPE, SMARTTV]], [

            /android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i,
            /((SM-T\w+))/i
            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, TABLET]], [                  // Samsung
            /smart-tv.+(samsung)/i
            ], [VENDOR, [TYPE, SMARTTV], MODEL], [
            /((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i,
            /(sam[sung]*)[\s-]*(\w+-?[\w-]*)/i,
            /sec-((sgh\w+))/i
            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, MOBILE]], [

            /sie-(\w*)/i                                                        // Siemens
            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [

            /(maemo|nokia).*(n900|lumia\s\d+)/i,                                // Nokia
            /(nokia)[\s_-]?([\w-]*)/i
            ], [[VENDOR, 'Nokia'], MODEL, [TYPE, MOBILE]], [

            /android[x\d\.\s;]+\s([ab][1-7]\-?[0178a]\d\d?)/i                   // Acer
            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [

            /android.+([vl]k\-?\d{3})\s+build/i                                 // LG Tablet
            ], [MODEL, [VENDOR, 'LG'], [TYPE, TABLET]], [
            /android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i                     // LG Tablet
            ], [[VENDOR, 'LG'], MODEL, [TYPE, TABLET]], [
            /(lg) netcast\.tv/i                                                 // LG SmartTV
            ], [VENDOR, MODEL, [TYPE, SMARTTV]], [
            /(nexus\s[45])/i,                                                   // LG
            /lg[e;\s\/-]+(\w*)/i,
            /android.+lg(\-?[\d\w]+)\s+build/i
            ], [MODEL, [VENDOR, 'LG'], [TYPE, MOBILE]], [

            /(lenovo)\s?(s(?:5000|6000)(?:[\w-]+)|tab(?:[\s\w]+))/i             // Lenovo tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [
            /android.+(ideatab[a-z0-9\-\s]+)/i                                  // Lenovo
            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [
            /(lenovo)[_\s-]?([\w-]+)/i
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /linux;.+((jolla));/i                                               // Jolla
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /((pebble))app\/[\d\.]+\s/i                                         // Pebble
            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [

            /android.+;\s(oppo)\s?([\w\s]+)\sbuild/i                            // OPPO
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /crkey/i                                                            // Google Chromecast
            ], [[MODEL, 'Chromecast'], [VENDOR, 'Google'], [TYPE, SMARTTV]], [

            /android.+;\s(glass)\s\d/i                                          // Google Glass
            ], [MODEL, [VENDOR, 'Google'], [TYPE, WEARABLE]], [

            /android.+;\s(pixel c)[\s)]/i                                       // Google Pixel C
            ], [MODEL, [VENDOR, 'Google'], [TYPE, TABLET]], [

            /android.+;\s(pixel( [23])?( xl)?)[\s)]/i                              // Google Pixel
            ], [MODEL, [VENDOR, 'Google'], [TYPE, MOBILE]], [

            /android.+;\s(\w+)\s+build\/hm\1/i,                                 // Xiaomi Hongmi 'numeric' models
            /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,               // Xiaomi Hongmi
            /android.+(mi[\s\-_]*(?:a\d|one|one[\s_]plus|note lte)?[\s_]*(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i,    
                                                                                // Xiaomi Mi
            /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]?[\w\s]+))\s+build/i       // Redmi Phones
            ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [
            /android.+(mi[\s\-_]*(?:pad)(?:[\s_]?[\w\s]+))\s+build/i            // Mi Pad tablets
            ],[[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, TABLET]], [
            /android.+;\s(m[1-5]\snote)\sbuild/i                                // Meizu
            ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [
            /(mz)-([\w-]{2,})/i
            ], [[VENDOR, 'Meizu'], MODEL, [TYPE, MOBILE]], [

            /android.+a000(1)\s+build/i,                                        // OnePlus
            /android.+oneplus\s(a\d{4})[\s)]/i
            ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [

            /android.+[;\/]\s*(RCT[\d\w]+)\s+build/i                            // RCA Tablets
            ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [

            /android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i                      // Dell Venue Tablets
            ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i                         // Verizon Tablet
            ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [

            /android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i     // Barnes & Noble Tablet
            ], [[VENDOR, 'Barnes & Noble'], MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i                           // Barnes & Noble Tablet
            ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [

            /android.+;\s(k88)\sbuild/i                                         // ZTE K Series Tablet
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(gen\d{3})\s+build.*49h/i                         // Swiss GEN Mobile
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [

            /android.+[;\/]\s*(zur\d{3})\s+build/i                              // Swiss ZUR Tablet
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [

            /android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i                         // Zeki Tablets
            ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [

            /(android).+[;\/]\s+([YR]\d{2})\s+build/i,
            /android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(\w{5})\sbuild/i        // Dragon Touch Tablet
            ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*(NS-?\w{0,9})\sbuild/i                            // Insignia Tablets
            ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [

            /android.+[;\/]\s*((NX|Next)-?\w{0,9})\s+build/i                    // NextBook Tablets
            ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Xtreme\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i
            ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [                    // Voice Xtreme Phones

            /android.+[;\/]\s*(LVTEL\-)?(V1[12])\s+build/i                     // LvTel Phones
            ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [

            /android.+;\s(PH-1)\s/i
            ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [                // Essential PH-1

            /android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i          // Envizen Tablets
            ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(\w{1,9})\s+build/i          // Le Pan Tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i                         // MachSpeed Tablets
            ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [

            /android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i                // Trinity Tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /android.+[;\/]\s*TU_(1491)\s+build/i                               // Rotor Tablets
            ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [

            /android.+(KS(.+))\s+build/i                                        // Amazon Kindle Tablets
            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [

            /android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i                      // Gigaset Tablets
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /\s(tablet|tab)[;\/]/i,                                             // Unidentifiable Tablet
            /\s(mobile)(?:[;\/]|\ssafari)/i                                     // Unidentifiable Mobile
            ], [[TYPE, util.lowerize], VENDOR, MODEL], [

            /[\s\/\(](smart-?tv)[;\)]/i                                         // SmartTV
            ], [[TYPE, SMARTTV]], [

            /(android[\w\.\s\-]{0,9});.+build/i                                 // Generic Android Device
            ], [MODEL, [VENDOR, 'Generic']]
        ],

        engine : [[

            /windows.+\sedge\/([\w\.]+)/i                                       // EdgeHTML
            ], [VERSION, [NAME, 'EdgeHTML']], [

            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i                         // Blink
            ], [VERSION, [NAME, 'Blink']], [

            /(presto)\/([\w\.]+)/i,                                             // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,     
                                                                                // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
            /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,                          // KHTML/Tasman/Links
            /(icab)[\/\s]([23]\.[\d\.]+)/i                                      // iCab
            ], [NAME, VERSION], [

            /rv\:([\w\.]{1,9}).+(gecko)/i                                       // Gecko
            ], [VERSION, NAME]
        ],

        os : [[

            // Windows based
            /microsoft\s(windows)\s(vista|xp)/i                                 // Windows (iTunes)
            ], [NAME, VERSION], [
            /(windows)\snt\s6\.2;\s(arm)/i,                                     // Windows RT
            /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i,                   // Windows Phone
            /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i
            ], [NAME, [VERSION, mapper.str, maps.os.windows.version]], [
            /(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i
            ], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [

            // Mobile/Embedded OS
            /\((bb)(10);/i                                                      // BlackBerry 10
            ], [[NAME, 'BlackBerry'], VERSION], [
            /(blackberry)\w*\/?([\w\.]*)/i,                                     // Blackberry
            /(tizen|kaios)[\/\s]([\w\.]+)/i,                                    // Tizen/KaiOS
            /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|sailfish|contiki)[\/\s-]?([\w\.]*)/i
                                                                                // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo/Contiki/Sailfish OS
            ], [NAME, VERSION], [
            /(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]*)/i                  // Symbian
            ], [[NAME, 'Symbian'], VERSION], [
            /\((series40);/i                                                    // Series 40
            ], [NAME], [
            /mozilla.+\(mobile;.+gecko.+firefox/i                               // Firefox OS
            ], [[NAME, 'Firefox OS'], VERSION], [

            // Console
            /(nintendo|playstation)\s([wids34portablevu]+)/i,                   // Nintendo/Playstation

            // GNU/Linux based
            /(mint)[\/\s\(]?(\w*)/i,                                            // Mint
            /(mageia|vectorlinux)[;\s]/i,                                       // Mageia/VectorLinux
            /(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]*)/i,
                                                                                // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware
                                                                                // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus
            /(hurd|linux)\s?([\w\.]*)/i,                                        // Hurd/Linux
            /(gnu)\s?([\w\.]*)/i                                                // GNU
            ], [NAME, VERSION], [

            /(cros)\s[\w]+\s([\w\.]+\w)/i                                       // Chromium OS
            ], [[NAME, 'Chromium OS'], VERSION],[

            // Solaris
            /(sunos)\s?([\w\.\d]*)/i                                            // Solaris
            ], [[NAME, 'Solaris'], VERSION], [

            // BSD based
            /\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]*)/i                    // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly
            ], [NAME, VERSION],[

            /(haiku)\s(\w+)/i                                                   // Haiku
            ], [NAME, VERSION],[

            /cfnetwork\/.+darwin/i,
            /ip[honead]{2,4}(?:.*os\s([\w]+)\slike\smac|;\sopera)/i             // iOS
            ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [

            /(mac\sos\sx)\s?([\w\s\.]*)/i,
            /(macintosh|mac(?=_powerpc)\s)/i                                    // Mac OS
            ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [

            // Other
            /((?:open)?solaris)[\/\s-]?([\w\.]*)/i,                             // Solaris
            /(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i,                                // AIX
            /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms|fuchsia)/i,
                                                                                // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS/OpenVMS/Fuchsia
            /(unix)\s?([\w\.]*)/i                                               // UNIX
            ], [NAME, VERSION]
        ]
    };


    /////////////////
    // Constructor
    ////////////////
    var UAParser = function (uastring, extensions) {

        if (typeof uastring === 'object') {
            extensions = uastring;
            uastring = undefined;
        }

        if (!(this instanceof UAParser)) {
            return new UAParser(uastring, extensions).getResult();
        }

        var ua = uastring || ((window && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);
        var rgxmap = extensions ? util.extend(regexes, extensions) : regexes;

        this.getBrowser = function () {
            var browser = { name: undefined, version: undefined };
            mapper.rgx.call(browser, ua, rgxmap.browser);
            browser.major = util.major(browser.version); // deprecated
            return browser;
        };
        this.getCPU = function () {
            var cpu = { architecture: undefined };
            mapper.rgx.call(cpu, ua, rgxmap.cpu);
            return cpu;
        };
        this.getDevice = function () {
            var device = { vendor: undefined, model: undefined, type: undefined };
            mapper.rgx.call(device, ua, rgxmap.device);
            return device;
        };
        this.getEngine = function () {
            var engine = { name: undefined, version: undefined };
            mapper.rgx.call(engine, ua, rgxmap.engine);
            return engine;
        };
        this.getOS = function () {
            var os = { name: undefined, version: undefined };
            mapper.rgx.call(os, ua, rgxmap.os);
            return os;
        };
        this.getResult = function () {
            return {
                ua      : this.getUA(),
                browser : this.getBrowser(),
                engine  : this.getEngine(),
                os      : this.getOS(),
                device  : this.getDevice(),
                cpu     : this.getCPU()
            };
        };
        this.getUA = function () {
            return ua;
        };
        this.setUA = function (uastring) {
            ua = uastring;
            return this;
        };
        return this;
    };

    UAParser.VERSION = LIBVERSION;
    UAParser.BROWSER = {
        NAME    : NAME,
        MAJOR   : MAJOR, // deprecated
        VERSION : VERSION
    };
    UAParser.CPU = {
        ARCHITECTURE : ARCHITECTURE
    };
    UAParser.DEVICE = {
        MODEL   : MODEL,
        VENDOR  : VENDOR,
        TYPE    : TYPE,
        CONSOLE : CONSOLE,
        MOBILE  : MOBILE,
        SMARTTV : SMARTTV,
        TABLET  : TABLET,
        WEARABLE: WEARABLE,
        EMBEDDED: EMBEDDED
    };
    UAParser.ENGINE = {
        NAME    : NAME,
        VERSION : VERSION
    };
    UAParser.OS = {
        NAME    : NAME,
        VERSION : VERSION
    };

    ///////////
    // Export
    //////////


    // check js environment
    if (typeof(exports) !== UNDEF_TYPE) {
        // nodejs env
        if ("object" !== UNDEF_TYPE && module.exports) {
            exports = module.exports = UAParser;
        }
        exports.UAParser = UAParser;
    } else {
        // requirejs env (optional)
        if (true) {
            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
                return UAParser;
            }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {}
    }

    // jQuery/Zepto specific (optional)
    // Note:
    //   In AMD env the global scope should be kept clean, but jQuery is an exception.
    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
    //   and we should catch that.
    var $ = window && (window.jQuery || window.Zepto);
    if ($ && !$.ua) {
        var parser = new UAParser();
        $.ua = parser.getResult();
        $.ua.get = function () {
            return parser.getUA();
        };
        $.ua.set = function (uastring) {
            parser.setUA(uastring);
            var result = parser.getResult();
            for (var prop in result) {
                $.ua[prop] = result[prop];
            }
        };
    }

})(typeof window === 'object' ? window : this);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/index.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL3NyYy92aWV3cy9Ib21lVmlldy50YWcuaHRtbCIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL3NyYy9tb2RlbHMvRm9ybWF0TW9kZWwuanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9zcmMvbW9kZWxzL0hvbWVNb2RlbC5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL3NyYy9tb2RlbHMvU3BlZWNoUmVjb2duaXRpb25Nb2RlbC5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL3NyYy9yZXBvc2l0b3JpZXMvT0JTUmVwb3NpdG9yeS5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLm5hdGl2ZS9kaXN0L2Jvb3RzdHJhcC1uYXRpdmUuZXNtLmpzIiwid2VicGFjazovL29icy10cmFuc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwid2VicGFjazovL29icy10cmFuc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9zcmMvYXNzZXRzL2ltYWdlcy9vYnMtY3JlYXRlLXRleHQtc291cmNlLnBuZyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL3NyYy9hc3NldHMvaW1hZ2VzL29icy13ZWJzb2NrZXQtY29ubmVjdGlvbi5wbmciLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovL29icy10cmFuc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvaXNvbW9ycGhpYy13cy9icm93c2VyLmpzIiwid2VicGFjazovL29icy10cmFuc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwid2VicGFjazovL29icy10cmFuc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL29icy13ZWJzb2NrZXQtanMvbGliL09CU1dlYlNvY2tldC5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL25vZGVfbW9kdWxlcy9vYnMtd2Vic29ja2V0LWpzL2xpYi9Tb2NrZXQuanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvb2JzLXdlYnNvY2tldC1qcy9saWIvU3RhdHVzLmpzIiwid2VicGFjazovL29icy10cmFuc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL29icy13ZWJzb2NrZXQtanMvbGliL2luZGV4LmpzIiwid2VicGFjazovL29icy10cmFuc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL29icy13ZWJzb2NrZXQtanMvbGliL3V0aWwvYXV0aGVudGljYXRpb25IYXNoaW5nLmpzIiwid2VicGFjazovL29icy10cmFuc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL29icy13ZWJzb2NrZXQtanMvbGliL3V0aWwvY2FtZWxDYXNlS2V5cy5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL25vZGVfbW9kdWxlcy9vYnMtd2Vic29ja2V0LWpzL2xpYi91dGlsL2xvZ0FtYmlndW91c0Vycm9yLmpzIiwid2VicGFjazovL29icy10cmFuc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3Jpb3QvcmlvdC5lc20uanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvc2hhLmpzL2hhc2guanMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTI1Ni5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC8uL25vZGVfbW9kdWxlcy91YS1wYXJzZXItanMvc3JjL3VhLXBhcnNlci5qcyIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9vYnMtdHJhbnNjcmlwdC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL29icy10cmFuc2NyaXB0L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vb2JzLXRyYW5zY3JpcHQvd2VicGFjay9zdGFydHVwIl0sIm5hbWVzIjpbInJpb3QiLCJIb21lVmlldyIsInN0cnMiLCJtYXhSb3dzIiwibWF4Q29scyIsImxpbmVzIiwibWFwIiwicyIsInNwbGl0bGluZXMiLCJmbGF0Iiwic2xpY2UiLCJNYXRoIiwibWF4IiwibGVuZ3RoIiwiam9pbiIsInN0ciIsImN1cnJMaW5lIiwic3BsaXQiLCJmb3JFYWNoIiwid2QiLCJzcGxpdGNoYXJ3aXNlIiwicG9wIiwibmV3TGluZSIsInB1c2giLCJzdWJzdHJpbmciLCJvYnNSZXBvc2l0b3J5IiwiT0JTUmVwb3NpdG9yeSIsInVhUGFyc2VyIiwiVUFQYXJzZXIiLCJzcGVlY2hSZWNvZ25pdGlvbk1vZGVsIiwiU3BlZWNoUmVjb2duaXRpb25Nb2RlbCIsImZvcm1hdE1vZGVsIiwiRm9ybWF0TW9kZWwiLCJsYW5nIiwiZ2V0RGVmYXVsdExhbmd1YWdlIiwid2Vic29ja2V0QWRkcmVzcyIsIndlYnNvY2tldFBhc3N3b3JkIiwic291cmNlTmFtZSIsInNvdXJjZVR5cGUiLCJnZXREZWZhdWx0U291cmNlVHlwZSIsImZpeGVkVHJhbnNjcmlwdHMiLCJpc1N1cHBvcnRlZCIsIndpbmRvdyIsIm5hdmlnYXRvciIsImxhbmd1YWdlcyIsImxhbmd1YWdlIiwidXNlckxhbmd1YWdlIiwiYnJvd3Nlckxhbmd1YWdlIiwib3MiLCJnZXRPUyIsIm5hbWUiLCJjb25uZWN0IiwiYWRkcmVzcyIsInBhc3N3b3JkIiwidGhlbiIsInNldFRleHQiLCJzdGFydCIsImV2ZW50IiwiY29uc29sZSIsImxvZyIsInRyYW5zY3JpcHRzIiwiaXNGaW5hbCIsInRyYW5zY3JpcHQiLCJ0ZXh0IiwiZm9ybWF0IiwiZXJyIiwic3RvcCIsImRpc2Nvbm5lY3QiLCJ3ZWJraXRTcGVlY2hSZWNvZ25pdGlvbiIsIlNwZWVjaFJlY29nbml0aW9uIiwib25yZXN1bHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImVuZ2luZSIsImNvbnRpbnVvdXMiLCJpbnRlcmltUmVzdWx0cyIsIm1heEFsdGVybmF0aXZlcyIsIm9uc3RhcnQiLCJvbmVuZCIsImlzUnVubmluZyIsIm9uZXJyb3IiLCJpIiwicmVzdWx0SW5kZXgiLCJyZXN1bHRzIiwiY29uZmlkZW5jZSIsIndlYnNvY2tldCIsIk9CU1dlYlNvY2tldCIsImNvbm5JbmZvIiwic2V0VGV4dEdESVBsdXMiLCJzZXRUZXh0RnJlZXR5cGUy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SztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3QkFBd0IsRUFBRTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLE9BQU8sZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxxQ0FBcUM7QUFDM0YsU0FBUztBQUNULHVEQUF1RCxrQ0FBa0M7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sT0FBTyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFzRDtBQUM1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQyxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBDQUEwQywyQkFBMkIsRUFBRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLDBDQUEwQyxxQ0FBcUMsRUFBRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEtBQUssRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3puRHJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxvREFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMsZ0RBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLGdEQUFTOztBQUUvQixjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUJBQU07QUFDbkMsSUFBSSxxQkFBTTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNXZEQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCLGVBQWU7O0FBRWY7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FB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QSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMsZ0JBQWdCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEs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O1dBQ0E7V0FDQSx3Q0FBd0MseUNBQXlDO1dBQ2pGO1dBQ0E7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsRUFBRTtXQUNGO1dBQ0E7V0FDQSxDQUFDLEk7Ozs7O1dDUEQsc0Y7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0Esc0RBQXNELGtCQUFrQjtXQUN4RTtXQUNBLCtDQUErQyxjQUFjO1dBQzdELEU7Ozs7O1dDTkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esa0M7Ozs7VUNmQTtVQUNBO1VBQ0E7VUFDQSIsImZpbGUiOiJpbmRleC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyI8SG9tZVZpZXc+XG4gIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwianVtYm90cm9uXCI+XG4gICAgICA8aDE+T0JTIFRyYW5zY3JpcHQ8L2gxPlxuICAgICAgPHA+QXV0b21hdGljIHRyYW5zY3JpcHQgYnkgc3BlZWNoIHJlY29nbml0aW9uIGZvciBPQlMgU3R1ZGlvLjwvcD5cbiAgICAgIDxzZWN0aW9uPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC00XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXBcIj5cblx0ICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvblwiPkxhbmd1YWdlPC9zcGFuPlxuICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIlxuICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJMYW5ndWFnZVwiXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZT1cInsgaG9tZU1vZGVsLmxhbmcgfVwiXG4gICAgICAgICAgICAgICAgICAgICBvbmlucHV0PVwieyBlID0+IGhvbWVNb2RlbC5sYW5nID0gZS50YXJnZXQudmFsdWUgfVwiXG4gICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD1cInsgaXNSdW5uaW5nIH1cIiAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC0yXCI+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgY2xhc3M9XCJidG4geyBpc1J1bm5pbmcgPyAnYnRuLWRhbmdlcicgOiAnYnRuLXN1Y2Nlc3MnIH1cIlxuICAgICAgICAgICAgICAgICAgIHZhbHVlPVwieyBpc1J1bm5pbmcgPyAnU3RvcCcgOiAnU3RhcnQnIH1cIlxuICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9XCJ7IG9uVG9nZ2xlU3RhcnRTdG9wQnV0dG9uIH1cIlxuICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPVwieyAhaG9tZU1vZGVsLmlzU3VwcG9ydGVkIH1cIiAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvc2VjdGlvbj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtMTJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LWRhbmdlclwiIHJvbGU9XCJhbGVydFwiIGlmPVwieyBlcnJvck1lc3NhZ2UgfVwiPlxuICAgICAgICAgIDxzdHJvbmc+RXJyb3I8L3N0cm9uZz46IHsgZXJyb3JNZXNzYWdlIH1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxzZWN0aW9uPlxuICAgICAgPGgzPjEuIEVuYWJsZSBPQlMgV2ViU29ja2V0PC9oMz5cbiAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC03XCI+XG4gICAgICAgICAgPHA+XG4gICAgICAgICAgICBJbnN0YWxsIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vUGFsYWtpcy9vYnMtd2Vic29ja2V0L3JlbGVhc2VzXCI+b2JzLXdlYnNvY2tldDwvYT4gNC44IG9yIGFib3ZlLCBhbmRcbiAgICAgICAgICAgIG9wZW4gXCJXZWJTb2NrZXQgU2VydmVyIFNldHRpbmdzXCIgZGlhbG9nIHVuZGVyIE9CUycgXCJUb29sc1wiIG1lbnUuXG4gICAgICAgICAgICBBZnRlciBhY3RpdmF0aW9uIG9mIE9CUyBXZWJTb2NrZXQgU2VydmVyLCBjb3B5IHRoZSBXZWJTb2NrZXQgc2V0dGluZ3MgaW50byB0aGUgZm9sbG93aW5nIHRleHQgYm94ZXMuXG4gICAgICAgICAgPC9wPlxuICAgICAgICAgIDxwPlxuICAgICAgICAgICAgPGxhYmVsPkFkZHJlc3M8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwXCI+XG5cdCAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIj53czovLzwvc3Bhbj5cbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiSG9zdDpQb3J0XCJcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlPVwieyBob21lTW9kZWwud2Vic29ja2V0QWRkcmVzcyB9XCJcbiAgICAgICAgICAgICAgICAgICAgIG9uaW5wdXQ9XCJ7IGUgPT4gaG9tZU1vZGVsLndlYnNvY2tldEFkZHJlc3MgPSBlLnRhcmdldC52YWx1ZSB9XCJcbiAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPVwieyBpc1J1bm5pbmcgfVwiIC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L3A+XG4gICAgICAgICAgPHA+XG4gICAgICAgICAgICA8bGFiZWw+UGFzc3dvcmQ8L2xhYmVsPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiXG4gICAgICAgICAgICAgICAgICAgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIlxuICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiUGFzc3dvcmRcIlxuICAgICAgICAgICAgICAgICAgIHZhbHVlPVwieyBob21lTW9kZWwud2Vic29ja2V0UGFzc3dvcmQgfVwiXG4gICAgICAgICAgICAgICAgICAgb25pbnB1dD1cInsgZSA9PiBob21lTW9kZWwud2Vic29ja2V0UGFzc3dvcmQgPSBlLnRhcmdldC52YWx1ZSB9XCJcbiAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD1cInsgaXNSdW5uaW5nIH1cIiAvPlxuICAgICAgICAgIDwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNSByaWdodC1pbWFnZVwiPlxuICAgICAgICAgIDxpbWFnZSBzcmM9XCJpbWFnZXMvb2JzLXdlYnNvY2tldC1jb25uZWN0aW9uLnBuZ1wiIHdpZHRoPVwiMzUwXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L3NlY3Rpb24+XG5cbiAgICA8c2VjdGlvbj5cbiAgICAgIDxoMz4yLiBDcmVhdGUgYSB0ZXh0IHNvdXJjZTwvaDM+XG4gICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtN1wiPlxuICAgICAgICAgIDxwPlxuICAgICAgICAgICAgQWRkIFwiVGV4dCAoR0RJKylcIiBvbiBXaW5kb3dzLCBvciBcIlRleHQgKEZyZWVUeXBlIDIpXCIgb24gTWFjIE9TIFggb3IgTGludXggdG8gT0JTJyBcIlNvdXJjZXNcIi5cbiAgICAgICAgICA8L3A+XG4gICAgICAgICAgPHA+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbD5Tb3VyY2UgbmFtZTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIlxuICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlRleHQgc291cmNlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9XCJ7IGhvbWVNb2RlbC5zb3VyY2VOYW1lIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICBvbmlucHV0PVwieyBlID0+IGhvbWVNb2RlbC5zb3VyY2VOYW1lID0gZS50YXJnZXQudmFsdWUgfVwiXG4gICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPVwieyBpc1J1bm5pbmcgfVwiIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWw+U291cmNlIHR5cGU8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxzZWxlY3QgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIlxuICAgICAgICAgICAgICAgICAgICAgICAgb25pbnB1dD1cInsgZSA9PiBob21lTW9kZWwuc291cmNlVHlwZSA9IGUudGFyZ2V0LnZhbHVlIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9XCJ7IGlzUnVubmluZyB9XCI+XG4gICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMFwiIHNlbGVjdGVkPVwieyBob21lTW9kZWwuc291cmNlVHlwZSA9PSAwIH1cIj5UZXh0IChHREkrKSBbV2luZG93c108L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxXCIgc2VsZWN0ZWQ9XCJ7IGhvbWVNb2RlbC5zb3VyY2VUeXBlID09IDEgfVwiPlRleHQgKEZyZWVUeXBlIDIpIFtNYWMvTGludXhdPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9wPlxuICAgICAgICAgIDxwPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWw+VGhlIG51bWJlciBvZiBsaW5lczwvbGFiZWw+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiB2YWx1ZT1cInsgaG9tZU1vZGVsLm1heFJvd3MgfVwiXG4gICAgICAgICAgICAgICAgICAgICAgIG9uaW5wdXQ9XCJ7IGUgPT4gaG9tZU1vZGVsLm1heFJvd3MgPSBlLnRhcmdldC52YWx1ZSB9XCIgLz5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiPlxuICAgICAgICAgICAgICAgIDxsYWJlbD5UaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgcGVyIGxpbmU8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgdmFsdWU9XCJ7IGhvbWVNb2RlbC5tYXhDb2xzIH1cIlxuICAgICAgICAgICAgICAgICAgICAgICBvbmlucHV0PVwieyBlID0+IGhvbWVNb2RlbC5tYXhDb2xzID0gZS50YXJnZXQudmFsdWUgfVwiIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1tZC01IHJpZ2h0LWltYWdlXCI+XG4gICAgICAgICAgPGltYWdlIHNyYz1cImltYWdlcy9vYnMtY3JlYXRlLXRleHQtc291cmNlLnBuZ1wiIHdpZHRoPVwiMzUwXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L3NlY3Rpb24+XG4gIDwvZGl2PlxuXG4gIDxzY3JpcHQ+XG4gICBpbXBvcnQgSG9tZU1vZGVsIGZyb20gXCIuLi9tb2RlbHMvSG9tZU1vZGVsLmpzXCI7XG5cbiAgIGV4cG9ydCBkZWZhdWx0IHtcbiAgICAgaXNSdW5uaW5nOiBmYWxzZSxcbiAgICAgZXJyb3JNZXNzYWdlOiBudWxsLFxuICAgICBob21lTW9kZWw6IG5ldyBIb21lTW9kZWwoKSxcbiAgICAgb25Nb3VudGVkKCkge1xuICAgICAgIGlmICghdGhpcy5ob21lTW9kZWwuaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gXCJTcGVlY2ggcmVjb2duaXRpb24gaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuIFVzZSBHb29nbGUgQ2hyb21lIDMzKyBvciBFZGdlIDc5KyBwbGVhc2UuXCI7XG4gICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgIH1cbiAgICAgfSxcbiAgICAgb25Ub2dnbGVTdGFydFN0b3BCdXR0b24oKSB7XG4gICAgICAgdGhpcy5lcnJvck1lc3NhZ2UgPSBudWxsO1xuXG4gICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICAgICB0aGlzLmhvbWVNb2RlbC5zdG9wKCk7XG4gICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgdGhpcy5ob21lTW9kZWxcbiAgICAgICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICAgICB0aGlzLmVycm9yTWVzc2FnZSA9IGVyci5lcnJvcjtcbiAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgfVxuICAgICB9XG4gICB9O1xuICA8L3NjcmlwdD5cbjwvSG9tZVZpZXc+XG4iLCIvLyBBc3NldHNcbmltcG9ydCBcIi4vYXNzZXRzL2ltYWdlcy9vYnMtY3JlYXRlLXRleHQtc291cmNlLnBuZ1wiO1xuaW1wb3J0IFwiLi9hc3NldHMvaW1hZ2VzL29icy13ZWJzb2NrZXQtY29ubmVjdGlvbi5wbmdcIjtcblxuaW1wb3J0IGJvb3RzdHJhcCBmcm9tIFwiYm9vdHN0cmFwLm5hdGl2ZVwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgKiBhcyByaW90IGZyb20gXCJyaW90XCI7XG5pbXBvcnQgSG9tZVZpZXcgZnJvbSBcIi4vdmlld3MvSG9tZVZpZXcudGFnLmh0bWxcIjtcblxucmlvdC5yZWdpc3RlcihcImhvbWV2aWV3XCIsIEhvbWVWaWV3KTtcbnJpb3QubW91bnQoXCJob21ldmlld1wiKTtcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcblxuICAvKipcbiAgICogRm9ybWF0cyBhIGdpdmVuIHN0cmluZy5cbiAgICovXG4gIGZvcm1hdChzdHJzLCBtYXhSb3dzLCBtYXhDb2xzKSB7XG4gICAgY29uc3QgbGluZXMgPSBzdHJzLm1hcChzID0+IHRoaXMuc3BsaXRsaW5lcyhzLCBtYXhDb2xzKSkuZmxhdCgpO1xuICAgIHJldHVybiBsaW5lcy5zbGljZShNYXRoLm1heCgwLCBsaW5lcy5sZW5ndGggLSBtYXhSb3dzKSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYSBnaXZlbiBzdHJpbmcgaW50byBsaW5lcyBvZiBtYXhpbXVtIGxlbmd0aCBgbWF4Q29sc2AuXG4gICAqL1xuICBzcGxpdGxpbmVzKHN0ciwgbWF4Q29scykge1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxldCBjdXJyTGluZSA9IFwiXCI7XG5cbiAgICBzdHIuc3BsaXQoLyAvKS5mb3JFYWNoKHdkID0+IHtcbiAgICAgIGlmIChjdXJyTGluZS5sZW5ndGggPT0gMCkge1xuICAgICAgICBsaW5lcyA9IHRoaXMuc3BsaXRjaGFyd2lzZShsaW5lcywgd2QsIG1heENvbHMpO1xuICAgICAgICBjdXJyTGluZSA9IGxpbmVzLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV3TGluZSA9IGN1cnJMaW5lICsgXCIgXCIgKyB3ZDtcblxuICAgICAgICBpZiAobmV3TGluZS5sZW5ndGggPD0gbWF4Q29scykge1xuICAgICAgICAgIGN1cnJMaW5lID0gbmV3TGluZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZC5sZW5ndGggPD0gbWF4Q29scykge1xuICAgICAgICAgIGxpbmVzLnB1c2goY3VyckxpbmUpO1xuICAgICAgICAgIGN1cnJMaW5lID0gd2Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZXMgPSB0aGlzLnNwbGl0Y2hhcndpc2UobGluZXMsIG5ld0xpbmUsIG1heENvbHMpO1xuICAgICAgICAgIGN1cnJMaW5lID0gbGluZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChjdXJyTGluZS5sZW5ndGggPiAwKSB7XG4gICAgICBsaW5lcy5wdXNoKGN1cnJMaW5lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGluZXM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGEgZ2l2ZW4gc3RyaW5nIGludG8gc3Vic3RyaW5ncyBvZiBtYXhpbXVtIGxlbmd0aCBgbWF4Q29sc2AsXG4gICAqIGFuZCBhcHBlbmRzIHRoZSBzdWJzdHJpbmdzIGludG8gYGxpbmVzYC5cbiAgICovXG4gIHNwbGl0Y2hhcndpc2UobGluZXMsIHN0ciwgbWF4Q29scykge1xuICAgIHdoaWxlIChzdHIubGVuZ3RoID4gbWF4Q29scykge1xuICAgICAgbGluZXMucHVzaChzdHIuc3Vic3RyaW5nKDAsIG1heENvbHMpKTtcbiAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcobWF4Q29scyk7XG4gICAgfVxuXG4gICAgaWYgKHN0ci5sZW5ndGggPiAwKSB7XG4gICAgICBsaW5lcy5wdXNoKHN0cik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG59XG4iLCJpbXBvcnQgVUFQYXJzZXIgZnJvbSBcInVhLXBhcnNlci1qc1wiO1xuaW1wb3J0IE9CU1JlcG9zaXRvcnkgZnJvbSBcIi4uL3JlcG9zaXRvcmllcy9PQlNSZXBvc2l0b3J5LmpzXCI7XG5pbXBvcnQgU3BlZWNoUmVjb2duaXRpb25Nb2RlbCBmcm9tIFwiLi4vbW9kZWxzL1NwZWVjaFJlY29nbml0aW9uTW9kZWwuanNcIjtcbmltcG9ydCBGb3JtYXRNb2RlbCBmcm9tIFwiLi4vbW9kZWxzL0Zvcm1hdE1vZGVsLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5vYnNSZXBvc2l0b3J5ID0gbmV3IE9CU1JlcG9zaXRvcnkoKTtcbiAgICB0aGlzLnVhUGFyc2VyID0gbmV3IFVBUGFyc2VyKCk7XG4gICAgdGhpcy5zcGVlY2hSZWNvZ25pdGlvbk1vZGVsID0gbmV3IFNwZWVjaFJlY29nbml0aW9uTW9kZWwoKTtcbiAgICB0aGlzLmZvcm1hdE1vZGVsID0gbmV3IEZvcm1hdE1vZGVsKCk7XG5cbiAgICB0aGlzLmxhbmcgPSB0aGlzLmdldERlZmF1bHRMYW5ndWFnZSgpO1xuICAgIHRoaXMud2Vic29ja2V0QWRkcmVzcyA9IFwibG9jYWxob3N0OjQ0NDRcIjtcbiAgICB0aGlzLndlYnNvY2tldFBhc3N3b3JkID0gbnVsbDtcbiAgICB0aGlzLnNvdXJjZU5hbWUgPSBcIm15X3RyYW5zY3JpcHRfc3JjXCI7XG4gICAgdGhpcy5zb3VyY2VUeXBlID0gdGhpcy5nZXREZWZhdWx0U291cmNlVHlwZSgpO1xuICAgIHRoaXMubWF4Um93cyA9IDM7XG4gICAgdGhpcy5tYXhDb2xzID0gMjA7XG4gICAgdGhpcy5maXhlZFRyYW5zY3JpcHRzID0gW107XG4gIH1cblxuICBpc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGVlY2hSZWNvZ25pdGlvbk1vZGVsLmlzU3VwcG9ydGVkKCk7XG4gIH1cblxuICBnZXREZWZhdWx0TGFuZ3VhZ2UoKSB7XG4gICAgcmV0dXJuICh3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlcyAmJiB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlc1swXSkgfHxcbiAgICAgIHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2UgfHxcbiAgICAgIHdpbmRvdy5uYXZpZ2F0b3IudXNlckxhbmd1YWdlIHx8XG4gICAgICB3aW5kb3cubmF2aWdhdG9yLmJyb3dzZXJMYW5ndWFnZSB8fCBcImVuXCI7XG4gIH1cblxuICBnZXREZWZhdWx0U291cmNlVHlwZSgpIHtcbiAgICBjb25zdCBvcyA9IHRoaXMudWFQYXJzZXIuZ2V0T1MoKTtcbiAgICByZXR1cm4gb3MubmFtZSA9PT0gXCJXaW5kb3dzXCIgPyAwIDogMTtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLm9ic1JlcG9zaXRvcnlcbiAgICAgIC5jb25uZWN0KHtcbiAgICAgICAgYWRkcmVzczogdGhpcy53ZWJzb2NrZXRBZGRyZXNzLFxuICAgICAgICBwYXNzd29yZDogdGhpcy53ZWJzb2NrZXRQYXNzd29yZFxuICAgICAgfSkudGhlbigoKSA9PlxuICAgICAgICB0aGlzLm9ic1JlcG9zaXRvcnlcbiAgICAgICAgICAuc2V0VGV4dCh0aGlzLnNvdXJjZVR5cGUsIHRoaXMuc291cmNlTmFtZSwgXCJcIikgLy8gVmFsaWRhdGVzIHNvdXJjZVR5cGUgYW5kIHNvdXJjZU5hbWVcbiAgICAgICAgICAudGhlbigoKSA9PlxuICAgICAgICAgICAgdGhpcy5zcGVlY2hSZWNvZ25pdGlvbk1vZGVsLnN0YXJ0KHRoaXMubGFuZywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50KTtcblxuICAgICAgICAgICAgICBsZXQgdHJhbnNjcmlwdHM7XG4gICAgICAgICAgICAgIGlmIChldmVudC5pc0ZpbmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXhlZFRyYW5zY3JpcHRzLnB1c2goZXZlbnQudHJhbnNjcmlwdCk7XG4gICAgICAgICAgICAgICAgdHJhbnNjcmlwdHMgPSB0aGlzLmZpeGVkVHJhbnNjcmlwdHM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNjcmlwdHMgPSBbLi4udGhpcy5maXhlZFRyYW5zY3JpcHRzLCBldmVudC50cmFuc2NyaXB0XTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLmZvcm1hdE1vZGVsLmZvcm1hdCh0cmFuc2NyaXB0cywgdGhpcy5tYXhSb3dzLCB0aGlzLm1heENvbHMpO1xuICAgICAgICAgICAgICB0aGlzLm9ic1JlcG9zaXRvcnkuc2V0VGV4dCh0aGlzLnNvdXJjZVR5cGUsIHRoaXMuc291cmNlTmFtZSwgdGV4dCk7XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpOyAvLyBjbG9zZSBjb25uZWN0aW9uIGlmIGZhaWxlZC5cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9KSk7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIHRoaXMuc3BlZWNoUmVjb2duaXRpb25Nb2RlbC5zdG9wKCk7XG4gICAgdGhpcy5vYnNSZXBvc2l0b3J5LmRpc2Nvbm5lY3QoKTtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgfVxuXG4gIGlzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAhISh3ZWJraXRTcGVlY2hSZWNvZ25pdGlvbiB8fCBTcGVlY2hSZWNvZ25pdGlvbik7XG4gIH1cblxuICBzdGFydChsYW5nLCBvbnJlc3VsdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAod2Via2l0U3BlZWNoUmVjb2duaXRpb24pIHtcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBuZXcgd2Via2l0U3BlZWNoUmVjb2duaXRpb24oKTtcbiAgICAgIH0gZWxzZSBpZiAoU3BlZWNoUmVjb2duaXRpb24pIHtcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBuZXcgU3BlZWNoUmVjb2duaXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbmdpbmUubGFuZyA9IGxhbmc7XG4gICAgICB0aGlzLmVuZ2luZS5jb250aW51b3VzID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW5naW5lLmludGVyaW1SZXN1bHRzID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW5naW5lLm1heEFsdGVybmF0aXZlcyA9IDE7XG5cbiAgICAgIHRoaXMuZW5naW5lLm9uc3RhcnQgPSByZXNvbHZlO1xuICAgICAgdGhpcy5lbmdpbmUub25lbmQgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmlzUnVubmluZykgdGhpcy5lbmdpbmUuc3RhcnQoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmVuZ2luZS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgdGhpcy5lbmdpbmUub25yZXN1bHQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGV2ZW50LnJlc3VsdEluZGV4OyBpIDwgZXZlbnQucmVzdWx0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIG9ucmVzdWx0KHtcbiAgICAgICAgICAgIFwiaXNGaW5hbFwiOiBldmVudC5yZXN1bHRzW2ldLmlzRmluYWwsXG4gICAgICAgICAgICBcInRyYW5zY3JpcHRcIjogZXZlbnQucmVzdWx0c1tpXVswXS50cmFuc2NyaXB0LFxuICAgICAgICAgICAgXCJjb25maWRlbmNlXCI6IGV2ZW50LnJlc3VsdHNbaV1bMF0uY29uZmlkZW5jZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5lbmdpbmUuc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuZW5naW5lKSB7XG4gICAgICB0aGlzLmVuZ2luZS5zdG9wKCk7XG4gICAgICB0aGlzLmVuZ2luZSA9IG51bGw7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgT0JTV2ViU29ja2V0IGZyb20gXCJvYnMtd2Vic29ja2V0LWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy53ZWJzb2NrZXQgPSBuZXcgT0JTV2ViU29ja2V0KCk7XG4gIH1cblxuICBjb25uZWN0KGNvbm5JbmZvKSB7XG4gICAgcmV0dXJuIHRoaXMud2Vic29ja2V0LmNvbm5lY3QoY29ubkluZm8pO1xuICB9XG5cbiAgZGlzY29ubmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy53ZWJzb2NrZXQuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgc2V0VGV4dChzb3VyY2VUeXBlLCBzb3VyY2VOYW1lLCB0ZXh0KSB7XG4gICAgaWYgKHNvdXJjZVR5cGUgPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0VGV4dEdESVBsdXMoc291cmNlTmFtZSwgdGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFRleHRGcmVldHlwZTIoc291cmNlTmFtZSwgdGV4dCk7XG4gICAgfVxuICB9XG5cbiAgc2V0VGV4dEdESVBsdXMoc291cmNlTmFtZSwgdGV4dCkge1xuICAgIHJldHVybiB0aGlzLndlYnNvY2tldC5zZW5kKFwiU2V0VGV4dEdESVBsdXNQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogc291cmNlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gIH1cblxuICBzZXRUZXh0RnJlZXR5cGUyKHNvdXJjZU5hbWUsIHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy53ZWJzb2NrZXQuc2VuZChcIlNldFRleHRGcmVldHlwZTJQcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogc291cmNlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAgKiBOYXRpdmUgSmF2YVNjcmlwdCBmb3IgQm9vdHN0cmFwIHYzLjAuMTMgKGh0dHBzOi8vdGhlZG5wLmdpdGh1Yi5pby9ib290c3RyYXAubmF0aXZlLylcbiAgKiBDb3B5cmlnaHQgMjAxNS0yMDIwIMKpIGRucF90aGVtZVxuICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3RoZWRucC9ib290c3RyYXAubmF0aXZlL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gICovXG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb24nIGluIGRvY3VtZW50LmhlYWQuc3R5bGUgPyAnd2Via2l0VHJhbnNpdGlvbkVuZCcgOiAndHJhbnNpdGlvbmVuZCc7XG5cbnZhciBzdXBwb3J0VHJhbnNpdGlvbiA9ICd3ZWJraXRUcmFuc2l0aW9uJyBpbiBkb2N1bWVudC5oZWFkLnN0eWxlIHx8ICd0cmFuc2l0aW9uJyBpbiBkb2N1bWVudC5oZWFkLnN0eWxlO1xuXG52YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gJ3dlYmtpdFRyYW5zaXRpb24nIGluIGRvY3VtZW50LmhlYWQuc3R5bGUgPyAnd2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uJyA6ICd0cmFuc2l0aW9uRHVyYXRpb24nO1xuXG52YXIgdHJhbnNpdGlvblByb3BlcnR5ID0gJ3dlYmtpdFRyYW5zaXRpb24nIGluIGRvY3VtZW50LmhlYWQuc3R5bGUgPyAnd2Via2l0VHJhbnNpdGlvblByb3BlcnR5JyA6ICd0cmFuc2l0aW9uUHJvcGVydHknO1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50VHJhbnNpdGlvbkR1cmF0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuICAgICAgcHJvcGVydHkgPSBjb21wdXRlZFN0eWxlW3RyYW5zaXRpb25Qcm9wZXJ0eV0sXG4gICAgICBkdXJhdGlvbiA9IHN1cHBvcnRUcmFuc2l0aW9uICYmIHByb3BlcnR5ICYmIHByb3BlcnR5ICE9PSAnbm9uZSdcbiAgICAgICAgICAgICAgID8gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlW3RyYW5zaXRpb25EdXJhdGlvbl0pIDogMDtcbiAgcmV0dXJuICFpc05hTihkdXJhdGlvbikgPyBkdXJhdGlvbiAqIDEwMDAgOiAwO1xufVxuXG5mdW5jdGlvbiBlbXVsYXRlVHJhbnNpdGlvbkVuZChlbGVtZW50LGhhbmRsZXIpe1xuICB2YXIgY2FsbGVkID0gMCwgZHVyYXRpb24gPSBnZXRFbGVtZW50VHJhbnNpdGlvbkR1cmF0aW9uKGVsZW1lbnQpO1xuICBkdXJhdGlvbiA/IGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHJhbnNpdGlvbkVuZEV2ZW50LCBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kV3JhcHBlcihlKXtcbiAgICAgICAgICAgICAgIWNhbGxlZCAmJiBoYW5kbGVyKGUpLCBjYWxsZWQgPSAxO1xuICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHRyYW5zaXRpb25FbmRFdmVudCwgdHJhbnNpdGlvbkVuZFdyYXBwZXIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgOiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyAhY2FsbGVkICYmIGhhbmRsZXIoKSwgY2FsbGVkID0gMTsgfSwgMTcpO1xufVxuXG5mdW5jdGlvbiBxdWVyeUVsZW1lbnQoc2VsZWN0b3IsIHBhcmVudCkge1xuICB2YXIgbG9va1VwID0gcGFyZW50ICYmIHBhcmVudCBpbnN0YW5jZW9mIEVsZW1lbnQgPyBwYXJlbnQgOiBkb2N1bWVudDtcbiAgcmV0dXJuIHNlbGVjdG9yIGluc3RhbmNlb2YgRWxlbWVudCA/IHNlbGVjdG9yIDogbG9va1VwLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiBib290c3RyYXBDdXN0b21FdmVudChldmVudE5hbWUsIGNvbXBvbmVudE5hbWUsIHJlbGF0ZWQpIHtcbiAgdmFyIE9yaWdpbmFsQ3VzdG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoIGV2ZW50TmFtZSArICcuYnMuJyArIGNvbXBvbmVudE5hbWUsIHtjYW5jZWxhYmxlOiB0cnVlfSk7XG4gIE9yaWdpbmFsQ3VzdG9tRXZlbnQucmVsYXRlZFRhcmdldCA9IHJlbGF0ZWQ7XG4gIHJldHVybiBPcmlnaW5hbEN1c3RvbUV2ZW50O1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50KXtcbiAgdGhpcyAmJiB0aGlzLmRpc3BhdGNoRXZlbnQoY3VzdG9tRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBBbGVydChlbGVtZW50KSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICBhbGVydCxcbiAgICBjbG9zZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2Nsb3NlJywnYWxlcnQnKSxcbiAgICBjbG9zZWRDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdjbG9zZWQnLCdhbGVydCcpO1xuICBmdW5jdGlvbiB0cmlnZ2VySGFuZGxlcigpIHtcbiAgICBhbGVydC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZhZGUnKSA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKGFsZXJ0LHRyYW5zaXRpb25FbmRIYW5kbGVyKSA6IHRyYW5zaXRpb25FbmRIYW5kbGVyKCk7XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlRXZlbnRzKGFjdGlvbil7XG4gICAgYWN0aW9uID0gYWN0aW9uID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgIGVsZW1lbnRbYWN0aW9uXSgnY2xpY2snLGNsaWNrSGFuZGxlcixmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gY2xpY2tIYW5kbGVyKGUpIHtcbiAgICBhbGVydCA9IGUgJiYgZS50YXJnZXQuY2xvc2VzdChcIi5hbGVydFwiKTtcbiAgICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KCdbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nLGFsZXJ0KTtcbiAgICBlbGVtZW50ICYmIGFsZXJ0ICYmIChlbGVtZW50ID09PSBlLnRhcmdldCB8fCBlbGVtZW50LmNvbnRhaW5zKGUudGFyZ2V0KSkgJiYgc2VsZi5jbG9zZSgpO1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25FbmRIYW5kbGVyKCkge1xuICAgIHRvZ2dsZUV2ZW50cygpO1xuICAgIGFsZXJ0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYWxlcnQpO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChhbGVydCxjbG9zZWRDdXN0b21FdmVudCk7XG4gIH1cbiAgc2VsZi5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIGFsZXJ0ICYmIGVsZW1lbnQgJiYgYWxlcnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgKSB7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoYWxlcnQsY2xvc2VDdXN0b21FdmVudCk7XG4gICAgICBpZiAoIGNsb3NlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCApIHsgcmV0dXJuOyB9XG4gICAgICBzZWxmLmRpc3Bvc2UoKTtcbiAgICAgIGFsZXJ0LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICAgIHRyaWdnZXJIYW5kbGVyKCk7XG4gICAgfVxuICB9O1xuICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdG9nZ2xlRXZlbnRzKCk7XG4gICAgZGVsZXRlIGVsZW1lbnQuQWxlcnQ7XG4gIH07XG4gIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG4gIGFsZXJ0ID0gZWxlbWVudC5jbG9zZXN0KCcuYWxlcnQnKTtcbiAgZWxlbWVudC5BbGVydCAmJiBlbGVtZW50LkFsZXJ0LmRpc3Bvc2UoKTtcbiAgaWYgKCAhZWxlbWVudC5BbGVydCApIHtcbiAgICB0b2dnbGVFdmVudHMoMSk7XG4gIH1cbiAgc2VsZi5lbGVtZW50ID0gZWxlbWVudDtcbiAgZWxlbWVudC5BbGVydCA9IHNlbGY7XG59XG5cbmZ1bmN0aW9uIEJ1dHRvbihlbGVtZW50KSB7XG4gIHZhciBzZWxmID0gdGhpcywgbGFiZWxzLFxuICAgICAgY2hhbmdlQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnY2hhbmdlJywgJ2J1dHRvbicpO1xuICBmdW5jdGlvbiB0b2dnbGUoZSkge1xuICAgIHZhciBpbnB1dCxcbiAgICAgICAgbGFiZWwgPSBlLnRhcmdldC50YWdOYW1lID09PSAnTEFCRUwnID8gZS50YXJnZXRcbiAgICAgICAgICAgICAgOiBlLnRhcmdldC5jbG9zZXN0KCdMQUJFTCcpID8gZS50YXJnZXQuY2xvc2VzdCgnTEFCRUwnKSA6IG51bGw7XG4gICAgaW5wdXQgPSBsYWJlbCAmJiBsYWJlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnSU5QVVQnKVswXTtcbiAgICBpZiAoICFpbnB1dCApIHsgcmV0dXJuOyB9XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGlucHV0LCBjaGFuZ2VDdXN0b21FdmVudCk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIGNoYW5nZUN1c3RvbUV2ZW50KTtcbiAgICBpZiAoIGlucHV0LnR5cGUgPT09ICdjaGVja2JveCcgKSB7XG4gICAgICBpZiAoIGNoYW5nZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgKSB7IHJldHVybjsgfVxuICAgICAgaWYgKCAhaW5wdXQuY2hlY2tlZCApIHtcbiAgICAgICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgIGlucHV0LmdldEF0dHJpYnV0ZSgnY2hlY2tlZCcpO1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCdjaGVja2VkJyk7XG4gICAgICAgIGlucHV0LmNoZWNrZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWwuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgIGlucHV0LmdldEF0dHJpYnV0ZSgnY2hlY2tlZCcpO1xuICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgICAgICAgaW5wdXQuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFlbGVtZW50LnRvZ2dsZWQpIHtcbiAgICAgICAgZWxlbWVudC50b2dnbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCBpbnB1dC50eXBlID09PSAncmFkaW8nICYmICFlbGVtZW50LnRvZ2dsZWQgKSB7XG4gICAgICBpZiAoIGNoYW5nZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgKSB7IHJldHVybjsgfVxuICAgICAgaWYgKCAhaW5wdXQuY2hlY2tlZCB8fCAoZS5zY3JlZW5YID09PSAwICYmIGUuc2NyZWVuWSA9PSAwKSApIHtcbiAgICAgICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgIGxhYmVsLmNsYXNzTGlzdC5hZGQoJ2ZvY3VzJyk7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsJ2NoZWNrZWQnKTtcbiAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIGVsZW1lbnQudG9nZ2xlZCA9IHRydWU7XG4gICAgICAgIEFycmF5LmZyb20obGFiZWxzKS5tYXAoZnVuY3Rpb24gKG90aGVyTGFiZWwpe1xuICAgICAgICAgIHZhciBvdGhlcklucHV0ID0gb3RoZXJMYWJlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnSU5QVVQnKVswXTtcbiAgICAgICAgICBpZiAoIG90aGVyTGFiZWwgIT09IGxhYmVsICYmIG90aGVyTGFiZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSApICB7XG4gICAgICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwob3RoZXJJbnB1dCwgY2hhbmdlQ3VzdG9tRXZlbnQpO1xuICAgICAgICAgICAgb3RoZXJMYWJlbC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIG90aGVySW5wdXQucmVtb3ZlQXR0cmlidXRlKCdjaGVja2VkJyk7XG4gICAgICAgICAgICBvdGhlcklucHV0LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7IGVsZW1lbnQudG9nZ2xlZCA9IGZhbHNlOyB9LCA1MCApO1xuICB9XG4gIGZ1bmN0aW9uIGtleUhhbmRsZXIoZSkge1xuICAgIHZhciBrZXkgPSBlLndoaWNoIHx8IGUua2V5Q29kZTtcbiAgICBrZXkgPT09IDMyICYmIGUudGFyZ2V0ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIHRvZ2dsZShlKTtcbiAgfVxuICBmdW5jdGlvbiBwcmV2ZW50U2Nyb2xsKGUpIHtcbiAgICB2YXIga2V5ID0gZS53aGljaCB8fCBlLmtleUNvZGU7XG4gICAga2V5ID09PSAzMiAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgZnVuY3Rpb24gZm9jdXNUb2dnbGUoZSkge1xuICAgIGlmIChlLnRhcmdldC50YWdOYW1lID09PSAnSU5QVVQnICkge1xuICAgICAgdmFyIGFjdGlvbiA9IGUudHlwZSA9PT0gJ2ZvY3VzaW4nID8gJ2FkZCcgOiAncmVtb3ZlJztcbiAgICAgIGUudGFyZ2V0LmNsb3Nlc3QoJy5idG4nKS5jbGFzc0xpc3RbYWN0aW9uXSgnZm9jdXMnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlRXZlbnRzKGFjdGlvbikge1xuICAgIGFjdGlvbiA9IGFjdGlvbiA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICBlbGVtZW50W2FjdGlvbl0oJ2NsaWNrJyx0b2dnbGUsZmFsc2UgKTtcbiAgICBlbGVtZW50W2FjdGlvbl0oJ2tleXVwJyxrZXlIYW5kbGVyLGZhbHNlKSwgZWxlbWVudFthY3Rpb25dKCdrZXlkb3duJyxwcmV2ZW50U2Nyb2xsLGZhbHNlKTtcbiAgICBlbGVtZW50W2FjdGlvbl0oJ2ZvY3VzaW4nLGZvY3VzVG9nZ2xlLGZhbHNlKSwgZWxlbWVudFthY3Rpb25dKCdmb2N1c291dCcsZm9jdXNUb2dnbGUsZmFsc2UpO1xuICB9XG4gIHNlbGYuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVFdmVudHMoKTtcbiAgICBkZWxldGUgZWxlbWVudC5CdXR0b247XG4gIH07XG4gIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG4gIGVsZW1lbnQuQnV0dG9uICYmIGVsZW1lbnQuQnV0dG9uLmRpc3Bvc2UoKTtcbiAgbGFiZWxzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdidG4nKTtcbiAgaWYgKCFsYWJlbHMubGVuZ3RoKSB7IHJldHVybjsgfVxuICBpZiAoICFlbGVtZW50LkJ1dHRvbiApIHtcbiAgICB0b2dnbGVFdmVudHMoMSk7XG4gIH1cbiAgZWxlbWVudC50b2dnbGVkID0gZmFsc2U7XG4gIGVsZW1lbnQuQnV0dG9uID0gc2VsZjtcbiAgQXJyYXkuZnJvbShsYWJlbHMpLm1hcChmdW5jdGlvbiAoYnRuKXtcbiAgICAhYnRuLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJylcbiAgICAgICYmIHF1ZXJ5RWxlbWVudCgnaW5wdXQ6Y2hlY2tlZCcsYnRuKVxuICAgICAgJiYgYnRuLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgIGJ0bi5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpXG4gICAgICAmJiAhcXVlcnlFbGVtZW50KCdpbnB1dDpjaGVja2VkJyxidG4pXG4gICAgICAmJiBidG4uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gIH0pO1xufVxuXG52YXIgbW91c2VIb3ZlckV2ZW50cyA9ICgnb25tb3VzZWxlYXZlJyBpbiBkb2N1bWVudCkgPyBbICdtb3VzZWVudGVyJywgJ21vdXNlbGVhdmUnXSA6IFsgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcgXTtcblxudmFyIHN1cHBvcnRQYXNzaXZlID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uIHdyYXAoKXtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB3cmFwLCBvcHRzKTtcbiAgICB9LCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIHJlc3VsdDtcbn0pKCk7XG5cbnZhciBwYXNzaXZlSGFuZGxlciA9IHN1cHBvcnRQYXNzaXZlID8geyBwYXNzaXZlOiB0cnVlIH0gOiBmYWxzZTtcblxuZnVuY3Rpb24gaXNFbGVtZW50SW5TY3JvbGxSYW5nZShlbGVtZW50KSB7XG4gIHZhciBiY3IgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgdmlld3BvcnRIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmV0dXJuIGJjci50b3AgPD0gdmlld3BvcnRIZWlnaHQgJiYgYmNyLmJvdHRvbSA+PSAwO1xufVxuXG5mdW5jdGlvbiBDYXJvdXNlbCAoZWxlbWVudCxvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgdmFycywgb3BzLFxuICAgIHNsaWRlQ3VzdG9tRXZlbnQsIHNsaWRDdXN0b21FdmVudCxcbiAgICBzbGlkZXMsIGxlZnRBcnJvdywgcmlnaHRBcnJvdywgaW5kaWNhdG9yLCBpbmRpY2F0b3JzO1xuICBmdW5jdGlvbiBwYXVzZUhhbmRsZXIoKSB7XG4gICAgaWYgKCBvcHMuaW50ZXJ2YWwgIT09ZmFsc2UgJiYgIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYXVzZWQnKSApIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgncGF1c2VkJyk7XG4gICAgICAhdmFycy5pc1NsaWRpbmcgJiYgKCBjbGVhckludGVydmFsKHZhcnMudGltZXIpLCB2YXJzLnRpbWVyID0gbnVsbCApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXN1bWVIYW5kbGVyKCkge1xuICAgIGlmICggb3BzLmludGVydmFsICE9PSBmYWxzZSAmJiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygncGF1c2VkJykgKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3BhdXNlZCcpO1xuICAgICAgIXZhcnMuaXNTbGlkaW5nICYmICggY2xlYXJJbnRlcnZhbCh2YXJzLnRpbWVyKSwgdmFycy50aW1lciA9IG51bGwgKTtcbiAgICAgICF2YXJzLmlzU2xpZGluZyAmJiBzZWxmLmN5Y2xlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGluZGljYXRvckhhbmRsZXIoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAodmFycy5pc1NsaWRpbmcpIHsgcmV0dXJuOyB9XG4gICAgdmFyIGV2ZW50VGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgaWYgKCBldmVudFRhcmdldCAmJiAhZXZlbnRUYXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSAmJiBldmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xpZGUtdG8nKSApIHtcbiAgICAgIHZhcnMuaW5kZXggPSBwYXJzZUludCggZXZlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXNsaWRlLXRvJykpO1xuICAgIH0gZWxzZSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHNlbGYuc2xpZGVUbyggdmFycy5pbmRleCApO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnRyb2xzSGFuZGxlcihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICh2YXJzLmlzU2xpZGluZykgeyByZXR1cm47IH1cbiAgICB2YXIgZXZlbnRUYXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgIGlmICggZXZlbnRUYXJnZXQgPT09IHJpZ2h0QXJyb3cgKSB7XG4gICAgICB2YXJzLmluZGV4Kys7XG4gICAgfSBlbHNlIGlmICggZXZlbnRUYXJnZXQgPT09IGxlZnRBcnJvdyApIHtcbiAgICAgIHZhcnMuaW5kZXgtLTtcbiAgICB9XG4gICAgc2VsZi5zbGlkZVRvKCB2YXJzLmluZGV4ICk7XG4gIH1cbiAgZnVuY3Rpb24ga2V5SGFuZGxlcihyZWYpIHtcbiAgICB2YXIgd2hpY2ggPSByZWYud2hpY2g7XG4gICAgaWYgKHZhcnMuaXNTbGlkaW5nKSB7IHJldHVybjsgfVxuICAgIHN3aXRjaCAod2hpY2gpIHtcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIHZhcnMuaW5kZXgrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM3OlxuICAgICAgICB2YXJzLmluZGV4LS07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLnNsaWRlVG8oIHZhcnMuaW5kZXggKTtcbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVFdmVudHMoYWN0aW9uKSB7XG4gICAgYWN0aW9uID0gYWN0aW9uID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgIGlmICggb3BzLnBhdXNlICYmIG9wcy5pbnRlcnZhbCApIHtcbiAgICAgIGVsZW1lbnRbYWN0aW9uXSggbW91c2VIb3ZlckV2ZW50c1swXSwgcGF1c2VIYW5kbGVyLCBmYWxzZSApO1xuICAgICAgZWxlbWVudFthY3Rpb25dKCBtb3VzZUhvdmVyRXZlbnRzWzFdLCByZXN1bWVIYW5kbGVyLCBmYWxzZSApO1xuICAgICAgZWxlbWVudFthY3Rpb25dKCAndG91Y2hzdGFydCcsIHBhdXNlSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIgKTtcbiAgICAgIGVsZW1lbnRbYWN0aW9uXSggJ3RvdWNoZW5kJywgcmVzdW1lSGFuZGxlciwgcGFzc2l2ZUhhbmRsZXIgKTtcbiAgICB9XG4gICAgb3BzLnRvdWNoICYmIHNsaWRlcy5sZW5ndGggPiAxICYmIGVsZW1lbnRbYWN0aW9uXSggJ3RvdWNoc3RhcnQnLCB0b3VjaERvd25IYW5kbGVyLCBwYXNzaXZlSGFuZGxlciApO1xuICAgIHJpZ2h0QXJyb3cgJiYgcmlnaHRBcnJvd1thY3Rpb25dKCAnY2xpY2snLCBjb250cm9sc0hhbmRsZXIsZmFsc2UgKTtcbiAgICBsZWZ0QXJyb3cgJiYgbGVmdEFycm93W2FjdGlvbl0oICdjbGljaycsIGNvbnRyb2xzSGFuZGxlcixmYWxzZSApO1xuICAgIGluZGljYXRvciAmJiBpbmRpY2F0b3JbYWN0aW9uXSggJ2NsaWNrJywgaW5kaWNhdG9ySGFuZGxlcixmYWxzZSApO1xuICAgIG9wcy5rZXlib2FyZCAmJiB3aW5kb3dbYWN0aW9uXSggJ2tleWRvd24nLCBrZXlIYW5kbGVyLGZhbHNlICk7XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlVG91Y2hFdmVudHMoYWN0aW9uKSB7XG4gICAgYWN0aW9uID0gYWN0aW9uID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgIGVsZW1lbnRbYWN0aW9uXSggJ3RvdWNobW92ZScsIHRvdWNoTW92ZUhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyICk7XG4gICAgZWxlbWVudFthY3Rpb25dKCAndG91Y2hlbmQnLCB0b3VjaEVuZEhhbmRsZXIsIHBhc3NpdmVIYW5kbGVyICk7XG4gIH1cbiAgZnVuY3Rpb24gdG91Y2hEb3duSGFuZGxlcihlKSB7XG4gICAgaWYgKCB2YXJzLmlzVG91Y2ggKSB7IHJldHVybjsgfVxuICAgIHZhcnMudG91Y2hQb3NpdGlvbi5zdGFydFggPSBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgIGlmICggZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkgKSB7XG4gICAgICB2YXJzLmlzVG91Y2ggPSB0cnVlO1xuICAgICAgdG9nZ2xlVG91Y2hFdmVudHMoMSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvdWNoTW92ZUhhbmRsZXIoZSkge1xuICAgIGlmICggIXZhcnMuaXNUb3VjaCApIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm47IH1cbiAgICB2YXJzLnRvdWNoUG9zaXRpb24uY3VycmVudFggPSBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgIGlmICggZS50eXBlID09PSAndG91Y2htb3ZlJyAmJiBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDEgKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvdWNoRW5kSGFuZGxlciAoZSkge1xuICAgIGlmICggIXZhcnMuaXNUb3VjaCB8fCB2YXJzLmlzU2xpZGluZyApIHsgcmV0dXJuIH1cbiAgICB2YXJzLnRvdWNoUG9zaXRpb24uZW5kWCA9IHZhcnMudG91Y2hQb3NpdGlvbi5jdXJyZW50WCB8fCBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgIGlmICggdmFycy5pc1RvdWNoICkge1xuICAgICAgaWYgKCAoIWVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpIHx8ICFlbGVtZW50LmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkgKVxuICAgICAgICAgICYmIE1hdGguYWJzKHZhcnMudG91Y2hQb3NpdGlvbi5zdGFydFggLSB2YXJzLnRvdWNoUG9zaXRpb24uZW5kWCkgPCA3NSApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCB2YXJzLnRvdWNoUG9zaXRpb24uY3VycmVudFggPCB2YXJzLnRvdWNoUG9zaXRpb24uc3RhcnRYICkge1xuICAgICAgICAgIHZhcnMuaW5kZXgrKztcbiAgICAgICAgfSBlbHNlIGlmICggdmFycy50b3VjaFBvc2l0aW9uLmN1cnJlbnRYID4gdmFycy50b3VjaFBvc2l0aW9uLnN0YXJ0WCApIHtcbiAgICAgICAgICB2YXJzLmluZGV4LS07XG4gICAgICAgIH1cbiAgICAgICAgdmFycy5pc1RvdWNoID0gZmFsc2U7XG4gICAgICAgIHNlbGYuc2xpZGVUbyh2YXJzLmluZGV4KTtcbiAgICAgIH1cbiAgICAgIHRvZ2dsZVRvdWNoRXZlbnRzKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldEFjdGl2ZVBhZ2UocGFnZUluZGV4KSB7XG4gICAgQXJyYXkuZnJvbShpbmRpY2F0b3JzKS5tYXAoZnVuY3Rpb24gKHgpe3guY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7fSk7XG4gICAgaW5kaWNhdG9yc1twYWdlSW5kZXhdICYmIGluZGljYXRvcnNbcGFnZUluZGV4XS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kSGFuZGxlcihlKXtcbiAgICBpZiAodmFycy50b3VjaFBvc2l0aW9uKXtcbiAgICAgIHZhciBuZXh0ID0gdmFycy5pbmRleCxcbiAgICAgICAgICB0aW1lb3V0ID0gZSAmJiBlLnRhcmdldCAhPT0gc2xpZGVzW25leHRdID8gZS5lbGFwc2VkVGltZSoxMDAwKzEwMCA6IDIwLFxuICAgICAgICAgIGFjdGl2ZUl0ZW0gPSBzZWxmLmdldEFjdGl2ZUluZGV4KCksXG4gICAgICAgICAgb3JpZW50YXRpb24gPSB2YXJzLmRpcmVjdGlvbiA9PT0gJ2xlZnQnID8gJ25leHQnIDogJ3ByZXYnO1xuICAgICAgdmFycy5pc1NsaWRpbmcgJiYgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2YXJzLnRvdWNoUG9zaXRpb24pe1xuICAgICAgICAgIHZhcnMuaXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICAgICAgc2xpZGVzW25leHRdLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgIHNsaWRlc1thY3RpdmVJdGVtXS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICBzbGlkZXNbbmV4dF0uY2xhc3NMaXN0LnJlbW92ZSgoXCJjYXJvdXNlbC1pdGVtLVwiICsgb3JpZW50YXRpb24pKTtcbiAgICAgICAgICBzbGlkZXNbbmV4dF0uY2xhc3NMaXN0LnJlbW92ZSgoXCJjYXJvdXNlbC1pdGVtLVwiICsgKHZhcnMuZGlyZWN0aW9uKSkpO1xuICAgICAgICAgIHNsaWRlc1thY3RpdmVJdGVtXS5jbGFzc0xpc3QucmVtb3ZlKChcImNhcm91c2VsLWl0ZW0tXCIgKyAodmFycy5kaXJlY3Rpb24pKSk7XG4gICAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIHNsaWRDdXN0b21FdmVudCk7XG4gICAgICAgICAgaWYgKCAhZG9jdW1lbnQuaGlkZGVuICYmIG9wcy5pbnRlcnZhbCAmJiAhZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3BhdXNlZCcpICkge1xuICAgICAgICAgICAgc2VsZi5jeWNsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdGltZW91dCk7XG4gICAgfVxuICB9XG4gIHNlbGYuY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHZhcnMudGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodmFycy50aW1lcik7XG4gICAgICB2YXJzLnRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgdmFycy50aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZHggPSB2YXJzLmluZGV4IHx8IHNlbGYuZ2V0QWN0aXZlSW5kZXgoKTtcbiAgICAgIGlzRWxlbWVudEluU2Nyb2xsUmFuZ2UoZWxlbWVudCkgJiYgKGlkeCsrLCBzZWxmLnNsaWRlVG8oIGlkeCApICk7XG4gICAgfSwgb3BzLmludGVydmFsKTtcbiAgfTtcbiAgc2VsZi5zbGlkZVRvID0gZnVuY3Rpb24gKG5leHQpIHtcbiAgICBpZiAodmFycy5pc1NsaWRpbmcpIHsgcmV0dXJuOyB9XG4gICAgdmFyIGFjdGl2ZUl0ZW0gPSBzZWxmLmdldEFjdGl2ZUluZGV4KCksIG9yaWVudGF0aW9uO1xuICAgIGlmICggYWN0aXZlSXRlbSA9PT0gbmV4dCApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgICggKGFjdGl2ZUl0ZW0gPCBuZXh0ICkgfHwgKGFjdGl2ZUl0ZW0gPT09IDAgJiYgbmV4dCA9PT0gc2xpZGVzLmxlbmd0aCAtMSApICkge1xuICAgICAgdmFycy5kaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIGlmICAoIChhY3RpdmVJdGVtID4gbmV4dCkgfHwgKGFjdGl2ZUl0ZW0gPT09IHNsaWRlcy5sZW5ndGggLSAxICYmIG5leHQgPT09IDAgKSApIHtcbiAgICAgIHZhcnMuZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICB9XG4gICAgaWYgKCBuZXh0IDwgMCApIHsgbmV4dCA9IHNsaWRlcy5sZW5ndGggLSAxOyB9XG4gICAgZWxzZSBpZiAoIG5leHQgPj0gc2xpZGVzLmxlbmd0aCApeyBuZXh0ID0gMDsgfVxuICAgIG9yaWVudGF0aW9uID0gdmFycy5kaXJlY3Rpb24gPT09ICdsZWZ0JyA/ICduZXh0JyA6ICdwcmV2JztcbiAgICBzbGlkZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3NsaWRlJywgJ2Nhcm91c2VsJywgc2xpZGVzW25leHRdKTtcbiAgICBzbGlkQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2xpZCcsICdjYXJvdXNlbCcsIHNsaWRlc1tuZXh0XSk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIHNsaWRlQ3VzdG9tRXZlbnQpO1xuICAgIGlmIChzbGlkZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG4gICAgdmFycy5pbmRleCA9IG5leHQ7XG4gICAgdmFycy5pc1NsaWRpbmcgPSB0cnVlO1xuICAgIGNsZWFySW50ZXJ2YWwodmFycy50aW1lcik7XG4gICAgdmFycy50aW1lciA9IG51bGw7XG4gICAgc2V0QWN0aXZlUGFnZSggbmV4dCApO1xuICAgIGlmICggZ2V0RWxlbWVudFRyYW5zaXRpb25EdXJhdGlvbihzbGlkZXNbbmV4dF0pICYmIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzbGlkZScpICkge1xuICAgICAgc2xpZGVzW25leHRdLmNsYXNzTGlzdC5hZGQoKFwiY2Fyb3VzZWwtaXRlbS1cIiArIG9yaWVudGF0aW9uKSk7XG4gICAgICBzbGlkZXNbbmV4dF0ub2Zmc2V0V2lkdGg7XG4gICAgICBzbGlkZXNbbmV4dF0uY2xhc3NMaXN0LmFkZCgoXCJjYXJvdXNlbC1pdGVtLVwiICsgKHZhcnMuZGlyZWN0aW9uKSkpO1xuICAgICAgc2xpZGVzW2FjdGl2ZUl0ZW1dLmNsYXNzTGlzdC5hZGQoKFwiY2Fyb3VzZWwtaXRlbS1cIiArICh2YXJzLmRpcmVjdGlvbikpKTtcbiAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKHNsaWRlc1tuZXh0XSwgdHJhbnNpdGlvbkVuZEhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbGlkZXNbbmV4dF0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICBzbGlkZXNbbmV4dF0ub2Zmc2V0V2lkdGg7XG4gICAgICBzbGlkZXNbYWN0aXZlSXRlbV0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFycy5pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKCBvcHMuaW50ZXJ2YWwgJiYgZWxlbWVudCAmJiAhZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3BhdXNlZCcpICkge1xuICAgICAgICAgIHNlbGYuY3ljbGUoKTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgc2xpZEN1c3RvbUV2ZW50KTtcbiAgICAgIH0sIDEwMCApO1xuICAgIH1cbiAgfTtcbiAgc2VsZi5nZXRBY3RpdmVJbmRleCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5LmZyb20oc2xpZGVzKS5pbmRleE9mKGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2Fyb3VzZWwtaXRlbSBhY3RpdmUnKVswXSkgfHwgMDsgfTtcbiAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpdGVtQ2xhc3NlcyA9IFsnbGVmdCcsJ3JpZ2h0JywncHJldicsJ25leHQnXTtcbiAgICBBcnJheS5mcm9tKHNsaWRlcykubWFwKGZ1bmN0aW9uIChzbGlkZSxpZHgpIHtcbiAgICAgIHNsaWRlLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgJiYgc2V0QWN0aXZlUGFnZSggaWR4ICk7XG4gICAgICBpdGVtQ2xhc3Nlcy5tYXAoZnVuY3Rpb24gKGNscykgeyByZXR1cm4gc2xpZGUuY2xhc3NMaXN0LnJlbW92ZSgoXCJjYXJvdXNlbC1pdGVtLVwiICsgY2xzKSk7IH0pO1xuICAgIH0pO1xuICAgIGNsZWFySW50ZXJ2YWwodmFycy50aW1lcik7XG4gICAgdG9nZ2xlRXZlbnRzKCk7XG4gICAgdmFycyA9IHt9O1xuICAgIG9wcyA9IHt9O1xuICAgIGRlbGV0ZSBlbGVtZW50LkNhcm91c2VsO1xuICB9O1xuICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KCBlbGVtZW50ICk7XG4gIGVsZW1lbnQuQ2Fyb3VzZWwgJiYgZWxlbWVudC5DYXJvdXNlbC5kaXNwb3NlKCk7XG4gIHNsaWRlcyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2Fyb3VzZWwtaXRlbScpO1xuICBsZWZ0QXJyb3cgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2Nhcm91c2VsLWNvbnRyb2wtcHJldicpWzBdO1xuICByaWdodEFycm93ID0gZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjYXJvdXNlbC1jb250cm9sLW5leHQnKVswXTtcbiAgaW5kaWNhdG9yID0gZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjYXJvdXNlbC1pbmRpY2F0b3JzJylbMF07XG4gIGluZGljYXRvcnMgPSBpbmRpY2F0b3IgJiYgaW5kaWNhdG9yLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcIkxJXCIgKSB8fCBbXTtcbiAgaWYgKHNsaWRlcy5sZW5ndGggPCAyKSB7IHJldHVybiB9XG4gIHZhclxuICAgIGludGVydmFsQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW50ZXJ2YWwnKSxcbiAgICBpbnRlcnZhbERhdGEgPSBpbnRlcnZhbEF0dHJpYnV0ZSA9PT0gJ2ZhbHNlJyA/IDAgOiBwYXJzZUludChpbnRlcnZhbEF0dHJpYnV0ZSksXG4gICAgdG91Y2hEYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG91Y2gnKSA9PT0gJ2ZhbHNlJyA/IDAgOiAxLFxuICAgIHBhdXNlRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXBhdXNlJykgPT09ICdob3ZlcicgfHwgZmFsc2UsXG4gICAga2V5Ym9hcmREYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEta2V5Ym9hcmQnKSA9PT0gJ3RydWUnIHx8IGZhbHNlLFxuICAgIGludGVydmFsT3B0aW9uID0gb3B0aW9ucy5pbnRlcnZhbCxcbiAgICB0b3VjaE9wdGlvbiA9IG9wdGlvbnMudG91Y2g7XG4gIG9wcyA9IHt9O1xuICBvcHMua2V5Ym9hcmQgPSBvcHRpb25zLmtleWJvYXJkID09PSB0cnVlIHx8IGtleWJvYXJkRGF0YTtcbiAgb3BzLnBhdXNlID0gKG9wdGlvbnMucGF1c2UgPT09ICdob3ZlcicgfHwgcGF1c2VEYXRhKSA/ICdob3ZlcicgOiBmYWxzZTtcbiAgb3BzLnRvdWNoID0gdG91Y2hPcHRpb24gfHwgdG91Y2hEYXRhO1xuICBvcHMuaW50ZXJ2YWwgPSB0eXBlb2YgaW50ZXJ2YWxPcHRpb24gPT09ICdudW1iZXInID8gaW50ZXJ2YWxPcHRpb25cbiAgICAgICAgICAgICAgOiBpbnRlcnZhbE9wdGlvbiA9PT0gZmFsc2UgfHwgaW50ZXJ2YWxEYXRhID09PSAwIHx8IGludGVydmFsRGF0YSA9PT0gZmFsc2UgPyAwXG4gICAgICAgICAgICAgIDogaXNOYU4oaW50ZXJ2YWxEYXRhKSA/IDUwMDBcbiAgICAgICAgICAgICAgOiBpbnRlcnZhbERhdGE7XG4gIGlmIChzZWxmLmdldEFjdGl2ZUluZGV4KCk8MCkge1xuICAgIHNsaWRlcy5sZW5ndGggJiYgc2xpZGVzWzBdLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgIGluZGljYXRvcnMubGVuZ3RoICYmIHNldEFjdGl2ZVBhZ2UoMCk7XG4gIH1cbiAgdmFycyA9IHt9O1xuICB2YXJzLmRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgdmFycy5pbmRleCA9IDA7XG4gIHZhcnMudGltZXIgPSBudWxsO1xuICB2YXJzLmlzU2xpZGluZyA9IGZhbHNlO1xuICB2YXJzLmlzVG91Y2ggPSBmYWxzZTtcbiAgdmFycy50b3VjaFBvc2l0aW9uID0ge1xuICAgIHN0YXJ0WCA6IDAsXG4gICAgY3VycmVudFggOiAwLFxuICAgIGVuZFggOiAwXG4gIH07XG4gIHRvZ2dsZUV2ZW50cygxKTtcbiAgaWYgKCBvcHMuaW50ZXJ2YWwgKXsgc2VsZi5jeWNsZSgpOyB9XG4gIGVsZW1lbnQuQ2Fyb3VzZWwgPSBzZWxmO1xufVxuXG5mdW5jdGlvbiBDb2xsYXBzZShlbGVtZW50LG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGFjY29yZGlvbiA9IG51bGwsXG4gICAgICBjb2xsYXBzZSA9IG51bGwsXG4gICAgICBhY3RpdmVDb2xsYXBzZSxcbiAgICAgIGFjdGl2ZUVsZW1lbnQsXG4gICAgICBzaG93Q3VzdG9tRXZlbnQsXG4gICAgICBzaG93bkN1c3RvbUV2ZW50LFxuICAgICAgaGlkZUN1c3RvbUV2ZW50LFxuICAgICAgaGlkZGVuQ3VzdG9tRXZlbnQ7XG4gIGZ1bmN0aW9uIG9wZW5BY3Rpb24oY29sbGFwc2VFbGVtZW50LCB0b2dnbGUpIHtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoY29sbGFwc2VFbGVtZW50LCBzaG93Q3VzdG9tRXZlbnQpO1xuICAgIGlmICggc2hvd0N1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgKSB7IHJldHVybjsgfVxuICAgIGNvbGxhcHNlRWxlbWVudC5pc0FuaW1hdGluZyA9IHRydWU7XG4gICAgY29sbGFwc2VFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2NvbGxhcHNpbmcnKTtcbiAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2UnKTtcbiAgICBjb2xsYXBzZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKGNvbGxhcHNlRWxlbWVudC5zY3JvbGxIZWlnaHQpICsgXCJweFwiO1xuICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKGNvbGxhcHNlRWxlbWVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgY29sbGFwc2VFbGVtZW50LmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICBjb2xsYXBzZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywndHJ1ZScpO1xuICAgICAgdG9nZ2xlLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsJ3RydWUnKTtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdjb2xsYXBzaW5nJyk7XG4gICAgICBjb2xsYXBzZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2UnKTtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XG4gICAgICBjb2xsYXBzZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoY29sbGFwc2VFbGVtZW50LCBzaG93bkN1c3RvbUV2ZW50KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBjbG9zZUFjdGlvbihjb2xsYXBzZUVsZW1lbnQsIHRvZ2dsZSkge1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChjb2xsYXBzZUVsZW1lbnQsIGhpZGVDdXN0b21FdmVudCk7XG4gICAgaWYgKCBoaWRlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCApIHsgcmV0dXJuOyB9XG4gICAgY29sbGFwc2VFbGVtZW50LmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICBjb2xsYXBzZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKGNvbGxhcHNlRWxlbWVudC5zY3JvbGxIZWlnaHQpICsgXCJweFwiO1xuICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdjb2xsYXBzZScpO1xuICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgY29sbGFwc2VFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2NvbGxhcHNpbmcnKTtcbiAgICBjb2xsYXBzZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgY29sbGFwc2VFbGVtZW50LnN0eWxlLmhlaWdodCA9ICcwcHgnO1xuICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKGNvbGxhcHNlRWxlbWVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgY29sbGFwc2VFbGVtZW50LmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICBjb2xsYXBzZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywnZmFsc2UnKTtcbiAgICAgIHRvZ2dsZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCdmYWxzZScpO1xuICAgICAgY29sbGFwc2VFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2NvbGxhcHNpbmcnKTtcbiAgICAgIGNvbGxhcHNlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzZScpO1xuICAgICAgY29sbGFwc2VFbGVtZW50LnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGNvbGxhcHNlRWxlbWVudCwgaGlkZGVuQ3VzdG9tRXZlbnQpO1xuICAgIH0pO1xuICB9XG4gIHNlbGYudG9nZ2xlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZSAmJiBlLnRhcmdldC50YWdOYW1lID09PSAnQScgfHwgZWxlbWVudC50YWdOYW1lID09PSAnQScpIHtlLnByZXZlbnREZWZhdWx0KCk7fVxuICAgIGlmIChlbGVtZW50LmNvbnRhaW5zKGUudGFyZ2V0KSB8fCBlLnRhcmdldCA9PT0gZWxlbWVudCkge1xuICAgICAgaWYgKCFjb2xsYXBzZS5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSkgeyBzZWxmLnNob3coKTsgfVxuICAgICAgZWxzZSB7IHNlbGYuaGlkZSgpOyB9XG4gICAgfVxuICB9O1xuICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCBjb2xsYXBzZS5pc0FuaW1hdGluZyApIHsgcmV0dXJuOyB9XG4gICAgY2xvc2VBY3Rpb24oY29sbGFwc2UsZWxlbWVudCk7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzZWQnKTtcbiAgfTtcbiAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICggYWNjb3JkaW9uICkge1xuICAgICAgYWN0aXZlQ29sbGFwc2UgPSBhY2NvcmRpb24uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImNvbGxhcHNlIHNob3dcIilbMF07XG4gICAgICBhY3RpdmVFbGVtZW50ID0gYWN0aXZlQ29sbGFwc2UgJiYgKHF1ZXJ5RWxlbWVudCgoXCJbZGF0YS10YXJnZXQ9XFxcIiNcIiArIChhY3RpdmVDb2xsYXBzZS5pZCkgKyBcIlxcXCJdXCIpLGFjY29yZGlvbilcbiAgICAgICAgICAgICAgICAgICAgfHwgcXVlcnlFbGVtZW50KChcIltocmVmPVxcXCIjXCIgKyAoYWN0aXZlQ29sbGFwc2UuaWQpICsgXCJcXFwiXVwiKSxhY2NvcmRpb24pICk7XG4gICAgfVxuICAgIGlmICggIWNvbGxhcHNlLmlzQW5pbWF0aW5nICkge1xuICAgICAgaWYgKCBhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUNvbGxhcHNlICE9PSBjb2xsYXBzZSApIHtcbiAgICAgICAgY2xvc2VBY3Rpb24oYWN0aXZlQ29sbGFwc2UsYWN0aXZlRWxlbWVudCk7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2VkJyk7XG4gICAgICB9XG4gICAgICBvcGVuQWN0aW9uKGNvbGxhcHNlLGVsZW1lbnQpO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdjb2xsYXBzZWQnKTtcbiAgICB9XG4gIH07XG4gIHNlbGYuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxzZWxmLnRvZ2dsZSxmYWxzZSk7XG4gICAgZGVsZXRlIGVsZW1lbnQuQ29sbGFwc2U7XG4gIH07XG4gICAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcbiAgICBlbGVtZW50LkNvbGxhcHNlICYmIGVsZW1lbnQuQ29sbGFwc2UuZGlzcG9zZSgpO1xuICAgIHZhciBhY2NvcmRpb25EYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFyZW50Jyk7XG4gICAgc2hvd0N1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3cnLCAnY29sbGFwc2UnKTtcbiAgICBzaG93bkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3duJywgJ2NvbGxhcHNlJyk7XG4gICAgaGlkZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGUnLCAnY29sbGFwc2UnKTtcbiAgICBoaWRkZW5DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRkZW4nLCAnY29sbGFwc2UnKTtcbiAgICBjb2xsYXBzZSA9IHF1ZXJ5RWxlbWVudChvcHRpb25zLnRhcmdldCB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpKTtcbiAgICBjb2xsYXBzZS5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgIGFjY29yZGlvbiA9IGVsZW1lbnQuY2xvc2VzdChvcHRpb25zLnBhcmVudCB8fCBhY2NvcmRpb25EYXRhKTtcbiAgICBpZiAoICFlbGVtZW50LkNvbGxhcHNlICkge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsc2VsZi50b2dnbGUsZmFsc2UpO1xuICAgIH1cbiAgICBlbGVtZW50LkNvbGxhcHNlID0gc2VsZjtcbn1cblxuZnVuY3Rpb24gc2V0Rm9jdXMgKGVsZW1lbnQpe1xuICBlbGVtZW50LmZvY3VzID8gZWxlbWVudC5mb2N1cygpIDogZWxlbWVudC5zZXRBY3RpdmUoKTtcbn1cblxuZnVuY3Rpb24gRHJvcGRvd24oZWxlbWVudCxvcHRpb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgc2hvd0N1c3RvbUV2ZW50LFxuICAgICAgc2hvd25DdXN0b21FdmVudCxcbiAgICAgIGhpZGVDdXN0b21FdmVudCxcbiAgICAgIGhpZGRlbkN1c3RvbUV2ZW50LFxuICAgICAgcmVsYXRlZFRhcmdldCA9IG51bGwsXG4gICAgICBwYXJlbnQsIG1lbnUsIG1lbnVJdGVtcyA9IFtdLFxuICAgICAgcGVyc2lzdDtcbiAgZnVuY3Rpb24gcHJldmVudEVtcHR5QW5jaG9yKGFuY2hvcikge1xuICAgIChhbmNob3IuaHJlZiAmJiBhbmNob3IuaHJlZi5zbGljZSgtMSkgPT09ICcjJyB8fCBhbmNob3IucGFyZW50Tm9kZSAmJiBhbmNob3IucGFyZW50Tm9kZS5ocmVmXG4gICAgICAmJiBhbmNob3IucGFyZW50Tm9kZS5ocmVmLnNsaWNlKC0xKSA9PT0gJyMnKSAmJiB0aGlzLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlRGlzbWlzcygpIHtcbiAgICB2YXIgYWN0aW9uID0gZWxlbWVudC5vcGVuID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgIGRvY3VtZW50W2FjdGlvbl0oJ2NsaWNrJyxkaXNtaXNzSGFuZGxlcixmYWxzZSk7XG4gICAgZG9jdW1lbnRbYWN0aW9uXSgna2V5ZG93bicscHJldmVudFNjcm9sbCxmYWxzZSk7XG4gICAgZG9jdW1lbnRbYWN0aW9uXSgna2V5dXAnLGtleUhhbmRsZXIsZmFsc2UpO1xuICAgIGRvY3VtZW50W2FjdGlvbl0oJ2ZvY3VzJyxkaXNtaXNzSGFuZGxlcixmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gZGlzbWlzc0hhbmRsZXIoZSkge1xuICAgIHZhciBldmVudFRhcmdldCA9IGUudGFyZ2V0LFxuICAgICAgICAgIGhhc0RhdGEgPSBldmVudFRhcmdldCAmJiAoZXZlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXRvZ2dsZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGV2ZW50VGFyZ2V0LnBhcmVudE5vZGUgJiYgZXZlbnRUYXJnZXQucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgZXZlbnRUYXJnZXQucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG9nZ2xlJykpO1xuICAgIGlmICggZS50eXBlID09PSAnZm9jdXMnICYmIChldmVudFRhcmdldCA9PT0gZWxlbWVudCB8fCBldmVudFRhcmdldCA9PT0gbWVudSB8fCBtZW51LmNvbnRhaW5zKGV2ZW50VGFyZ2V0KSApICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIChldmVudFRhcmdldCA9PT0gbWVudSB8fCBtZW51LmNvbnRhaW5zKGV2ZW50VGFyZ2V0KSkgJiYgKHBlcnNpc3QgfHwgaGFzRGF0YSkgKSB7IHJldHVybjsgfVxuICAgIGVsc2Uge1xuICAgICAgcmVsYXRlZFRhcmdldCA9IGV2ZW50VGFyZ2V0ID09PSBlbGVtZW50IHx8IGVsZW1lbnQuY29udGFpbnMoZXZlbnRUYXJnZXQpID8gZWxlbWVudCA6IG51bGw7XG4gICAgICBzZWxmLmhpZGUoKTtcbiAgICB9XG4gICAgcHJldmVudEVtcHR5QW5jaG9yLmNhbGwoZSxldmVudFRhcmdldCk7XG4gIH1cbiAgZnVuY3Rpb24gY2xpY2tIYW5kbGVyKGUpIHtcbiAgICByZWxhdGVkVGFyZ2V0ID0gZWxlbWVudDtcbiAgICBzZWxmLnNob3coKTtcbiAgICBwcmV2ZW50RW1wdHlBbmNob3IuY2FsbChlLGUudGFyZ2V0KTtcbiAgfVxuICBmdW5jdGlvbiBwcmV2ZW50U2Nyb2xsKGUpIHtcbiAgICB2YXIga2V5ID0gZS53aGljaCB8fCBlLmtleUNvZGU7XG4gICAgaWYoIGtleSA9PT0gMzggfHwga2V5ID09PSA0MCApIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG4gIH1cbiAgZnVuY3Rpb24ga2V5SGFuZGxlcihlKSB7XG4gICAgdmFyIGtleSA9IGUud2hpY2ggfHwgZS5rZXlDb2RlLFxuICAgICAgICBhY3RpdmVJdGVtID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCxcbiAgICAgICAgaXNTYW1lRWxlbWVudCA9IGFjdGl2ZUl0ZW0gPT09IGVsZW1lbnQsXG4gICAgICAgIGlzSW5zaWRlTWVudSA9IG1lbnUuY29udGFpbnMoYWN0aXZlSXRlbSksXG4gICAgICAgIGlzTWVudUl0ZW0gPSBhY3RpdmVJdGVtLnBhcmVudE5vZGUgPT09IG1lbnUgfHwgYWN0aXZlSXRlbS5wYXJlbnROb2RlLnBhcmVudE5vZGUgPT09IG1lbnUsXG4gICAgICAgIGlkeCA9IG1lbnVJdGVtcy5pbmRleE9mKGFjdGl2ZUl0ZW0pO1xuICAgIGlmICggaXNNZW51SXRlbSApIHtcbiAgICAgIGlkeCA9IGlzU2FtZUVsZW1lbnQgPyAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDoga2V5ID09PSAzOCA/IChpZHg+MT9pZHgtMTowKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGtleSA9PT0gNDAgPyAoaWR4PG1lbnVJdGVtcy5sZW5ndGgtMT9pZHgrMTppZHgpIDogaWR4O1xuICAgICAgbWVudUl0ZW1zW2lkeF0gJiYgc2V0Rm9jdXMobWVudUl0ZW1zW2lkeF0pO1xuICAgIH1cbiAgICBpZiAoIChtZW51SXRlbXMubGVuZ3RoICYmIGlzTWVudUl0ZW1cbiAgICAgICAgICB8fCAhbWVudUl0ZW1zLmxlbmd0aCAmJiAoaXNJbnNpZGVNZW51IHx8IGlzU2FtZUVsZW1lbnQpXG4gICAgICAgICAgfHwgIWlzSW5zaWRlTWVudSApXG4gICAgICAgICAgJiYgZWxlbWVudC5vcGVuICYmIGtleSA9PT0gMjdcbiAgICApIHtcbiAgICAgIHNlbGYudG9nZ2xlKCk7XG4gICAgICByZWxhdGVkVGFyZ2V0ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc2VsZi5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHNob3dDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93JywgJ2Ryb3Bkb3duJywgcmVsYXRlZFRhcmdldCk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKHBhcmVudCwgc2hvd0N1c3RvbUV2ZW50KTtcbiAgICBpZiAoIHNob3dDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkICkgeyByZXR1cm47IH1cbiAgICBtZW51LmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcbiAgICBwYXJlbnQuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJyx0cnVlKTtcbiAgICBlbGVtZW50Lm9wZW4gPSB0cnVlO1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLGNsaWNrSGFuZGxlcixmYWxzZSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRGb2N1cyggbWVudS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnSU5QVVQnKVswXSB8fCBlbGVtZW50ICk7XG4gICAgICB0b2dnbGVEaXNtaXNzKCk7XG4gICAgICBzaG93bkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoICdzaG93bicsICdkcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKHBhcmVudCwgc2hvd25DdXN0b21FdmVudCk7XG4gICAgfSwxKTtcbiAgfTtcbiAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGhpZGVDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRlJywgJ2Ryb3Bkb3duJywgcmVsYXRlZFRhcmdldCk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKHBhcmVudCwgaGlkZUN1c3RvbUV2ZW50KTtcbiAgICBpZiAoIGhpZGVDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkICkgeyByZXR1cm47IH1cbiAgICBtZW51LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICBwYXJlbnQuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJyxmYWxzZSk7XG4gICAgZWxlbWVudC5vcGVuID0gZmFsc2U7XG4gICAgdG9nZ2xlRGlzbWlzcygpO1xuICAgIHNldEZvY3VzKGVsZW1lbnQpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZWxlbWVudC5Ecm9wZG93biAmJiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxjbGlja0hhbmRsZXIsZmFsc2UpO1xuICAgIH0sMSk7XG4gICAgaGlkZGVuQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZGVuJywgJ2Ryb3Bkb3duJywgcmVsYXRlZFRhcmdldCk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKHBhcmVudCwgaGlkZGVuQ3VzdG9tRXZlbnQpO1xuICB9O1xuICBzZWxmLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocGFyZW50LmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpICYmIGVsZW1lbnQub3BlbikgeyBzZWxmLmhpZGUoKTsgfVxuICAgIGVsc2UgeyBzZWxmLnNob3coKTsgfVxuICB9O1xuICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSAmJiBlbGVtZW50Lm9wZW4pIHsgc2VsZi5oaWRlKCk7IH1cbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxjbGlja0hhbmRsZXIsZmFsc2UpO1xuICAgIGRlbGV0ZSBlbGVtZW50LkRyb3Bkb3duO1xuICB9O1xuICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICBlbGVtZW50LkRyb3Bkb3duICYmIGVsZW1lbnQuRHJvcGRvd24uZGlzcG9zZSgpO1xuICBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gIG1lbnUgPSBxdWVyeUVsZW1lbnQoJy5kcm9wZG93bi1tZW51JywgcGFyZW50KTtcbiAgQXJyYXkuZnJvbShtZW51LmNoaWxkcmVuKS5tYXAoZnVuY3Rpb24gKGNoaWxkKXtcbiAgICBjaGlsZC5jaGlsZHJlbi5sZW5ndGggJiYgKGNoaWxkLmNoaWxkcmVuWzBdLnRhZ05hbWUgPT09ICdBJyAmJiBtZW51SXRlbXMucHVzaChjaGlsZC5jaGlsZHJlblswXSkpO1xuICAgIGNoaWxkLnRhZ05hbWUgPT09ICdBJyAmJiBtZW51SXRlbXMucHVzaChjaGlsZCk7XG4gIH0pO1xuICBpZiAoICFlbGVtZW50LkRyb3Bkb3duICkge1xuICAgICEoJ3RhYmluZGV4JyBpbiBtZW51KSAmJiBtZW51LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGNsaWNrSGFuZGxlcixmYWxzZSk7XG4gIH1cbiAgcGVyc2lzdCA9IG9wdGlvbiA9PT0gdHJ1ZSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1wZXJzaXN0JykgPT09ICd0cnVlJyB8fCBmYWxzZTtcbiAgZWxlbWVudC5vcGVuID0gZmFsc2U7XG4gIGVsZW1lbnQuRHJvcGRvd24gPSBzZWxmO1xufVxuXG5mdW5jdGlvbiBNb2RhbChlbGVtZW50LG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBzZWxmID0gdGhpcywgbW9kYWwsXG4gICAgc2hvd0N1c3RvbUV2ZW50LFxuICAgIHNob3duQ3VzdG9tRXZlbnQsXG4gICAgaGlkZUN1c3RvbUV2ZW50LFxuICAgIGhpZGRlbkN1c3RvbUV2ZW50LFxuICAgIHJlbGF0ZWRUYXJnZXQgPSBudWxsLFxuICAgIHNjcm9sbEJhcldpZHRoLFxuICAgIG92ZXJsYXksXG4gICAgb3ZlcmxheURlbGF5LFxuICAgIGZpeGVkSXRlbXMsXG4gICAgb3BzID0ge307XG4gIGZ1bmN0aW9uIHNldFNjcm9sbGJhcigpIHtcbiAgICB2YXIgb3Blbk1vZGFsID0gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ21vZGFsLW9wZW4nKSxcbiAgICAgICAgYm9keVBhZCA9IHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkucGFkZGluZ1JpZ2h0KSxcbiAgICAgICAgYm9keU92ZXJmbG93ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodFxuICAgICAgICAgICAgICAgICAgICB8fCBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCAhPT0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsXG4gICAgICAgIG1vZGFsT3ZlcmZsb3cgPSBtb2RhbC5jbGllbnRIZWlnaHQgIT09IG1vZGFsLnNjcm9sbEhlaWdodDtcbiAgICBzY3JvbGxCYXJXaWR0aCA9IG1lYXN1cmVTY3JvbGxiYXIoKTtcbiAgICBtb2RhbC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAhbW9kYWxPdmVyZmxvdyAmJiBzY3JvbGxCYXJXaWR0aCA/IChzY3JvbGxCYXJXaWR0aCArIFwicHhcIikgOiAnJztcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IG1vZGFsT3ZlcmZsb3cgfHwgYm9keU92ZXJmbG93ID8gKChib2R5UGFkICsgKG9wZW5Nb2RhbCA/IDA6c2Nyb2xsQmFyV2lkdGgpKSArIFwicHhcIikgOiAnJztcbiAgICBmaXhlZEl0ZW1zLmxlbmd0aCAmJiBmaXhlZEl0ZW1zLm1hcChmdW5jdGlvbiAoZml4ZWQpe1xuICAgICAgdmFyIGl0ZW1QYWQgPSBnZXRDb21wdXRlZFN0eWxlKGZpeGVkKS5wYWRkaW5nUmlnaHQ7XG4gICAgICBmaXhlZC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBtb2RhbE92ZXJmbG93IHx8IGJvZHlPdmVyZmxvdyA/ICgocGFyc2VJbnQoaXRlbVBhZCkgKyAob3Blbk1vZGFsPzA6c2Nyb2xsQmFyV2lkdGgpKSArIFwicHhcIikgOiAoKHBhcnNlSW50KGl0ZW1QYWQpKSArIFwicHhcIik7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzZXRTY3JvbGxiYXIoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJztcbiAgICBtb2RhbC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJztcbiAgICBmaXhlZEl0ZW1zLmxlbmd0aCAmJiBmaXhlZEl0ZW1zLm1hcChmdW5jdGlvbiAoZml4ZWQpe1xuICAgICAgZml4ZWQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZVNjcm9sbGJhcigpIHtcbiAgICB2YXIgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIHdpZHRoVmFsdWU7XG4gICAgc2Nyb2xsRGl2LmNsYXNzTmFtZSA9ICdtb2RhbC1zY3JvbGxiYXItbWVhc3VyZSc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpO1xuICAgIHdpZHRoVmFsdWUgPSBzY3JvbGxEaXYub2Zmc2V0V2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGg7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpO1xuICAgIHJldHVybiB3aWR0aFZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU92ZXJsYXkoKSB7XG4gICAgdmFyIG5ld092ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBvdmVybGF5ID0gcXVlcnlFbGVtZW50KCcubW9kYWwtYmFja2Ryb3AnKTtcbiAgICBpZiAoIG92ZXJsYXkgPT09IG51bGwgKSB7XG4gICAgICBuZXdPdmVybGF5LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnbW9kYWwtYmFja2Ryb3AnICsgKG9wcy5hbmltYXRpb24gPyAnIGZhZGUnIDogJycpKTtcbiAgICAgIG92ZXJsYXkgPSBuZXdPdmVybGF5O1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdmVybGF5KTtcbiAgICB9XG4gICAgcmV0dXJuIG92ZXJsYXk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlT3ZlcmxheSAoKSB7XG4gICAgb3ZlcmxheSA9IHF1ZXJ5RWxlbWVudCgnLm1vZGFsLWJhY2tkcm9wJyk7XG4gICAgaWYgKCBvdmVybGF5ICYmICFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtb2RhbCBzaG93JylbMF0gKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG92ZXJsYXkpOyBvdmVybGF5ID0gbnVsbDtcbiAgICB9XG4gICAgb3ZlcmxheSA9PT0gbnVsbCAmJiAoZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdtb2RhbC1vcGVuJyksIHJlc2V0U2Nyb2xsYmFyKCkpO1xuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZUV2ZW50cyhhY3Rpb24pIHtcbiAgICBhY3Rpb24gPSBhY3Rpb24gPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgd2luZG93W2FjdGlvbl0oICdyZXNpemUnLCBzZWxmLnVwZGF0ZSwgcGFzc2l2ZUhhbmRsZXIpO1xuICAgIG1vZGFsW2FjdGlvbl0oICdjbGljaycsZGlzbWlzc0hhbmRsZXIsZmFsc2UpO1xuICAgIGRvY3VtZW50W2FjdGlvbl0oICdrZXlkb3duJyxrZXlIYW5kbGVyLGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBiZWZvcmVTaG93KCkge1xuICAgIG1vZGFsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIHNldFNjcm9sbGJhcigpO1xuICAgICFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtb2RhbCBzaG93JylbMF0gJiYgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdtb2RhbC1vcGVuJyk7XG4gICAgbW9kYWwuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xuICAgIG1vZGFsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCBmYWxzZSk7XG4gICAgbW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYWRlJykgPyBlbXVsYXRlVHJhbnNpdGlvbkVuZChtb2RhbCwgdHJpZ2dlclNob3cpIDogdHJpZ2dlclNob3coKTtcbiAgfVxuICBmdW5jdGlvbiB0cmlnZ2VyU2hvdygpIHtcbiAgICBzZXRGb2N1cyhtb2RhbCk7XG4gICAgbW9kYWwuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICB0b2dnbGVFdmVudHMoMSk7XG4gICAgc2hvd25DdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93bicsICdtb2RhbCcsIHJlbGF0ZWRUYXJnZXQpO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChtb2RhbCwgc2hvd25DdXN0b21FdmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gdHJpZ2dlckhpZGUoZm9yY2UpIHtcbiAgICBtb2RhbC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgZWxlbWVudCAmJiAoc2V0Rm9jdXMoZWxlbWVudCkpO1xuICAgIG92ZXJsYXkgPSBxdWVyeUVsZW1lbnQoJy5tb2RhbC1iYWNrZHJvcCcpO1xuICAgIGlmIChmb3JjZSAhPT0gMSAmJiBvdmVybGF5ICYmIG92ZXJsYXkuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgJiYgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21vZGFsIHNob3cnKVswXSkge1xuICAgICAgb3ZlcmxheS5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZChvdmVybGF5LHJlbW92ZU92ZXJsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVPdmVybGF5KCk7XG4gICAgfVxuICAgIHRvZ2dsZUV2ZW50cygpO1xuICAgIG1vZGFsLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgaGlkZGVuQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZGVuJywgJ21vZGFsJyk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKG1vZGFsLCBoaWRkZW5DdXN0b21FdmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gY2xpY2tIYW5kbGVyKGUpIHtcbiAgICBpZiAoIG1vZGFsLmlzQW5pbWF0aW5nICkgeyByZXR1cm47IH1cbiAgICB2YXIgY2xpY2tUYXJnZXQgPSBlLnRhcmdldCxcbiAgICAgICAgbW9kYWxJRCA9IFwiI1wiICsgKG1vZGFsLmdldEF0dHJpYnV0ZSgnaWQnKSksXG4gICAgICAgIHRhcmdldEF0dHJWYWx1ZSA9IGNsaWNrVGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKSB8fCBjbGlja1RhcmdldC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSxcbiAgICAgICAgZWxlbUF0dHJWYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgaWYgKCAhbW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JylcbiAgICAgICAgJiYgKGNsaWNrVGFyZ2V0ID09PSBlbGVtZW50ICYmIHRhcmdldEF0dHJWYWx1ZSA9PT0gbW9kYWxJRFxuICAgICAgICB8fCBlbGVtZW50LmNvbnRhaW5zKGNsaWNrVGFyZ2V0KSAmJiBlbGVtQXR0clZhbHVlID09PSBtb2RhbElEKSApIHtcbiAgICAgIG1vZGFsLm1vZGFsVHJpZ2dlciA9IGVsZW1lbnQ7XG4gICAgICByZWxhdGVkVGFyZ2V0ID0gZWxlbWVudDtcbiAgICAgIHNlbGYuc2hvdygpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBrZXlIYW5kbGVyKHJlZikge1xuICAgIHZhciB3aGljaCA9IHJlZi53aGljaDtcbiAgICBpZiAoIW1vZGFsLmlzQW5pbWF0aW5nICYmIG9wcy5rZXlib2FyZCAmJiB3aGljaCA9PSAyNyAmJiBtb2RhbC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSApIHtcbiAgICAgIHNlbGYuaGlkZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkaXNtaXNzSGFuZGxlcihlKSB7XG4gICAgaWYgKCBtb2RhbC5pc0FuaW1hdGluZyApIHsgcmV0dXJuOyB9XG4gICAgdmFyIGNsaWNrVGFyZ2V0ID0gZS50YXJnZXQsXG4gICAgICAgIGhhc0RhdGEgPSBjbGlja1RhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlzbWlzcycpID09PSAnbW9kYWwnLFxuICAgICAgICBwYXJlbnRXaXRoRGF0YSA9IGNsaWNrVGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXScpO1xuICAgIGlmICggbW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgJiYgKCBwYXJlbnRXaXRoRGF0YSB8fCBoYXNEYXRhXG4gICAgICAgIHx8IGNsaWNrVGFyZ2V0ID09PSBtb2RhbCAmJiBvcHMuYmFja2Ryb3AgIT09ICdzdGF0aWMnICkgKSB7XG4gICAgICBzZWxmLmhpZGUoKTsgcmVsYXRlZFRhcmdldCA9IG51bGw7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIHNlbGYudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICggbW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgKSB7c2VsZi5oaWRlKCk7fSBlbHNlIHtzZWxmLnNob3coKTt9XG4gIH07XG4gIHNlbGYuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobW9kYWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgJiYgISFtb2RhbC5pc0FuaW1hdGluZyApIHtyZXR1cm59XG4gICAgc2hvd0N1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3cnLCAnbW9kYWwnLCByZWxhdGVkVGFyZ2V0KTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwobW9kYWwsIHNob3dDdXN0b21FdmVudCk7XG4gICAgaWYgKCBzaG93Q3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCApIHsgcmV0dXJuOyB9XG4gICAgbW9kYWwuaXNBbmltYXRpbmcgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50T3BlbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21vZGFsIHNob3cnKVswXTtcbiAgICBpZiAoY3VycmVudE9wZW4gJiYgY3VycmVudE9wZW4gIT09IG1vZGFsKSB7XG4gICAgICBjdXJyZW50T3Blbi5tb2RhbFRyaWdnZXIgJiYgY3VycmVudE9wZW4ubW9kYWxUcmlnZ2VyLk1vZGFsLmhpZGUoKTtcbiAgICAgIGN1cnJlbnRPcGVuLk1vZGFsICYmIGN1cnJlbnRPcGVuLk1vZGFsLmhpZGUoKTtcbiAgICB9XG4gICAgaWYgKCBvcHMuYmFja2Ryb3AgKSB7XG4gICAgICBvdmVybGF5ID0gY3JlYXRlT3ZlcmxheSgpO1xuICAgIH1cbiAgICBpZiAoIG92ZXJsYXkgJiYgIWN1cnJlbnRPcGVuICYmICFvdmVybGF5LmNsYXNzTGlzdC5jb250YWlucygnc2hvdycpICkge1xuICAgICAgb3ZlcmxheS5vZmZzZXRXaWR0aDtcbiAgICAgIG92ZXJsYXlEZWxheSA9IGdldEVsZW1lbnRUcmFuc2l0aW9uRHVyYXRpb24ob3ZlcmxheSk7XG4gICAgICBvdmVybGF5LmNsYXNzTGlzdC5hZGQoJ3Nob3cnKTtcbiAgICB9XG4gICAgIWN1cnJlbnRPcGVuID8gc2V0VGltZW91dCggYmVmb3JlU2hvdywgb3ZlcmxheSAmJiBvdmVybGF5RGVsYXkgPyBvdmVybGF5RGVsYXk6MCApIDogYmVmb3JlU2hvdygpO1xuICB9O1xuICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICBpZiAoICFtb2RhbC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSApIHtyZXR1cm59XG4gICAgaGlkZUN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoICdoaWRlJywgJ21vZGFsJyk7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKG1vZGFsLCBoaWRlQ3VzdG9tRXZlbnQpO1xuICAgIGlmICggaGlkZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgKSB7IHJldHVybjsgfVxuICAgIG1vZGFsLmlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICBtb2RhbC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Jyk7XG4gICAgbW9kYWwuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgIG1vZGFsLmNsYXNzTGlzdC5jb250YWlucygnZmFkZScpICYmIGZvcmNlICE9PSAxID8gZW11bGF0ZVRyYW5zaXRpb25FbmQobW9kYWwsIHRyaWdnZXJIaWRlKSA6IHRyaWdnZXJIaWRlKCk7XG4gIH07XG4gIHNlbGYuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgcXVlcnlFbGVtZW50KCcubW9kYWwtY29udGVudCcsbW9kYWwpLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gIH07XG4gIHNlbGYudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChtb2RhbC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSkge1xuICAgICAgc2V0U2Nyb2xsYmFyKCk7XG4gICAgfVxuICB9O1xuICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5oaWRlKDEpO1xuICAgIGlmIChlbGVtZW50KSB7ZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsY2xpY2tIYW5kbGVyLGZhbHNlKTsgZGVsZXRlIGVsZW1lbnQuTW9kYWw7IH1cbiAgICBlbHNlIHtkZWxldGUgbW9kYWwuTW9kYWw7fVxuICB9O1xuICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgY2hlY2tNb2RhbCA9IHF1ZXJ5RWxlbWVudCggZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JykgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSApO1xuICBtb2RhbCA9IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtb2RhbCcpID8gZWxlbWVudCA6IGNoZWNrTW9kYWw7XG4gIGZpeGVkSXRlbXMgPSBBcnJheS5mcm9tKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2ZpeGVkLXRvcCcpKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KEFycmF5LmZyb20oZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZml4ZWQtYm90dG9tJykpKTtcbiAgaWYgKCBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnbW9kYWwnKSApIHsgZWxlbWVudCA9IG51bGw7IH1cbiAgZWxlbWVudCAmJiBlbGVtZW50Lk1vZGFsICYmIGVsZW1lbnQuTW9kYWwuZGlzcG9zZSgpO1xuICBtb2RhbCAmJiBtb2RhbC5Nb2RhbCAmJiBtb2RhbC5Nb2RhbC5kaXNwb3NlKCk7XG4gIG9wcy5rZXlib2FyZCA9IG9wdGlvbnMua2V5Ym9hcmQgPT09IGZhbHNlIHx8IG1vZGFsLmdldEF0dHJpYnV0ZSgnZGF0YS1rZXlib2FyZCcpID09PSAnZmFsc2UnID8gZmFsc2UgOiB0cnVlO1xuICBvcHMuYmFja2Ryb3AgPSBvcHRpb25zLmJhY2tkcm9wID09PSAnc3RhdGljJyB8fCBtb2RhbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYmFja2Ryb3AnKSA9PT0gJ3N0YXRpYycgPyAnc3RhdGljJyA6IHRydWU7XG4gIG9wcy5iYWNrZHJvcCA9IG9wdGlvbnMuYmFja2Ryb3AgPT09IGZhbHNlIHx8IG1vZGFsLmdldEF0dHJpYnV0ZSgnZGF0YS1iYWNrZHJvcCcpID09PSAnZmFsc2UnID8gZmFsc2UgOiBvcHMuYmFja2Ryb3A7XG4gIG9wcy5hbmltYXRpb24gPSBtb2RhbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZhZGUnKSA/IHRydWUgOiBmYWxzZTtcbiAgb3BzLmNvbnRlbnQgPSBvcHRpb25zLmNvbnRlbnQ7XG4gIG1vZGFsLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gIGlmICggZWxlbWVudCAmJiAhZWxlbWVudC5Nb2RhbCApIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxjbGlja0hhbmRsZXIsZmFsc2UpO1xuICB9XG4gIGlmICggb3BzLmNvbnRlbnQgKSB7XG4gICAgc2VsZi5zZXRDb250ZW50KCBvcHMuY29udGVudC50cmltKCkgKTtcbiAgfVxuICBpZiAoZWxlbWVudCkge1xuICAgIG1vZGFsLm1vZGFsVHJpZ2dlciA9IGVsZW1lbnQ7XG4gICAgZWxlbWVudC5Nb2RhbCA9IHNlbGY7XG4gIH0gZWxzZSB7XG4gICAgbW9kYWwuTW9kYWwgPSBzZWxmO1xuICB9XG59XG5cbnZhciBtb3VzZUNsaWNrRXZlbnRzID0geyBkb3duOiAnbW91c2Vkb3duJywgdXA6ICdtb3VzZXVwJyB9O1xuXG5mdW5jdGlvbiBnZXRTY3JvbGwoKSB7XG4gIHJldHVybiB7XG4gICAgeSA6IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgIHggOiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnRcbiAgfVxufVxuXG5mdW5jdGlvbiBzdHlsZVRpcChsaW5rLGVsZW1lbnQscG9zaXRpb24scGFyZW50KSB7XG4gIHZhciB0aXBQb3NpdGlvbnMgPSAvXFxiKHRvcHxib3R0b218bGVmdHxyaWdodCkrLyxcbiAgICAgIGVsZW1lbnREaW1lbnNpb25zID0geyB3IDogZWxlbWVudC5vZmZzZXRXaWR0aCwgaDogZWxlbWVudC5vZmZzZXRIZWlnaHQgfSxcbiAgICAgIHdpbmRvd1dpZHRoID0gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoKSxcbiAgICAgIHdpbmRvd0hlaWdodCA9IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0KSxcbiAgICAgIHJlY3QgPSBsaW5rLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgc2Nyb2xsID0gcGFyZW50ID09PSBkb2N1bWVudC5ib2R5ID8gZ2V0U2Nyb2xsKCkgOiB7IHg6IHBhcmVudC5vZmZzZXRMZWZ0ICsgcGFyZW50LnNjcm9sbExlZnQsIHk6IHBhcmVudC5vZmZzZXRUb3AgKyBwYXJlbnQuc2Nyb2xsVG9wIH0sXG4gICAgICBsaW5rRGltZW5zaW9ucyA9IHsgdzogcmVjdC5yaWdodCAtIHJlY3QubGVmdCwgaDogcmVjdC5ib3R0b20gLSByZWN0LnRvcCB9LFxuICAgICAgaXNQb3BvdmVyID0gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3BvcG92ZXInKSxcbiAgICAgIGFycm93ID0gZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdhcnJvdycpWzBdLFxuICAgICAgaGFsZlRvcEV4Y2VlZCA9IHJlY3QudG9wICsgbGlua0RpbWVuc2lvbnMuaC8yIC0gZWxlbWVudERpbWVuc2lvbnMuaC8yIDwgMCxcbiAgICAgIGhhbGZMZWZ0RXhjZWVkID0gcmVjdC5sZWZ0ICsgbGlua0RpbWVuc2lvbnMudy8yIC0gZWxlbWVudERpbWVuc2lvbnMudy8yIDwgMCxcbiAgICAgIGhhbGZSaWdodEV4Y2VlZCA9IHJlY3QubGVmdCArIGVsZW1lbnREaW1lbnNpb25zLncvMiArIGxpbmtEaW1lbnNpb25zLncvMiA+PSB3aW5kb3dXaWR0aCxcbiAgICAgIGhhbGZCb3R0b21FeGNlZWQgPSByZWN0LnRvcCArIGVsZW1lbnREaW1lbnNpb25zLmgvMiArIGxpbmtEaW1lbnNpb25zLmgvMiA+PSB3aW5kb3dIZWlnaHQsXG4gICAgICB0b3BFeGNlZWQgPSByZWN0LnRvcCAtIGVsZW1lbnREaW1lbnNpb25zLmggPCAwLFxuICAgICAgbGVmdEV4Y2VlZCA9IHJlY3QubGVmdCAtIGVsZW1lbnREaW1lbnNpb25zLncgPCAwLFxuICAgICAgYm90dG9tRXhjZWVkID0gcmVjdC50b3AgKyBlbGVtZW50RGltZW5zaW9ucy5oICsgbGlua0RpbWVuc2lvbnMuaCA+PSB3aW5kb3dIZWlnaHQsXG4gICAgICByaWdodEV4Y2VlZCA9IHJlY3QubGVmdCArIGVsZW1lbnREaW1lbnNpb25zLncgKyBsaW5rRGltZW5zaW9ucy53ID49IHdpbmRvd1dpZHRoO1xuICBwb3NpdGlvbiA9IChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSAmJiBsZWZ0RXhjZWVkICYmIHJpZ2h0RXhjZWVkID8gJ3RvcCcgOiBwb3NpdGlvbjtcbiAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gJ3RvcCcgJiYgdG9wRXhjZWVkID8gJ2JvdHRvbScgOiBwb3NpdGlvbjtcbiAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgJiYgYm90dG9tRXhjZWVkID8gJ3RvcCcgOiBwb3NpdGlvbjtcbiAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gJ2xlZnQnICYmIGxlZnRFeGNlZWQgPyAncmlnaHQnIDogcG9zaXRpb247XG4gIHBvc2l0aW9uID0gcG9zaXRpb24gPT09ICdyaWdodCcgJiYgcmlnaHRFeGNlZWQgPyAnbGVmdCcgOiBwb3NpdGlvbjtcbiAgdmFyIHRvcFBvc2l0aW9uLFxuICAgIGxlZnRQb3NpdGlvbixcbiAgICBhcnJvd1RvcCxcbiAgICBhcnJvd0xlZnQsXG4gICAgYXJyb3dXaWR0aCxcbiAgICBhcnJvd0hlaWdodDtcbiAgZWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZihwb3NpdGlvbikgPT09IC0xICYmIChlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UodGlwUG9zaXRpb25zLHBvc2l0aW9uKSk7XG4gIGFycm93V2lkdGggPSBhcnJvdy5vZmZzZXRXaWR0aDsgYXJyb3dIZWlnaHQgPSBhcnJvdy5vZmZzZXRIZWlnaHQ7XG4gIGlmICggcG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0JyApIHtcbiAgICBpZiAoIHBvc2l0aW9uID09PSAnbGVmdCcgKSB7XG4gICAgICBsZWZ0UG9zaXRpb24gPSByZWN0LmxlZnQgKyBzY3JvbGwueCAtIGVsZW1lbnREaW1lbnNpb25zLncgLSAoIGlzUG9wb3ZlciA/IGFycm93V2lkdGggOiAwICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnRQb3NpdGlvbiA9IHJlY3QubGVmdCArIHNjcm9sbC54ICsgbGlua0RpbWVuc2lvbnMudztcbiAgICB9XG4gICAgaWYgKGhhbGZUb3BFeGNlZWQpIHtcbiAgICAgIHRvcFBvc2l0aW9uID0gcmVjdC50b3AgKyBzY3JvbGwueTtcbiAgICAgIGFycm93VG9wID0gbGlua0RpbWVuc2lvbnMuaC8yIC0gYXJyb3dXaWR0aDtcbiAgICB9IGVsc2UgaWYgKGhhbGZCb3R0b21FeGNlZWQpIHtcbiAgICAgIHRvcFBvc2l0aW9uID0gcmVjdC50b3AgKyBzY3JvbGwueSAtIGVsZW1lbnREaW1lbnNpb25zLmggKyBsaW5rRGltZW5zaW9ucy5oO1xuICAgICAgYXJyb3dUb3AgPSBlbGVtZW50RGltZW5zaW9ucy5oIC0gbGlua0RpbWVuc2lvbnMuaC8yIC0gYXJyb3dXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wUG9zaXRpb24gPSByZWN0LnRvcCArIHNjcm9sbC55IC0gZWxlbWVudERpbWVuc2lvbnMuaC8yICsgbGlua0RpbWVuc2lvbnMuaC8yO1xuICAgICAgYXJyb3dUb3AgPSBlbGVtZW50RGltZW5zaW9ucy5oLzIgLSAoaXNQb3BvdmVyID8gYXJyb3dIZWlnaHQqMC45IDogYXJyb3dIZWlnaHQvMik7XG4gICAgfVxuICB9IGVsc2UgaWYgKCBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nICkge1xuICAgIGlmICggcG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICB0b3BQb3NpdGlvbiA9ICByZWN0LnRvcCArIHNjcm9sbC55IC0gZWxlbWVudERpbWVuc2lvbnMuaCAtICggaXNQb3BvdmVyID8gYXJyb3dIZWlnaHQgOiAwICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcFBvc2l0aW9uID0gcmVjdC50b3AgKyBzY3JvbGwueSArIGxpbmtEaW1lbnNpb25zLmg7XG4gICAgfVxuICAgIGlmIChoYWxmTGVmdEV4Y2VlZCkge1xuICAgICAgbGVmdFBvc2l0aW9uID0gMDtcbiAgICAgIGFycm93TGVmdCA9IHJlY3QubGVmdCArIGxpbmtEaW1lbnNpb25zLncvMiAtIGFycm93V2lkdGg7XG4gICAgfSBlbHNlIGlmIChoYWxmUmlnaHRFeGNlZWQpIHtcbiAgICAgIGxlZnRQb3NpdGlvbiA9IHdpbmRvd1dpZHRoIC0gZWxlbWVudERpbWVuc2lvbnMudyoxLjAxO1xuICAgICAgYXJyb3dMZWZ0ID0gZWxlbWVudERpbWVuc2lvbnMudyAtICggd2luZG93V2lkdGggLSByZWN0LmxlZnQgKSArIGxpbmtEaW1lbnNpb25zLncvMiAtIGFycm93V2lkdGgvMjtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdFBvc2l0aW9uID0gcmVjdC5sZWZ0ICsgc2Nyb2xsLnggLSBlbGVtZW50RGltZW5zaW9ucy53LzIgKyBsaW5rRGltZW5zaW9ucy53LzI7XG4gICAgICBhcnJvd0xlZnQgPSBlbGVtZW50RGltZW5zaW9ucy53LzIgLSAoIGlzUG9wb3ZlciA/IGFycm93V2lkdGggOiBhcnJvd1dpZHRoLzIgKTtcbiAgICB9XG4gIH1cbiAgZWxlbWVudC5zdHlsZS50b3AgPSB0b3BQb3NpdGlvbiArICdweCc7XG4gIGVsZW1lbnQuc3R5bGUubGVmdCA9IGxlZnRQb3NpdGlvbiArICdweCc7XG4gIGFycm93VG9wICYmIChhcnJvdy5zdHlsZS50b3AgPSBhcnJvd1RvcCArICdweCcpO1xuICBhcnJvd0xlZnQgJiYgKGFycm93LnN0eWxlLmxlZnQgPSBhcnJvd0xlZnQgKyAncHgnKTtcbn1cblxuZnVuY3Rpb24gUG9wb3ZlcihlbGVtZW50LG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHBvcG92ZXIgPSBudWxsLFxuICAgICAgdGltZXIgPSAwLFxuICAgICAgaXNJcGhvbmUgPSAvKGlQaG9uZXxpUG9kfGlQYWQpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLFxuICAgICAgdGl0bGVTdHJpbmcsXG4gICAgICBjb250ZW50U3RyaW5nLFxuICAgICAgb3BzID0ge307XG4gIHZhciB0cmlnZ2VyRGF0YSxcbiAgICAgIGFuaW1hdGlvbkRhdGEsXG4gICAgICBwbGFjZW1lbnREYXRhLFxuICAgICAgZGlzbWlzc2libGVEYXRhLFxuICAgICAgZGVsYXlEYXRhLFxuICAgICAgY29udGFpbmVyRGF0YSxcbiAgICAgIGNsb3NlQnRuLFxuICAgICAgc2hvd0N1c3RvbUV2ZW50LFxuICAgICAgc2hvd25DdXN0b21FdmVudCxcbiAgICAgIGhpZGVDdXN0b21FdmVudCxcbiAgICAgIGhpZGRlbkN1c3RvbUV2ZW50LFxuICAgICAgY29udGFpbmVyRWxlbWVudCxcbiAgICAgIGNvbnRhaW5lckRhdGFFbGVtZW50LFxuICAgICAgbW9kYWwsXG4gICAgICBuYXZiYXJGaXhlZFRvcCxcbiAgICAgIG5hdmJhckZpeGVkQm90dG9tLFxuICAgICAgcGxhY2VtZW50Q2xhc3M7XG4gIGZ1bmN0aW9uIGRpc21pc3NpYmxlSGFuZGxlcihlKSB7XG4gICAgaWYgKHBvcG92ZXIgIT09IG51bGwgJiYgZS50YXJnZXQgPT09IHF1ZXJ5RWxlbWVudCgnLmNsb3NlJyxwb3BvdmVyKSkge1xuICAgICAgc2VsZi5oaWRlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldENvbnRlbnRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAwIDogb3B0aW9ucy50aXRsZSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10aXRsZScpIHx8IG51bGwsXG4gICAgICAxIDogb3B0aW9ucy5jb250ZW50IHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbnRlbnQnKSB8fCBudWxsXG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVBvcG92ZXIoKSB7XG4gICAgb3BzLmNvbnRhaW5lci5yZW1vdmVDaGlsZChwb3BvdmVyKTtcbiAgICB0aW1lciA9IG51bGw7IHBvcG92ZXIgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVBvcG92ZXIoKSB7XG4gICAgdGl0bGVTdHJpbmcgPSBnZXRDb250ZW50cygpWzBdIHx8IG51bGw7XG4gICAgY29udGVudFN0cmluZyA9IGdldENvbnRlbnRzKClbMV07XG4gICAgY29udGVudFN0cmluZyA9ICEhY29udGVudFN0cmluZyA/IGNvbnRlbnRTdHJpbmcudHJpbSgpIDogbnVsbDtcbiAgICBwb3BvdmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIHBvcG92ZXJBcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHBvcG92ZXJBcnJvdy5jbGFzc0xpc3QuYWRkKCdhcnJvdycpO1xuICAgIHBvcG92ZXIuYXBwZW5kQ2hpbGQocG9wb3ZlckFycm93KTtcbiAgICBpZiAoIGNvbnRlbnRTdHJpbmcgIT09IG51bGwgJiYgb3BzLnRlbXBsYXRlID09PSBudWxsICkge1xuICAgICAgcG9wb3Zlci5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCd0b29sdGlwJyk7XG4gICAgICBpZiAodGl0bGVTdHJpbmcgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHBvcG92ZXJUaXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gzJyk7XG4gICAgICAgIHBvcG92ZXJUaXRsZS5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyLWhlYWRlcicpO1xuICAgICAgICBwb3BvdmVyVGl0bGUuaW5uZXJIVE1MID0gb3BzLmRpc21pc3NpYmxlID8gdGl0bGVTdHJpbmcgKyBjbG9zZUJ0biA6IHRpdGxlU3RyaW5nO1xuICAgICAgICBwb3BvdmVyLmFwcGVuZENoaWxkKHBvcG92ZXJUaXRsZSk7XG4gICAgICB9XG4gICAgICB2YXIgcG9wb3ZlckJvZHlNYXJrdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHBvcG92ZXJCb2R5TWFya3VwLmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXItYm9keScpO1xuICAgICAgcG9wb3ZlckJvZHlNYXJrdXAuaW5uZXJIVE1MID0gb3BzLmRpc21pc3NpYmxlICYmIHRpdGxlU3RyaW5nID09PSBudWxsID8gY29udGVudFN0cmluZyArIGNsb3NlQnRuIDogY29udGVudFN0cmluZztcbiAgICAgIHBvcG92ZXIuYXBwZW5kQ2hpbGQocG9wb3ZlckJvZHlNYXJrdXApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcG9wb3ZlclRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBwb3BvdmVyVGVtcGxhdGUuaW5uZXJIVE1MID0gb3BzLnRlbXBsYXRlLnRyaW0oKTtcbiAgICAgIHBvcG92ZXIuY2xhc3NOYW1lID0gcG9wb3ZlclRlbXBsYXRlLmZpcnN0Q2hpbGQuY2xhc3NOYW1lO1xuICAgICAgcG9wb3Zlci5pbm5lckhUTUwgPSBwb3BvdmVyVGVtcGxhdGUuZmlyc3RDaGlsZC5pbm5lckhUTUw7XG4gICAgICB2YXIgcG9wb3ZlckhlYWRlciA9IHF1ZXJ5RWxlbWVudCgnLnBvcG92ZXItaGVhZGVyJyxwb3BvdmVyKSxcbiAgICAgICAgICBwb3BvdmVyQm9keSA9IHF1ZXJ5RWxlbWVudCgnLnBvcG92ZXItYm9keScscG9wb3Zlcik7XG4gICAgICB0aXRsZVN0cmluZyAmJiBwb3BvdmVySGVhZGVyICYmIChwb3BvdmVySGVhZGVyLmlubmVySFRNTCA9IHRpdGxlU3RyaW5nLnRyaW0oKSk7XG4gICAgICBjb250ZW50U3RyaW5nICYmIHBvcG92ZXJCb2R5ICYmIChwb3BvdmVyQm9keS5pbm5lckhUTUwgPSBjb250ZW50U3RyaW5nLnRyaW0oKSk7XG4gICAgfVxuICAgIG9wcy5jb250YWluZXIuYXBwZW5kQ2hpbGQocG9wb3Zlcik7XG4gICAgcG9wb3Zlci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAhcG9wb3Zlci5jbGFzc0xpc3QuY29udGFpbnMoICdwb3BvdmVyJykgJiYgcG9wb3Zlci5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyJyk7XG4gICAgIXBvcG92ZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCBvcHMuYW5pbWF0aW9uKSAmJiBwb3BvdmVyLmNsYXNzTGlzdC5hZGQob3BzLmFuaW1hdGlvbik7XG4gICAgIXBvcG92ZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCBwbGFjZW1lbnRDbGFzcykgJiYgcG9wb3Zlci5jbGFzc0xpc3QuYWRkKHBsYWNlbWVudENsYXNzKTtcbiAgfVxuICBmdW5jdGlvbiBzaG93UG9wb3ZlcigpIHtcbiAgICAhcG9wb3Zlci5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSAmJiAoIHBvcG92ZXIuY2xhc3NMaXN0LmFkZCgnc2hvdycpICk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUG9wb3ZlcigpIHtcbiAgICBzdHlsZVRpcChlbGVtZW50LCBwb3BvdmVyLCBvcHMucGxhY2VtZW50LCBvcHMuY29udGFpbmVyKTtcbiAgfVxuICBmdW5jdGlvbiBmb3JjZUZvY3VzICgpIHtcbiAgICBpZiAocG9wb3ZlciA9PT0gbnVsbCkgeyBlbGVtZW50LmZvY3VzKCk7IH1cbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVFdmVudHMoYWN0aW9uKSB7XG4gICAgYWN0aW9uID0gYWN0aW9uID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgIGlmIChvcHMudHJpZ2dlciA9PT0gJ2hvdmVyJykge1xuICAgICAgZWxlbWVudFthY3Rpb25dKCBtb3VzZUNsaWNrRXZlbnRzLmRvd24sIHNlbGYuc2hvdyApO1xuICAgICAgZWxlbWVudFthY3Rpb25dKCBtb3VzZUhvdmVyRXZlbnRzWzBdLCBzZWxmLnNob3cgKTtcbiAgICAgIGlmICghb3BzLmRpc21pc3NpYmxlKSB7IGVsZW1lbnRbYWN0aW9uXSggbW91c2VIb3ZlckV2ZW50c1sxXSwgc2VsZi5oaWRlICk7IH1cbiAgICB9IGVsc2UgaWYgKCdjbGljaycgPT0gb3BzLnRyaWdnZXIpIHtcbiAgICAgIGVsZW1lbnRbYWN0aW9uXSggb3BzLnRyaWdnZXIsIHNlbGYudG9nZ2xlICk7XG4gICAgfSBlbHNlIGlmICgnZm9jdXMnID09IG9wcy50cmlnZ2VyKSB7XG4gICAgICBpc0lwaG9uZSAmJiBlbGVtZW50W2FjdGlvbl0oICdjbGljaycsIGZvcmNlRm9jdXMsIGZhbHNlICk7XG4gICAgICBlbGVtZW50W2FjdGlvbl0oIG9wcy50cmlnZ2VyLCBzZWxmLnRvZ2dsZSApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0b3VjaEhhbmRsZXIoZSl7XG4gICAgaWYgKCBwb3BvdmVyICYmIHBvcG92ZXIuY29udGFpbnMoZS50YXJnZXQpIHx8IGUudGFyZ2V0ID09PSBlbGVtZW50IHx8IGVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpKSA7IGVsc2Uge1xuICAgICAgc2VsZi5oaWRlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRpc21pc3NIYW5kbGVyVG9nZ2xlKGFjdGlvbikge1xuICAgIGFjdGlvbiA9IGFjdGlvbiA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICBpZiAob3BzLmRpc21pc3NpYmxlKSB7XG4gICAgICBkb2N1bWVudFthY3Rpb25dKCdjbGljaycsIGRpc21pc3NpYmxlSGFuZGxlciwgZmFsc2UgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJ2ZvY3VzJyA9PSBvcHMudHJpZ2dlciAmJiBlbGVtZW50W2FjdGlvbl0oICdibHVyJywgc2VsZi5oaWRlICk7XG4gICAgICAnaG92ZXInID09IG9wcy50cmlnZ2VyICYmIGRvY3VtZW50W2FjdGlvbl0oICd0b3VjaHN0YXJ0JywgdG91Y2hIYW5kbGVyLCBwYXNzaXZlSGFuZGxlciApO1xuICAgIH1cbiAgICB3aW5kb3dbYWN0aW9uXSgncmVzaXplJywgc2VsZi5oaWRlLCBwYXNzaXZlSGFuZGxlciApO1xuICB9XG4gIGZ1bmN0aW9uIHNob3dUcmlnZ2VyKCkge1xuICAgIGRpc21pc3NIYW5kbGVyVG9nZ2xlKDEpO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzaG93bkN1c3RvbUV2ZW50KTtcbiAgfVxuICBmdW5jdGlvbiBoaWRlVHJpZ2dlcigpIHtcbiAgICBkaXNtaXNzSGFuZGxlclRvZ2dsZSgpO1xuICAgIHJlbW92ZVBvcG92ZXIoKTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgaGlkZGVuQ3VzdG9tRXZlbnQpO1xuICB9XG4gIHNlbGYudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwb3BvdmVyID09PSBudWxsKSB7IHNlbGYuc2hvdygpOyB9XG4gICAgZWxzZSB7IHNlbGYuaGlkZSgpOyB9XG4gIH07XG4gIHNlbGYuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHRpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHBvcG92ZXIgPT09IG51bGwpIHtcbiAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGVsZW1lbnQsIHNob3dDdXN0b21FdmVudCk7XG4gICAgICAgIGlmICggc2hvd0N1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgKSB7IHJldHVybjsgfVxuICAgICAgICBjcmVhdGVQb3BvdmVyKCk7XG4gICAgICAgIHVwZGF0ZVBvcG92ZXIoKTtcbiAgICAgICAgc2hvd1BvcG92ZXIoKTtcbiAgICAgICAgISFvcHMuYW5pbWF0aW9uID8gZW11bGF0ZVRyYW5zaXRpb25FbmQocG9wb3Zlciwgc2hvd1RyaWdnZXIpIDogc2hvd1RyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9LCAyMCApO1xuICB9O1xuICBzZWxmLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwb3BvdmVyICYmIHBvcG92ZXIgIT09IG51bGwgJiYgcG9wb3Zlci5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSkge1xuICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgaGlkZUN1c3RvbUV2ZW50KTtcbiAgICAgICAgaWYgKCBoaWRlQ3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCApIHsgcmV0dXJuOyB9XG4gICAgICAgIHBvcG92ZXIuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdycpO1xuICAgICAgICAhIW9wcy5hbmltYXRpb24gPyBlbXVsYXRlVHJhbnNpdGlvbkVuZChwb3BvdmVyLCBoaWRlVHJpZ2dlcikgOiBoaWRlVHJpZ2dlcigpO1xuICAgICAgfVxuICAgIH0sIG9wcy5kZWxheSApO1xuICB9O1xuICBzZWxmLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5oaWRlKCk7XG4gICAgdG9nZ2xlRXZlbnRzKCk7XG4gICAgZGVsZXRlIGVsZW1lbnQuUG9wb3ZlcjtcbiAgfTtcbiAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcbiAgZWxlbWVudC5Qb3BvdmVyICYmIGVsZW1lbnQuUG9wb3Zlci5kaXNwb3NlKCk7XG4gIHRyaWdnZXJEYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHJpZ2dlcicpO1xuICBhbmltYXRpb25EYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYW5pbWF0aW9uJyk7XG4gIHBsYWNlbWVudERhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1wbGFjZW1lbnQnKTtcbiAgZGlzbWlzc2libGVEYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlzbWlzc2libGUnKTtcbiAgZGVsYXlEYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGVsYXknKTtcbiAgY29udGFpbmVyRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbnRhaW5lcicpO1xuICBjbG9zZUJ0biA9ICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImNsb3NlXCI+w5c8L2J1dHRvbj4nO1xuICBzaG93Q3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvdycsICdwb3BvdmVyJyk7XG4gIHNob3duQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvd24nLCAncG9wb3ZlcicpO1xuICBoaWRlQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZScsICdwb3BvdmVyJyk7XG4gIGhpZGRlbkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGRlbicsICdwb3BvdmVyJyk7XG4gIGNvbnRhaW5lckVsZW1lbnQgPSBxdWVyeUVsZW1lbnQob3B0aW9ucy5jb250YWluZXIpO1xuICBjb250YWluZXJEYXRhRWxlbWVudCA9IHF1ZXJ5RWxlbWVudChjb250YWluZXJEYXRhKTtcbiAgbW9kYWwgPSBlbGVtZW50LmNsb3Nlc3QoJy5tb2RhbCcpO1xuICBuYXZiYXJGaXhlZFRvcCA9IGVsZW1lbnQuY2xvc2VzdCgnLmZpeGVkLXRvcCcpO1xuICBuYXZiYXJGaXhlZEJvdHRvbSA9IGVsZW1lbnQuY2xvc2VzdCgnLmZpeGVkLWJvdHRvbScpO1xuICBvcHMudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlID8gb3B0aW9ucy50ZW1wbGF0ZSA6IG51bGw7XG4gIG9wcy50cmlnZ2VyID0gb3B0aW9ucy50cmlnZ2VyID8gb3B0aW9ucy50cmlnZ2VyIDogdHJpZ2dlckRhdGEgfHwgJ2hvdmVyJztcbiAgb3BzLmFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSAnZmFkZScgPyBvcHRpb25zLmFuaW1hdGlvbiA6IGFuaW1hdGlvbkRhdGEgfHwgJ2ZhZGUnO1xuICBvcHMucGxhY2VtZW50ID0gb3B0aW9ucy5wbGFjZW1lbnQgPyBvcHRpb25zLnBsYWNlbWVudCA6IHBsYWNlbWVudERhdGEgfHwgJ3RvcCc7XG4gIG9wcy5kZWxheSA9IHBhcnNlSW50KG9wdGlvbnMuZGVsYXkgfHwgZGVsYXlEYXRhKSB8fCAyMDA7XG4gIG9wcy5kaXNtaXNzaWJsZSA9IG9wdGlvbnMuZGlzbWlzc2libGUgfHwgZGlzbWlzc2libGVEYXRhID09PSAndHJ1ZScgPyB0cnVlIDogZmFsc2U7XG4gIG9wcy5jb250YWluZXIgPSBjb250YWluZXJFbGVtZW50ID8gY29udGFpbmVyRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnRhaW5lckRhdGFFbGVtZW50ID8gY29udGFpbmVyRGF0YUVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuYXZiYXJGaXhlZFRvcCA/IG5hdmJhckZpeGVkVG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogbmF2YmFyRml4ZWRCb3R0b20gPyBuYXZiYXJGaXhlZEJvdHRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IG1vZGFsID8gbW9kYWwgOiBkb2N1bWVudC5ib2R5O1xuICBwbGFjZW1lbnRDbGFzcyA9IFwiYnMtcG9wb3Zlci1cIiArIChvcHMucGxhY2VtZW50KTtcbiAgdmFyIHBvcG92ZXJDb250ZW50cyA9IGdldENvbnRlbnRzKCk7XG4gIHRpdGxlU3RyaW5nID0gcG9wb3ZlckNvbnRlbnRzWzBdO1xuICBjb250ZW50U3RyaW5nID0gcG9wb3ZlckNvbnRlbnRzWzFdO1xuICBpZiAoICFjb250ZW50U3RyaW5nICYmICFvcHMudGVtcGxhdGUgKSB7IHJldHVybjsgfVxuICBpZiAoICFlbGVtZW50LlBvcG92ZXIgKSB7XG4gICAgdG9nZ2xlRXZlbnRzKDEpO1xuICB9XG4gIGVsZW1lbnQuUG9wb3ZlciA9IHNlbGY7XG59XG5cbmZ1bmN0aW9uIFNjcm9sbFNweShlbGVtZW50LG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICB2YXJzLFxuICAgIHRhcmdldERhdGEsXG4gICAgb2Zmc2V0RGF0YSxcbiAgICBzcHlUYXJnZXQsXG4gICAgc2Nyb2xsVGFyZ2V0LFxuICAgIG9wcyA9IHt9O1xuICBmdW5jdGlvbiB1cGRhdGVUYXJnZXRzKCl7XG4gICAgdmFyIGxpbmtzID0gc3B5VGFyZ2V0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdBJyk7XG4gICAgaWYgKHZhcnMubGVuZ3RoICE9PSBsaW5rcy5sZW5ndGgpIHtcbiAgICAgIHZhcnMuaXRlbXMgPSBbXTtcbiAgICAgIHZhcnMudGFyZ2V0cyA9IFtdO1xuICAgICAgQXJyYXkuZnJvbShsaW5rcykubWFwKGZ1bmN0aW9uIChsaW5rKXtcbiAgICAgICAgdmFyIGhyZWYgPSBsaW5rLmdldEF0dHJpYnV0ZSgnaHJlZicpLFxuICAgICAgICAgIHRhcmdldEl0ZW0gPSBocmVmICYmIGhyZWYuY2hhckF0KDApID09PSAnIycgJiYgaHJlZi5zbGljZSgtMSkgIT09ICcjJyAmJiBxdWVyeUVsZW1lbnQoaHJlZik7XG4gICAgICAgIGlmICggdGFyZ2V0SXRlbSApIHtcbiAgICAgICAgICB2YXJzLml0ZW1zLnB1c2gobGluayk7XG4gICAgICAgICAgdmFycy50YXJnZXRzLnB1c2godGFyZ2V0SXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFycy5sZW5ndGggPSBsaW5rcy5sZW5ndGg7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUl0ZW0oaW5kZXgpIHtcbiAgICB2YXIgaXRlbSA9IHZhcnMuaXRlbXNbaW5kZXhdLFxuICAgICAgdGFyZ2V0SXRlbSA9IHZhcnMudGFyZ2V0c1tpbmRleF0sXG4gICAgICBkcm9wbWVudSA9IGl0ZW0uY2xhc3NMaXN0LmNvbnRhaW5zKCdkcm9wZG93bi1pdGVtJykgJiYgaXRlbS5jbG9zZXN0KCcuZHJvcGRvd24tbWVudScpLFxuICAgICAgZHJvcExpbmsgPSBkcm9wbWVudSAmJiBkcm9wbWVudS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLFxuICAgICAgbmV4dFNpYmxpbmcgPSBpdGVtLm5leHRFbGVtZW50U2libGluZyxcbiAgICAgIGFjdGl2ZVNpYmxpbmcgPSBuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdhY3RpdmUnKS5sZW5ndGgsXG4gICAgICB0YXJnZXRSZWN0ID0gdmFycy5pc1dpbmRvdyAmJiB0YXJnZXRJdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgaXNBY3RpdmUgPSBpdGVtLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgfHwgZmFsc2UsXG4gICAgICB0b3BFZGdlID0gKHZhcnMuaXNXaW5kb3cgPyB0YXJnZXRSZWN0LnRvcCArIHZhcnMuc2Nyb2xsT2Zmc2V0IDogdGFyZ2V0SXRlbS5vZmZzZXRUb3ApIC0gb3BzLm9mZnNldCxcbiAgICAgIGJvdHRvbUVkZ2UgPSB2YXJzLmlzV2luZG93ID8gdGFyZ2V0UmVjdC5ib3R0b20gKyB2YXJzLnNjcm9sbE9mZnNldCAtIG9wcy5vZmZzZXRcbiAgICAgICAgICAgICAgICAgOiB2YXJzLnRhcmdldHNbaW5kZXgrMV0gPyB2YXJzLnRhcmdldHNbaW5kZXgrMV0ub2Zmc2V0VG9wIC0gb3BzLm9mZnNldFxuICAgICAgICAgICAgICAgICA6IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0LFxuICAgICAgaW5zaWRlID0gYWN0aXZlU2libGluZyB8fCB2YXJzLnNjcm9sbE9mZnNldCA+PSB0b3BFZGdlICYmIGJvdHRvbUVkZ2UgPiB2YXJzLnNjcm9sbE9mZnNldDtcbiAgICAgaWYgKCAhaXNBY3RpdmUgJiYgaW5zaWRlICkge1xuICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgIGlmIChkcm9wTGluayAmJiAhZHJvcExpbmsuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSApIHtcbiAgICAgICAgZHJvcExpbmsuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICB9XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgYm9vdHN0cmFwQ3VzdG9tRXZlbnQoICdhY3RpdmF0ZScsICdzY3JvbGxzcHknLCB2YXJzLml0ZW1zW2luZGV4XSkpO1xuICAgIH0gZWxzZSBpZiAoIGlzQWN0aXZlICYmICFpbnNpZGUgKSB7XG4gICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgaWYgKGRyb3BMaW5rICYmIGRyb3BMaW5rLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykgJiYgIWl0ZW0ucGFyZW50Tm9kZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdhY3RpdmUnKS5sZW5ndGggKSB7XG4gICAgICAgIGRyb3BMaW5rLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIGlzQWN0aXZlICYmIGluc2lkZSB8fCAhaW5zaWRlICYmICFpc0FjdGl2ZSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlSXRlbXMoKSB7XG4gICAgdXBkYXRlVGFyZ2V0cygpO1xuICAgIHZhcnMuc2Nyb2xsT2Zmc2V0ID0gdmFycy5pc1dpbmRvdyA/IGdldFNjcm9sbCgpLnkgOiBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICB2YXJzLml0ZW1zLm1hcChmdW5jdGlvbiAobCxpZHgpeyByZXR1cm4gdXBkYXRlSXRlbShpZHgpOyB9KTtcbiAgfVxuICBmdW5jdGlvbiB0b2dnbGVFdmVudHMoYWN0aW9uKSB7XG4gICAgYWN0aW9uID0gYWN0aW9uID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgIHNjcm9sbFRhcmdldFthY3Rpb25dKCdzY3JvbGwnLCBzZWxmLnJlZnJlc2gsIHBhc3NpdmVIYW5kbGVyICk7XG4gICAgd2luZG93W2FjdGlvbl0oICdyZXNpemUnLCBzZWxmLnJlZnJlc2gsIHBhc3NpdmVIYW5kbGVyICk7XG4gIH1cbiAgc2VsZi5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHVwZGF0ZUl0ZW1zKCk7XG4gIH07XG4gIHNlbGYuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVFdmVudHMoKTtcbiAgICBkZWxldGUgZWxlbWVudC5TY3JvbGxTcHk7XG4gIH07XG4gIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG4gIGVsZW1lbnQuU2Nyb2xsU3B5ICYmIGVsZW1lbnQuU2Nyb2xsU3B5LmRpc3Bvc2UoKTtcbiAgdGFyZ2V0RGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpO1xuICBvZmZzZXREYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb2Zmc2V0Jyk7XG4gIHNweVRhcmdldCA9IHF1ZXJ5RWxlbWVudChvcHRpb25zLnRhcmdldCB8fCB0YXJnZXREYXRhKTtcbiAgc2Nyb2xsVGFyZ2V0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgPCBlbGVtZW50LnNjcm9sbEhlaWdodCA/IGVsZW1lbnQgOiB3aW5kb3c7XG4gIGlmICghc3B5VGFyZ2V0KSB7IHJldHVybiB9XG4gIG9wcy50YXJnZXQgPSBzcHlUYXJnZXQ7XG4gIG9wcy5vZmZzZXQgPSBwYXJzZUludChvcHRpb25zLm9mZnNldCB8fCBvZmZzZXREYXRhKSB8fCAxMDtcbiAgdmFycyA9IHt9O1xuICB2YXJzLmxlbmd0aCA9IDA7XG4gIHZhcnMuaXRlbXMgPSBbXTtcbiAgdmFycy50YXJnZXRzID0gW107XG4gIHZhcnMuaXNXaW5kb3cgPSBzY3JvbGxUYXJnZXQgPT09IHdpbmRvdztcbiAgaWYgKCAhZWxlbWVudC5TY3JvbGxTcHkgKSB7XG4gICAgdG9nZ2xlRXZlbnRzKDEpO1xuICB9XG4gIHNlbGYucmVmcmVzaCgpO1xuICBlbGVtZW50LlNjcm9sbFNweSA9IHNlbGY7XG59XG5cbmZ1bmN0aW9uIFRhYihlbGVtZW50LG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICBoZWlnaHREYXRhLFxuICAgIHRhYnMsIGRyb3Bkb3duLFxuICAgIHNob3dDdXN0b21FdmVudCxcbiAgICBzaG93bkN1c3RvbUV2ZW50LFxuICAgIGhpZGVDdXN0b21FdmVudCxcbiAgICBoaWRkZW5DdXN0b21FdmVudCxcbiAgICBuZXh0LFxuICAgIHRhYnNDb250ZW50Q29udGFpbmVyID0gZmFsc2UsXG4gICAgYWN0aXZlVGFiLFxuICAgIGFjdGl2ZUNvbnRlbnQsXG4gICAgbmV4dENvbnRlbnQsXG4gICAgY29udGFpbmVySGVpZ2h0LFxuICAgIGVxdWFsQ29udGVudHMsXG4gICAgbmV4dEhlaWdodCxcbiAgICBhbmltYXRlSGVpZ2h0O1xuICBmdW5jdGlvbiB0cmlnZ2VyRW5kKCkge1xuICAgIHRhYnNDb250ZW50Q29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgIHRhYnNDb250ZW50Q29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2NvbGxhcHNpbmcnKTtcbiAgICB0YWJzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gdHJpZ2dlclNob3coKSB7XG4gICAgaWYgKHRhYnNDb250ZW50Q29udGFpbmVyKSB7XG4gICAgICBpZiAoIGVxdWFsQ29udGVudHMgKSB7XG4gICAgICAgIHRyaWdnZXJFbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhYnNDb250ZW50Q29udGFpbmVyLnN0eWxlLmhlaWdodCA9IG5leHRIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgdGFic0NvbnRlbnRDb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQodGFic0NvbnRlbnRDb250YWluZXIsIHRyaWdnZXJFbmQpO1xuICAgICAgICB9LDUwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFicy5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBzaG93bkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ3Nob3duJywgJ3RhYicsIGFjdGl2ZVRhYik7XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKG5leHQsIHNob3duQ3VzdG9tRXZlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIHRyaWdnZXJIaWRlKCkge1xuICAgIGlmICh0YWJzQ29udGVudENvbnRhaW5lcikge1xuICAgICAgYWN0aXZlQ29udGVudC5zdHlsZS5mbG9hdCA9ICdsZWZ0JztcbiAgICAgIG5leHRDb250ZW50LnN0eWxlLmZsb2F0ID0gJ2xlZnQnO1xuICAgICAgY29udGFpbmVySGVpZ2h0ID0gYWN0aXZlQ29udGVudC5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuICAgIHNob3dDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93JywgJ3RhYicsIGFjdGl2ZVRhYik7XG4gICAgaGlkZGVuQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZGVuJywgJ3RhYicsIG5leHQpO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChuZXh0LCBzaG93Q3VzdG9tRXZlbnQpO1xuICAgIGlmICggc2hvd0N1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgKSB7IHJldHVybjsgfVxuICAgIG5leHRDb250ZW50LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgIGFjdGl2ZUNvbnRlbnQuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgaWYgKHRhYnNDb250ZW50Q29udGFpbmVyKSB7XG4gICAgICBuZXh0SGVpZ2h0ID0gbmV4dENvbnRlbnQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgZXF1YWxDb250ZW50cyA9IG5leHRIZWlnaHQgPT09IGNvbnRhaW5lckhlaWdodDtcbiAgICAgIHRhYnNDb250ZW50Q29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2NvbGxhcHNpbmcnKTtcbiAgICAgIHRhYnNDb250ZW50Q29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGNvbnRhaW5lckhlaWdodCArIFwicHhcIjtcbiAgICAgIHRhYnNDb250ZW50Q29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICAgIGFjdGl2ZUNvbnRlbnQuc3R5bGUuZmxvYXQgPSAnJztcbiAgICAgIG5leHRDb250ZW50LnN0eWxlLmZsb2F0ID0gJyc7XG4gICAgfVxuICAgIGlmICggbmV4dENvbnRlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYWRlJykgKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV4dENvbnRlbnQuY2xhc3NMaXN0LmFkZCgnc2hvdycpO1xuICAgICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZChuZXh0Q29udGVudCx0cmlnZ2VyU2hvdyk7XG4gICAgICB9LDIwKTtcbiAgICB9IGVsc2UgeyB0cmlnZ2VyU2hvdygpOyB9XG4gICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKGFjdGl2ZVRhYiwgaGlkZGVuQ3VzdG9tRXZlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEFjdGl2ZVRhYigpIHtcbiAgICB2YXIgYWN0aXZlVGFicyA9IHRhYnMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYWN0aXZlJyksIGFjdGl2ZVRhYjtcbiAgICBpZiAoIGFjdGl2ZVRhYnMubGVuZ3RoID09PSAxICYmICFhY3RpdmVUYWJzWzBdLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdkcm9wZG93bicpICkge1xuICAgICAgYWN0aXZlVGFiID0gYWN0aXZlVGFic1swXTtcbiAgICB9IGVsc2UgaWYgKCBhY3RpdmVUYWJzLmxlbmd0aCA+IDEgKSB7XG4gICAgICBhY3RpdmVUYWIgPSBhY3RpdmVUYWJzW2FjdGl2ZVRhYnMubGVuZ3RoLTFdO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlVGFiO1xuICB9XG4gIGZ1bmN0aW9uIGdldEFjdGl2ZUNvbnRlbnQoKSB7IHJldHVybiBxdWVyeUVsZW1lbnQoZ2V0QWN0aXZlVGFiKCkuZ2V0QXR0cmlidXRlKCdocmVmJykpIH1cbiAgZnVuY3Rpb24gY2xpY2tIYW5kbGVyKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgbmV4dCA9IGUuY3VycmVudFRhcmdldDtcbiAgICAhdGFicy5pc0FuaW1hdGluZyAmJiBzZWxmLnNob3coKTtcbiAgfVxuICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgbmV4dCA9IG5leHQgfHwgZWxlbWVudDtcbiAgICBpZiAoIW5leHQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkge1xuICAgICAgbmV4dENvbnRlbnQgPSBxdWVyeUVsZW1lbnQobmV4dC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSk7XG4gICAgICBhY3RpdmVUYWIgPSBnZXRBY3RpdmVUYWIoKTtcbiAgICAgIGFjdGl2ZUNvbnRlbnQgPSBnZXRBY3RpdmVDb250ZW50KCk7XG4gICAgICBoaWRlQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCggJ2hpZGUnLCAndGFiJywgbmV4dCk7XG4gICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoYWN0aXZlVGFiLCBoaWRlQ3VzdG9tRXZlbnQpO1xuICAgICAgaWYgKGhpZGVDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybjsgfVxuICAgICAgdGFicy5pc0FuaW1hdGluZyA9IHRydWU7XG4gICAgICBhY3RpdmVUYWIuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICBhY3RpdmVUYWIuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywnZmFsc2UnKTtcbiAgICAgIG5leHQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICBuZXh0LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsJ3RydWUnKTtcbiAgICAgIGlmICggZHJvcGRvd24gKSB7XG4gICAgICAgIGlmICggIWVsZW1lbnQucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2Ryb3Bkb3duLW1lbnUnKSApIHtcbiAgICAgICAgICBpZiAoZHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkgeyBkcm9wZG93bi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghZHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkgeyBkcm9wZG93bi5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlQ29udGVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZhZGUnKSkge1xuICAgICAgICBhY3RpdmVDb250ZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoYWN0aXZlQ29udGVudCwgdHJpZ2dlckhpZGUpO1xuICAgICAgfSBlbHNlIHsgdHJpZ2dlckhpZGUoKTsgfVxuICAgIH1cbiAgfTtcbiAgc2VsZi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLGNsaWNrSGFuZGxlcixmYWxzZSk7XG4gICAgZGVsZXRlIGVsZW1lbnQuVGFiO1xuICB9O1xuICBlbGVtZW50ID0gcXVlcnlFbGVtZW50KGVsZW1lbnQpO1xuICBlbGVtZW50LlRhYiAmJiBlbGVtZW50LlRhYi5kaXNwb3NlKCk7XG4gIGhlaWdodERhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1oZWlnaHQnKTtcbiAgdGFicyA9IGVsZW1lbnQuY2xvc2VzdCgnLm5hdicpO1xuICBkcm9wZG93biA9IHRhYnMgJiYgcXVlcnlFbGVtZW50KCcuZHJvcGRvd24tdG9nZ2xlJyx0YWJzKTtcbiAgYW5pbWF0ZUhlaWdodCA9ICFzdXBwb3J0VHJhbnNpdGlvbiB8fCAob3B0aW9ucy5oZWlnaHQgPT09IGZhbHNlIHx8IGhlaWdodERhdGEgPT09ICdmYWxzZScpID8gZmFsc2UgOiB0cnVlO1xuICB0YWJzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gIGlmICggIWVsZW1lbnQuVGFiICkge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGNsaWNrSGFuZGxlcixmYWxzZSk7XG4gIH1cbiAgaWYgKGFuaW1hdGVIZWlnaHQpIHsgdGFic0NvbnRlbnRDb250YWluZXIgPSBnZXRBY3RpdmVDb250ZW50KCkucGFyZW50Tm9kZTsgfVxuICBlbGVtZW50LlRhYiA9IHNlbGY7XG59XG5cbmZ1bmN0aW9uIFRvYXN0KGVsZW1lbnQsb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgdG9hc3QsIHRpbWVyID0gMCxcbiAgICAgIGFuaW1hdGlvbkRhdGEsXG4gICAgICBhdXRvaGlkZURhdGEsXG4gICAgICBkZWxheURhdGEsXG4gICAgICBzaG93Q3VzdG9tRXZlbnQsXG4gICAgICBoaWRlQ3VzdG9tRXZlbnQsXG4gICAgICBzaG93bkN1c3RvbUV2ZW50LFxuICAgICAgaGlkZGVuQ3VzdG9tRXZlbnQsXG4gICAgICBvcHMgPSB7fTtcbiAgZnVuY3Rpb24gc2hvd0NvbXBsZXRlKCkge1xuICAgIHRvYXN0LmNsYXNzTGlzdC5yZW1vdmUoICdzaG93aW5nJyApO1xuICAgIHRvYXN0LmNsYXNzTGlzdC5hZGQoICdzaG93JyApO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbCh0b2FzdCxzaG93bkN1c3RvbUV2ZW50KTtcbiAgICBpZiAob3BzLmF1dG9oaWRlKSB7IHNlbGYuaGlkZSgpOyB9XG4gIH1cbiAgZnVuY3Rpb24gaGlkZUNvbXBsZXRlKCkge1xuICAgIHRvYXN0LmNsYXNzTGlzdC5hZGQoICdoaWRlJyApO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbCh0b2FzdCxoaWRkZW5DdXN0b21FdmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gY2xvc2UgKCkge1xuICAgIHRvYXN0LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnICk7XG4gICAgb3BzLmFuaW1hdGlvbiA/IGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRvYXN0LCBoaWRlQ29tcGxldGUpIDogaGlkZUNvbXBsZXRlKCk7XG4gIH1cbiAgZnVuY3Rpb24gZGlzcG9zZUNvbXBsZXRlKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsc2VsZi5oaWRlLGZhbHNlKTtcbiAgICBkZWxldGUgZWxlbWVudC5Ub2FzdDtcbiAgfVxuICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRvYXN0ICYmICF0b2FzdC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSkge1xuICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudC5jYWxsKHRvYXN0LHNob3dDdXN0b21FdmVudCk7XG4gICAgICBpZiAoc2hvd0N1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG4gICAgICBvcHMuYW5pbWF0aW9uICYmIHRvYXN0LmNsYXNzTGlzdC5hZGQoICdmYWRlJyApO1xuICAgICAgdG9hc3QuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZScgKTtcbiAgICAgIHRvYXN0Lm9mZnNldFdpZHRoO1xuICAgICAgdG9hc3QuY2xhc3NMaXN0LmFkZCgnc2hvd2luZycgKTtcbiAgICAgIG9wcy5hbmltYXRpb24gPyBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0b2FzdCwgc2hvd0NvbXBsZXRlKSA6IHNob3dDb21wbGV0ZSgpO1xuICAgIH1cbiAgfTtcbiAgc2VsZi5oaWRlID0gZnVuY3Rpb24gKG5vVGltZXIpIHtcbiAgICBpZiAodG9hc3QgJiYgdG9hc3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykpIHtcbiAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbCh0b2FzdCxoaWRlQ3VzdG9tRXZlbnQpO1xuICAgICAgaWYoaGlkZUN1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG4gICAgICBub1RpbWVyID8gY2xvc2UoKSA6ICh0aW1lciA9IHNldFRpbWVvdXQoIGNsb3NlLCBvcHMuZGVsYXkpKTtcbiAgICB9XG4gIH07XG4gIHNlbGYuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBvcHMuYW5pbWF0aW9uID8gZW11bGF0ZVRyYW5zaXRpb25FbmQodG9hc3QsIGRpc3Bvc2VDb21wbGV0ZSkgOiBkaXNwb3NlQ29tcGxldGUoKTtcbiAgfTtcbiAgZWxlbWVudCA9IHF1ZXJ5RWxlbWVudChlbGVtZW50KTtcbiAgZWxlbWVudC5Ub2FzdCAmJiBlbGVtZW50LlRvYXN0LmRpc3Bvc2UoKTtcbiAgdG9hc3QgPSBlbGVtZW50LmNsb3Nlc3QoJy50b2FzdCcpO1xuICBhbmltYXRpb25EYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYW5pbWF0aW9uJyk7XG4gIGF1dG9oaWRlRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWF1dG9oaWRlJyk7XG4gIGRlbGF5RGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRlbGF5Jyk7XG4gIHNob3dDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdzaG93JywgJ3RvYXN0Jyk7XG4gIGhpZGVDdXN0b21FdmVudCA9IGJvb3RzdHJhcEN1c3RvbUV2ZW50KCdoaWRlJywgJ3RvYXN0Jyk7XG4gIHNob3duQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvd24nLCAndG9hc3QnKTtcbiAgaGlkZGVuQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZGVuJywgJ3RvYXN0Jyk7XG4gIG9wcy5hbmltYXRpb24gPSBvcHRpb25zLmFuaW1hdGlvbiA9PT0gZmFsc2UgfHwgYW5pbWF0aW9uRGF0YSA9PT0gJ2ZhbHNlJyA/IDAgOiAxO1xuICBvcHMuYXV0b2hpZGUgPSBvcHRpb25zLmF1dG9oaWRlID09PSBmYWxzZSB8fCBhdXRvaGlkZURhdGEgPT09ICdmYWxzZScgPyAwIDogMTtcbiAgb3BzLmRlbGF5ID0gcGFyc2VJbnQob3B0aW9ucy5kZWxheSB8fCBkZWxheURhdGEpIHx8IDUwMDtcbiAgaWYgKCAhZWxlbWVudC5Ub2FzdCApIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxzZWxmLmhpZGUsZmFsc2UpO1xuICB9XG4gIGVsZW1lbnQuVG9hc3QgPSBzZWxmO1xufVxuXG5mdW5jdGlvbiBUb29sdGlwKGVsZW1lbnQsb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgdG9vbHRpcCA9IG51bGwsIHRpbWVyID0gMCwgdGl0bGVTdHJpbmcsXG4gICAgICBhbmltYXRpb25EYXRhLFxuICAgICAgcGxhY2VtZW50RGF0YSxcbiAgICAgIGRlbGF5RGF0YSxcbiAgICAgIGNvbnRhaW5lckRhdGEsXG4gICAgICBzaG93Q3VzdG9tRXZlbnQsXG4gICAgICBzaG93bkN1c3RvbUV2ZW50LFxuICAgICAgaGlkZUN1c3RvbUV2ZW50LFxuICAgICAgaGlkZGVuQ3VzdG9tRXZlbnQsXG4gICAgICBjb250YWluZXJFbGVtZW50LFxuICAgICAgY29udGFpbmVyRGF0YUVsZW1lbnQsXG4gICAgICBtb2RhbCxcbiAgICAgIG5hdmJhckZpeGVkVG9wLFxuICAgICAgbmF2YmFyRml4ZWRCb3R0b20sXG4gICAgICBwbGFjZW1lbnRDbGFzcyxcbiAgICAgIG9wcyA9IHt9O1xuICBmdW5jdGlvbiBnZXRUaXRsZSgpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJylcbiAgICAgICAgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGl0bGUnKVxuICAgICAgICB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpXG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlVG9vbFRpcCgpIHtcbiAgICBvcHMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRvb2x0aXApO1xuICAgIHRvb2x0aXAgPSBudWxsOyB0aW1lciA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlVG9vbFRpcCgpIHtcbiAgICB0aXRsZVN0cmluZyA9IGdldFRpdGxlKCk7XG4gICAgaWYgKCB0aXRsZVN0cmluZyApIHtcbiAgICAgIHRvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGlmIChvcHMudGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIHRvb2x0aXBNYXJrdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdG9vbHRpcE1hcmt1cC5pbm5lckhUTUwgPSBvcHMudGVtcGxhdGUudHJpbSgpO1xuICAgICAgICB0b29sdGlwLmNsYXNzTmFtZSA9IHRvb2x0aXBNYXJrdXAuZmlyc3RDaGlsZC5jbGFzc05hbWU7XG4gICAgICAgIHRvb2x0aXAuaW5uZXJIVE1MID0gdG9vbHRpcE1hcmt1cC5maXJzdENoaWxkLmlubmVySFRNTDtcbiAgICAgICAgcXVlcnlFbGVtZW50KCcudG9vbHRpcC1pbm5lcicsdG9vbHRpcCkuaW5uZXJIVE1MID0gdGl0bGVTdHJpbmcudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRvb2x0aXBBcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0b29sdGlwQXJyb3cuY2xhc3NMaXN0LmFkZCgnYXJyb3cnKTtcbiAgICAgICAgdG9vbHRpcC5hcHBlbmRDaGlsZCh0b29sdGlwQXJyb3cpO1xuICAgICAgICB2YXIgdG9vbHRpcElubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRvb2x0aXBJbm5lci5jbGFzc0xpc3QuYWRkKCd0b29sdGlwLWlubmVyJyk7XG4gICAgICAgIHRvb2x0aXAuYXBwZW5kQ2hpbGQodG9vbHRpcElubmVyKTtcbiAgICAgICAgdG9vbHRpcElubmVyLmlubmVySFRNTCA9IHRpdGxlU3RyaW5nO1xuICAgICAgfVxuICAgICAgdG9vbHRpcC5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgdG9vbHRpcC5zdHlsZS50b3AgPSAnMCc7XG4gICAgICB0b29sdGlwLnNldEF0dHJpYnV0ZSgncm9sZScsJ3Rvb2x0aXAnKTtcbiAgICAgICF0b29sdGlwLmNsYXNzTGlzdC5jb250YWlucygndG9vbHRpcCcpICYmIHRvb2x0aXAuY2xhc3NMaXN0LmFkZCgndG9vbHRpcCcpO1xuICAgICAgIXRvb2x0aXAuY2xhc3NMaXN0LmNvbnRhaW5zKG9wcy5hbmltYXRpb24pICYmIHRvb2x0aXAuY2xhc3NMaXN0LmFkZChvcHMuYW5pbWF0aW9uKTtcbiAgICAgICF0b29sdGlwLmNsYXNzTGlzdC5jb250YWlucyhwbGFjZW1lbnRDbGFzcykgJiYgdG9vbHRpcC5jbGFzc0xpc3QuYWRkKHBsYWNlbWVudENsYXNzKTtcbiAgICAgIG9wcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodG9vbHRpcCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVRvb2x0aXAoKSB7XG4gICAgc3R5bGVUaXAoZWxlbWVudCwgdG9vbHRpcCwgb3BzLnBsYWNlbWVudCwgb3BzLmNvbnRhaW5lcik7XG4gIH1cbiAgZnVuY3Rpb24gc2hvd1Rvb2x0aXAoKSB7XG4gICAgIXRvb2x0aXAuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93JykgJiYgKCB0b29sdGlwLmNsYXNzTGlzdC5hZGQoJ3Nob3cnKSApO1xuICB9XG4gIGZ1bmN0aW9uIHRvdWNoSGFuZGxlcihlKXtcbiAgICBpZiAoIHRvb2x0aXAgJiYgdG9vbHRpcC5jb250YWlucyhlLnRhcmdldCkgfHwgZS50YXJnZXQgPT09IGVsZW1lbnQgfHwgZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkpIDsgZWxzZSB7XG4gICAgICBzZWxmLmhpZGUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlQWN0aW9uKGFjdGlvbil7XG4gICAgYWN0aW9uID0gYWN0aW9uID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgIGRvY3VtZW50W2FjdGlvbl0oICd0b3VjaHN0YXJ0JywgdG91Y2hIYW5kbGVyLCBwYXNzaXZlSGFuZGxlciApO1xuICAgIHdpbmRvd1thY3Rpb25dKCAncmVzaXplJywgc2VsZi5oaWRlLCBwYXNzaXZlSGFuZGxlciApO1xuICB9XG4gIGZ1bmN0aW9uIHNob3dBY3Rpb24oKSB7XG4gICAgdG9nZ2xlQWN0aW9uKDEpO1xuICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzaG93bkN1c3RvbUV2ZW50KTtcbiAgfVxuICBmdW5jdGlvbiBoaWRlQWN0aW9uKCkge1xuICAgIHRvZ2dsZUFjdGlvbigpO1xuICAgIHJlbW92ZVRvb2xUaXAoKTtcbiAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgaGlkZGVuQ3VzdG9tRXZlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIHRvZ2dsZUV2ZW50cyhhY3Rpb24pIHtcbiAgICBhY3Rpb24gPSBhY3Rpb24gPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gICAgZWxlbWVudFthY3Rpb25dKG1vdXNlQ2xpY2tFdmVudHMuZG93biwgc2VsZi5zaG93LGZhbHNlKTtcbiAgICBlbGVtZW50W2FjdGlvbl0obW91c2VIb3ZlckV2ZW50c1swXSwgc2VsZi5zaG93LGZhbHNlKTtcbiAgICBlbGVtZW50W2FjdGlvbl0obW91c2VIb3ZlckV2ZW50c1sxXSwgc2VsZi5oaWRlLGZhbHNlKTtcbiAgfVxuICBzZWxmLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0b29sdGlwID09PSBudWxsKSB7XG4gICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQuY2FsbChlbGVtZW50LCBzaG93Q3VzdG9tRXZlbnQpO1xuICAgICAgICBpZiAoc2hvd0N1c3RvbUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmKGNyZWF0ZVRvb2xUaXAoKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB1cGRhdGVUb29sdGlwKCk7XG4gICAgICAgICAgc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgICAhIW9wcy5hbmltYXRpb24gPyBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0b29sdGlwLCBzaG93QWN0aW9uKSA6IHNob3dBY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDIwICk7XG4gIH07XG4gIHNlbGYuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHRpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRvb2x0aXAgJiYgdG9vbHRpcC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3cnKSkge1xuICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50LmNhbGwoZWxlbWVudCwgaGlkZUN1c3RvbUV2ZW50KTtcbiAgICAgICAgaWYgKGhpZGVDdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybjsgfVxuICAgICAgICB0b29sdGlwLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcbiAgICAgICAgISFvcHMuYW5pbWF0aW9uID8gZW11bGF0ZVRyYW5zaXRpb25FbmQodG9vbHRpcCwgaGlkZUFjdGlvbikgOiBoaWRlQWN0aW9uKCk7XG4gICAgICB9XG4gICAgfSwgb3BzLmRlbGF5KTtcbiAgfTtcbiAgc2VsZi50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0b29sdGlwKSB7IHNlbGYuc2hvdygpOyB9XG4gICAgZWxzZSB7IHNlbGYuaGlkZSgpOyB9XG4gIH07XG4gIHNlbGYuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2dnbGVFdmVudHMoKTtcbiAgICBzZWxmLmhpZGUoKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGl0bGUnLCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpKTtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpO1xuICAgIGRlbGV0ZSBlbGVtZW50LlRvb2x0aXA7XG4gIH07XG4gIGVsZW1lbnQgPSBxdWVyeUVsZW1lbnQoZWxlbWVudCk7XG4gIGVsZW1lbnQuVG9vbHRpcCAmJiBlbGVtZW50LlRvb2x0aXAuZGlzcG9zZSgpO1xuICBhbmltYXRpb25EYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYW5pbWF0aW9uJyk7XG4gIHBsYWNlbWVudERhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1wbGFjZW1lbnQnKTtcbiAgZGVsYXlEYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGVsYXknKTtcbiAgY29udGFpbmVyRGF0YSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbnRhaW5lcicpO1xuICBzaG93Q3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvdycsICd0b29sdGlwJyk7XG4gIHNob3duQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnc2hvd24nLCAndG9vbHRpcCcpO1xuICBoaWRlQ3VzdG9tRXZlbnQgPSBib290c3RyYXBDdXN0b21FdmVudCgnaGlkZScsICd0b29sdGlwJyk7XG4gIGhpZGRlbkN1c3RvbUV2ZW50ID0gYm9vdHN0cmFwQ3VzdG9tRXZlbnQoJ2hpZGRlbicsICd0b29sdGlwJyk7XG4gIGNvbnRhaW5lckVsZW1lbnQgPSBxdWVyeUVsZW1lbnQob3B0aW9ucy5jb250YWluZXIpO1xuICBjb250YWluZXJEYXRhRWxlbWVudCA9IHF1ZXJ5RWxlbWVudChjb250YWluZXJEYXRhKTtcbiAgbW9kYWwgPSBlbGVtZW50LmNsb3Nlc3QoJy5tb2RhbCcpO1xuICBuYXZiYXJGaXhlZFRvcCA9IGVsZW1lbnQuY2xvc2VzdCgnLmZpeGVkLXRvcCcpO1xuICBuYXZiYXJGaXhlZEJvdHRvbSA9IGVsZW1lbnQuY2xvc2VzdCgnLmZpeGVkLWJvdHRvbScpO1xuICBvcHMuYW5pbWF0aW9uID0gb3B0aW9ucy5hbmltYXRpb24gJiYgb3B0aW9ucy5hbmltYXRpb24gIT09ICdmYWRlJyA/IG9wdGlvbnMuYW5pbWF0aW9uIDogYW5pbWF0aW9uRGF0YSB8fCAnZmFkZSc7XG4gIG9wcy5wbGFjZW1lbnQgPSBvcHRpb25zLnBsYWNlbWVudCA/IG9wdGlvbnMucGxhY2VtZW50IDogcGxhY2VtZW50RGF0YSB8fCAndG9wJztcbiAgb3BzLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZSA/IG9wdGlvbnMudGVtcGxhdGUgOiBudWxsO1xuICBvcHMuZGVsYXkgPSBwYXJzZUludChvcHRpb25zLmRlbGF5IHx8IGRlbGF5RGF0YSkgfHwgMjAwO1xuICBvcHMuY29udGFpbmVyID0gY29udGFpbmVyRWxlbWVudCA/IGNvbnRhaW5lckVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjb250YWluZXJEYXRhRWxlbWVudCA/IGNvbnRhaW5lckRhdGFFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogbmF2YmFyRml4ZWRUb3AgPyBuYXZiYXJGaXhlZFRvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5hdmJhckZpeGVkQm90dG9tID8gbmF2YmFyRml4ZWRCb3R0b21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtb2RhbCA/IG1vZGFsIDogZG9jdW1lbnQuYm9keTtcbiAgcGxhY2VtZW50Q2xhc3MgPSBcImJzLXRvb2x0aXAtXCIgKyAob3BzLnBsYWNlbWVudCk7XG4gIHRpdGxlU3RyaW5nID0gZ2V0VGl0bGUoKTtcbiAgaWYgKCAhdGl0bGVTdHJpbmcgKSB7IHJldHVybjsgfVxuICBpZiAoIWVsZW1lbnQuVG9vbHRpcCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJyx0aXRsZVN0cmluZyk7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RpdGxlJyk7XG4gICAgdG9nZ2xlRXZlbnRzKDEpO1xuICB9XG4gIGVsZW1lbnQuVG9vbHRpcCA9IHNlbGY7XG59XG5cbnZhciBjb21wb25lbnRzSW5pdCA9IHt9O1xuXG5mdW5jdGlvbiBpbml0aWFsaXplRGF0YUFQSSggQ29uc3RydWN0b3IsIGNvbGxlY3Rpb24gKXtcbiAgQXJyYXkuZnJvbShjb2xsZWN0aW9uKS5tYXAoZnVuY3Rpb24gKHgpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHgpOyB9KTtcbn1cbmZ1bmN0aW9uIGluaXRDYWxsYmFjayhsb29rVXApe1xuICBsb29rVXAgPSBsb29rVXAgfHwgZG9jdW1lbnQ7XG4gIGZvciAodmFyIGNvbXBvbmVudCBpbiBjb21wb25lbnRzSW5pdCkge1xuICAgIGluaXRpYWxpemVEYXRhQVBJKCBjb21wb25lbnRzSW5pdFtjb21wb25lbnRdWzBdLCBsb29rVXAucXVlcnlTZWxlY3RvckFsbCAoY29tcG9uZW50c0luaXRbY29tcG9uZW50XVsxXSkgKTtcbiAgfVxufVxuXG5jb21wb25lbnRzSW5pdC5BbGVydCA9IFsgQWxlcnQsICdbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nXTtcbmNvbXBvbmVudHNJbml0LkJ1dHRvbiA9IFsgQnV0dG9uLCAnW2RhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiXScgXTtcbmNvbXBvbmVudHNJbml0LkNhcm91c2VsID0gWyBDYXJvdXNlbCwgJ1tkYXRhLXJpZGU9XCJjYXJvdXNlbFwiXScgXTtcbmNvbXBvbmVudHNJbml0LkNvbGxhcHNlID0gWyBDb2xsYXBzZSwgJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdJyBdO1xuY29tcG9uZW50c0luaXQuRHJvcGRvd24gPSBbIERyb3Bkb3duLCAnW2RhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIl0nXTtcbmNvbXBvbmVudHNJbml0Lk1vZGFsID0gWyBNb2RhbCwgJ1tkYXRhLXRvZ2dsZT1cIm1vZGFsXCJdJyBdO1xuY29tcG9uZW50c0luaXQuUG9wb3ZlciA9IFsgUG9wb3ZlciwgJ1tkYXRhLXRvZ2dsZT1cInBvcG92ZXJcIl0sW2RhdGEtdGlwPVwicG9wb3ZlclwiXScgXTtcbmNvbXBvbmVudHNJbml0LlNjcm9sbFNweSA9IFsgU2Nyb2xsU3B5LCAnW2RhdGEtc3B5PVwic2Nyb2xsXCJdJyBdO1xuY29tcG9uZW50c0luaXQuVGFiID0gWyBUYWIsICdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nIF07XG5jb21wb25lbnRzSW5pdC5Ub2FzdCA9IFsgVG9hc3QsICdbZGF0YS1kaXNtaXNzPVwidG9hc3RcIl0nIF07XG5jb21wb25lbnRzSW5pdC5Ub29sdGlwID0gWyBUb29sdGlwLCAnW2RhdGEtdG9nZ2xlPVwidG9vbHRpcFwiXSxbZGF0YS10aXA9XCJ0b29sdGlwXCJdJyBdO1xuZG9jdW1lbnQuYm9keSA/IGluaXRDYWxsYmFjaygpIDogZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiBpbml0V3JhcHBlcigpe1xuXHRpbml0Q2FsbGJhY2soKTtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsaW5pdFdyYXBwZXIsZmFsc2UpO1xufSwgZmFsc2UgKTtcblxuZnVuY3Rpb24gcmVtb3ZlRWxlbWVudERhdGFBUEkoIENvbnN0cnVjdG9yTmFtZSwgY29sbGVjdGlvbiApe1xuICBBcnJheS5mcm9tKGNvbGxlY3Rpb24pLm1hcChmdW5jdGlvbiAoeCl7IHJldHVybiB4W0NvbnN0cnVjdG9yTmFtZV0uZGlzcG9zZSgpOyB9KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZURhdGFBUEkobG9va1VwKSB7XG4gIGxvb2tVcCA9IGxvb2tVcCB8fCBkb2N1bWVudDtcbiAgZm9yICh2YXIgY29tcG9uZW50IGluIGNvbXBvbmVudHNJbml0KSB7XG4gICAgcmVtb3ZlRWxlbWVudERhdGFBUEkoIGNvbXBvbmVudCwgbG9va1VwLnF1ZXJ5U2VsZWN0b3JBbGwgKGNvbXBvbmVudHNJbml0W2NvbXBvbmVudF1bMV0pICk7XG4gIH1cbn1cblxudmFyIHZlcnNpb24gPSBcIjMuMC4xM1wiO1xuXG52YXIgaW5kZXggPSB7XG4gIEFsZXJ0OiBBbGVydCxcbiAgQnV0dG9uOiBCdXR0b24sXG4gIENhcm91c2VsOiBDYXJvdXNlbCxcbiAgQ29sbGFwc2U6IENvbGxhcHNlLFxuICBEcm9wZG93bjogRHJvcGRvd24sXG4gIE1vZGFsOiBNb2RhbCxcbiAgUG9wb3ZlcjogUG9wb3ZlcixcbiAgU2Nyb2xsU3B5OiBTY3JvbGxTcHksXG4gIFRhYjogVGFiLFxuICBUb2FzdDogVG9hc3QsXG4gIFRvb2x0aXA6IFRvb2x0aXAsXG4gIGluaXRDYWxsYmFjazogaW5pdENhbGxiYWNrLFxuICByZW1vdmVEYXRhQVBJOiByZW1vdmVEYXRhQVBJLFxuICBjb21wb25lbnRzSW5pdDogY29tcG9uZW50c0luaXQsXG4gIFZlcnNpb246IHZlcnNpb25cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmluc3RhbmNlcyA9IFtdO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnN0IGluZGV4ID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgaW5zdGFuY2UgPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXNbaV07XG5cdFx0XHRpbnN0YW5jZS5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXZlbnRMaXN0ZW5lcigpIHtcbiAgICAgIGlmIChlcnJvckxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIHZhciBlcnJvckxpc3RlbmVyO1xuXG4gICAgLy8gQWRkaW5nIGFuIGVycm9yIGxpc3RlbmVyIGlzIG5vdCBvcHRpb25hbCBiZWNhdXNlXG4gICAgLy8gaWYgYW4gZXJyb3IgaXMgdGhyb3duIG9uIGFuIGV2ZW50IGVtaXR0ZXIgd2UgY2Fubm90XG4gICAgLy8gZ3VhcmFudGVlIHRoYXQgdGhlIGFjdHVhbCBldmVudCB3ZSBhcmUgd2FpdGluZyB3aWxsXG4gICAgLy8gYmUgZmlyZWQuIFRoZSByZXN1bHQgY291bGQgYmUgYSBzaWxlbnQgd2F5IHRvIGNyZWF0ZVxuICAgIC8vIG1lbW9yeSBvciBmaWxlIGRlc2NyaXB0b3IgbGVha3MsIHdoaWNoIGlzIHNvbWV0aGluZ1xuICAgIC8vIHdlIHNob3VsZCBhdm9pZC5cbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgZXJyb3JMaXN0ZW5lciA9IGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgZXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfTtcblxuICAgICAgZW1pdHRlci5vbmNlKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgIH1cblxuICAgIGVtaXR0ZXIub25jZShuYW1lLCBldmVudExpc3RlbmVyKTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1hZ2VzL29icy1jcmVhdGUtdGV4dC1zb3VyY2UucG5nXCI7IiwiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImltYWdlcy9vYnMtd2Vic29ja2V0LWNvbm5lY3Rpb24ucG5nXCI7IiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbWF4b2dkZW4vd2Vic29ja2V0LXN0cmVhbS9ibG9iLzQ4ZGMzZGRmOTQzZTVhZGE2NjhjMzFjY2Q5NGU5MTg2ZjAyZmFmYmQvd3MtZmFsbGJhY2suanNcblxudmFyIHdzID0gbnVsbFxuXG5pZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd3MgPSBXZWJTb2NrZXRcbn0gZWxzZSBpZiAodHlwZW9mIE1veldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd3MgPSBNb3pXZWJTb2NrZXRcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd3MgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXRcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd3MgPSB3aW5kb3cuV2ViU29ja2V0IHx8IHdpbmRvdy5Nb3pXZWJTb2NrZXRcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdzID0gc2VsZi5XZWJTb2NrZXQgfHwgc2VsZi5Nb3pXZWJTb2NrZXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3c1xuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCJjb25zdCBTb2NrZXQgPSByZXF1aXJlKCcuL1NvY2tldCcpO1xuY29uc3QgU3RhdHVzID0gcmVxdWlyZSgnLi9TdGF0dXMnKTtcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnb2JzLXdlYnNvY2tldC1qczpDb3JlJyk7XG5cbmxldCByZXF1ZXN0Q291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTWVzc2FnZUlkKCkge1xuICByZXR1cm4gU3RyaW5nKHJlcXVlc3RDb3VudGVyKyspO1xufVxuXG5jbGFzcyBPQlNXZWJTb2NrZXQgZXh0ZW5kcyBTb2NrZXQge1xuICAvKipcbiAgICogR2VuZXJpYyBTb2NrZXQgcmVxdWVzdCBtZXRob2QuIFJldHVybnMgYSBwcm9taXNlLlxuICAgKiBHZW5lcmF0ZXMgYSBtZXNzYWdlSWQgaW50ZXJuYWxseSBhbmQgd2lsbCBvdmVycmlkZSBhbnkgcGFzc2VkIGluIHRoZSBhcmdzLlxuICAgKiBOb3RlIHRoYXQgdGhlIHJlcXVlc3RUeXBlIGhlcmUgaXMgcHJlLW1hcnNoYWxpbmcgYW5kIGN1cnJlbnRseSBtdXN0IG1hdGNoIGV4YWN0bHkgd2hhdCB0aGUgd2Vic29ja2V0IHBsdWdpbiBpcyBleHBlY3RpbmcuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICByZXF1ZXN0VHlwZSBvYnMtd2Vic29ja2V0IHBsdWdpbiBleHBlY3RlZCByZXF1ZXN0IHR5cGUuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBbYXJncz17fV0gICByZXF1ZXN0IGFyZ3VtZW50cy5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgIFByb21pc2UsIHBhc3NlcyB0aGUgcGx1Z2luIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIHNlbmQocmVxdWVzdFR5cGUsIGFyZ3MgPSB7fSkge1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VJZCA9IGdlbmVyYXRlTWVzc2FnZUlkKCk7XG4gICAgICBsZXQgcmVqZWN0UmVhc29uO1xuXG4gICAgICBpZiAoIXJlcXVlc3RUeXBlKSB7XG4gICAgICAgIHJlamVjdFJlYXNvbiA9IFN0YXR1cy5SRVFVRVNUX1RZUEVfTk9UX1NQRUNJRklFRDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgcmVqZWN0UmVhc29uID0gU3RhdHVzLk5PVF9DT05ORUNURUQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEFzc2lnbiBhIHRlbXBvcmFyeSBldmVudCBsaXN0ZW5lciBmb3IgdGhpcyBwYXJ0aWN1bGFyIG1lc3NhZ2VJZCB0byB1bmlxdWVseSBpZGVudGlmeSB0aGUgcmVzcG9uc2UuXG4gICAgICB0aGlzLm9uY2UoYG9iczppbnRlcm5hbDptZXNzYWdlOmlkLSR7bWVzc2FnZUlkfWAsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGRlYnVnKCdbc2VuZDpyZWplY3RdICVvJywgZXJyKTtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnW3NlbmQ6cmVzb2x2ZV0gJW8nLCBkYXRhKTtcbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHJlYXNvbiB0byBmYWlsIGZhc3QsIHNlbmQgdGhlIHJlcXVlc3QgdG8gdGhlIHNvY2tldC5cbiAgICAgIGlmICghcmVqZWN0UmVhc29uKSB7XG4gICAgICAgIGFyZ3NbJ3JlcXVlc3QtdHlwZSddID0gcmVxdWVzdFR5cGU7XG4gICAgICAgIGFyZ3NbJ21lc3NhZ2UtaWQnXSA9IG1lc3NhZ2VJZDtcblxuICAgICAgICAvLyBTdWJtaXQgdGhlIHJlcXVlc3QgdG8gdGhlIHdlYnNvY2tldC5cbiAgICAgICAgZGVidWcoJ1tzZW5kXSAlcyAlcyAlbycsIG1lc3NhZ2VJZCwgcmVxdWVzdFR5cGUsIGFyZ3MpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuX3NvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KGFyZ3MpKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIC8vIFRPRE86IENvbnNpZGVyIGluc3BlY3RpbmcgdGhlIGV4Y2VwdGlvbiB0aHJvd24gdG8gZ2xlYW0gc29tZSByZWxldmFudCBpbmZvIGFuZCBwYXNzIHRoYXQgb24uXG4gICAgICAgICAgcmVqZWN0UmVhc29uID0gU3RhdHVzLlNPQ0tFVF9FWENFUFRJT047XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHNvY2tldCBjYWxsIHdhcyB1bnN1Y2Nlc3NmdWwgb3IgYnlwYXNzZWQsIHNpbXVsYXRlIGl0cyByZXNvbHV0aW9uLlxuICAgICAgaWYgKHJlamVjdFJlYXNvbikge1xuICAgICAgICB0aGlzLmVtaXQoYG9iczppbnRlcm5hbDptZXNzYWdlOmlkLSR7bWVzc2FnZUlkfWAsIHJlamVjdFJlYXNvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJpYyBTb2NrZXQgcmVxdWVzdCBtZXRob2QuIEhhbmRsZXMgY2FsbGJhY2tzLlxuICAgKiBJbnRlcm5hbGx5IGNhbGxzIGBzZW5kYCAod2hpY2ggaXMgcHJvbWlzZS1iYXNlZCkuIFNlZSBgc2VuZGAncyBkb2NzIGZvciBtb3JlIGRldGFpbHMuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICByZXF1ZXN0VHlwZSBvYnMtd2Vic29ja2V0IHBsdWdpbiBleHBlY3RlZCByZXF1ZXN0IHR5cGUuXG4gICAqIEBwYXJhbSAge09iamVjdH0gICBbYXJncz17fV0gICByZXF1ZXN0IGFyZ3VtZW50cy5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrICAgIE9wdGlvbmFsLiBjYWxsYmFjayhlcnIsIGRhdGEpXG4gICAqL1xuICBzZW5kQ2FsbGJhY2socmVxdWVzdFR5cGUsIGFyZ3MgPSB7fSwgY2FsbGJhY2spIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZWZhdWx0LXBhcmFtLWxhc3RcbiAgICAvLyBBbGxvdyB0aGUgYGFyZ3NgIGFyZ3VtZW50IHRvIGJlIG9taXR0ZWQuXG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIGFyZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gYXJncztcbiAgICAgIGFyZ3MgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIHRoZSBhY3R1YWwgcmVxdWVzdCwgdXNpbmcgYHNlbmRgLlxuICAgIHRoaXMuc2VuZChyZXF1ZXN0VHlwZSwgYXJncykudGhlbigoLi4ucmVzcG9uc2UpID0+IHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIC4uLnJlc3BvbnNlKTtcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPQlNXZWJTb2NrZXQ7XG4iLCJjb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCdpc29tb3JwaGljLXdzJyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGhhc2ggPSByZXF1aXJlKCcuL3V0aWwvYXV0aGVudGljYXRpb25IYXNoaW5nJyk7XG5jb25zdCBTdGF0dXMgPSByZXF1aXJlKCcuL1N0YXR1cycpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdvYnMtd2Vic29ja2V0LWpzOlNvY2tldCcpO1xuY29uc3QgbG9nQW1iaWd1b3VzRXJyb3IgPSByZXF1aXJlKCcuL3V0aWwvbG9nQW1iaWd1b3VzRXJyb3InKTtcbmNvbnN0IGNhbWVsQ2FzZUtleXMgPSByZXF1aXJlKCcuL3V0aWwvY2FtZWxDYXNlS2V5cycpO1xuXG5jbGFzcyBTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3NvY2tldCA9IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IG9yaWdpbmFsRW1pdCA9IHRoaXMuZW1pdDtcbiAgICB0aGlzLmVtaXQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgZGVidWcoJ1tlbWl0XSAlcyBlcnI6ICVvIGRhdGE6ICVvJywgLi4uYXJncyk7XG4gICAgICBvcmlnaW5hbEVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGNvbm5lY3QoYXJncyA9IHt9KSB7XG4gICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgY29uc3QgYWRkcmVzcyA9IGFyZ3MuYWRkcmVzcyB8fCAnbG9jYWxob3N0OjQ0NDQnO1xuXG4gICAgaWYgKHRoaXMuX3NvY2tldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQmxpbmRseSB0cnkgdG8gY2xvc2UgdGhlIHNvY2tldC5cbiAgICAgICAgLy8gRG9uJ3QgY2FyZSBpZiBpdHMgYWxyZWFkeSBjbG9zZWQuXG4gICAgICAgIC8vIFdlIGp1c3QgZG9uJ3Qgd2FudCBhbnkgc29ja2V0cyB0byBsZWFrLlxuICAgICAgICB0aGlzLl9zb2NrZXQuY2xvc2UoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFRoZXNlIGVycm9ycyBhcmUgcHJvYmFibHkgc2FmZSB0byBpZ25vcmUsIGJ1dCBkZWJ1ZyBsb2cgdGhlbSBqdXN0IGluIGNhc2UuXG4gICAgICAgIGRlYnVnKCdGYWlsZWQgdG8gY2xvc2UgcHJldmlvdXMgV2ViU29ja2V0OicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2Nvbm5lY3QoYWRkcmVzcywgQm9vbGVhbihhcmdzLnNlY3VyZSkpO1xuICAgICAgICBhd2FpdCB0aGlzLl9hdXRoZW50aWNhdGUoYXJncy5wYXNzd29yZCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLl9zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIGxvZ0FtYmlndW91c0Vycm9yKGRlYnVnLCAnQ29ubmVjdGlvbiBmYWlsZWQ6JywgZXJyKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgYSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byBhbiBvYnMtd2Vic29ja2V0IHNlcnZlciwgYnV0IGRvZXMgbm90IGF0dGVtcHQgYW55IGF1dGhlbnRpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB1cmwgd2l0aG91dCB3czovLyBvciB3c3M6Ly8gcHJlZml4LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNlY3VyZSB3aGV0aGVyIHRvIHVzIHdzOi8vIG9yIHdzczovL1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7UHJvbWlzZX0gb24gYXR0ZW1wdGVkIGNyZWF0aW9uIG9mIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgX2Nvbm5lY3QoYWRkcmVzcywgc2VjdXJlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBzZXR0bGVkID0gZmFsc2U7XG5cbiAgICAgIGRlYnVnKCdBdHRlbXB0aW5nIHRvIGNvbm5lY3QgdG86ICVzIChzZWN1cmU6ICVzKScsIGFkZHJlc3MsIHNlY3VyZSk7XG4gICAgICB0aGlzLl9zb2NrZXQgPSBuZXcgV2ViU29ja2V0KChzZWN1cmUgPyAnd3NzOi8vJyA6ICd3czovLycpICsgYWRkcmVzcyk7XG5cbiAgICAgIC8vIFdlIG9ubHkgaGFuZGxlIHRoZSBpbml0aWFsIGNvbm5lY3Rpb24gZXJyb3IuXG4gICAgICAvLyBCZXlvbmQgdGhhdCwgdGhlIGNvbnN1bWVyIGlzIHJlc3BvbnNpYmxlIGZvciBhZGRpbmcgdGhlaXIgb3duIGdlbmVyaWMgYGVycm9yYCBldmVudCBsaXN0ZW5lci5cbiAgICAgIC8vIEZJWE1FOiBVbnN1cmUgaG93IGJlc3QgdG8gZXhwb3NlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIFdlYlNvY2tldCBlcnJvci5cbiAgICAgIHRoaXMuX3NvY2tldC5vbmVycm9yID0gZXJyID0+IHtcbiAgICAgICAgaWYgKHNldHRsZWQpIHtcbiAgICAgICAgICBsb2dBbWJpZ3VvdXNFcnJvcihkZWJ1ZywgJ1Vua25vd24gU29ja2V0IEVycm9yJywgZXJyKTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgbG9nQW1iaWd1b3VzRXJyb3IoZGVidWcsICdXZWJzb2NrZXQgQ29ubmVjdGlvbiBmYWlsZWQ6JywgZXJyKTtcbiAgICAgICAgcmVqZWN0KFN0YXR1cy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3NvY2tldC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIGlmIChzZXR0bGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgc2V0dGxlZCA9IHRydWU7XG5cbiAgICAgICAgZGVidWcoJ0Nvbm5lY3Rpb24gb3BlbmVkOiAlcycsIGFkZHJlc3MpO1xuICAgICAgICB0aGlzLmVtaXQoJ0Nvbm5lY3Rpb25PcGVuZWQnKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcblxuICAgICAgLy8gTG9va3MgbGlrZSB0aGlzIHNob3VsZCBiZSBib3VuZC4gV2UgZG9uJ3QgdGVjaG5pY2FsbHkgY2FuY2VsIHRoZSBjb25uZWN0aW9uIHdoZW4gdGhlIGF1dGhlbnRpY2F0aW9uIGZhaWxzLlxuICAgICAgdGhpcy5fc29ja2V0Lm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBkZWJ1ZygnQ29ubmVjdGlvbiBjbG9zZWQ6ICVzJywgYWRkcmVzcyk7XG4gICAgICAgIHRoaXMuZW1pdCgnQ29ubmVjdGlvbkNsb3NlZCcpO1xuICAgICAgfTtcblxuICAgICAgLy8gVGhpcyBoYW5kbGVyIG11c3QgYmUgcHJlc2VudCBiZWZvcmUgd2UgY2FuIGNhbGwgX2F1dGhlbnRpY2F0ZS5cbiAgICAgIHRoaXMuX3NvY2tldC5vbm1lc3NhZ2UgPSBtc2cgPT4ge1xuICAgICAgICBkZWJ1ZygnW09uTWVzc2FnZV06ICVvJywgbXNnKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNhbWVsQ2FzZUtleXMoSlNPTi5wYXJzZShtc2cuZGF0YSkpO1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBsZXQgZGF0YTtcblxuICAgICAgICBpZiAobWVzc2FnZS5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICBlcnIgPSBtZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBtZXNzYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW1pdCB0aGUgbWVzc2FnZSB3aXRoIElEIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHRyeSB0byBmaW5kIGEgbm9uLW1lc3NhZ2VJZCBkcml2ZW4gZXZlbnQuXG4gICAgICAgIGlmIChtZXNzYWdlLm1lc3NhZ2VJZCkge1xuICAgICAgICAgIHRoaXMuZW1pdChgb2JzOmludGVybmFsOm1lc3NhZ2U6aWQtJHttZXNzYWdlLm1lc3NhZ2VJZH1gLCBlcnIsIGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudXBkYXRlVHlwZSkge1xuICAgICAgICAgIHRoaXMuZW1pdChtZXNzYWdlLnVwZGF0ZVR5cGUsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ0FtYmlndW91c0Vycm9yKGRlYnVnLCAnVW5yZWNvZ25pemVkIFNvY2tldCBNZXNzYWdlOicsIG1lc3NhZ2UpO1xuICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEF1dGhlbnRpY2F0ZXMgdG8gYW4gb2JzLXdlYnNvY2tldCBzZXJ2ZXIuIE11c3QgYWxyZWFkeSBoYXZlIGFuIGFjdGl2ZSBjb25uZWN0aW9uIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3Bhc3N3b3JkPScnXSBhdXRoZW50aWNhdGlvbiBzdHJpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IG9uIHJlc29sdXRpb24gb2YgYXV0aGVudGljYXRpb24gY2FsbC5cbiAgICovXG4gIGFzeW5jIF9hdXRoZW50aWNhdGUocGFzc3dvcmQgPSAnJykge1xuICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICB0aHJvdyBTdGF0dXMuTk9UX0NPTk5FQ1RFRDtcbiAgICB9XG5cbiAgICBjb25zdCBhdXRoID0gYXdhaXQgdGhpcy5zZW5kKCdHZXRBdXRoUmVxdWlyZWQnKTtcblxuICAgIGlmICghYXV0aC5hdXRoUmVxdWlyZWQpIHtcbiAgICAgIGRlYnVnKCdBdXRoZW50aWNhdGlvbiBub3QgUmVxdWlyZWQnKTtcbiAgICAgIHRoaXMuZW1pdCgnQXV0aGVudGljYXRpb25TdWNjZXNzJyk7XG4gICAgICByZXR1cm4gU3RhdHVzLkFVVEhfTk9UX1JFUVVJUkVEO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnNlbmQoJ0F1dGhlbnRpY2F0ZScsIHtcbiAgICAgICAgYXV0aDogaGFzaChhdXRoLnNhbHQsIGF1dGguY2hhbGxlbmdlLCBwYXNzd29yZClcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCdBdXRoZW50aWNhdGlvbiBGYWlsdXJlICVvJywgZSk7XG4gICAgICB0aGlzLmVtaXQoJ0F1dGhlbnRpY2F0aW9uRmFpbHVyZScpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBkZWJ1ZygnQXV0aGVudGljYXRpb24gU3VjY2VzcycpO1xuICAgIHRoaXMuZW1pdCgnQXV0aGVudGljYXRpb25TdWNjZXNzJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2UgYW5kIGRpc2Nvbm5lY3QgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKiBGSVhNRTogdGhpcyBzaG91bGQgc3VwcG9ydCBhIGNhbGxiYWNrIGFuZCByZXR1cm4gYSBQcm9taXNlIHRvIG1hdGNoIHRoZSBjb25uZWN0IG1ldGhvZC5cbiAgICpcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBjYXRlZ29yeSByZXF1ZXN0XG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIGRlYnVnKCdEaXNjb25uZWN0IHJlcXVlc3RlZC4nKTtcbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9zb2NrZXQuY2xvc2UoKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgTk9UX0NPTk5FQ1RFRDoge1xuICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICBkZXNjcmlwdGlvbjogJ1RoZXJlIGlzIG5vIFNvY2tldCBjb25uZWN0aW9uIGF2YWlsYWJsZS4nXG4gIH0sXG4gIENPTk5FQ1RJT05fRVJST1I6IHtcbiAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgZGVzY3JpcHRpb246ICdDb25uZWN0aW9uIGVycm9yLidcbiAgfSxcbiAgU09DS0VUX0VYQ0VQVElPTjoge1xuICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICBkZXNjcmlwdGlvbjogJ0FuIGV4Y2VwdGlvbiBvY2N1cnJlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIFdlYlNvY2tldC4nXG4gIH0sXG4gIEFVVEhfTk9UX1JFUVVJUkVEOiB7XG4gICAgc3RhdHVzOiAnb2snLFxuICAgIGRlc2NyaXB0aW9uOiAnQXV0aGVudGljYXRpb24gaXMgbm90IHJlcXVpcmVkLidcbiAgfSxcbiAgUkVRVUVTVF9UWVBFX05PVF9TUEVDSUZJRUQ6IHtcbiAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgZGVzY3JpcHRpb246ICdBIFJlcXVlc3QgVHlwZSB3YXMgbm90IHNwZWNpZmllZC4nXG4gIH0sXG5cbiAgaW5pdCgpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzKSB7XG4gICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBrZXkpKSB7XG4gICAgICAgIC8vIEFzc2lnbiBhIHZhbHVlIHRvICdjb2RlJyBpZGVudGlmaWVkIGJ5IHRoZSBzdGF0dXMnIGtleS5cbiAgICAgICAgdGhpc1trZXldLmNvZGUgPSBrZXk7XG5cbiAgICAgICAgLy8gQXNzaWduIGEgdmFsdWUgdG8gJ2Vycm9yJyBpZiBvbmUgaXMgbm90IGFscmVhZHkgZGVmaW5lZC5cbiAgICAgICAgaWYgKHRoaXNba2V5XS5zdGF0dXMgPT09ICdlcnJvcicgJiYgIXRoaXNba2V5XS5lcnJvcikge1xuICAgICAgICAgIHRoaXNba2V5XS5lcnJvciA9IHRoaXNba2V5XS5kZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLmluaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0uaW5pdCgpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL09CU1dlYlNvY2tldC5qcycpO1xuIiwiY29uc3QgU0hBMjU2ID0gcmVxdWlyZSgnc2hhLmpzL3NoYTI1NicpO1xuXG4vKipcbiAqIFNIQTI1NiBIYXNoaW5nLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gW3NhbHQ9JyddIHNhbHQuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFtjaGFsbGVuZ2U9JyddIGNoYWxsZW5nZS5cbiAqIEBwYXJhbSAge1N0cmluZ30gbXNnIE1lc3NhZ2UgdG8gZW5jb2RlLlxuICogQHJldHVybiB7U3RyaW5nfSBzaGEyNTYgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LXBhcmFtLWxhc3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNhbHQgPSAnJywgY2hhbGxlbmdlID0gJycsIG1zZykge1xuICBjb25zdCBoYXNoID0gbmV3IFNIQTI1NigpXG4gICAgLnVwZGF0ZShtc2cpXG4gICAgLnVwZGF0ZShzYWx0KVxuICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gIGNvbnN0IHJlc3AgPSBuZXcgU0hBMjU2KClcbiAgICAudXBkYXRlKGhhc2gpXG4gICAgLnVwZGF0ZShjaGFsbGVuZ2UpXG4gICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgcmV0dXJuIHJlc3A7XG59O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBrZWJhYi1jYXNlIHRvIGNhbWVsQ2FzZS5cbiAqIFJldGFpbnMgdGhlIG9yaWdpbmFsIGtlYmFiLWNhc2UgZW50cmllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29iaj17fV0gS2V5ZWQgb2JqZWN0LlxuICogQHJldHVybiB7T2JqZWN0fSBLZXllZCBvYmplY3Qgd2l0aCBhZGRlZCBjYW1lbENhc2VkIGtleXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICBvYmogPSBvYmogfHwge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbWVsQ2FzZWRLZXkgPSBrZXkucmVwbGFjZSgvLShbYS16XSkvZ2ksICgkMCwgJDEpID0+IHtcbiAgICAgIHJldHVybiAkMS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICAgIG9ialtjYW1lbENhc2VkS2V5XSA9IG9ialtrZXldO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG4iLCIvKipcbiAqIERpc2FtYmlndWF0ZXMgYW4gXCJlcnJvclwiIGFuZCBmb3JtYXRzIGl0IG5pY2VseSBmb3IgYGRlYnVnYCBvdXRwdXQuXG4gKiBQYXJ0aWN1bGFybHkgdXNlZnVsIHdoZW4gZGVhbGluZyB3aXRoIGVycm9yIHJlc3BvbnNlIG9iamVjdHMgZnJvbSBvYnMtd2Vic29ja2V0LFxuICogd2hpY2ggYXJlIG5vdCBhY3R1YWwgRXJyb3ItdHlwZSBlcnJvcnMsIGJ1dCBzaW1wbHkgT2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVidWcgQSBgZGVidWdgIGluc3RhbmNlLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBBIHN0cmluZyB0byBwcmludCBpbiBmcm9udCBvZiB0aGUgZm9ybWF0dGVkIGVycm9yLlxuICogQHBhcmFtIHtPYmplY3R8RXJyb3J9IGVycm9yIEFuIGVycm9yIG9mIGFtYmlndW91cyB0eXBlIHRoYXQgeW91IHdpc2ggdG8gbG9nIHRvIGBkZWJ1Z2AuIENhbiBiZSBhbiBFcnJvciwgT2JqZWN0LCBvciBTdHJpbmcuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRlYnVnLCBwcmVmaXgsIGVycm9yKSB7XG4gIGlmIChlcnJvciAmJiBlcnJvci5zdGFjaykge1xuICAgIGRlYnVnKGAke3ByZWZpeH1cXG4gJU9gLCBlcnJvci5zdGFjayk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuICAgIGRlYnVnKGAke3ByZWZpeH0gJW9gLCBlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoYCR7cHJlZml4fSAlc2AsIGVycm9yKTtcbiAgfVxufTtcbiIsIi8qIFJpb3QgdjUuMC4wLCBAbGljZW5zZSBNSVQgKi9cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyBmcm9tIGNhbWVsIGNhc2UgdG8gZGFzaC1jYXNlXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBzdHJpbmcgLSBwcm9iYWJseSBhIGNvbXBvbmVudCB0YWcgbmFtZVxuICogQHJldHVybnMge3N0cmluZ30gY29tcG9uZW50IG5hbWUgbm9ybWFsaXplZFxuICovXG5mdW5jdGlvbiBjYW1lbFRvRGFzaENhc2Uoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbn1cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyBjb250YWluaW5nIGRhc2hlcyB0byBjYW1lbCBjYXNlXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBzdHJpbmcgLSBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IG15LXN0cmluZyAtPiBteVN0cmluZ1xuICovXG5cbmZ1bmN0aW9uIGRhc2hUb0NhbWVsQ2FzZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8tKFxcdykvZywgKF8sIGMpID0+IGMudG9VcHBlckNhc2UoKSk7XG59XG5cbi8qKlxuICogR2V0IGFsbCB0aGUgZWxlbWVudCBhdHRyaWJ1dGVzIGFzIG9iamVjdFxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gRE9NIG5vZGUgd2Ugd2FudCB0byBwYXJzZVxuICogQHJldHVybnMge09iamVjdH0gYWxsIHRoZSBhdHRyaWJ1dGVzIGZvdW5kIGFzIGEga2V5IHZhbHVlIHBhaXJzXG4gKi9cblxuZnVuY3Rpb24gRE9NYXR0cmlidXRlc1RvT2JqZWN0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5hdHRyaWJ1dGVzKS5yZWR1Y2UoKGFjYywgYXR0cmlidXRlKSA9PiB7XG4gICAgYWNjW2Rhc2hUb0NhbWVsQ2FzZShhdHRyaWJ1dGUubmFtZSldID0gYXR0cmlidXRlLnZhbHVlO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cbi8qKlxuICogTW92ZSBhbGwgdGhlIGNoaWxkIG5vZGVzIGZyb20gYSBzb3VyY2UgdGFnIHRvIGFub3RoZXJcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gc291cmNlIC0gc291cmNlIG5vZGVcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gdGFyZ2V0IG5vZGVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9IGl0J3MgYSB2b2lkIG1ldGhvZCDCr1xcXyjjg4QpXy/Cr1xuICovXG4vLyBJZ25vcmUgdGhpcyBoZWxwZXIgYmVjYXVzZSBpdCdzIG5lZWRlZCBvbmx5IGZvciBzdmcgdGFnc1xuXG5mdW5jdGlvbiBtb3ZlQ2hpbGRyZW4oc291cmNlLCB0YXJnZXQpIHtcbiAgaWYgKHNvdXJjZS5maXJzdENoaWxkKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHNvdXJjZS5maXJzdENoaWxkKTtcbiAgICBtb3ZlQ2hpbGRyZW4oc291cmNlLCB0YXJnZXQpO1xuICB9XG59XG4vKipcbiAqIFJlbW92ZSB0aGUgY2hpbGQgbm9kZXMgZnJvbSBhbnkgRE9NIG5vZGVcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gbm9kZSAtIHRhcmdldCBub2RlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNsZWFuTm9kZShub2RlKSB7XG4gIGNsZWFyQ2hpbGRyZW4obm9kZS5jaGlsZE5vZGVzKTtcbn1cbi8qKlxuICogQ2xlYXIgbXVsdGlwbGUgY2hpbGRyZW4gaW4gYSBub2RlXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnRbXX0gY2hpbGRyZW4gLSBkaXJlY3QgY2hpbGRyZW4gbm9kZXNcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gY2xlYXJDaGlsZHJlbihjaGlsZHJlbikge1xuICBBcnJheS5mcm9tKGNoaWxkcmVuKS5mb3JFYWNoKHJlbW92ZUNoaWxkKTtcbn1cbi8qKlxuICogUmVtb3ZlIGEgbm9kZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH1ub2RlIC0gbm9kZSB0byByZW1vdmVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuY29uc3QgcmVtb3ZlQ2hpbGQgPSBub2RlID0+IG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlICYmIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbi8qKlxuICogSW5zZXJ0IGJlZm9yZSBhIG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5ld05vZGUgLSBub2RlIHRvIGluc2VydFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmTm9kZSAtIHJlZiBjaGlsZFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5jb25zdCBpbnNlcnRCZWZvcmUgPSAobmV3Tm9kZSwgcmVmTm9kZSkgPT4gcmVmTm9kZSAmJiByZWZOb2RlLnBhcmVudE5vZGUgJiYgcmVmTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZOb2RlKTtcbi8qKlxuICogUmVwbGFjZSBhIG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5ld05vZGUgLSBuZXcgbm9kZSB0byBhZGQgdG8gdGhlIERPTVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVwbGFjZWQgLSBub2RlIHRvIHJlcGxhY2VcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuY29uc3QgcmVwbGFjZUNoaWxkID0gKG5ld05vZGUsIHJlcGxhY2VkKSA9PiByZXBsYWNlZCAmJiByZXBsYWNlZC5wYXJlbnROb2RlICYmIHJlcGxhY2VkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld05vZGUsIHJlcGxhY2VkKTtcblxuY29uc3QgRUFDSCA9IDA7XG5jb25zdCBJRiA9IDE7XG5jb25zdCBTSU1QTEUgPSAyO1xuY29uc3QgVEFHID0gMztcbmNvbnN0IFNMT1QgPSA0O1xudmFyIGJpbmRpbmdUeXBlcyA9IHtcbiAgRUFDSCxcbiAgSUYsXG4gIFNJTVBMRSxcbiAgVEFHLFxuICBTTE9UXG59O1xuXG5jb25zdCBBVFRSSUJVVEUgPSAwO1xuY29uc3QgRVZFTlQgPSAxO1xuY29uc3QgVEVYVCA9IDI7XG5jb25zdCBWQUxVRSA9IDM7XG52YXIgZXhwcmVzc2lvblR5cGVzID0ge1xuICBBVFRSSUJVVEUsXG4gIEVWRU5ULFxuICBURVhULFxuICBWQUxVRVxufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIHRlbXBsYXRlIG1ldGEgb2JqZWN0IGluIGNhc2Ugb2YgPHRlbXBsYXRlPiBmcmFnbWVudHNcbiAqIEBwYXJhbSAgIHtUZW1wbGF0ZUNodW5rfSBjb21wb25lbnRUZW1wbGF0ZSAtIHRlbXBsYXRlIGNodW5rIG9iamVjdFxuICogQHJldHVybnMge09iamVjdH0gdGhlIG1ldGEgcHJvcGVydHkgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbW91bnQgZnVuY3Rpb24gb2YgdGhlIFRlbXBsYXRlQ2h1bmtcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGVNZXRhKGNvbXBvbmVudFRlbXBsYXRlKSB7XG4gIGNvbnN0IGZyYWdtZW50ID0gY29tcG9uZW50VGVtcGxhdGUuZG9tLmNsb25lTm9kZSh0cnVlKTtcbiAgcmV0dXJuIHtcbiAgICBhdm9pZERPTUluamVjdGlvbjogdHJ1ZSxcbiAgICBmcmFnbWVudCxcbiAgICBjaGlsZHJlbjogQXJyYXkuZnJvbShmcmFnbWVudC5jaGlsZE5vZGVzKVxuICB9O1xufVxuXG4vKipcbiAqIFF1aWNrIHR5cGUgY2hlY2tpbmdcbiAqIEBwYXJhbSAgIHsqfSBlbGVtZW50IC0gYW55dGhpbmdcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IHR5cGUgLSB0eXBlIGRlZmluaXRpb25cbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0eXBlIGNvcnJlc3BvbmRzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrVHlwZShlbGVtZW50LCB0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgZWxlbWVudCA9PT0gdHlwZTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBwYXJ0IG9mIGFuIHN2Z1xuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgZWwgLSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB3ZSBhcmUgaW4gYW4gc3ZnIGNvbnRleHRcbiAqL1xuXG5mdW5jdGlvbiBpc1N2ZyhlbCkge1xuICBjb25zdCBvd25lciA9IGVsLm93bmVyU1ZHRWxlbWVudDtcbiAgcmV0dXJuICEhb3duZXIgfHwgb3duZXIgPT09IG51bGw7XG59XG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSB0ZW1wbGF0ZSB0YWdcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gIGVsIC0gZWxlbWVudCB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgaXQncyBhIDx0ZW1wbGF0ZT5cbiAqL1xuXG5mdW5jdGlvbiBpc1RlbXBsYXRlKGVsKSB7XG4gIHJldHVybiAhaXNOaWwoZWwuY29udGVudCk7XG59XG4vKipcbiAqIENoZWNrIHRoYXQgd2lsbCBiZSBwYXNzZWQgaWYgaXRzIGFyZ3VtZW50IGlzIGEgZnVuY3Rpb25cbiAqIEBwYXJhbSAgIHsqfSB2YWx1ZSAtIHZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tUeXBlKHZhbHVlLCAnZnVuY3Rpb24nKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIEJvb2xlYW5cbiAqIEBwYXJhbSAgIHsqfSAgdmFsdWUgLSBhbnl0aGluZ1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb25seSBmb3IgdGhlIHZhbHVlIGlzIGEgYm9vbGVhblxuICovXG5cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tUeXBlKHZhbHVlLCAnYm9vbGVhbicpO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICogQHBhcmFtICAgeyp9ICB2YWx1ZSAtIGFueXRoaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBvbmx5IGZvciB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0XG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuICFpc05pbCh2YWx1ZSkgJiYgY2hlY2tUeXBlKHZhbHVlLCAnb2JqZWN0Jyk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWRcbiAqIEBwYXJhbSAgIHsqfSAgdmFsdWUgLSBhbnl0aGluZ1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb25seSBmb3IgdGhlICd1bmRlZmluZWQnIGFuZCAnbnVsbCcgdHlwZXNcbiAqL1xuXG5mdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBJU0MgTGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAyMCwgQW5kcmVhIEdpYW1tYXJjaGksIEBXZWJSZWZsZWN0aW9uXG4gKlxuICogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4gKiBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcbiAqIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuICogQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuICogSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG4gKiBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRVxuICogT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuICogUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAqL1xuLy8gZm9yayBvZiBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi91ZG9tZGlmZiB2ZXJzaW9uIDEuMS4wXG4vLyBkdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vdWRvbWRpZmYvcHVsbC8yXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBwYXJlbnROb2RlIFRoZSBjb250YWluZXIgd2hlcmUgY2hpbGRyZW4gbGl2ZVxuICogQHBhcmFtIHtOb2RlW119IGEgVGhlIGxpc3Qgb2YgY3VycmVudC9saXZlIGNoaWxkcmVuXG4gKiBAcGFyYW0ge05vZGVbXX0gYiBUaGUgbGlzdCBvZiBmdXR1cmUgY2hpbGRyZW5cbiAqIEBwYXJhbSB7KGVudHJ5OiBOb2RlLCBhY3Rpb246IG51bWJlcikgPT4gTm9kZX0gZ2V0XG4gKiBUaGUgY2FsbGJhY2sgaW52b2tlZCBwZXIgZWFjaCBlbnRyeSByZWxhdGVkIERPTSBvcGVyYXRpb24uXG4gKiBAcGFyYW0ge05vZGV9IFtiZWZvcmVdIFRoZSBvcHRpb25hbCBub2RlIHVzZWQgYXMgYW5jaG9yIHRvIGluc2VydCBiZWZvcmUuXG4gKiBAcmV0dXJucyB7Tm9kZVtdfSBUaGUgc2FtZSBsaXN0IG9mIGZ1dHVyZSBjaGlsZHJlbi5cbiAqL1xuXG52YXIgdWRvbWRpZmYgPSAoKHBhcmVudE5vZGUsIGEsIGIsIGdldCwgYmVmb3JlKSA9PiB7XG4gIGNvbnN0IGJMZW5ndGggPSBiLmxlbmd0aDtcbiAgbGV0IGFFbmQgPSBhLmxlbmd0aDtcbiAgbGV0IGJFbmQgPSBiTGVuZ3RoO1xuICBsZXQgYVN0YXJ0ID0gMDtcbiAgbGV0IGJTdGFydCA9IDA7XG4gIGxldCBtYXAgPSBudWxsO1xuXG4gIHdoaWxlIChhU3RhcnQgPCBhRW5kIHx8IGJTdGFydCA8IGJFbmQpIHtcbiAgICAvLyBhcHBlbmQgaGVhZCwgdGFpbCwgb3Igbm9kZXMgaW4gYmV0d2VlbjogZmFzdCBwYXRoXG4gICAgaWYgKGFFbmQgPT09IGFTdGFydCkge1xuICAgICAgLy8gd2UgY291bGQgYmUgaW4gYSBzaXR1YXRpb24gd2hlcmUgdGhlIHJlc3Qgb2Ygbm9kZXMgdGhhdFxuICAgICAgLy8gbmVlZCB0byBiZSBhZGRlZCBhcmUgbm90IGF0IHRoZSBlbmQsIGFuZCBpbiBzdWNoIGNhc2VcbiAgICAgIC8vIHRoZSBub2RlIHRvIGBpbnNlcnRCZWZvcmVgLCBpZiB0aGUgaW5kZXggaXMgbW9yZSB0aGFuIDBcbiAgICAgIC8vIG11c3QgYmUgcmV0cmlldmVkLCBvdGhlcndpc2UgaXQncyBnb25uYSBiZSB0aGUgZmlyc3QgaXRlbS5cbiAgICAgIGNvbnN0IG5vZGUgPSBiRW5kIDwgYkxlbmd0aCA/IGJTdGFydCA/IGdldChiW2JTdGFydCAtIDFdLCAtMCkubmV4dFNpYmxpbmcgOiBnZXQoYltiRW5kIC0gYlN0YXJ0XSwgMCkgOiBiZWZvcmU7XG5cbiAgICAgIHdoaWxlIChiU3RhcnQgPCBiRW5kKSBpbnNlcnRCZWZvcmUoZ2V0KGJbYlN0YXJ0KytdLCAxKSwgbm9kZSk7XG4gICAgfSAvLyByZW1vdmUgaGVhZCBvciB0YWlsOiBmYXN0IHBhdGhcbiAgICBlbHNlIGlmIChiRW5kID09PSBiU3RhcnQpIHtcbiAgICAgICAgd2hpbGUgKGFTdGFydCA8IGFFbmQpIHtcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIG5vZGUgb25seSBpZiBpdCdzIHVua25vd24gb3Igbm90IGxpdmVcbiAgICAgICAgICBpZiAoIW1hcCB8fCAhbWFwLmhhcyhhW2FTdGFydF0pKSByZW1vdmVDaGlsZChnZXQoYVthU3RhcnRdLCAtMSkpO1xuICAgICAgICAgIGFTdGFydCsrO1xuICAgICAgICB9XG4gICAgICB9IC8vIHNhbWUgbm9kZTogZmFzdCBwYXRoXG4gICAgICBlbHNlIGlmIChhW2FTdGFydF0gPT09IGJbYlN0YXJ0XSkge1xuICAgICAgICAgIGFTdGFydCsrO1xuICAgICAgICAgIGJTdGFydCsrO1xuICAgICAgICB9IC8vIHNhbWUgdGFpbDogZmFzdCBwYXRoXG4gICAgICAgIGVsc2UgaWYgKGFbYUVuZCAtIDFdID09PSBiW2JFbmQgLSAxXSkge1xuICAgICAgICAgICAgYUVuZC0tO1xuICAgICAgICAgICAgYkVuZC0tO1xuICAgICAgICAgIH0gLy8gVGhlIG9uY2UgaGVyZSBzaW5nbGUgbGFzdCBzd2FwIFwiZmFzdCBwYXRoXCIgaGFzIGJlZW4gcmVtb3ZlZCBpbiB2MS4xLjBcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi91ZG9tZGlmZi9ibG9iL3NpbmdsZS1maW5hbC1zd2FwL2VzbS9pbmRleC5qcyNMNjktTDg1XG4gICAgICAgICAgLy8gcmV2ZXJzZSBzd2FwOiBhbHNvIGZhc3QgcGF0aFxuICAgICAgICAgIGVsc2UgaWYgKGFbYVN0YXJ0XSA9PT0gYltiRW5kIC0gMV0gJiYgYltiU3RhcnRdID09PSBhW2FFbmQgLSAxXSkge1xuICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgXCJzaHJpbmtcIiBvcGVyYXRpb24gdGhhdCBjb3VsZCBoYXBwZW4gaW4gdGhlc2UgY2FzZXM6XG4gICAgICAgICAgICAgIC8vIFsxLCAyLCAzLCA0LCA1XVxuICAgICAgICAgICAgICAvLyBbMSwgNCwgMywgMiwgNV1cbiAgICAgICAgICAgICAgLy8gb3IgYXN5bW1ldHJpYyB0b29cbiAgICAgICAgICAgICAgLy8gWzEsIDIsIDMsIDQsIDVdXG4gICAgICAgICAgICAgIC8vIFsxLCAyLCAzLCA1LCA2LCA0XVxuICAgICAgICAgICAgICBjb25zdCBub2RlID0gZ2V0KGFbLS1hRW5kXSwgLTEpLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUoZ2V0KGJbYlN0YXJ0KytdLCAxKSwgZ2V0KGFbYVN0YXJ0KytdLCAtMSkubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUoZ2V0KGJbLS1iRW5kXSwgMSksIG5vZGUpOyAvLyBtYXJrIHRoZSBmdXR1cmUgaW5kZXggYXMgaWRlbnRpY2FsICh5ZWFoLCBpdCdzIGRpcnR5LCBidXQgY2hlYXAg8J+RjSlcbiAgICAgICAgICAgICAgLy8gVGhlIG1haW4gcmVhc29uIHRvIGRvIHRoaXMsIGlzIHRoYXQgd2hlbiBhW2FFbmRdIHdpbGwgYmUgcmVhY2hlZCxcbiAgICAgICAgICAgICAgLy8gdGhlIGxvb3Agd2lsbCBsaWtlbHkgYmUgb24gdGhlIGZhc3QgcGF0aCwgYXMgaWRlbnRpY2FsIHRvIGJbYkVuZF0uXG4gICAgICAgICAgICAgIC8vIEluIHRoZSBiZXN0IGNhc2Ugc2NlbmFyaW8sIHRoZSBuZXh0IGxvb3Agd2lsbCBza2lwIHRoZSB0YWlsLFxuICAgICAgICAgICAgICAvLyBidXQgaW4gdGhlIHdvcnN0IG9uZSwgdGhpcyBub2RlIHdpbGwgYmUgY29uc2lkZXJlZCBhcyBhbHJlYWR5XG4gICAgICAgICAgICAgIC8vIHByb2Nlc3NlZCwgYmFpbGluZyBvdXQgcHJldHR5IHF1aWNrbHkgZnJvbSB0aGUgbWFwIGluZGV4IGNoZWNrXG5cbiAgICAgICAgICAgICAgYVthRW5kXSA9IGJbYkVuZF07XG4gICAgICAgICAgICB9IC8vIG1hcCBiYXNlZCBmYWxsYmFjaywgXCJzbG93XCIgcGF0aFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG1hcCByZXF1aXJlcyBhbiBPKGJFbmQgLSBiU3RhcnQpIG9wZXJhdGlvbiBvbmNlXG4gICAgICAgICAgICAgICAgLy8gdG8gc3RvcmUgYWxsIGZ1dHVyZSBub2RlcyBpbmRleGVzIGZvciBsYXRlciBwdXJwb3Nlcy5cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgd29yc3QgY2FzZSBzY2VuYXJpbywgdGhpcyBpcyBhIGZ1bGwgTyhOKSBjb3N0LFxuICAgICAgICAgICAgICAgIC8vIGFuZCBzdWNoIHNjZW5hcmlvIGhhcHBlbnMgYXQgbGVhc3Qgd2hlbiBhbGwgbm9kZXMgYXJlIGRpZmZlcmVudCxcbiAgICAgICAgICAgICAgICAvLyBidXQgYWxzbyBpZiBib3RoIGZpcnN0IGFuZCBsYXN0IGl0ZW1zIG9mIHRoZSBsaXN0cyBhcmUgZGlmZmVyZW50XG4gICAgICAgICAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgICAgICAgIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgIGxldCBpID0gYlN0YXJ0O1xuXG4gICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGJFbmQpIG1hcC5zZXQoYltpXSwgaSsrKTtcbiAgICAgICAgICAgICAgICB9IC8vIGlmIGl0J3MgYSBmdXR1cmUgbm9kZSwgaGVuY2UgaXQgbmVlZHMgc29tZSBoYW5kbGluZ1xuXG5cbiAgICAgICAgICAgICAgICBpZiAobWFwLmhhcyhhW2FTdGFydF0pKSB7XG4gICAgICAgICAgICAgICAgICAvLyBncmFiIHRoZSBpbmRleCBvZiBzdWNoIG5vZGUsICdjYXVzZSBpdCBtaWdodCBoYXZlIGJlZW4gcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG1hcC5nZXQoYVthU3RhcnRdKTsgLy8gaWYgaXQncyBub3QgYWxyZWFkeSBwcm9jZXNzZWQsIGxvb2sgb24gZGVtYW5kIGZvciB0aGUgbmV4dCBMQ1NcblxuICAgICAgICAgICAgICAgICAgaWYgKGJTdGFydCA8IGluZGV4ICYmIGluZGV4IDwgYkVuZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IGFTdGFydDsgLy8gY291bnRzIHRoZSBhbW91bnQgb2Ygbm9kZXMgdGhhdCBhcmUgdGhlIHNhbWUgaW4gdGhlIGZ1dHVyZVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZXF1ZW5jZSA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IGFFbmQgJiYgaSA8IGJFbmQgJiYgbWFwLmdldChhW2ldKSA9PT0gaW5kZXggKyBzZXF1ZW5jZSkgc2VxdWVuY2UrKzsgLy8gZWZmb3J0IGRlY2lzaW9uIGhlcmU6IGlmIHRoZSBzZXF1ZW5jZSBpcyBsb25nZXIgdGhhbiByZXBsYWNlc1xuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkZWQgdG8gcmVhY2ggc3VjaCBzZXF1ZW5jZSwgd2hpY2ggd291bGQgYnJpbmdzIGFnYWluIHRoaXMgbG9vcFxuICAgICAgICAgICAgICAgICAgICAvLyB0byB0aGUgZmFzdCBwYXRoLCBwcmVwZW5kIHRoZSBkaWZmZXJlbmNlIGJlZm9yZSBhIHNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbW92ZSBvbmx5IHRoZSBmdXR1cmUgbGlzdCBpbmRleCBmb3J3YXJkLCBzbyB0aGF0IGFTdGFydFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgYlN0YXJ0IHdpbGwgYmUgYWxpZ25lZCBhZ2FpbiwgaGVuY2Ugb24gdGhlIGZhc3QgcGF0aC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQW4gZXhhbXBsZSBjb25zaWRlcmluZyBhU3RhcnQgYW5kIGJTdGFydCBhcmUgYm90aCAwOlxuICAgICAgICAgICAgICAgICAgICAvLyBhOiBbMSwgMiwgMywgNF1cbiAgICAgICAgICAgICAgICAgICAgLy8gYjogWzcsIDEsIDIsIDMsIDZdXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd291bGQgcGxhY2UgNyBiZWZvcmUgMSBhbmQsIGZyb20gdGhhdCB0aW1lIG9uLCAxLCAyLCBhbmQgM1xuICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBhdCB6ZXJvIGNvc3RcblxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXF1ZW5jZSA+IGluZGV4IC0gYlN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGdldChhW2FTdGFydF0sIDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJTdGFydCA8IGluZGV4KSBpbnNlcnRCZWZvcmUoZ2V0KGJbYlN0YXJ0KytdLCAxKSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gaWYgdGhlIGVmZm9ydCB3YXNuJ3QgZ29vZCBlbm91Z2gsIGZhbGxiYWNrIHRvIGEgcmVwbGFjZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92aW5nIGJvdGggc291cmNlIGFuZCB0YXJnZXQgaW5kZXhlcyBmb3J3YXJkLCBob3BpbmcgdGhhdCBzb21lXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbWlsYXIgbm9kZSB3aWxsIGJlIGZvdW5kIGxhdGVyIG9uLCB0byBnbyBiYWNrIHRvIHRoZSBmYXN0IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlQ2hpbGQoZ2V0KGJbYlN0YXJ0KytdLCAxKSwgZ2V0KGFbYVN0YXJ0KytdLCAtMSkpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gLy8gb3RoZXJ3aXNlIG1vdmUgdGhlIHNvdXJjZSBmb3J3YXJkLCAnY2F1c2UgdGhlcmUncyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICAgICAgICBlbHNlIGFTdGFydCsrO1xuICAgICAgICAgICAgICAgIH0gLy8gdGhpcyBub2RlIGhhcyBubyBtZWFuaW5nIGluIHRoZSBmdXR1cmUgbGlzdCwgc28gaXQncyBtb3JlIHRoYW4gc2FmZVxuICAgICAgICAgICAgICAgIC8vIHRvIHJlbW92ZSBpdCwgYW5kIGNoZWNrIHRoZSBuZXh0IGxpdmUgbm9kZSBvdXQgaW5zdGVhZCwgbWVhbmluZ1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgb25seSB0aGUgbGl2ZSBsaXN0IGluZGV4IHNob3VsZCBiZSBmb3J3YXJkZWRcbiAgICAgICAgICAgICAgICBlbHNlIHJlbW92ZUNoaWxkKGdldChhW2FTdGFydCsrXSwgLTEpKTtcbiAgICAgICAgICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIGI7XG59KTtcblxuY29uc3QgVU5NT1VOVF9TQ09QRSA9IFN5bWJvbCgndW5tb3VudCcpO1xuY29uc3QgRWFjaEJpbmRpbmcgPSBPYmplY3Quc2VhbCh7XG4gIC8vIGR5bmFtaWMgYmluZGluZyBwcm9wZXJ0aWVzXG4gIC8vIGNoaWxkcmVuTWFwOiBudWxsLFxuICAvLyBub2RlOiBudWxsLFxuICAvLyByb290OiBudWxsLFxuICAvLyBjb25kaXRpb246IG51bGwsXG4gIC8vIGV2YWx1YXRlOiBudWxsLFxuICAvLyB0ZW1wbGF0ZTogbnVsbCxcbiAgLy8gaXNUZW1wbGF0ZVRhZzogZmFsc2UsXG4gIG5vZGVzOiBbXSxcblxuICAvLyBnZXRLZXk6IG51bGwsXG4gIC8vIGluZGV4TmFtZTogbnVsbCxcbiAgLy8gaXRlbU5hbWU6IG51bGwsXG4gIC8vIGFmdGVyUGxhY2Vob2xkZXI6IG51bGwsXG4gIC8vIHBsYWNlaG9sZGVyOiBudWxsLFxuICAvLyBBUEkgbWV0aG9kc1xuICBtb3VudChzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGUoc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgfSxcblxuICB1cGRhdGUoc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICBub2RlcyxcbiAgICAgIGNoaWxkcmVuTWFwXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY29sbGVjdGlvbiA9IHNjb3BlID09PSBVTk1PVU5UX1NDT1BFID8gbnVsbCA6IHRoaXMuZXZhbHVhdGUoc2NvcGUpO1xuICAgIGNvbnN0IGl0ZW1zID0gY29sbGVjdGlvbiA/IEFycmF5LmZyb20oY29sbGVjdGlvbikgOiBbXTtcbiAgICBjb25zdCBwYXJlbnQgPSBwbGFjZWhvbGRlci5wYXJlbnROb2RlOyAvLyBwcmVwYXJlIHRoZSBkaWZmaW5nXG5cbiAgICBjb25zdCB7XG4gICAgICBuZXdDaGlsZHJlbk1hcCxcbiAgICAgIGJhdGNoZXMsXG4gICAgICBmdXR1cmVOb2Rlc1xuICAgIH0gPSBjcmVhdGVQYXRjaChpdGVtcywgc2NvcGUsIHBhcmVudFNjb3BlLCB0aGlzKTsgLy8gcGF0Y2ggdGhlIERPTSBvbmx5IGlmIHRoZXJlIGFyZSBuZXcgbm9kZXNcblxuICAgIHVkb21kaWZmKHBhcmVudCwgbm9kZXMsIGZ1dHVyZU5vZGVzLCBwYXRjaChBcnJheS5mcm9tKGNoaWxkcmVuTWFwLnZhbHVlcygpKSwgcGFyZW50U2NvcGUpLCBwbGFjZWhvbGRlcik7IC8vIHRyaWdnZXIgdGhlIG1vdW50cyBhbmQgdGhlIHVwZGF0ZXNcblxuICAgIGJhdGNoZXMuZm9yRWFjaChmbiA9PiBmbigpKTsgLy8gdXBkYXRlIHRoZSBjaGlsZHJlbiBtYXBcblxuICAgIHRoaXMuY2hpbGRyZW5NYXAgPSBuZXdDaGlsZHJlbk1hcDtcbiAgICB0aGlzLm5vZGVzID0gZnV0dXJlTm9kZXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdW5tb3VudChzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgICB0aGlzLnVwZGF0ZShVTk1PVU5UX1NDT1BFLCBwYXJlbnRTY29wZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufSk7XG4vKipcbiAqIFBhdGNoIHRoZSBET00gd2hpbGUgZGlmZmluZ1xuICogQHBhcmFtICAge1RlbXBsYXRlQ2h1bmtbXX0gcmVkdW5kYW50IC0gcmVkdW5kYW50IHRlcG1wbGF0ZSBjaHVua3NcbiAqIEBwYXJhbSAgIHsqfSBwYXJlbnRTY29wZSAtIHNjb3BlIG9mIHRoZSBwYXJlbnQgdGVtcGxhdGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gcGF0Y2ggZnVuY3Rpb24gdXNlZCBieSBkb21kaWZmXG4gKi9cblxuZnVuY3Rpb24gcGF0Y2gocmVkdW5kYW50LCBwYXJlbnRTY29wZSkge1xuICByZXR1cm4gKGl0ZW0sIGluZm8pID0+IHtcbiAgICBpZiAoaW5mbyA8IDApIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSByZWR1bmRhbnQucG9wKCk7XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0gPSBlbGVtZW50OyAvLyBub3RpY2UgdGhhdCB3ZSBwYXNzIG51bGwgYXMgbGFzdCBhcmd1bWVudCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSByb290IG5vZGUgYW5kIGl0cyBjaGlsZHJlbiB3aWxsIGJlIHJlbW92ZWQgYnkgZG9tZGlmZlxuXG4gICAgICAgIHRlbXBsYXRlLnVubW91bnQoY29udGV4dCwgcGFyZW50U2NvcGUsIG51bGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVtO1xuICB9O1xufVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgdGVtcGxhdGUgbXVzdCBiZSBmaWx0ZXJlZCBmcm9tIGEgbG9vcFxuICogQHBhcmFtICAge0Z1bmN0aW9ufSBjb25kaXRpb24gLSBmaWx0ZXIgZnVuY3Rpb25cbiAqIEBwYXJhbSAgIHtPYmplY3R9IGNvbnRleHQgLSBhcmd1bWVudCBwYXNzZWQgdG8gdGhlIGZpbHRlciBmdW5jdGlvblxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhpcyBpdGVtIHNob3VsZCBiZSBza2lwcGVkXG4gKi9cblxuXG5mdW5jdGlvbiBtdXN0RmlsdGVySXRlbShjb25kaXRpb24sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGNvbmRpdGlvbiA/IEJvb2xlYW4oY29uZGl0aW9uKGNvbnRleHQpKSA9PT0gZmFsc2UgOiBmYWxzZTtcbn1cbi8qKlxuICogRXh0ZW5kIHRoZSBzY29wZSBvZiB0aGUgbG9vcGVkIHRlbXBsYXRlXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBzY29wZSAtIGN1cnJlbnQgdGVtcGxhdGUgc2NvcGVcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG9wdGlvbnMuaXRlbU5hbWUgLSBrZXkgdG8gaWRlbnRpZnkgdGhlIGxvb3BlZCBpdGVtIGluIHRoZSBuZXcgY29udGV4dFxuICogQHBhcmFtICAge3N0cmluZ30gb3B0aW9ucy5pbmRleE5hbWUgLSBrZXkgdG8gaWRlbnRpZnkgdGhlIGluZGV4IG9mIHRoZSBsb29wZWQgaXRlbVxuICogQHBhcmFtICAge251bWJlcn0gb3B0aW9ucy5pbmRleCAtIGN1cnJlbnQgaW5kZXhcbiAqIEBwYXJhbSAgIHsqfSBvcHRpb25zLml0ZW0gLSBjb2xsZWN0aW9uIGl0ZW0gbG9vcGVkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBlbmhhbmNlZCBzY29wZSBvYmplY3RcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dGVuZFNjb3BlKHNjb3BlLCBfcmVmKSB7XG4gIGxldCB7XG4gICAgaXRlbU5hbWUsXG4gICAgaW5kZXhOYW1lLFxuICAgIGluZGV4LFxuICAgIGl0ZW1cbiAgfSA9IF9yZWY7XG4gIHNjb3BlW2l0ZW1OYW1lXSA9IGl0ZW07XG4gIGlmIChpbmRleE5hbWUpIHNjb3BlW2luZGV4TmFtZV0gPSBpbmRleDtcbiAgcmV0dXJuIHNjb3BlO1xufVxuLyoqXG4gKiBMb29wIHRoZSBjdXJyZW50IHRlbXBsYXRlIGl0ZW1zXG4gKiBAcGFyYW0gICB7QXJyYXl9IGl0ZW1zIC0gZXhwcmVzc2lvbiBjb2xsZWN0aW9uIHZhbHVlXG4gKiBAcGFyYW0gICB7Kn0gc2NvcGUgLSB0ZW1wbGF0ZSBzY29wZVxuICogQHBhcmFtICAgeyp9IHBhcmVudFNjb3BlIC0gc2NvcGUgb2YgdGhlIHBhcmVudCB0ZW1wbGF0ZVxuICogQHBhcmFtICAge0VlYWNoQmluZGluZ30gYmluZGluZyAtIGVhY2ggYmluZGluZyBvYmplY3QgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRhdGFcbiAqIEByZXR1cm5zIHtNYXB9IGRhdGEubmV3Q2hpbGRyZW5NYXAgLSBhIE1hcCBjb250YWluaW5nIHRoZSBuZXcgY2hpbGRyZW4gdGVtcGxhdGUgc3RydWN0dXJlXG4gKiBAcmV0dXJucyB7QXJyYXl9IGRhdGEuYmF0Y2hlcyAtIGFycmF5IGNvbnRhaW5pbmcgdGhlIHRlbXBsYXRlIGxpZmVjeWNsZSBmdW5jdGlvbnMgdG8gdHJpZ2dlclxuICogQHJldHVybnMge0FycmF5fSBkYXRhLmZ1dHVyZU5vZGVzIC0gYXJyYXkgY29udGFpbmluZyB0aGUgbm9kZXMgd2UgbmVlZCB0byBkaWZmXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaChpdGVtcywgc2NvcGUsIHBhcmVudFNjb3BlLCBiaW5kaW5nKSB7XG4gIGNvbnN0IHtcbiAgICBjb25kaXRpb24sXG4gICAgdGVtcGxhdGUsXG4gICAgY2hpbGRyZW5NYXAsXG4gICAgaXRlbU5hbWUsXG4gICAgZ2V0S2V5LFxuICAgIGluZGV4TmFtZSxcbiAgICByb290LFxuICAgIGlzVGVtcGxhdGVUYWdcbiAgfSA9IGJpbmRpbmc7XG4gIGNvbnN0IG5ld0NoaWxkcmVuTWFwID0gbmV3IE1hcCgpO1xuICBjb25zdCBiYXRjaGVzID0gW107XG4gIGNvbnN0IGZ1dHVyZU5vZGVzID0gW107XG4gIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IGV4dGVuZFNjb3BlKE9iamVjdC5jcmVhdGUoc2NvcGUpLCB7XG4gICAgICBpdGVtTmFtZSxcbiAgICAgIGluZGV4TmFtZSxcbiAgICAgIGluZGV4LFxuICAgICAgaXRlbVxuICAgIH0pO1xuICAgIGNvbnN0IGtleSA9IGdldEtleSA/IGdldEtleShjb250ZXh0KSA6IGluZGV4O1xuICAgIGNvbnN0IG9sZEl0ZW0gPSBjaGlsZHJlbk1hcC5nZXQoa2V5KTtcblxuICAgIGlmIChtdXN0RmlsdGVySXRlbShjb25kaXRpb24sIGNvbnRleHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29tcG9uZW50VGVtcGxhdGUgPSBvbGRJdGVtID8gb2xkSXRlbS50ZW1wbGF0ZSA6IHRlbXBsYXRlLmNsb25lKCk7XG4gICAgY29uc3QgZWwgPSBvbGRJdGVtID8gY29tcG9uZW50VGVtcGxhdGUuZWwgOiByb290LmNsb25lTm9kZSgpO1xuICAgIGNvbnN0IG11c3RNb3VudCA9ICFvbGRJdGVtO1xuICAgIGNvbnN0IG1ldGEgPSBpc1RlbXBsYXRlVGFnICYmIG11c3RNb3VudCA/IGNyZWF0ZVRlbXBsYXRlTWV0YShjb21wb25lbnRUZW1wbGF0ZSkgOiB7fTtcblxuICAgIGlmIChtdXN0TW91bnQpIHtcbiAgICAgIGJhdGNoZXMucHVzaCgoKSA9PiBjb21wb25lbnRUZW1wbGF0ZS5tb3VudChlbCwgY29udGV4dCwgcGFyZW50U2NvcGUsIG1ldGEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmF0Y2hlcy5wdXNoKCgpID0+IGNvbXBvbmVudFRlbXBsYXRlLnVwZGF0ZShjb250ZXh0LCBwYXJlbnRTY29wZSkpO1xuICAgIH0gLy8gY3JlYXRlIHRoZSBjb2xsZWN0aW9uIG9mIG5vZGVzIHRvIHVwZGF0ZSBvciB0byBhZGRcbiAgICAvLyBpbiBjYXNlIG9mIHRlbXBsYXRlIHRhZ3Mgd2UgbmVlZCB0byBhZGQgYWxsIGl0cyBjaGlsZHJlbiBub2Rlc1xuXG5cbiAgICBpZiAoaXNUZW1wbGF0ZVRhZykge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBtZXRhLmNoaWxkcmVuIHx8IGNvbXBvbmVudFRlbXBsYXRlLmNoaWxkcmVuO1xuICAgICAgZnV0dXJlTm9kZXMucHVzaCguLi5jaGlsZHJlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1dHVyZU5vZGVzLnB1c2goZWwpO1xuICAgIH0gLy8gZGVsZXRlIHRoZSBvbGQgaXRlbSBmcm9tIHRoZSBjaGlsZHJlbiBtYXBcblxuXG4gICAgY2hpbGRyZW5NYXAuZGVsZXRlKGtleSk7IC8vIHVwZGF0ZSB0aGUgY2hpbGRyZW4gbWFwXG5cbiAgICBuZXdDaGlsZHJlbk1hcC5zZXQoa2V5LCB7XG4gICAgICB0ZW1wbGF0ZTogY29tcG9uZW50VGVtcGxhdGUsXG4gICAgICBjb250ZXh0LFxuICAgICAgaW5kZXhcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgbmV3Q2hpbGRyZW5NYXAsXG4gICAgYmF0Y2hlcyxcbiAgICBmdXR1cmVOb2Rlc1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGUobm9kZSwgX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBldmFsdWF0ZSxcbiAgICBjb25kaXRpb24sXG4gICAgaXRlbU5hbWUsXG4gICAgaW5kZXhOYW1lLFxuICAgIGdldEtleSxcbiAgICB0ZW1wbGF0ZVxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBjb25zdCByb290ID0gbm9kZS5jbG9uZU5vZGUoKTtcbiAgaW5zZXJ0QmVmb3JlKHBsYWNlaG9sZGVyLCBub2RlKTtcbiAgcmVtb3ZlQ2hpbGQobm9kZSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBFYWNoQmluZGluZywge1xuICAgIGNoaWxkcmVuTWFwOiBuZXcgTWFwKCksXG4gICAgbm9kZSxcbiAgICByb290LFxuICAgIGNvbmRpdGlvbixcbiAgICBldmFsdWF0ZSxcbiAgICBpc1RlbXBsYXRlVGFnOiBpc1RlbXBsYXRlKHJvb3QpLFxuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZS5jcmVhdGVET00obm9kZSksXG4gICAgZ2V0S2V5LFxuICAgIGluZGV4TmFtZSxcbiAgICBpdGVtTmFtZSxcbiAgICBwbGFjZWhvbGRlclxuICB9KTtcbn1cblxuLyoqXG4gKiBCaW5kaW5nIHJlc3BvbnNpYmxlIGZvciB0aGUgYGlmYCBkaXJlY3RpdmVcbiAqL1xuXG5jb25zdCBJZkJpbmRpbmcgPSBPYmplY3Quc2VhbCh7XG4gIC8vIGR5bmFtaWMgYmluZGluZyBwcm9wZXJ0aWVzXG4gIC8vIG5vZGU6IG51bGwsXG4gIC8vIGV2YWx1YXRlOiBudWxsLFxuICAvLyBpc1RlbXBsYXRlVGFnOiBmYWxzZSxcbiAgLy8gcGxhY2Vob2xkZXI6IG51bGwsXG4gIC8vIHRlbXBsYXRlOiBudWxsLFxuICAvLyBBUEkgbWV0aG9kc1xuICBtb3VudChzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGUoc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgfSxcblxuICB1cGRhdGUoc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gICAgY29uc3QgdmFsdWUgPSAhIXRoaXMuZXZhbHVhdGUoc2NvcGUpO1xuICAgIGNvbnN0IG11c3RNb3VudCA9ICF0aGlzLnZhbHVlICYmIHZhbHVlO1xuICAgIGNvbnN0IG11c3RVbm1vdW50ID0gdGhpcy52YWx1ZSAmJiAhdmFsdWU7XG5cbiAgICBjb25zdCBtb3VudCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHByaXN0aW5lID0gdGhpcy5ub2RlLmNsb25lTm9kZSgpO1xuICAgICAgaW5zZXJ0QmVmb3JlKHByaXN0aW5lLCB0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICAgIHRoaXMudGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlLmNsb25lKCk7XG4gICAgICB0aGlzLnRlbXBsYXRlLm1vdW50KHByaXN0aW5lLCBzY29wZSwgcGFyZW50U2NvcGUpO1xuICAgIH07XG5cbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIGNhc2UgbXVzdE1vdW50OlxuICAgICAgICBtb3VudCgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBtdXN0VW5tb3VudDpcbiAgICAgICAgdGhpcy51bm1vdW50KHNjb3BlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh2YWx1ZSkgdGhpcy50ZW1wbGF0ZS51cGRhdGUoc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdW5tb3VudChzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgICB0aGlzLnRlbXBsYXRlLnVubW91bnQoc2NvcGUsIHBhcmVudFNjb3BlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59KTtcbmZ1bmN0aW9uIGNyZWF0ZSQxKG5vZGUsIF9yZWYpIHtcbiAgbGV0IHtcbiAgICBldmFsdWF0ZSxcbiAgICB0ZW1wbGF0ZVxuICB9ID0gX3JlZjtcbiAgY29uc3QgcGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIGluc2VydEJlZm9yZShwbGFjZWhvbGRlciwgbm9kZSk7XG4gIHJlbW92ZUNoaWxkKG5vZGUpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgSWZCaW5kaW5nLCB7XG4gICAgbm9kZSxcbiAgICBldmFsdWF0ZSxcbiAgICBwbGFjZWhvbGRlcixcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGUuY3JlYXRlRE9NKG5vZGUpXG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93IGFuIGVycm9yIHdpdGggYSBkZXNjcmlwdGl2ZSBtZXNzYWdlXG4gKiBAcGFyYW0gICB7IHN0cmluZyB9IG1lc3NhZ2UgLSBlcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJucyB7IHVuZGVmaW5lZCB9IGhvcHBsYS4uIGF0IHRoaXMgcG9pbnQgdGhlIHByb2dyYW0gc2hvdWxkIHN0b3Agd29ya2luZ1xuICovXG5cbmZ1bmN0aW9uIHBhbmljKG1lc3NhZ2UpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtZW1vaXplZCAoY2FjaGVkKSBmdW5jdGlvbi5cbiAqIC8vIGJvcnJvd2VkIGZyb20gaHR0cHM6Ly93d3cuMzBzZWNvbmRzb2Zjb2RlLm9yZy9qcy9zL21lbW9pemVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gZnVuY3Rpb24gdG8gbWVtb2l6ZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBtZW1vaXplIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcblxuICBjb25zdCBjYWNoZWQgPSB2YWwgPT4ge1xuICAgIHJldHVybiBjYWNoZS5oYXModmFsKSA/IGNhY2hlLmdldCh2YWwpIDogY2FjaGUuc2V0KHZhbCwgZm4uY2FsbCh0aGlzLCB2YWwpKSAmJiBjYWNoZS5nZXQodmFsKTtcbiAgfTtcblxuICBjYWNoZWQuY2FjaGUgPSBjYWNoZTtcbiAgcmV0dXJuIGNhY2hlZDtcbn1cbi8qKlxuICogRXZhbHVhdGUgYSBsaXN0IG9mIGF0dHJpYnV0ZSBleHByZXNzaW9uc1xuICogQHBhcmFtICAge0FycmF5fSBhdHRyaWJ1dGVzIC0gYXR0cmlidXRlIGV4cHJlc3Npb25zIGdlbmVyYXRlZCBieSB0aGUgcmlvdCBjb21waWxlclxuICogQHJldHVybnMge09iamVjdH0ga2V5IHZhbHVlIHBhaXJzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgY29tcHV0YXRpb25cbiAqL1xuXG5mdW5jdGlvbiBldmFsdWF0ZUF0dHJpYnV0ZUV4cHJlc3Npb25zKGF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuIGF0dHJpYnV0ZXMucmVkdWNlKChhY2MsIGF0dHJpYnV0ZSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgdHlwZVxuICAgIH0gPSBhdHRyaWJ1dGU7XG5cbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIC8vIHNwcmVhZCBhdHRyaWJ1dGVcbiAgICAgIGNhc2UgIWF0dHJpYnV0ZS5uYW1lICYmIHR5cGUgPT09IEFUVFJJQlVURTpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGFjYywgdmFsdWUpO1xuICAgICAgLy8gdmFsdWUgYXR0cmlidXRlXG5cbiAgICAgIGNhc2UgdHlwZSA9PT0gVkFMVUU6XG4gICAgICAgIGFjYy52YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBub3JtYWwgYXR0cmlidXRlc1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhY2NbZGFzaFRvQ2FtZWxDYXNlKGF0dHJpYnV0ZS5uYW1lKV0gPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG5jb25zdCBSRU1PVkVfQVRUUklCVVRFID0gJ3JlbW92ZUF0dHJpYnV0ZSc7XG5jb25zdCBTRVRfQVRUSUJVVEUgPSAnc2V0QXR0cmlidXRlJztcbmNvbnN0IEVsZW1lbnRQcm90byA9IHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyA/IHt9IDogRWxlbWVudC5wcm90b3R5cGU7XG5jb25zdCBpc05hdGl2ZUh0bWxQcm9wZXJ0eSA9IG1lbW9pemUobmFtZSA9PiBFbGVtZW50UHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSkpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKlxuICogQWRkIGFsbCB0aGUgYXR0cmlidXRlcyBwcm92aWRlZFxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBub2RlIC0gdGFyZ2V0IG5vZGVcbiAqIEBwYXJhbSAgIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBvYmplY3QgY29udGFpbmluZyB0aGUgYXR0cmlidXRlcyBuYW1lcyBhbmQgdmFsdWVzXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfSBzb3JyeSBpdCdzIGEgdm9pZCBmdW5jdGlvbiA6KFxuICovXG5cbmZ1bmN0aW9uIHNldEFsbEF0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuICBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChfcmVmKSA9PiB7XG4gICAgbGV0IFtuYW1lLCB2YWx1ZV0gPSBfcmVmO1xuICAgIHJldHVybiBhdHRyaWJ1dGVFeHByZXNzaW9uKG5vZGUsIHtcbiAgICAgIG5hbWVcbiAgICB9LCB2YWx1ZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBSZW1vdmUgYWxsIHRoZSBhdHRyaWJ1dGVzIHByb3ZpZGVkXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IG5vZGUgLSB0YXJnZXQgbm9kZVxuICogQHBhcmFtICAge09iamVjdH0gbmV3QXR0cmlidXRlcyAtIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmV3IGF0dHJpYnV0ZSBuYW1lc1xuICogQHBhcmFtICAge09iamVjdH0gb2xkQXR0cmlidXRlcyAtIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgb2xkIGF0dHJpYnV0ZSBuYW1lc1xuICogQHJldHVybnMge3VuZGVmaW5lZH0gc29ycnkgaXQncyBhIHZvaWQgZnVuY3Rpb24gOihcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbW92ZUFsbEF0dHJpYnV0ZXMobm9kZSwgbmV3QXR0cmlidXRlcywgb2xkQXR0cmlidXRlcykge1xuICBjb25zdCBuZXdLZXlzID0gbmV3QXR0cmlidXRlcyA/IE9iamVjdC5rZXlzKG5ld0F0dHJpYnV0ZXMpIDogW107XG4gIE9iamVjdC5rZXlzKG9sZEF0dHJpYnV0ZXMpLmZpbHRlcihuYW1lID0+ICFuZXdLZXlzLmluY2x1ZGVzKG5hbWUpKS5mb3JFYWNoKGF0dHJpYnV0ZSA9PiBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpKTtcbn1cbi8qKlxuICogVGhpcyBtZXRob2RzIGhhbmRsZXMgdGhlIERPTSBhdHRyaWJ1dGVzIHVwZGF0ZXNcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gbm9kZSAtIHRhcmdldCBub2RlXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBleHByZXNzaW9uIC0gZXhwcmVzc2lvbiBvYmplY3RcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IGV4cHJlc3Npb24ubmFtZSAtIGF0dHJpYnV0ZSBuYW1lXG4gKiBAcGFyYW0gICB7Kn0gdmFsdWUgLSBuZXcgZXhwcmVzc2lvbiB2YWx1ZVxuICogQHBhcmFtICAgeyp9IG9sZFZhbHVlIC0gdGhlIG9sZCBleHByZXNzaW9uIGNhY2hlZCB2YWx1ZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGF0dHJpYnV0ZUV4cHJlc3Npb24obm9kZSwgX3JlZjIsIHZhbHVlLCBvbGRWYWx1ZSkge1xuICBsZXQge1xuICAgIG5hbWVcbiAgfSA9IF9yZWYyO1xuXG4gIC8vIGlzIGl0IGEgc3ByZWFkIG9wZXJhdG9yPyB7Li4uYXR0cmlidXRlc31cbiAgaWYgKCFuYW1lKSB7XG4gICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAvLyByZW1vdmUgYWxsIHRoZSBvbGQgYXR0cmlidXRlc1xuICAgICAgcmVtb3ZlQWxsQXR0cmlidXRlcyhub2RlLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgIH0gLy8gaXMgdGhlIHZhbHVlIHN0aWxsIHRydXRoeT9cblxuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBzZXRBbGxBdHRyaWJ1dGVzKG5vZGUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0gLy8gaGFuZGxlIGJvb2xlYW4gYXR0cmlidXRlc1xuXG5cbiAgaWYgKCFpc05hdGl2ZUh0bWxQcm9wZXJ0eShuYW1lKSAmJiAoaXNCb29sZWFuKHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkgfHwgaXNGdW5jdGlvbih2YWx1ZSkpKSB7XG4gICAgbm9kZVtuYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgbm9kZVtnZXRNZXRob2QodmFsdWUpXShuYW1lLCBub3JtYWxpemVWYWx1ZShuYW1lLCB2YWx1ZSkpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGF0dHJpYnV0ZSBtb2RpZmllciBtZXRob2RcbiAqIEBwYXJhbSAgIHsqfSB2YWx1ZSAtIGlmIHRydXRoeSB3ZSByZXR1cm4gYHNldEF0dHJpYnV0ZWAgb3RoZXdpc2UgYHJlbW92ZUF0dHJpYnV0ZWBcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBub2RlIGF0dHJpYnV0ZSBtb2RpZmllciBtZXRob2QgbmFtZVxuICovXG5cbmZ1bmN0aW9uIGdldE1ldGhvZCh2YWx1ZSkge1xuICByZXR1cm4gaXNOaWwodmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gJycgfHwgaXNPYmplY3QodmFsdWUpIHx8IGlzRnVuY3Rpb24odmFsdWUpID8gUkVNT1ZFX0FUVFJJQlVURSA6IFNFVF9BVFRJQlVURTtcbn1cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBhcyBzdHJpbmdcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWUgLSBhdHRyaWJ1dGUgbmFtZVxuICogQHBhcmFtICAgeyp9IHZhbHVlIC0gdXNlciBpbnB1dCB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ30gaW5wdXQgdmFsdWUgYXMgc3RyaW5nXG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZShuYW1lLCB2YWx1ZSkge1xuICAvLyBiZSBzdXJlIHRoYXQgZXhwcmVzc2lvbnMgbGlrZSBzZWxlY3RlZD17IHRydWUgfSB3aWxsIGJlIGFsd2F5cyByZW5kZXJlZCBhcyBzZWxlY3RlZD0nc2VsZWN0ZWQnXG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSkgcmV0dXJuIG5hbWU7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuY29uc3QgUkVfRVZFTlRTX1BSRUZJWCA9IC9eb24vO1xuXG5jb25zdCBnZXRDYWxsYmFja0FuZE9wdGlvbnMgPSB2YWx1ZSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlLCBmYWxzZV07IC8vIHNlZSBhbHNvIGh0dHBzOi8vbWVkaXVtLmNvbS9AV2ViUmVmbGVjdGlvbi9kb20taGFuZGxlZXZlbnQtYS1jcm9zcy1wbGF0Zm9ybS1zdGFuZGFyZC1zaW5jZS15ZWFyLTIwMDAtNWJmMTcyODdmZDM4XG5cblxuY29uc3QgRXZlbnRMaXN0ZW5lciA9IHtcbiAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzW2V2ZW50LnR5cGVdKGV2ZW50KTtcbiAgfVxuXG59O1xuY29uc3QgTGlzdGVuZXJzV2Vha01hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbmNvbnN0IGNyZWF0ZUxpc3RlbmVyID0gbm9kZSA9PiB7XG4gIGNvbnN0IGxpc3RlbmVyID0gT2JqZWN0LmNyZWF0ZShFdmVudExpc3RlbmVyKTtcbiAgTGlzdGVuZXJzV2Vha01hcC5zZXQobm9kZSwgbGlzdGVuZXIpO1xuICByZXR1cm4gbGlzdGVuZXI7XG59O1xuLyoqXG4gKiBTZXQgYSBuZXcgZXZlbnQgbGlzdGVuZXJcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gbm9kZSAtIHRhcmdldCBub2RlXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBleHByZXNzaW9uIC0gZXhwcmVzc2lvbiBvYmplY3RcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IGV4cHJlc3Npb24ubmFtZSAtIGV2ZW50IG5hbWVcbiAqIEBwYXJhbSAgIHsqfSB2YWx1ZSAtIG5ldyBleHByZXNzaW9uIHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWV9IHRoZSBjYWxsYmFjayBqdXN0IHJlY2VpdmVkXG4gKi9cblxuXG5mdW5jdGlvbiBldmVudEV4cHJlc3Npb24obm9kZSwgX3JlZiwgdmFsdWUpIHtcbiAgbGV0IHtcbiAgICBuYW1lXG4gIH0gPSBfcmVmO1xuICBjb25zdCBub3JtYWxpemVkRXZlbnROYW1lID0gbmFtZS5yZXBsYWNlKFJFX0VWRU5UU19QUkVGSVgsICcnKTtcbiAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IExpc3RlbmVyc1dlYWtNYXAuZ2V0KG5vZGUpIHx8IGNyZWF0ZUxpc3RlbmVyKG5vZGUpO1xuICBjb25zdCBbY2FsbGJhY2ssIG9wdGlvbnNdID0gZ2V0Q2FsbGJhY2tBbmRPcHRpb25zKHZhbHVlKTtcbiAgY29uc3QgaGFuZGxlciA9IGV2ZW50TGlzdGVuZXJbbm9ybWFsaXplZEV2ZW50TmFtZV07XG4gIGNvbnN0IG11c3RSZW1vdmVFdmVudCA9IGhhbmRsZXIgJiYgIWNhbGxiYWNrO1xuICBjb25zdCBtdXN0QWRkRXZlbnQgPSBjYWxsYmFjayAmJiAhaGFuZGxlcjtcblxuICBpZiAobXVzdFJlbW92ZUV2ZW50KSB7XG4gICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKG5vcm1hbGl6ZWRFdmVudE5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICB9XG5cbiAgaWYgKG11c3RBZGRFdmVudCkge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihub3JtYWxpemVkRXZlbnROYW1lLCBldmVudExpc3RlbmVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIGV2ZW50TGlzdGVuZXJbbm9ybWFsaXplZEV2ZW50TmFtZV0gPSBjYWxsYmFjaztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIHVzZXIgdmFsdWUgaW4gb3JkZXIgdG8gcmVuZGVyIGEgZW1wdHkgc3RyaW5nIGluIGNhc2Ugb2YgZmFsc3kgdmFsdWVzXG4gKiBAcGFyYW0gICB7Kn0gdmFsdWUgLSB1c2VyIGlucHV0IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBob3BlZnVsbHkgYSBzdHJpbmdcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gaXNOaWwodmFsdWUpID8gJycgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRoZSB0YXJnZXQgdGV4dCBub2RlIHRvIHVwZGF0ZSBvciBjcmVhdGUgb25lIGZyb20gb2YgYSBjb21tZW50IG5vZGVcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gbm9kZSAtIGFueSBodG1sIGVsZW1lbnQgY29udGFpbmluZyBjaGlsZE5vZGVzXG4gKiBAcGFyYW0gICB7bnVtYmVyfSBjaGlsZE5vZGVJbmRleCAtIGluZGV4IG9mIHRoZSB0ZXh0IG5vZGUgaW4gdGhlIGNoaWxkTm9kZXMgbGlzdFxuICogQHJldHVybnMge0hUTUxUZXh0Tm9kZX0gdGhlIHRleHQgbm9kZSB0byB1cGRhdGVcbiAqL1xuXG5jb25zdCBnZXRUZXh0Tm9kZSA9IChub2RlLCBjaGlsZE5vZGVJbmRleCkgPT4ge1xuICBjb25zdCB0YXJnZXQgPSBub2RlLmNoaWxkTm9kZXNbY2hpbGROb2RlSW5kZXhdO1xuXG4gIGlmICh0YXJnZXQubm9kZVR5cGUgPT09IE5vZGUuQ09NTUVOVF9OT0RFKSB7XG4gICAgY29uc3QgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbm9kZS5yZXBsYWNlQ2hpbGQodGV4dE5vZGUsIHRhcmdldCk7XG4gICAgcmV0dXJuIHRleHROb2RlO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG4vKipcbiAqIFRoaXMgbWV0aG9kcyBoYW5kbGVzIGEgc2ltcGxlIHRleHQgZXhwcmVzc2lvbiB1cGRhdGVcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gbm9kZSAtIHRhcmdldCBub2RlXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBkYXRhIC0gZXhwcmVzc2lvbiBvYmplY3RcbiAqIEBwYXJhbSAgIHsqfSB2YWx1ZSAtIG5ldyBleHByZXNzaW9uIHZhbHVlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHRleHRFeHByZXNzaW9uKG5vZGUsIGRhdGEsIHZhbHVlKSB7XG4gIG5vZGUuZGF0YSA9IG5vcm1hbGl6ZVN0cmluZ1ZhbHVlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZHMgaGFuZGxlcyB0aGUgaW5wdXQgZmlsZWRzIHZhbHVlIHVwZGF0ZXNcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gbm9kZSAtIHRhcmdldCBub2RlXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBleHByZXNzaW9uIC0gZXhwcmVzc2lvbiBvYmplY3RcbiAqIEBwYXJhbSAgIHsqfSB2YWx1ZSAtIG5ldyBleHByZXNzaW9uIHZhbHVlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHZhbHVlRXhwcmVzc2lvbihub2RlLCBleHByZXNzaW9uLCB2YWx1ZSkge1xuICBub2RlLnZhbHVlID0gbm9ybWFsaXplU3RyaW5nVmFsdWUodmFsdWUpO1xufVxuXG52YXIgZXhwcmVzc2lvbnMgPSB7XG4gIFtBVFRSSUJVVEVdOiBhdHRyaWJ1dGVFeHByZXNzaW9uLFxuICBbRVZFTlRdOiBldmVudEV4cHJlc3Npb24sXG4gIFtURVhUXTogdGV4dEV4cHJlc3Npb24sXG4gIFtWQUxVRV06IHZhbHVlRXhwcmVzc2lvblxufTtcblxuY29uc3QgRXhwcmVzc2lvbiA9IE9iamVjdC5zZWFsKHtcbiAgLy8gU3RhdGljIHByb3BzXG4gIC8vIG5vZGU6IG51bGwsXG4gIC8vIHZhbHVlOiBudWxsLFxuICAvLyBBUEkgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBNb3VudCB0aGUgZXhwcmVzc2lvbiBldmFsdWF0aW5nIGl0cyBpbml0aWFsIHZhbHVlXG4gICAqIEBwYXJhbSAgIHsqfSBzY29wZSAtIGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgZXhwcmVzc2lvbiB0byBldmFsdWF0ZSBpdHMgY3VycmVudCB2YWx1ZXNcbiAgICogQHJldHVybnMge0V4cHJlc3Npb259IHNlbGZcbiAgICovXG4gIG1vdW50KHNjb3BlKSB7XG4gICAgLy8gaG9wZWZ1bGx5IGEgcHVyZSBmdW5jdGlvblxuICAgIHRoaXMudmFsdWUgPSB0aGlzLmV2YWx1YXRlKHNjb3BlKTsgLy8gSU8oKSBET00gdXBkYXRlc1xuXG4gICAgYXBwbHkodGhpcywgdGhpcy52YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZXhwcmVzc2lvbiBpZiBpdHMgdmFsdWUgY2hhbmdlZFxuICAgKiBAcGFyYW0gICB7Kn0gc2NvcGUgLSBhcmd1bWVudCBwYXNzZWQgdG8gdGhlIGV4cHJlc3Npb24gdG8gZXZhbHVhdGUgaXRzIGN1cnJlbnQgdmFsdWVzXG4gICAqIEByZXR1cm5zIHtFeHByZXNzaW9ufSBzZWxmXG4gICAqL1xuICB1cGRhdGUoc2NvcGUpIHtcbiAgICAvLyBwdXJlIGZ1bmN0aW9uXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmV2YWx1YXRlKHNjb3BlKTtcblxuICAgIGlmICh0aGlzLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgLy8gSU8oKSBET00gdXBkYXRlc1xuICAgICAgYXBwbHkodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHByZXNzaW9uIHRlYXJkb3duIG1ldGhvZFxuICAgKiBAcmV0dXJucyB7RXhwcmVzc2lvbn0gc2VsZlxuICAgKi9cbiAgdW5tb3VudCgpIHtcbiAgICAvLyB1bm1vdW50IG9ubHkgdGhlIGV2ZW50IGhhbmRsaW5nIGV4cHJlc3Npb25zXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gRVZFTlQpIGFwcGx5KHRoaXMsIG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn0pO1xuLyoqXG4gKiBJTygpIGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgRE9NIHVwZGF0ZXNcbiAqIEBwYXJhbSB7RXhwcmVzc2lvbn0gZXhwcmVzc2lvbiAtIGV4cHJlc3Npb24gb2JqZWN0XG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gY3VycmVudCBleHByZXNzaW9uIHZhbHVlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGFwcGx5KGV4cHJlc3Npb24sIHZhbHVlKSB7XG4gIHJldHVybiBleHByZXNzaW9uc1tleHByZXNzaW9uLnR5cGVdKGV4cHJlc3Npb24ubm9kZSwgZXhwcmVzc2lvbiwgdmFsdWUsIGV4cHJlc3Npb24udmFsdWUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUkMihub2RlLCBkYXRhKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBFeHByZXNzaW9uLCBkYXRhLCB7XG4gICAgbm9kZTogZGF0YS50eXBlID09PSBURVhUID8gZ2V0VGV4dE5vZGUobm9kZSwgZGF0YS5jaGlsZE5vZGVJbmRleCkgOiBub2RlXG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGZsYXQgb2JqZWN0IGhhdmluZyBhcyBrZXlzIGEgbGlzdCBvZiBtZXRob2RzIHRoYXQgaWYgZGlzcGF0Y2hlZCB3aWxsIHByb3BhZ2F0ZVxuICogb24gdGhlIHdob2xlIGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAgIHtBcnJheX0gY29sbGVjdGlvbiAtIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZVxuICogQHBhcmFtICAge0FycmF5PHN0cmluZz59IG1ldGhvZHMgLSBtZXRob2RzIHRvIGV4ZWN1dGUgb24gZWFjaCBpdGVtIG9mIHRoZSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gICB7Kn0gY29udGV4dCAtIGNvbnRleHQgcmV0dXJuZWQgYnkgdGhlIG5ldyBtZXRob2RzIGNyZWF0ZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IGEgbmV3IG9iamVjdCB0byBzaW1wbGlmeSB0aGUgdGhlIG5lc3RlZCBtZXRob2RzIGRpc3BhdGNoaW5nXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5Db2xsZWN0aW9uTWV0aG9kcyhjb2xsZWN0aW9uLCBtZXRob2RzLCBjb250ZXh0KSB7XG4gIHJldHVybiBtZXRob2RzLnJlZHVjZSgoYWNjLCBtZXRob2QpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYWNjLCB7XG4gICAgICBbbWV0aG9kXTogc2NvcGUgPT4ge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5tYXAoaXRlbSA9PiBpdGVtW21ldGhvZF0oc2NvcGUpKSAmJiBjb250ZXh0O1xuICAgICAgfVxuICAgIH0pO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZSQzKG5vZGUsIF9yZWYpIHtcbiAgbGV0IHtcbiAgICBleHByZXNzaW9uc1xuICB9ID0gX3JlZjtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGZsYXR0ZW5Db2xsZWN0aW9uTWV0aG9kcyhleHByZXNzaW9ucy5tYXAoZXhwcmVzc2lvbiA9PiBjcmVhdGUkMihub2RlLCBleHByZXNzaW9uKSksIFsnbW91bnQnLCAndXBkYXRlJywgJ3VubW91bnQnXSkpO1xufVxuXG4vLyBSaW90LmpzIGNvbnN0YW50cyB0aGF0IGNhbiBiZSB1c2VkIGFjY3Jvc3MgbW9yZSBtb2R1bGVzXG5jb25zdCBDT01QT05FTlRTX0lNUExFTUVOVEFUSU9OX01BUCA9IG5ldyBNYXAoKSxcbiAgICAgIERPTV9DT01QT05FTlRfSU5TVEFOQ0VfUFJPUEVSVFkgPSBTeW1ib2woJ3Jpb3QtY29tcG9uZW50JyksXG4gICAgICBQTFVHSU5TX1NFVCA9IG5ldyBTZXQoKSxcbiAgICAgIElTX0RJUkVDVElWRSA9ICdpcycsXG4gICAgICBWQUxVRV9BVFRSSUJVVEUgPSAndmFsdWUnLFxuICAgICAgTU9VTlRfTUVUSE9EX0tFWSA9ICdtb3VudCcsXG4gICAgICBVUERBVEVfTUVUSE9EX0tFWSA9ICd1cGRhdGUnLFxuICAgICAgVU5NT1VOVF9NRVRIT0RfS0VZID0gJ3VubW91bnQnLFxuICAgICAgU0hPVUxEX1VQREFURV9LRVkgPSAnc2hvdWxkVXBkYXRlJyxcbiAgICAgIE9OX0JFRk9SRV9NT1VOVF9LRVkgPSAnb25CZWZvcmVNb3VudCcsXG4gICAgICBPTl9NT1VOVEVEX0tFWSA9ICdvbk1vdW50ZWQnLFxuICAgICAgT05fQkVGT1JFX1VQREFURV9LRVkgPSAnb25CZWZvcmVVcGRhdGUnLFxuICAgICAgT05fVVBEQVRFRF9LRVkgPSAnb25VcGRhdGVkJyxcbiAgICAgIE9OX0JFRk9SRV9VTk1PVU5UX0tFWSA9ICdvbkJlZm9yZVVubW91bnQnLFxuICAgICAgT05fVU5NT1VOVEVEX0tFWSA9ICdvblVubW91bnRlZCcsXG4gICAgICBQUk9QU19LRVkgPSAncHJvcHMnLFxuICAgICAgU1RBVEVfS0VZID0gJ3N0YXRlJyxcbiAgICAgIFNMT1RTX0tFWSA9ICdzbG90cycsXG4gICAgICBST09UX0tFWSA9ICdyb290JyxcbiAgICAgIElTX1BVUkVfU1lNQk9MID0gU3ltYm9sLmZvcigncHVyZScpLFxuICAgICAgUEFSRU5UX0tFWV9TWU1CT0wgPSBTeW1ib2woJ3BhcmVudCcpLFxuICAgICAgQVRUUklCVVRFU19LRVlfU1lNQk9MID0gU3ltYm9sKCdhdHRyaWJ1dGVzJyksXG4gICAgICBURU1QTEFURV9LRVlfU1lNQk9MID0gU3ltYm9sKCd0ZW1wbGF0ZScpO1xuXG52YXIgZ2xvYmFscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBDT01QT05FTlRTX0lNUExFTUVOVEFUSU9OX01BUDogQ09NUE9ORU5UU19JTVBMRU1FTlRBVElPTl9NQVAsXG4gIERPTV9DT01QT05FTlRfSU5TVEFOQ0VfUFJPUEVSVFk6IERPTV9DT01QT05FTlRfSU5TVEFOQ0VfUFJPUEVSVFksXG4gIFBMVUdJTlNfU0VUOiBQTFVHSU5TX1NFVCxcbiAgSVNfRElSRUNUSVZFOiBJU19ESVJFQ1RJVkUsXG4gIFZBTFVFX0FUVFJJQlVURTogVkFMVUVfQVRUUklCVVRFLFxuICBNT1VOVF9NRVRIT0RfS0VZOiBNT1VOVF9NRVRIT0RfS0VZLFxuICBVUERBVEVfTUVUSE9EX0tFWTogVVBEQVRFX01FVEhPRF9LRVksXG4gIFVOTU9VTlRfTUVUSE9EX0tFWTogVU5NT1VOVF9NRVRIT0RfS0VZLFxuICBTSE9VTERfVVBEQVRFX0tFWTogU0hPVUxEX1VQREFURV9LRVksXG4gIE9OX0JFRk9SRV9NT1VOVF9LRVk6IE9OX0JFRk9SRV9NT1VOVF9LRVksXG4gIE9OX01PVU5URURfS0VZOiBPTl9NT1VOVEVEX0tFWSxcbiAgT05fQkVGT1JFX1VQREFURV9LRVk6IE9OX0JFRk9SRV9VUERBVEVfS0VZLFxuICBPTl9VUERBVEVEX0tFWTogT05fVVBEQVRFRF9LRVksXG4gIE9OX0JFRk9SRV9VTk1PVU5UX0tFWTogT05fQkVGT1JFX1VOTU9VTlRfS0VZLFxuICBPTl9VTk1PVU5URURfS0VZOiBPTl9VTk1PVU5URURfS0VZLFxuICBQUk9QU19LRVk6IFBST1BTX0tFWSxcbiAgU1RBVEVfS0VZOiBTVEFURV9LRVksXG4gIFNMT1RTX0tFWTogU0xPVFNfS0VZLFxuICBST09UX0tFWTogUk9PVF9LRVksXG4gIElTX1BVUkVfU1lNQk9MOiBJU19QVVJFX1NZTUJPTCxcbiAgUEFSRU5UX0tFWV9TWU1CT0w6IFBBUkVOVF9LRVlfU1lNQk9MLFxuICBBVFRSSUJVVEVTX0tFWV9TWU1CT0w6IEFUVFJJQlVURVNfS0VZX1NZTUJPTCxcbiAgVEVNUExBVEVfS0VZX1NZTUJPTDogVEVNUExBVEVfS0VZX1NZTUJPTFxufSk7XG5cbmZ1bmN0aW9uIGV4dGVuZFBhcmVudFNjb3BlKGF0dHJpYnV0ZXMsIHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICBpZiAoIWF0dHJpYnV0ZXMgfHwgIWF0dHJpYnV0ZXMubGVuZ3RoKSByZXR1cm4gcGFyZW50U2NvcGU7XG4gIGNvbnN0IGV4cHJlc3Npb25zID0gYXR0cmlidXRlcy5tYXAoYXR0ciA9PiBPYmplY3QuYXNzaWduKHt9LCBhdHRyLCB7XG4gICAgdmFsdWU6IGF0dHIuZXZhbHVhdGUoc2NvcGUpXG4gIH0pKTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZSB8fCBudWxsKSwgZXZhbHVhdGVBdHRyaWJ1dGVFeHByZXNzaW9ucyhleHByZXNzaW9ucykpO1xufSAvLyB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgbWVhbnQgdG8gZml4IGFuIGVkZ2UgY2FzZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3Jpb3QvcmlvdC9pc3N1ZXMvMjg0MlxuXG5cbmNvbnN0IGdldFJlYWxQYXJlbnQgPSAoc2NvcGUsIHBhcmVudFNjb3BlKSA9PiBzY29wZVtQQVJFTlRfS0VZX1NZTUJPTF0gfHwgcGFyZW50U2NvcGU7XG5cbmNvbnN0IFNsb3RCaW5kaW5nID0gT2JqZWN0LnNlYWwoe1xuICAvLyBkeW5hbWljIGJpbmRpbmcgcHJvcGVydGllc1xuICAvLyBub2RlOiBudWxsLFxuICAvLyBuYW1lOiBudWxsLFxuICBhdHRyaWJ1dGVzOiBbXSxcblxuICAvLyB0ZW1wbGF0ZTogbnVsbCxcbiAgZ2V0VGVtcGxhdGVTY29wZShzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgICByZXR1cm4gZXh0ZW5kUGFyZW50U2NvcGUodGhpcy5hdHRyaWJ1dGVzLCBzY29wZSwgcGFyZW50U2NvcGUpO1xuICB9LFxuXG4gIC8vIEFQSSBtZXRob2RzXG4gIG1vdW50KHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICAgIGNvbnN0IHRlbXBsYXRlRGF0YSA9IHNjb3BlLnNsb3RzID8gc2NvcGUuc2xvdHMuZmluZCgoX3JlZikgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgaWRcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIGlkID09PSB0aGlzLm5hbWU7XG4gICAgfSkgOiBmYWxzZTtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnROb2RlXG4gICAgfSA9IHRoaXMubm9kZTtcbiAgICBjb25zdCByZWFsUGFyZW50ID0gZ2V0UmVhbFBhcmVudChzY29wZSwgcGFyZW50U2NvcGUpO1xuICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZURhdGEgJiYgY3JlYXRlJDYodGVtcGxhdGVEYXRhLmh0bWwsIHRlbXBsYXRlRGF0YS5iaW5kaW5ncykuY3JlYXRlRE9NKHBhcmVudE5vZGUpO1xuXG4gICAgaWYgKHRoaXMudGVtcGxhdGUpIHtcbiAgICAgIHRoaXMudGVtcGxhdGUubW91bnQodGhpcy5ub2RlLCB0aGlzLmdldFRlbXBsYXRlU2NvcGUoc2NvcGUsIHJlYWxQYXJlbnQpLCByZWFsUGFyZW50KTtcbiAgICAgIHRoaXMudGVtcGxhdGUuY2hpbGRyZW4gPSBtb3ZlU2xvdElubmVyQ29udGVudCh0aGlzLm5vZGUpO1xuICAgIH1cblxuICAgIHJlbW92ZUNoaWxkKHRoaXMubm9kZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdXBkYXRlKHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICAgIGlmICh0aGlzLnRlbXBsYXRlKSB7XG4gICAgICBjb25zdCByZWFsUGFyZW50ID0gZ2V0UmVhbFBhcmVudChzY29wZSwgcGFyZW50U2NvcGUpO1xuICAgICAgdGhpcy50ZW1wbGF0ZS51cGRhdGUodGhpcy5nZXRUZW1wbGF0ZVNjb3BlKHNjb3BlLCByZWFsUGFyZW50KSwgcmVhbFBhcmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdW5tb3VudChzY29wZSwgcGFyZW50U2NvcGUsIG11c3RSZW1vdmVSb290KSB7XG4gICAgaWYgKHRoaXMudGVtcGxhdGUpIHtcbiAgICAgIHRoaXMudGVtcGxhdGUudW5tb3VudCh0aGlzLmdldFRlbXBsYXRlU2NvcGUoc2NvcGUsIHBhcmVudFNjb3BlKSwgbnVsbCwgbXVzdFJlbW92ZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn0pO1xuLyoqXG4gKiBNb3ZlIHRoZSBpbm5lciBjb250ZW50IG9mIHRoZSBzbG90cyBvdXRzaWRlIG9mIHRoZW1cbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gc2xvdCAtIHNsb3Qgbm9kZVxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBjaGlsZHJlbiAtIGFycmF5IHRvIGZpbGwgd2l0aCB0aGUgY2hpbGQgbm9kZXMgZGV0ZWN0ZWRcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFtdfSBsaXN0IG9mIHRoZSBub2RlIG1vdmVkXG4gKi9cblxuZnVuY3Rpb24gbW92ZVNsb3RJbm5lckNvbnRlbnQoc2xvdCwgY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICBjaGlsZHJlbiA9IFtdO1xuICB9XG5cbiAgY29uc3QgY2hpbGQgPSBzbG90LmZpcnN0Q2hpbGQ7XG5cbiAgaWYgKGNoaWxkKSB7XG4gICAgaW5zZXJ0QmVmb3JlKGNoaWxkLCBzbG90KTtcbiAgICByZXR1cm4gW2NoaWxkLCAuLi5tb3ZlU2xvdElubmVyQ29udGVudChzbG90KV07XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG4vKipcbiAqIENyZWF0ZSBhIHNpbmdsZSBzbG90IGJpbmRpbmdcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gbm9kZSAtIHNsb3Qgbm9kZVxuICogQHBhcmFtICAge3N0cmluZ30gb3B0aW9ucy5uYW1lIC0gc2xvdCBpZFxuICogQHJldHVybnMge09iamVjdH0gU2xvdCBiaW5kaW5nIG9iamVjdFxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlU2xvdChub2RlLCBfcmVmMikge1xuICBsZXQge1xuICAgIG5hbWUsXG4gICAgYXR0cmlidXRlc1xuICB9ID0gX3JlZjI7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBTbG90QmluZGluZywge1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgbm9kZSxcbiAgICBuYW1lXG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0YWcgb2JqZWN0IGlmIGl0IHdhcyByZWdpc3RlcmVkIGJlZm9yZSwgb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIHRoZSBzaW1wbGVcbiAqIHRlbXBsYXRlIGNodW5rXG4gKiBAcGFyYW0gICB7RnVuY3Rpb259IGNvbXBvbmVudCAtIGNvbXBvbmVudCBmYWN0b3J5IGZ1bmN0aW9uXG4gKiBAcGFyYW0gICB7QXJyYXk8T2JqZWN0Pn0gc2xvdHMgLSBhcnJheSBjb250YWluaW5nIHRoZSBzbG90cyBtYXJrdXBcbiAqIEBwYXJhbSAgIHtBcnJheX0gYXR0cmlidXRlcyAtIGR5bmFtaWMgYXR0cmlidXRlcyB0aGF0IHdpbGwgYmUgcmVjZWl2ZWQgYnkgdGhlIHRhZyBlbGVtZW50XG4gKiBAcmV0dXJucyB7VGFnSW1wbGVtZW50YXRpb258VGVtcGxhdGVDaHVua30gYSB0YWcgaW1wbGVtZW50YXRpb24gb3IgYSB0ZW1wbGF0ZSBjaHVuayBhcyBmYWxsYmFja1xuICovXG5cbmZ1bmN0aW9uIGdldFRhZyhjb21wb25lbnQsIHNsb3RzLCBhdHRyaWJ1dGVzKSB7XG4gIGlmIChzbG90cyA9PT0gdm9pZCAwKSB7XG4gICAgc2xvdHMgPSBbXTtcbiAgfVxuXG4gIGlmIChhdHRyaWJ1dGVzID09PSB2b2lkIDApIHtcbiAgICBhdHRyaWJ1dGVzID0gW107XG4gIH1cblxuICAvLyBpZiB0aGlzIHRhZyB3YXMgcmVnaXN0ZXJlZCBiZWZvcmUgd2Ugd2lsbCByZXR1cm4gaXRzIGltcGxlbWVudGF0aW9uXG4gIGlmIChjb21wb25lbnQpIHtcbiAgICByZXR1cm4gY29tcG9uZW50KHtcbiAgICAgIHNsb3RzLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH0pO1xuICB9IC8vIG90aGVyd2lzZSB3ZSByZXR1cm4gYSB0ZW1wbGF0ZSBjaHVua1xuXG5cbiAgcmV0dXJuIGNyZWF0ZSQ2KHNsb3RzVG9NYXJrdXAoc2xvdHMpLCBbLi4uc2xvdEJpbmRpbmdzKHNsb3RzKSwge1xuICAgIC8vIHRoZSBhdHRyaWJ1dGVzIHNob3VsZCBiZSByZWdpc3RlcmVkIGFzIGJpbmRpbmdcbiAgICAvLyBpZiB3ZSBmYWxsYmFjayB0byBhIG5vcm1hbCB0ZW1wbGF0ZSBjaHVua1xuICAgIGV4cHJlc3Npb25zOiBhdHRyaWJ1dGVzLm1hcChhdHRyID0+IHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgdHlwZTogQVRUUklCVVRFXG4gICAgICB9LCBhdHRyKTtcbiAgICB9KVxuICB9XSk7XG59XG4vKipcbiAqIE1lcmdlIGFsbCB0aGUgc2xvdHMgYmluZGluZ3MgaW50byBhIHNpbmdsZSBhcnJheVxuICogQHBhcmFtICAge0FycmF5PE9iamVjdD59IHNsb3RzIC0gc2xvdHMgY29sbGVjdGlvblxuICogQHJldHVybnMge0FycmF5PEJpbmRpbmdzPn0gZmxhdHRlbiBiaW5kaW5ncyBhcnJheVxuICovXG5cblxuZnVuY3Rpb24gc2xvdEJpbmRpbmdzKHNsb3RzKSB7XG4gIHJldHVybiBzbG90cy5yZWR1Y2UoKGFjYywgX3JlZikgPT4ge1xuICAgIGxldCB7XG4gICAgICBiaW5kaW5nc1xuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiBhY2MuY29uY2F0KGJpbmRpbmdzKTtcbiAgfSwgW10pO1xufVxuLyoqXG4gKiBNZXJnZSBhbGwgdGhlIHNsb3RzIHRvZ2V0aGVyIGluIGEgc2luZ2xlIG1hcmt1cCBzdHJpbmdcbiAqIEBwYXJhbSAgIHtBcnJheTxPYmplY3Q+fSBzbG90cyAtIHNsb3RzIGNvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHtzdHJpbmd9IG1hcmt1cCBvZiBhbGwgdGhlIHNsb3RzIGluIGEgc2luZ2xlIHN0cmluZ1xuICovXG5cblxuZnVuY3Rpb24gc2xvdHNUb01hcmt1cChzbG90cykge1xuICByZXR1cm4gc2xvdHMucmVkdWNlKChhY2MsIHNsb3QpID0+IHtcbiAgICByZXR1cm4gYWNjICsgc2xvdC5odG1sO1xuICB9LCAnJyk7XG59XG5cbmNvbnN0IFRhZ0JpbmRpbmcgPSBPYmplY3Quc2VhbCh7XG4gIC8vIGR5bmFtaWMgYmluZGluZyBwcm9wZXJ0aWVzXG4gIC8vIG5vZGU6IG51bGwsXG4gIC8vIGV2YWx1YXRlOiBudWxsLFxuICAvLyBuYW1lOiBudWxsLFxuICAvLyBzbG90czogbnVsbCxcbiAgLy8gdGFnOiBudWxsLFxuICAvLyBhdHRyaWJ1dGVzOiBudWxsLFxuICAvLyBnZXRDb21wb25lbnQ6IG51bGwsXG4gIG1vdW50KHNjb3BlKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlKHNjb3BlKTtcbiAgfSxcblxuICB1cGRhdGUoc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuZXZhbHVhdGUoc2NvcGUpOyAvLyBzaW1wbGUgdXBkYXRlXG5cbiAgICBpZiAobmFtZSA9PT0gdGhpcy5uYW1lKSB7XG4gICAgICB0aGlzLnRhZy51cGRhdGUoc2NvcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bm1vdW50IHRoZSBvbGQgdGFnIGlmIGl0IGV4aXN0c1xuICAgICAgdGhpcy51bm1vdW50KHNjb3BlLCBwYXJlbnRTY29wZSwgdHJ1ZSk7IC8vIG1vdW50IHRoZSBuZXcgdGFnXG5cbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLnRhZyA9IGdldFRhZyh0aGlzLmdldENvbXBvbmVudChuYW1lKSwgdGhpcy5zbG90cywgdGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgIHRoaXMudGFnLm1vdW50KHRoaXMubm9kZSwgc2NvcGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHVubW91bnQoc2NvcGUsIHBhcmVudFNjb3BlLCBrZWVwUm9vdFRhZykge1xuICAgIGlmICh0aGlzLnRhZykge1xuICAgICAgLy8ga2VlcCB0aGUgcm9vdCB0YWdcbiAgICAgIHRoaXMudGFnLnVubW91bnQoa2VlcFJvb3RUYWcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn0pO1xuZnVuY3Rpb24gY3JlYXRlJDQobm9kZSwgX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBldmFsdWF0ZSxcbiAgICBnZXRDb21wb25lbnQsXG4gICAgc2xvdHMsXG4gICAgYXR0cmlidXRlc1xuICB9ID0gX3JlZjI7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBUYWdCaW5kaW5nLCB7XG4gICAgbm9kZSxcbiAgICBldmFsdWF0ZSxcbiAgICBzbG90cyxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGdldENvbXBvbmVudFxuICB9KTtcbn1cblxudmFyIGJpbmRpbmdzID0ge1xuICBbSUZdOiBjcmVhdGUkMSxcbiAgW1NJTVBMRV06IGNyZWF0ZSQzLFxuICBbRUFDSF06IGNyZWF0ZSxcbiAgW1RBR106IGNyZWF0ZSQ0LFxuICBbU0xPVF06IGNyZWF0ZVNsb3Rcbn07XG5cbi8qKlxuICogVGV4dCBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlIHRhZyB3aWxsIGdldCBjaGlsZE5vZGVJbmRleCB2YWx1ZSBub3JtYWxpemVkXG4gKiBkZXBlbmRpbmcgb24gdGhlIHBvc2l0aW9uIG9mIHRoZSA8dGVtcGxhdGU+IHRhZyBvZmZzZXRcbiAqIEBwYXJhbSAgIHtFeHByZXNzaW9uW119IGV4cHJlc3Npb25zIC0gcmlvdCBleHByZXNzaW9ucyBhcnJheVxuICogQHBhcmFtICAge251bWJlcn0gdGV4dEV4cHJlc3Npb25zT2Zmc2V0IC0gb2Zmc2V0IG9mIHRoZSA8dGVtcGxhdGU+IHRhZ1xuICogQHJldHVybnMge0V4cHJlc3Npb25bXX0gZXhwcmVzc2lvbnMgY29udGFpbmluZyB0aGUgdGV4dCBleHByZXNzaW9ucyBub3JtYWxpemVkXG4gKi9cblxuZnVuY3Rpb24gZml4VGV4dEV4cHJlc3Npb25zT2Zmc2V0KGV4cHJlc3Npb25zLCB0ZXh0RXhwcmVzc2lvbnNPZmZzZXQpIHtcbiAgcmV0dXJuIGV4cHJlc3Npb25zLm1hcChlID0+IGUudHlwZSA9PT0gVEVYVCA/IE9iamVjdC5hc3NpZ24oe30sIGUsIHtcbiAgICBjaGlsZE5vZGVJbmRleDogZS5jaGlsZE5vZGVJbmRleCArIHRleHRFeHByZXNzaW9uc09mZnNldFxuICB9KSA6IGUpO1xufVxuLyoqXG4gKiBCaW5kIGEgbmV3IGV4cHJlc3Npb24gb2JqZWN0IHRvIGEgRE9NIG5vZGVcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gcm9vdCAtIERPTSBub2RlIHdoZXJlIHRvIGJpbmQgdGhlIGV4cHJlc3Npb25cbiAqIEBwYXJhbSAgIHtPYmplY3R9IGJpbmRpbmcgLSBiaW5kaW5nIGRhdGFcbiAqIEBwYXJhbSAgIHtudW1iZXJ8bnVsbH0gdGVtcGxhdGVUYWdPZmZzZXQgLSBpZiBpdCdzIGRlZmluZWQgd2UgbmVlZCB0byBmaXggdGhlIHRleHQgZXhwcmVzc2lvbnMgY2hpbGROb2RlSW5kZXggb2Zmc2V0XG4gKiBAcmV0dXJucyB7QmluZGluZ30gQmluZGluZyBvYmplY3RcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZSQ1KHJvb3QsIGJpbmRpbmcsIHRlbXBsYXRlVGFnT2Zmc2V0KSB7XG4gIGNvbnN0IHtcbiAgICBzZWxlY3RvcixcbiAgICB0eXBlLFxuICAgIHJlZHVuZGFudEF0dHJpYnV0ZSxcbiAgICBleHByZXNzaW9uc1xuICB9ID0gYmluZGluZzsgLy8gZmluZCB0aGUgbm9kZSB0byBhcHBseSB0aGUgYmluZGluZ3NcblxuICBjb25zdCBub2RlID0gc2VsZWN0b3IgPyByb290LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpIDogcm9vdDsgLy8gcmVtb3ZlIGV2ZW50dWFsbHkgYWRkaXRpb25hbCBhdHRyaWJ1dGVzIGNyZWF0ZWQgb25seSB0byBzZWxlY3QgdGhpcyBub2RlXG5cbiAgaWYgKHJlZHVuZGFudEF0dHJpYnV0ZSkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocmVkdW5kYW50QXR0cmlidXRlKTtcbiAgY29uc3QgYmluZGluZ0V4cHJlc3Npb25zID0gZXhwcmVzc2lvbnMgfHwgW107IC8vIGluaXQgdGhlIGJpbmRpbmdcblxuICByZXR1cm4gKGJpbmRpbmdzW3R5cGVdIHx8IGJpbmRpbmdzW1NJTVBMRV0pKG5vZGUsIE9iamVjdC5hc3NpZ24oe30sIGJpbmRpbmcsIHtcbiAgICBleHByZXNzaW9uczogdGVtcGxhdGVUYWdPZmZzZXQgJiYgIXNlbGVjdG9yID8gZml4VGV4dEV4cHJlc3Npb25zT2Zmc2V0KGJpbmRpbmdFeHByZXNzaW9ucywgdGVtcGxhdGVUYWdPZmZzZXQpIDogYmluZGluZ0V4cHJlc3Npb25zXG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSFRNTFRyZWUoaHRtbCwgcm9vdCkge1xuICBjb25zdCB0ZW1wbGF0ZSA9IGlzVGVtcGxhdGUocm9vdCkgPyByb290IDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQ7XG59IC8vIGZvciBzdmcgbm9kZXMgd2UgbmVlZCBhIGJpdCBtb3JlIHdvcmtcblxuXG5mdW5jdGlvbiBjcmVhdGVTVkdUcmVlKGh0bWwsIGNvbnRhaW5lcikge1xuICAvLyBjcmVhdGUgdGhlIFNWR05vZGVcbiAgY29uc3Qgc3ZnTm9kZSA9IGNvbnRhaW5lci5vd25lckRvY3VtZW50LmltcG9ydE5vZGUobmV3IHdpbmRvdy5ET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPiR7aHRtbH08L3N2Zz5gLCAnYXBwbGljYXRpb24veG1sJykuZG9jdW1lbnRFbGVtZW50LCB0cnVlKTtcbiAgcmV0dXJuIHN2Z05vZGU7XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgRE9NIHRoYXQgd2lsbCBiZSBpbmplY3RlZFxuICogQHBhcmFtIHtPYmplY3R9IHJvb3QgLSBET00gbm9kZSB0byBmaW5kIG91dCB0aGUgY29udGV4dCB3aGVyZSB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBodG1sIC0gRE9NIHRvIGNyZWF0ZSBhcyBzdHJpbmdcbiAqIEByZXR1cm5zIHtIVE1MRG9jdW1lbnRGcmFnbWVudHxIVE1MRWxlbWVudH0gYSBuZXcgaHRtbCBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRE9NVHJlZShyb290LCBodG1sKSB7XG4gIGlmIChpc1N2Zyhyb290KSkgcmV0dXJuIGNyZWF0ZVNWR1RyZWUoaHRtbCwgcm9vdCk7XG4gIHJldHVybiBjcmVhdGVIVE1MVHJlZShodG1sLCByb290KTtcbn1cblxuLyoqXG4gKiBJbmplY3QgdGhlIERPTSB0cmVlIGludG8gYSB0YXJnZXQgbm9kZVxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbCAtIHRhcmdldCBlbGVtZW50XG4gKiBAcGFyYW0gICB7SFRNTEZyYWdtZW50fFNWR0VsZW1lbnR9IGRvbSAtIGRvbSB0cmVlIHRvIGluamVjdFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBpbmplY3RET00oZWwsIGRvbSkge1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzU3ZnKGVsKTpcbiAgICAgIG1vdmVDaGlsZHJlbihkb20sIGVsKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBpc1RlbXBsYXRlKGVsKTpcbiAgICAgIGVsLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGRvbSwgZWwpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgZWwuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgVGVtcGxhdGUgRE9NIHNrZWxldG9uXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IGVsIC0gcm9vdCBub2RlIHdoZXJlIHRoZSBET00gd2lsbCBiZSBpbmplY3RlZFxuICogQHBhcmFtICAge3N0cmluZ30gaHRtbCAtIG1hcmt1cCB0aGF0IHdpbGwgYmUgaW5qZWN0ZWQgaW50byB0aGUgcm9vdCBub2RlXG4gKiBAcmV0dXJucyB7SFRNTEZyYWdtZW50fSBmcmFnbWVudCB0aGF0IHdpbGwgYmUgaW5qZWN0ZWQgaW50byB0aGUgcm9vdCBub2RlXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGVET00oZWwsIGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwgJiYgKHR5cGVvZiBodG1sID09PSAnc3RyaW5nJyA/IGNyZWF0ZURPTVRyZWUoZWwsIGh0bWwpIDogaHRtbCk7XG59XG4vKipcbiAqIFRlbXBsYXRlIENodW5rIG1vZGVsXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cblxuY29uc3QgVGVtcGxhdGVDaHVuayA9IE9iamVjdC5mcmVlemUoe1xuICAvLyBTdGF0aWMgcHJvcHNcbiAgLy8gYmluZGluZ3M6IG51bGwsXG4gIC8vIGJpbmRpbmdzRGF0YTogbnVsbCxcbiAgLy8gaHRtbDogbnVsbCxcbiAgLy8gaXNUZW1wbGF0ZVRhZzogZmFsc2UsXG4gIC8vIGZyYWdtZW50OiBudWxsLFxuICAvLyBjaGlsZHJlbjogbnVsbCxcbiAgLy8gZG9tOiBudWxsLFxuICAvLyBlbDogbnVsbCxcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSB0ZW1wbGF0ZSBET00gc3RydWN0dXJlIHRoYXQgd2lsbCBiZSBjbG9uZWQgb24gZWFjaCBtb3VudFxuICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IGVsIC0gdGhlIHJvb3Qgbm9kZVxuICAgKiBAcmV0dXJucyB7VGVtcGxhdGVDaHVua30gc2VsZlxuICAgKi9cbiAgY3JlYXRlRE9NKGVsKSB7XG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIERPTSBnZXRzIGNyZWF0ZWQgYmVmb3JlIGNsb25pbmcgdGhlIHRlbXBsYXRlXG4gICAgdGhpcy5kb20gPSB0aGlzLmRvbSB8fCBjcmVhdGVUZW1wbGF0ZURPTShlbCwgdGhpcy5odG1sKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBBUEkgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBBdHRhY2ggdGhlIHRlbXBsYXRlIHRvIGEgRE9NIG5vZGVcbiAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbCAtIHRhcmdldCBET00gbm9kZVxuICAgKiBAcGFyYW0gICB7Kn0gc2NvcGUgLSB0ZW1wbGF0ZSBkYXRhXG4gICAqIEBwYXJhbSAgIHsqfSBwYXJlbnRTY29wZSAtIHNjb3BlIG9mIHRoZSBwYXJlbnQgdGVtcGxhdGUgdGFnXG4gICAqIEBwYXJhbSAgIHtPYmplY3R9IG1ldGEgLSBtZXRhIHByb3BlcnRpZXMgbmVlZGVkIHRvIGhhbmRsZSB0aGUgPHRlbXBsYXRlPiB0YWdzIGluIGxvb3BzXG4gICAqIEByZXR1cm5zIHtUZW1wbGF0ZUNodW5rfSBzZWxmXG4gICAqL1xuICBtb3VudChlbCwgc2NvcGUsIHBhcmVudFNjb3BlLCBtZXRhKSB7XG4gICAgaWYgKG1ldGEgPT09IHZvaWQgMCkge1xuICAgICAgbWV0YSA9IHt9O1xuICAgIH1cblxuICAgIGlmICghZWwpIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgRE9NIG5vZGUgdG8gbW91bnQgcHJvcGVybHkgeW91ciB0ZW1wbGF0ZScpO1xuICAgIGlmICh0aGlzLmVsKSB0aGlzLnVubW91bnQoc2NvcGUpOyAvLyA8dGVtcGxhdGU+IHRhZ3MgcmVxdWlyZSBhIGJpdCBtb3JlIHdvcmtcbiAgICAvLyB0aGUgdGVtcGxhdGUgZnJhZ21lbnQgbWlnaHQgYmUgYWxyZWFkeSBjcmVhdGVkIHZpYSBtZXRhIG91dHNpZGUgb2YgdGhpcyBjYWxsXG5cbiAgICBjb25zdCB7XG4gICAgICBmcmFnbWVudCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgYXZvaWRET01JbmplY3Rpb25cbiAgICB9ID0gbWV0YTsgLy8gPHRlbXBsYXRlPiBiaW5kaW5ncyBvZiBjb3Vyc2UgY2FuIG5vdCBoYXZlIGEgcm9vdCBlbGVtZW50XG4gICAgLy8gc28gd2UgY2hlY2sgdGhlIHBhcmVudCBub2RlIHRvIHNldCB0aGUgcXVlcnkgc2VsZWN0b3IgYmluZGluZ3NcblxuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudE5vZGVcbiAgICB9ID0gY2hpbGRyZW4gPyBjaGlsZHJlblswXSA6IGVsO1xuICAgIGNvbnN0IGlzVGVtcGxhdGVUYWcgPSBpc1RlbXBsYXRlKGVsKTtcbiAgICBjb25zdCB0ZW1wbGF0ZVRhZ09mZnNldCA9IGlzVGVtcGxhdGVUYWcgPyBNYXRoLm1heChBcnJheS5mcm9tKHBhcmVudE5vZGUuY2hpbGROb2RlcykuaW5kZXhPZihlbCksIDApIDogbnVsbDtcbiAgICB0aGlzLmlzVGVtcGxhdGVUYWcgPSBpc1RlbXBsYXRlVGFnOyAvLyBjcmVhdGUgdGhlIERPTSBpZiBpdCB3YXNuJ3QgY3JlYXRlZCBiZWZvcmVcblxuICAgIHRoaXMuY3JlYXRlRE9NKGVsKTtcblxuICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgLy8gY3JlYXRlIHRoZSBuZXcgdGVtcGxhdGUgZG9tIGZyYWdtZW50IGlmIGl0IHdhbnQgYWxyZWFkeSBwYXNzZWQgaW4gdmlhIG1ldGFcbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudCB8fCB0aGlzLmRvbS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgfSAvLyBzdG9yZSByb290IG5vZGVcbiAgICAvLyBub3RpY2UgdGhhdCBmb3IgdGVtcGxhdGUgdGFncyB0aGUgcm9vdCBub3RlIHdpbGwgYmUgdGhlIHBhcmVudCB0YWdcblxuXG4gICAgdGhpcy5lbCA9IHRoaXMuaXNUZW1wbGF0ZVRhZyA/IHBhcmVudE5vZGUgOiBlbDsgLy8gY3JlYXRlIHRoZSBjaGlsZHJlbiBhcnJheSBvbmx5IGZvciB0aGUgPHRlbXBsYXRlPiBmcmFnbWVudHNcblxuICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLmlzVGVtcGxhdGVUYWcgPyBjaGlsZHJlbiB8fCBBcnJheS5mcm9tKHRoaXMuZnJhZ21lbnQuY2hpbGROb2RlcykgOiBudWxsOyAvLyBpbmplY3QgdGhlIERPTSBpbnRvIHRoZSBlbCBvbmx5IGlmIGEgZnJhZ21lbnQgaXMgYXZhaWxhYmxlXG5cbiAgICBpZiAoIWF2b2lkRE9NSW5qZWN0aW9uICYmIHRoaXMuZnJhZ21lbnQpIGluamVjdERPTShlbCwgdGhpcy5mcmFnbWVudCk7IC8vIGNyZWF0ZSB0aGUgYmluZGluZ3NcblxuICAgIHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzRGF0YS5tYXAoYmluZGluZyA9PiBjcmVhdGUkNSh0aGlzLmVsLCBiaW5kaW5nLCB0ZW1wbGF0ZVRhZ09mZnNldCkpO1xuICAgIHRoaXMuYmluZGluZ3MuZm9yRWFjaChiID0+IGIubW91bnQoc2NvcGUsIHBhcmVudFNjb3BlKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgdGVtcGxhdGUgd2l0aCBmcmVzaCBkYXRhXG4gICAqIEBwYXJhbSAgIHsqfSBzY29wZSAtIHRlbXBsYXRlIGRhdGFcbiAgICogQHBhcmFtICAgeyp9IHBhcmVudFNjb3BlIC0gc2NvcGUgb2YgdGhlIHBhcmVudCB0ZW1wbGF0ZSB0YWdcbiAgICogQHJldHVybnMge1RlbXBsYXRlQ2h1bmt9IHNlbGZcbiAgICovXG4gIHVwZGF0ZShzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgICB0aGlzLmJpbmRpbmdzLmZvckVhY2goYiA9PiBiLnVwZGF0ZShzY29wZSwgcGFyZW50U2NvcGUpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSB0ZW1wbGF0ZSBmcm9tIHRoZSBub2RlIHdoZXJlIGl0IHdhcyBpbml0aWFsbHkgbW91bnRlZFxuICAgKiBAcGFyYW0gICB7Kn0gc2NvcGUgLSB0ZW1wbGF0ZSBkYXRhXG4gICAqIEBwYXJhbSAgIHsqfSBwYXJlbnRTY29wZSAtIHNjb3BlIG9mIHRoZSBwYXJlbnQgdGVtcGxhdGUgdGFnXG4gICAqIEBwYXJhbSAgIHtib29sZWFufG51bGx9IG11c3RSZW1vdmVSb290IC0gaWYgdHJ1ZSByZW1vdmUgdGhlIHJvb3QgZWxlbWVudCxcbiAgICogaWYgZmFsc2Ugb3IgdW5kZWZpbmVkIGNsZWFuIHRoZSByb290IHRhZyBjb250ZW50LCBpZiBudWxsIGRvbid0IHRvdWNoIHRoZSBET01cbiAgICogQHJldHVybnMge1RlbXBsYXRlQ2h1bmt9IHNlbGZcbiAgICovXG4gIHVubW91bnQoc2NvcGUsIHBhcmVudFNjb3BlLCBtdXN0UmVtb3ZlUm9vdCkge1xuICAgIGlmICh0aGlzLmVsKSB7XG4gICAgICB0aGlzLmJpbmRpbmdzLmZvckVhY2goYiA9PiBiLnVubW91bnQoc2NvcGUsIHBhcmVudFNjb3BlLCBtdXN0UmVtb3ZlUm9vdCkpO1xuXG4gICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgLy8gPHRlbXBsYXRlPiB0YWdzIHNob3VsZCBiZSB0cmVhdGVkIGEgYml0IGRpZmZlcmVudGx5XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY2xlYXIgdGhlaXIgY2hpbGRyZW4gb25seSBpZiBpdCdzIGV4cGxpY2l0bHkgcmVxdWlyZWQgYnkgdGhlIGNhbGxlclxuICAgICAgICAvLyB2aWEgbXVzdFJlbW92ZVJvb3QgIT09IG51bGxcbiAgICAgICAgY2FzZSB0aGlzLmNoaWxkcmVuICYmIG11c3RSZW1vdmVSb290ICE9PSBudWxsOlxuICAgICAgICAgIGNsZWFyQ2hpbGRyZW4odGhpcy5jaGlsZHJlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgcm9vdCBub2RlIG9ubHkgaWYgdGhlIG11c3RSZW1vdmVSb290ID09PSB0cnVlXG5cbiAgICAgICAgY2FzZSBtdXN0UmVtb3ZlUm9vdCA9PT0gdHJ1ZTpcbiAgICAgICAgICByZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGNsZWFuIHRoZSBub2RlIGNoaWxkcmVuXG5cbiAgICAgICAgY2FzZSBtdXN0UmVtb3ZlUm9vdCAhPT0gbnVsbDpcbiAgICAgICAgICBjbGVhbk5vZGUodGhpcy5lbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZSB0aGUgdGVtcGxhdGUgY2h1bmtcbiAgICogQHJldHVybnMge1RlbXBsYXRlQ2h1bmt9IGEgY2xvbmUgb2YgdGhpcyBvYmplY3QgcmVzZXR0aW5nIHRoZSB0aGlzLmVsIHByb3BlcnR5XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcywge1xuICAgICAgZWw6IG51bGxcbiAgICB9KTtcbiAgfVxuXG59KTtcbi8qKlxuICogQ3JlYXRlIGEgdGVtcGxhdGUgY2h1bmsgd2lyaW5nIGFsc28gdGhlIGJpbmRpbmdzXG4gKiBAcGFyYW0gICB7c3RyaW5nfEhUTUxFbGVtZW50fSBodG1sIC0gdGVtcGxhdGUgc3RyaW5nXG4gKiBAcGFyYW0gICB7QXJyYXl9IGJpbmRpbmdzIC0gYmluZGluZ3MgY29sbGVjdGlvblxuICogQHJldHVybnMge1RlbXBsYXRlQ2h1bmt9IGEgbmV3IFRlbXBsYXRlQ2h1bmsgY29weVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZSQ2KGh0bWwsIGJpbmRpbmdzKSB7XG4gIGlmIChiaW5kaW5ncyA9PT0gdm9pZCAwKSB7XG4gICAgYmluZGluZ3MgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBUZW1wbGF0ZUNodW5rLCB7XG4gICAgaHRtbCxcbiAgICBiaW5kaW5nc0RhdGE6IGJpbmRpbmdzXG4gIH0pO1xufVxuXG4vKipcbiAqIE1ldGhvZCB1c2VkIHRvIGJpbmQgZXhwcmVzc2lvbnMgdG8gYSBET00gbm9kZVxuICogQHBhcmFtICAge3N0cmluZ3xIVE1MRWxlbWVudH0gaHRtbCAtIHlvdXIgc3RhdGljIHRlbXBsYXRlIGh0bWwgc3RydWN0dXJlXG4gKiBAcGFyYW0gICB7QXJyYXl9IGJpbmRpbmdzIC0gbGlzdCBvZiB0aGUgZXhwcmVzc2lvbnMgdG8gYmluZCB0byB1cGRhdGUgdGhlIG1hcmt1cFxuICogQHJldHVybnMge1RlbXBsYXRlQ2h1bmt9IGEgbmV3IFRlbXBsYXRlQ2h1bmsgb2JqZWN0IGhhdmluZyB0aGUgYHVwZGF0ZWAsYG1vdW50YCwgYHVubW91bnRgIGFuZCBgY2xvbmVgIG1ldGhvZHNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIHJpb3RET01CaW5kaW5nc1xuICogIC50ZW1wbGF0ZShcbiAqICAgYDxkaXYgZXhwcjA+PCEtLS0tPjwvZGl2PjxkaXY+PHAgZXhwcjE+PCEtLS0tPjxzZWN0aW9uIGV4cHIyPjwvc2VjdGlvbj48L3A+YCxcbiAqICAgW1xuICogICAgIHtcbiAqICAgICAgIHNlbGVjdG9yOiAnW2V4cHIwXScsXG4gKiAgICAgICByZWR1bmRhbnRBdHRyaWJ1dGU6ICdleHByMCcsXG4gKiAgICAgICBleHByZXNzaW9uczogW1xuICogICAgICAgICB7XG4gKiAgICAgICAgICAgdHlwZTogZXhwcmVzc2lvblR5cGVzLlRFWFQsXG4gKiAgICAgICAgICAgY2hpbGROb2RlSW5kZXg6IDAsXG4gKiAgICAgICAgICAgZXZhbHVhdGUoc2NvcGUpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBzY29wZS50aW1lO1xuICogICAgICAgICAgIH0sXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICBdLFxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgc2VsZWN0b3I6ICdbZXhwcjFdJyxcbiAqICAgICAgIHJlZHVuZGFudEF0dHJpYnV0ZTogJ2V4cHIxJyxcbiAqICAgICAgIGV4cHJlc3Npb25zOiBbXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICB0eXBlOiBleHByZXNzaW9uVHlwZXMuVEVYVCxcbiAqICAgICAgICAgICBjaGlsZE5vZGVJbmRleDogMCxcbiAqICAgICAgICAgICBldmFsdWF0ZShzY29wZSkge1xuICogICAgICAgICAgICAgcmV0dXJuIHNjb3BlLm5hbWU7XG4gKiAgICAgICAgICAgfSxcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIHR5cGU6ICdhdHRyaWJ1dGUnLFxuICogICAgICAgICAgIG5hbWU6ICdzdHlsZScsXG4gKiAgICAgICAgICAgZXZhbHVhdGUoc2NvcGUpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBzY29wZS5zdHlsZTtcbiAqICAgICAgICAgICB9LFxuICogICAgICAgICB9LFxuICogICAgICAgXSxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIHNlbGVjdG9yOiAnW2V4cHIyXScsXG4gKiAgICAgICByZWR1bmRhbnRBdHRyaWJ1dGU6ICdleHByMicsXG4gKiAgICAgICB0eXBlOiBiaW5kaW5nVHlwZXMuSUYsXG4gKiAgICAgICBldmFsdWF0ZShzY29wZSkge1xuICogICAgICAgICByZXR1cm4gc2NvcGUuaXNWaXNpYmxlO1xuICogICAgICAgfSxcbiAqICAgICAgIHRlbXBsYXRlOiByaW90RE9NQmluZGluZ3MudGVtcGxhdGUoJ2hlbGxvIHRoZXJlJyksXG4gKiAgICAgfSxcbiAqICAgXVxuICogKVxuICovXG5cbnZhciBET01CaW5kaW5ncyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICB0ZW1wbGF0ZTogY3JlYXRlJDYsXG4gIGNyZWF0ZUJpbmRpbmc6IGNyZWF0ZSQ1LFxuICBjcmVhdGVFeHByZXNzaW9uOiBjcmVhdGUkMixcbiAgYmluZGluZ1R5cGVzOiBiaW5kaW5nVHlwZXMsXG4gIGV4cHJlc3Npb25UeXBlczogZXhwcmVzc2lvblR5cGVzXG59KTtcblxuZnVuY3Rpb24gbm9vcCgpIHtcbiAgcmV0dXJuIHRoaXM7XG59XG4vKipcbiAqIEF1dG9iaW5kIHRoZSBtZXRob2RzIG9mIGEgc291cmNlIG9iamVjdCB0byBpdHNlbGZcbiAqIEBwYXJhbSAgIHtPYmplY3R9IHNvdXJjZSAtIHByb2JhYmx5IGEgcmlvdCB0YWcgaW5zdGFuY2VcbiAqIEBwYXJhbSAgIHtBcnJheTxzdHJpbmc+fSBtZXRob2RzIC0gbGlzdCBvZiB0aGUgbWV0aG9kcyB0byBhdXRvYmluZFxuICogQHJldHVybnMge09iamVjdH0gdGhlIG9yaWdpbmFsIG9iamVjdCByZWNlaXZlZFxuICovXG5cbmZ1bmN0aW9uIGF1dG9iaW5kTWV0aG9kcyhzb3VyY2UsIG1ldGhvZHMpIHtcbiAgbWV0aG9kcy5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgc291cmNlW21ldGhvZF0gPSBzb3VyY2VbbWV0aG9kXS5iaW5kKHNvdXJjZSk7XG4gIH0pO1xuICByZXR1cm4gc291cmNlO1xufVxuLyoqXG4gKiBDYWxsIHRoZSBmaXJzdCBhcmd1bWVudCByZWNlaXZlZCBvbmx5IGlmIGl0J3MgYSBmdW5jdGlvbiBvdGhlcndpc2UgcmV0dXJuIGl0IGFzIGl0IGlzXG4gKiBAcGFyYW0gICB7Kn0gc291cmNlIC0gYW55dGhpbmdcbiAqIEByZXR1cm5zIHsqfSBhbnl0aGluZ1xuICovXG5cbmZ1bmN0aW9uIGNhbGxPckFzc2lnbihzb3VyY2UpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oc291cmNlKSA/IHNvdXJjZS5wcm90b3R5cGUgJiYgc291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA/IG5ldyBzb3VyY2UoKSA6IHNvdXJjZSgpIDogc291cmNlO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBzZXQgYW4gaW1tdXRhYmxlIHByb3BlcnR5XG4gKiBAcGFyYW0gICB7T2JqZWN0fSBzb3VyY2UgLSBvYmplY3Qgd2hlcmUgdGhlIG5ldyBwcm9wZXJ0eSB3aWxsIGJlIHNldFxuICogQHBhcmFtICAge3N0cmluZ30ga2V5IC0gb2JqZWN0IGtleSB3aGVyZSB0aGUgbmV3IHByb3BlcnR5IHdpbGwgYmUgc3RvcmVkXG4gKiBAcGFyYW0gICB7Kn0gdmFsdWUgLSB2YWx1ZSBvZiB0aGUgbmV3IHByb3BlcnR5XG4gKiBAcGFyYW0gICB7T2JqZWN0fSBvcHRpb25zIC0gc2V0IHRoZSBwcm9wZXJ5IG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gLSB0aGUgb3JpZ2luYWwgb2JqZWN0IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHNvdXJjZSwga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgZnAvbm8tbXV0YXRpbmctbWV0aG9kcyAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc291cmNlLCBrZXksIE9iamVjdC5hc3NpZ24oe1xuICAgIHZhbHVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSwgb3B0aW9ucykpO1xuICAvKiBlc2xpbnQtZW5hYmxlIGZwL25vLW11dGF0aW5nLW1ldGhvZHMgKi9cblxuICByZXR1cm4gc291cmNlO1xufVxuLyoqXG4gKiBEZWZpbmUgbXVsdGlwbGUgcHJvcGVydGllcyBvbiBhIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSAgIHtPYmplY3R9IHNvdXJjZSAtIG9iamVjdCB3aGVyZSB0aGUgbmV3IHByb3BlcnRpZXMgd2lsbCBiZSBzZXRcbiAqIEBwYXJhbSAgIHtPYmplY3R9IHByb3BlcnRpZXMgLSBvYmplY3QgY29udGFpbmluZyBhcyBrZXkgcGFpciB0aGUga2V5ICsgdmFsdWUgcHJvcGVydGllc1xuICogQHBhcmFtICAge09iamVjdH0gb3B0aW9ucyAtIHNldCB0aGUgcHJvcGVyeSBvdmVycmlkaW5nIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBvcmlnaW5hbCBvYmplY3QgbW9kaWZpZWRcbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHNvdXJjZSwgcHJvcGVydGllcywgb3B0aW9ucykge1xuICBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKS5mb3JFYWNoKChfcmVmKSA9PiB7XG4gICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWY7XG4gICAgZGVmaW5lUHJvcGVydHkoc291cmNlLCBrZXksIHZhbHVlLCBvcHRpb25zKTtcbiAgfSk7XG4gIHJldHVybiBzb3VyY2U7XG59XG4vKipcbiAqIERlZmluZSBkZWZhdWx0IHByb3BlcnRpZXMgaWYgdGhleSBkb24ndCBleGlzdCBvbiB0aGUgc291cmNlIG9iamVjdFxuICogQHBhcmFtICAge09iamVjdH0gc291cmNlIC0gb2JqZWN0IHRoYXQgd2lsbCByZWNlaXZlIHRoZSBkZWZhdWx0IHByb3BlcnRpZXNcbiAqIEBwYXJhbSAgIHtPYmplY3R9IGRlZmF1bHRzIC0gb2JqZWN0IGNvbnRhaW5pbmcgYWRkaXRpb25hbCBvcHRpb25hbCBrZXlzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgb3JpZ2luYWwgb2JqZWN0IHJlY2VpdmVkIGVuaGFuY2VkXG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lRGVmYXVsdHMoc291cmNlLCBkZWZhdWx0cykge1xuICBPYmplY3QuZW50cmllcyhkZWZhdWx0cykuZm9yRWFjaCgoX3JlZjIpID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjI7XG4gICAgaWYgKCFzb3VyY2Vba2V5XSkgc291cmNlW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBzb3VyY2U7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW55IERPTSBub2RlL3MgdG8gYSBsb29wYWJsZSBhcnJheVxuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudHxOb2RlTGlzdCB9IGVscyAtIHNpbmdsZSBodG1sIGVsZW1lbnQgb3IgYSBub2RlIGxpc3RcbiAqIEByZXR1cm5zIHsgQXJyYXkgfSBhbHdheXMgYSBsb29wYWJsZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZG9tVG9BcnJheShlbHMpIHtcbiAgLy8gY2FuIHRoaXMgb2JqZWN0IGJlIGFscmVhZHkgbG9vcGVkP1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZWxzKSkge1xuICAgIC8vIGlzIGl0IGEgbm9kZSBsaXN0P1xuICAgIGlmICgvXlxcW29iamVjdCAoSFRNTENvbGxlY3Rpb258Tm9kZUxpc3R8T2JqZWN0KVxcXSQvLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVscykpICYmIHR5cGVvZiBlbHMubGVuZ3RoID09PSAnbnVtYmVyJykgcmV0dXJuIEFycmF5LmZyb20oZWxzKTtlbHNlIC8vIGlmIGl0J3MgYSBzaW5nbGUgbm9kZVxuICAgICAgLy8gaXQgd2lsbCBiZSByZXR1cm5lZCBhcyBcImFycmF5XCIgd2l0aCBvbmUgc2luZ2xlIGVudHJ5XG4gICAgICByZXR1cm4gW2Vsc107XG4gIH0gLy8gdGhpcyBvYmplY3QgY291bGQgYmUgbG9vcGVkIG91dCBvZiB0aGUgYm94XG5cblxuICByZXR1cm4gZWxzO1xufVxuXG4vKipcbiAqIFNpbXBsZSBoZWxwZXIgdG8gZmluZCBET00gbm9kZXMgcmV0dXJuaW5nIHRoZW0gYXMgYXJyYXkgbGlrZSBsb29wYWJsZSBvYmplY3RcbiAqIEBwYXJhbSAgIHsgc3RyaW5nfERPTU5vZGVMaXN0IH0gc2VsZWN0b3IgLSBlaXRoZXIgdGhlIHF1ZXJ5IG9yIHRoZSBET00gbm9kZXMgdG8gYXJyYWlmeVxuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9ICAgICAgICBjdHggICAgICAtIGNvbnRleHQgZGVmaW5pbmcgd2hlcmUgdGhlIHF1ZXJ5IHdpbGwgc2VhcmNoIGZvciB0aGUgRE9NIG5vZGVzXG4gKiBAcmV0dXJucyB7IEFycmF5IH0gRE9NIG5vZGVzIGZvdW5kIGFzIGFycmF5XG4gKi9cblxuZnVuY3Rpb24gJChzZWxlY3RvciwgY3R4KSB7XG4gIHJldHVybiBkb21Ub0FycmF5KHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycgPyAoY3R4IHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSA6IHNlbGVjdG9yKTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIHJldHVybiB2YWx1ZXMsIGluIGNhc2Ugb2YgYSBzaW5nbGUgdmFsdWUgd2UgYXZvaWQgdG8gcmV0dXJuIGFuIGFycmF5XG4gKiBAcGFyYW0gICB7IEFycmF5IH0gdmFsdWVzIC0gbGlzdCBvZiB2YWx1ZXMgd2Ugd2FudCB0byByZXR1cm5cbiAqIEByZXR1cm5zIHsgQXJyYXl8c3RyaW5nfGJvb2xlYW4gfSBlaXRoZXIgdGhlIHdob2xlIGxpc3Qgb2YgdmFsdWVzIG9yIHRoZSBzaW5nbGUgb25lIGZvdW5kXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNvbnN0IG5vcm1hbGl6ZSA9IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID09PSAxID8gdmFsdWVzWzBdIDogdmFsdWVzO1xuLyoqXG4gKiBQYXJzZSBhbGwgdGhlIG5vZGVzIHJlY2VpdmVkIHRvIGdldC9yZW1vdmUvY2hlY2sgdGhlaXIgYXR0cmlidXRlc1xuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudHxOb2RlTGlzdHxBcnJheSB9IGVscyAgICAtIERPTSBub2RlL3MgdG8gcGFyc2VcbiAqIEBwYXJhbSAgIHsgc3RyaW5nfEFycmF5IH0gICAgICAgICAgICAgICBuYW1lICAgLSBuYW1lIG9yIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtICAgeyBzdHJpbmcgfSAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCAtIG1ldGhvZCB0aGF0IHdpbGwgYmUgdXNlZCB0byBwYXJzZSB0aGUgYXR0cmlidXRlc1xuICogQHJldHVybnMgeyBBcnJheXxzdHJpbmcgfSByZXN1bHQgb2YgdGhlIHBhcnNpbmcgaW4gYSBsaXN0IG9yIGEgc2luZ2xlIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VOb2RlcyhlbHMsIG5hbWUsIG1ldGhvZCkge1xuICBjb25zdCBuYW1lcyA9IHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyA/IFtuYW1lXSA6IG5hbWU7XG4gIHJldHVybiBub3JtYWxpemUoZG9tVG9BcnJheShlbHMpLm1hcChlbCA9PiB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZShuYW1lcy5tYXAobiA9PiBlbFttZXRob2RdKG4pKSk7XG4gIH0pKTtcbn1cbi8qKlxuICogU2V0IGFueSBhdHRyaWJ1dGUgb24gYSBzaW5nbGUgb3IgYSBsaXN0IG9mIERPTSBub2Rlc1xuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudHxOb2RlTGlzdHxBcnJheSB9IGVscyAgIC0gRE9NIG5vZGUvcyB0byBwYXJzZVxuICogQHBhcmFtICAgeyBzdHJpbmd8T2JqZWN0IH0gICAgICAgICAgICAgIG5hbWUgIC0gZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gc2V0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhIGxpc3Qgb2YgcHJvcGVydGllcyBhcyBvYmplY3Qga2V5IC0gdmFsdWVcbiAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gICAgICAgICAgICAgICAgICAgICB2YWx1ZSAtIHRoZSBuZXcgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyB7IEhUTUxFbGVtZW50fE5vZGVMaXN0fEFycmF5IH0gdGhlIG9yaWdpbmFsIGFycmF5IG9mIGVsZW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQgeyBzZXQgfSBmcm9tICdiaWFuY28uYXR0cidcbiAqXG4gKiBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKVxuICpcbiAqIHNldChpbWcsICd3aWR0aCcsIDEwMClcbiAqXG4gKiAvLyBvciBhbHNvXG4gKiBzZXQoaW1nLCB7XG4gKiAgIHdpZHRoOiAzMDAsXG4gKiAgIGhlaWdodDogMzAwXG4gKiB9KVxuICpcbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChlbHMsIG5hbWUsIHZhbHVlKSB7XG4gIGNvbnN0IGF0dHJzID0gdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnID8gbmFtZSA6IHtcbiAgICBbbmFtZV06IHZhbHVlXG4gIH07XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xuICBkb21Ub0FycmF5KGVscykuZm9yRWFjaChlbCA9PiB7XG4gICAgcHJvcHMuZm9yRWFjaChwcm9wID0+IGVsLnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyc1twcm9wXSkpO1xuICB9KTtcbiAgcmV0dXJuIGVscztcbn1cbi8qKlxuICogR2V0IGFueSBhdHRyaWJ1dGUgZnJvbSBhIHNpbmdsZSBvciBhIGxpc3Qgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50fE5vZGVMaXN0fEFycmF5IH0gZWxzICAgLSBET00gbm9kZS9zIHRvIHBhcnNlXG4gKiBAcGFyYW0gICB7IHN0cmluZ3xBcnJheSB9ICAgICAgICAgICAgICAgbmFtZSAgLSBuYW1lIG9yIGxpc3Qgb2YgYXR0cmlidXRlcyB0byBnZXRcbiAqIEByZXR1cm5zIHsgQXJyYXl8c3RyaW5nIH0gbGlzdCBvZiB0aGUgYXR0cmlidXRlcyBmb3VuZFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IHsgZ2V0IH0gZnJvbSAnYmlhbmNvLmF0dHInXG4gKlxuICogY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAqXG4gKiBnZXQoaW1nLCAnd2lkdGgnKSAvLyA9PiAnMjAwJ1xuICpcbiAqIC8vIG9yIGFsc29cbiAqIGdldChpbWcsIFsnd2lkdGgnLCAnaGVpZ2h0J10pIC8vID0+IFsnMjAwJywgJzMwMCddXG4gKlxuICogLy8gb3IgYWxzb1xuICogZ2V0KFtpbWcxLCBpbWcyXSwgWyd3aWR0aCcsICdoZWlnaHQnXSkgLy8gPT4gW1snMjAwJywgJzMwMCddLCBbJzUwMCcsICcyMDAnXV1cbiAqL1xuXG5mdW5jdGlvbiBnZXQoZWxzLCBuYW1lKSB7XG4gIHJldHVybiBwYXJzZU5vZGVzKGVscywgbmFtZSwgJ2dldEF0dHJpYnV0ZScpO1xufVxuXG5jb25zdCBDU1NfQllfTkFNRSA9IG5ldyBNYXAoKTtcbmNvbnN0IFNUWUxFX05PREVfU0VMRUNUT1IgPSAnc3R5bGVbcmlvdF0nOyAvLyBtZW1vaXplZCBjdXJyaWVkIGZ1bmN0aW9uXG5cbmNvbnN0IGdldFN0eWxlTm9kZSA9IChzdHlsZSA9PiB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgLy8gbGF6eSBldmFsdWF0aW9uOlxuICAgIC8vIGlmIHRoaXMgZnVuY3Rpb24gd2FzIGFscmVhZHkgY2FsbGVkIGJlZm9yZVxuICAgIC8vIHdlIHJldHVybiBpdHMgY2FjaGVkIHJlc3VsdFxuICAgIGlmIChzdHlsZSkgcmV0dXJuIHN0eWxlOyAvLyBjcmVhdGUgYSBuZXcgc3R5bGUgZWxlbWVudCBvciB1c2UgYW4gZXhpc3Rpbmcgb25lXG4gICAgLy8gYW5kIGNhY2hlIGl0IGludGVybmFsbHlcblxuICAgIHN0eWxlID0gJChTVFlMRV9OT0RFX1NFTEVDVE9SKVswXSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHNldChzdHlsZSwgJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgaWYgKCFzdHlsZS5wYXJlbnROb2RlKSBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG59KSgpO1xuLyoqXG4gKiBPYmplY3QgdGhhdCB3aWxsIGJlIHVzZWQgdG8gaW5qZWN0IGFuZCBtYW5hZ2UgdGhlIGNzcyBvZiBldmVyeSB0YWcgaW5zdGFuY2VcbiAqL1xuXG5cbnZhciBjc3NNYW5hZ2VyID0ge1xuICBDU1NfQllfTkFNRSxcblxuICAvKipcbiAgICogU2F2ZSBhIHRhZyBzdHlsZSB0byBiZSBsYXRlciBpbmplY3RlZCBpbnRvIERPTVxuICAgKiBAcGFyYW0geyBzdHJpbmcgfSBuYW1lIC0gaWYgaXQncyBwYXNzZWQgd2Ugd2lsbCBtYXAgdGhlIGNzcyB0byBhIHRhZ25hbWVcbiAgICogQHBhcmFtIHsgc3RyaW5nIH0gY3NzIC0gY3NzIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzZWxmXG4gICAqL1xuICBhZGQobmFtZSwgY3NzKSB7XG4gICAgaWYgKCFDU1NfQllfTkFNRS5oYXMobmFtZSkpIHtcbiAgICAgIENTU19CWV9OQU1FLnNldChuYW1lLCBjc3MpO1xuICAgICAgdGhpcy5pbmplY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogSW5qZWN0IGFsbCBwcmV2aW91c2x5IHNhdmVkIHRhZyBzdHlsZXMgaW50byBET01cbiAgICogaW5uZXJIVE1MIHNlZW1zIHNsb3c6IGh0dHA6Ly9qc3BlcmYuY29tL3Jpb3QtaW5zZXJ0LXN0eWxlXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHNlbGZcbiAgICovXG4gIGluamVjdCgpIHtcbiAgICBnZXRTdHlsZU5vZGUoKS5pbm5lckhUTUwgPSBbLi4uQ1NTX0JZX05BTUUudmFsdWVzKCldLmpvaW4oJ1xcbicpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB0YWcgc3R5bGUgZnJvbSB0aGUgRE9NXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGEgcmVnaXN0ZXJlZCB0YWduYW1lXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHNlbGZcbiAgICovXG4gIHJlbW92ZShuYW1lKSB7XG4gICAgaWYgKENTU19CWV9OQU1FLmhhcyhuYW1lKSkge1xuICAgICAgQ1NTX0JZX05BTUUuZGVsZXRlKG5hbWUpO1xuICAgICAgdGhpcy5pbmplY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGN1cnJ5IGFueSBqYXZhc2NyaXB0IG1ldGhvZFxuICogQHBhcmFtICAge0Z1bmN0aW9ufSAgZm4gLSB0aGUgdGFyZ2V0IGZ1bmN0aW9uIHdlIHdhbnQgdG8gY3VycnlcbiAqIEBwYXJhbSAgIHsuLi5bYXJnc119IGFjYyAtIGluaXRpYWwgYXJndW1lbnRzXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258Kn0gaXQgd2lsbCByZXR1cm4gYSBmdW5jdGlvbiB1bnRpbCB0aGUgdGFyZ2V0IGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCByZWNlaXZlIGFsbCBvZiBpdHMgYXJndW1lbnRzXG4gKi9cbmZ1bmN0aW9uIGN1cnJ5KGZuKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhY2MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFjY1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGFyZ3MgPSBbLi4uYWNjLCAuLi5hcmdzXTtcbiAgICByZXR1cm4gYXJncy5sZW5ndGggPCBmbi5sZW5ndGggPyBjdXJyeShmbiwgLi4uYXJncykgOiBmbiguLi5hcmdzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRhZyBuYW1lIG9mIGFueSBET00gbm9kZVxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gRE9NIG5vZGUgd2Ugd2FudCB0byBpbnNwZWN0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBuYW1lIHRvIGlkZW50aWZ5IHRoaXMgZG9tIG5vZGUgaW4gcmlvdFxuICovXG5cbmZ1bmN0aW9uIGdldE5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0KGVsZW1lbnQsIElTX0RJUkVDVElWRSkgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG59XG5cbmNvbnN0IENPTVBPTkVOVF9DT1JFX0hFTFBFUlMgPSBPYmplY3QuZnJlZXplKHtcbiAgLy8gY29tcG9uZW50IGhlbHBlcnNcbiAgJChzZWxlY3Rvcikge1xuICAgIHJldHVybiAkKHNlbGVjdG9yLCB0aGlzLnJvb3QpWzBdO1xuICB9LFxuXG4gICQkKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuICQoc2VsZWN0b3IsIHRoaXMucm9vdCk7XG4gIH1cblxufSk7XG5jb25zdCBQVVJFX0NPTVBPTkVOVF9BUEkgPSBPYmplY3QuZnJlZXplKHtcbiAgW01PVU5UX01FVEhPRF9LRVldOiBub29wLFxuICBbVVBEQVRFX01FVEhPRF9LRVldOiBub29wLFxuICBbVU5NT1VOVF9NRVRIT0RfS0VZXTogbm9vcFxufSk7XG5jb25zdCBDT01QT05FTlRfTElGRUNZQ0xFX01FVEhPRFMgPSBPYmplY3QuZnJlZXplKHtcbiAgW1NIT1VMRF9VUERBVEVfS0VZXTogbm9vcCxcbiAgW09OX0JFRk9SRV9NT1VOVF9LRVldOiBub29wLFxuICBbT05fTU9VTlRFRF9LRVldOiBub29wLFxuICBbT05fQkVGT1JFX1VQREFURV9LRVldOiBub29wLFxuICBbT05fVVBEQVRFRF9LRVldOiBub29wLFxuICBbT05fQkVGT1JFX1VOTU9VTlRfS0VZXTogbm9vcCxcbiAgW09OX1VOTU9VTlRFRF9LRVldOiBub29wXG59KTtcbmNvbnN0IE1PQ0tFRF9URU1QTEFURV9JTlRFUkZBQ0UgPSBPYmplY3QuYXNzaWduKHt9LCBQVVJFX0NPTVBPTkVOVF9BUEksIHtcbiAgY2xvbmU6IG5vb3AsXG4gIGNyZWF0ZURPTTogbm9vcFxufSk7XG4vKipcbiAqIEV2YWx1YXRlIHRoZSBjb21wb25lbnQgcHJvcGVydGllcyBlaXRoZXIgZnJvbSBpdHMgcmVhbCBhdHRyaWJ1dGVzIG9yIGZyb20gaXRzIGluaXRpYWwgdXNlciBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBjb21wb25lbnQgcm9vdFxuICogQHBhcmFtICAge09iamVjdH0gIGluaXRpYWxQcm9wcyAtIGluaXRpYWwgcHJvcHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGNvbXBvbmVudCBwcm9wcyBrZXkgdmFsdWUgcGFpcnNcbiAqL1xuXG5mdW5jdGlvbiBldmFsdWF0ZUluaXRpYWxQcm9wcyhlbGVtZW50LCBpbml0aWFsUHJvcHMpIHtcbiAgaWYgKGluaXRpYWxQcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgaW5pdGlhbFByb3BzID0ge307XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgRE9NYXR0cmlidXRlc1RvT2JqZWN0KGVsZW1lbnQpLCBjYWxsT3JBc3NpZ24oaW5pdGlhbFByb3BzKSk7XG59XG4vKipcbiAqIEJpbmQgYSBET00gbm9kZSB0byBpdHMgY29tcG9uZW50IG9iamVjdFxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBub2RlIC0gaHRtbCBub2RlIG1vdW50ZWRcbiAqIEBwYXJhbSAgIHtPYmplY3R9IGNvbXBvbmVudCAtIFJpb3QuanMgY29tcG9uZW50IG9iamVjdFxuICogQHJldHVybnMge09iamVjdH0gdGhlIGNvbXBvbmVudCBvYmplY3QgcmVjZWl2ZWQgYXMgc2Vjb25kIGFyZ3VtZW50XG4gKi9cblxuXG5jb25zdCBiaW5kRE9NTm9kZVRvQ29tcG9uZW50T2JqZWN0ID0gKG5vZGUsIGNvbXBvbmVudCkgPT4gbm9kZVtET01fQ09NUE9ORU5UX0lOU1RBTkNFX1BST1BFUlRZXSA9IGNvbXBvbmVudDtcbi8qKlxuICogV3JhcCB0aGUgUmlvdC5qcyBjb3JlIEFQSSBtZXRob2RzIHVzaW5nIGEgbWFwcGluZyBmdW5jdGlvblxuICogQHBhcmFtICAge0Z1bmN0aW9ufSBtYXBGdW5jdGlvbiAtIGxpZnRpbmcgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IGFuIG9iamVjdCBoYXZpbmcgdGhlIHsgbW91bnQsIHVwZGF0ZSwgdW5tb3VudCB9IGZ1bmN0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQ29yZUFQSU1ldGhvZHMobWFwRnVuY3Rpb24pIHtcbiAgcmV0dXJuIFtNT1VOVF9NRVRIT0RfS0VZLCBVUERBVEVfTUVUSE9EX0tFWSwgVU5NT1VOVF9NRVRIT0RfS0VZXS5yZWR1Y2UoKGFjYywgbWV0aG9kKSA9PiB7XG4gICAgYWNjW21ldGhvZF0gPSBtYXBGdW5jdGlvbihtZXRob2QpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGNvbXBvbmVudCB0ZW1wbGF0ZXMgb25seSBvbmNlXG4gKiBAcGFyYW0gICB7RnVuY3Rpb259IHRlbXBsYXRlIC0gY29tcG9uZW50IHRlbXBsYXRlIGNyZWF0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBjb21wb25lbnRzIC0gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lc3RlZCBjb21wb25lbnRzXG4gKiBAcmV0dXJucyB7VGVtcGxhdGVDaHVua30gdGVtcGxhdGUgY2h1bmsgb2JqZWN0XG4gKi9cblxuXG5mdW5jdGlvbiBjb21wb25lbnRUZW1wbGF0ZUZhY3RvcnkodGVtcGxhdGUsIGNvbXBvbmVudHMpIHtcbiAgcmV0dXJuIHRlbXBsYXRlKGNyZWF0ZSQ2LCBleHByZXNzaW9uVHlwZXMsIGJpbmRpbmdUeXBlcywgbmFtZSA9PiB7XG4gICAgcmV0dXJuIGNvbXBvbmVudHNbbmFtZV0gfHwgQ09NUE9ORU5UU19JTVBMRU1FTlRBVElPTl9NQVAuZ2V0KG5hbWUpO1xuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcHVyZSBjb21wb25lbnRcbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gcHVyZUZhY3RvcnlGdW5jdGlvbiAtIHB1cmUgY29tcG9uZW50IGZhY3RvcnkgZnVuY3Rpb25cbiAqIEBwYXJhbSAgIHtBcnJheX0gb3B0aW9ucy5zbG90cyAtIGNvbXBvbmVudCBzbG90c1xuICogQHBhcmFtICAge0FycmF5fSBvcHRpb25zLmF0dHJpYnV0ZXMgLSBjb21wb25lbnQgYXR0cmlidXRlc1xuICogQHBhcmFtICAge0FycmF5fSBvcHRpb25zLnRlbXBsYXRlIC0gdGVtcGxhdGUgZmFjdG9yeSBmdW5jdGlvblxuICogQHBhcmFtICAge0FycmF5fSBvcHRpb25zLnRlbXBsYXRlIC0gdGVtcGxhdGUgZmFjdG9yeSBmdW5jdGlvblxuICogQHBhcmFtICAge2FueX0gb3B0aW9ucy5wcm9wcyAtIGluaXRpYWwgY29tcG9uZW50IHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IHB1cmUgY29tcG9uZW50IG9iamVjdFxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlUHVyZUNvbXBvbmVudChwdXJlRmFjdG9yeUZ1bmN0aW9uLCBfcmVmKSB7XG4gIGxldCB7XG4gICAgc2xvdHMsXG4gICAgYXR0cmlidXRlcyxcbiAgICBwcm9wcyxcbiAgICBjc3MsXG4gICAgdGVtcGxhdGVcbiAgfSA9IF9yZWY7XG4gIGlmICh0ZW1wbGF0ZSkgcGFuaWMoJ1B1cmUgY29tcG9uZW50cyBjYW4gbm90IGhhdmUgaHRtbCcpO1xuICBpZiAoY3NzKSBwYW5pYygnUHVyZSBjb21wb25lbnRzIGRvIG5vdCBoYXZlIGNzcycpO1xuICBjb25zdCBjb21wb25lbnQgPSBkZWZpbmVEZWZhdWx0cyhwdXJlRmFjdG9yeUZ1bmN0aW9uKHtcbiAgICBzbG90cyxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIHByb3BzXG4gIH0pLCBQVVJFX0NPTVBPTkVOVF9BUEkpO1xuICByZXR1cm4gY3JlYXRlQ29yZUFQSU1ldGhvZHMobWV0aG9kID0+IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgLy8gaW50ZXJjZXB0IHRoZSBtb3VudCBjYWxscyB0byBiaW5kIHRoZSBET00gbm9kZSB0byB0aGUgcHVyZSBvYmplY3QgY3JlYXRlZFxuICAgIC8vIHNlZSBhbHNvIGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L3Jpb3QvaXNzdWVzLzI4MDZcbiAgICBpZiAobWV0aG9kID09PSBNT1VOVF9NRVRIT0RfS0VZKSB7XG4gICAgICBjb25zdCBbZWxdID0gYXJncztcbiAgICAgIGJpbmRET01Ob2RlVG9Db21wb25lbnRPYmplY3QoZWwsIGNvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50W21ldGhvZF0oLi4uYXJncyk7XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgY29tcG9uZW50IGludGVyZmFjZSBuZWVkZWQgZm9yIHRoZSBAcmlvdGpzL2RvbS1iaW5kaW5ncyB0YWcgYmluZGluZ3NcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG9wdGlvbnMuY3NzIC0gY29tcG9uZW50IGNzc1xuICogQHBhcmFtICAge0Z1bmN0aW9ufSBvcHRpb25zLnRlbXBsYXRlIC0gZnVuY3RvbiB0aGF0IHdpbGwgcmV0dXJuIHRoZSBkb20tYmluZGluZ3MgdGVtcGxhdGUgZnVuY3Rpb25cbiAqIEBwYXJhbSAgIHtPYmplY3R9IG9wdGlvbnMuZXhwb3J0cyAtIGNvbXBvbmVudCBpbnRlcmZhY2VcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG9wdGlvbnMubmFtZSAtIGNvbXBvbmVudCBuYW1lXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjb21wb25lbnQgbGlrZSBpbnRlcmZhY2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudChfcmVmMikge1xuICBsZXQge1xuICAgIGNzcyxcbiAgICB0ZW1wbGF0ZSxcbiAgICBleHBvcnRzLFxuICAgIG5hbWVcbiAgfSA9IF9yZWYyO1xuICBjb25zdCB0ZW1wbGF0ZUZuID0gdGVtcGxhdGUgPyBjb21wb25lbnRUZW1wbGF0ZUZhY3RvcnkodGVtcGxhdGUsIGV4cG9ydHMgPyBjcmVhdGVTdWJjb21wb25lbnRzKGV4cG9ydHMuY29tcG9uZW50cykgOiB7fSkgOiBNT0NLRURfVEVNUExBVEVfSU5URVJGQUNFO1xuICByZXR1cm4gKF9yZWYzKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHNsb3RzLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIHByb3BzXG4gICAgfSA9IF9yZWYzO1xuICAgIC8vIHB1cmUgY29tcG9uZW50cyByZW5kZXJpbmcgd2lsbCBiZSBtYW5hZ2VkIGJ5IHRoZSBlbmQgdXNlclxuICAgIGlmIChleHBvcnRzICYmIGV4cG9ydHNbSVNfUFVSRV9TWU1CT0xdKSByZXR1cm4gY3JlYXRlUHVyZUNvbXBvbmVudChleHBvcnRzLCB7XG4gICAgICBzbG90cyxcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBwcm9wcyxcbiAgICAgIGNzcyxcbiAgICAgIHRlbXBsYXRlXG4gICAgfSk7XG4gICAgY29uc3QgY29tcG9uZW50QVBJID0gY2FsbE9yQXNzaWduKGV4cG9ydHMpIHx8IHt9O1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGRlZmluZUNvbXBvbmVudCh7XG4gICAgICBjc3MsXG4gICAgICB0ZW1wbGF0ZTogdGVtcGxhdGVGbixcbiAgICAgIGNvbXBvbmVudEFQSSxcbiAgICAgIG5hbWVcbiAgICB9KSh7XG4gICAgICBzbG90cyxcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBwcm9wc1xuICAgIH0pOyAvLyBub3RpY2UgdGhhdCBmb3IgdGhlIGNvbXBvbmVudHMgY3JlYXRlIHZpYSB0YWcgYmluZGluZ1xuICAgIC8vIHdlIG5lZWQgdG8gaW52ZXJ0IHRoZSBtb3VudCAoc3RhdGUvcGFyZW50U2NvcGUpIGFyZ3VtZW50c1xuICAgIC8vIHRoZSB0ZW1wbGF0ZSBiaW5kaW5ncyB3aWxsIG9ubHkgZm9yd2FyZCB0aGUgcGFyZW50U2NvcGUgdXBkYXRlc1xuICAgIC8vIGFuZCBuZXZlciBkZWFsIHdpdGggdGhlIGNvbXBvbmVudCBzdGF0ZVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1vdW50KGVsZW1lbnQsIHBhcmVudFNjb3BlLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50Lm1vdW50KGVsZW1lbnQsIHN0YXRlLCBwYXJlbnRTY29wZSk7XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGUocGFyZW50U2NvcGUsIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQudXBkYXRlKHN0YXRlLCBwYXJlbnRTY29wZSk7XG4gICAgICB9LFxuXG4gICAgICB1bm1vdW50KHByZXNlcnZlUm9vdCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50LnVubW91bnQocHJlc2VydmVSb290KTtcbiAgICAgIH1cblxuICAgIH07XG4gIH07XG59XG4vKipcbiAqIENvbXBvbmVudCBkZWZpbml0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBpbXBsZW1lbnRhdGlvbiAtIHRoZSBjb21wb25lbiBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIGdlbmVyYXRlZCB2aWEgY29tcGlsZXJcbiAqIEBwYXJhbSAgIHtPYmplY3R9IGNvbXBvbmVudCAtIHRoZSBjb21wb25lbnQgaW5pdGlhbCBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhIG5ldyBjb21wb25lbnQgaW1wbGVtZW50YXRpb24gb2JqZWN0XG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KF9yZWY0KSB7XG4gIGxldCB7XG4gICAgY3NzLFxuICAgIHRlbXBsYXRlLFxuICAgIGNvbXBvbmVudEFQSSxcbiAgICBuYW1lXG4gIH0gPSBfcmVmNDtcbiAgLy8gYWRkIHRoZSBjb21wb25lbnQgY3NzIGludG8gdGhlIERPTVxuICBpZiAoY3NzICYmIG5hbWUpIGNzc01hbmFnZXIuYWRkKG5hbWUsIGNzcyk7XG4gIHJldHVybiBjdXJyeShlbmhhbmNlQ29tcG9uZW50QVBJKShkZWZpbmVQcm9wZXJ0aWVzKCAvLyBzZXQgdGhlIGNvbXBvbmVudCBkZWZhdWx0cyB3aXRob3V0IG92ZXJyaWRpbmcgdGhlIG9yaWdpbmFsIGNvbXBvbmVudCBBUElcbiAgZGVmaW5lRGVmYXVsdHMoY29tcG9uZW50QVBJLCBPYmplY3QuYXNzaWduKHt9LCBDT01QT05FTlRfTElGRUNZQ0xFX01FVEhPRFMsIHtcbiAgICBbU1RBVEVfS0VZXToge31cbiAgfSkpLCBPYmplY3QuYXNzaWduKHtcbiAgICAvLyBkZWZpbmVkIGR1cmluZyB0aGUgY29tcG9uZW50IGNyZWF0aW9uXG4gICAgW1NMT1RTX0tFWV06IG51bGwsXG4gICAgW1JPT1RfS0VZXTogbnVsbFxuICB9LCBDT01QT05FTlRfQ09SRV9IRUxQRVJTLCB7XG4gICAgbmFtZSxcbiAgICBjc3MsXG4gICAgdGVtcGxhdGVcbiAgfSkpKTtcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBiaW5kaW5ncyB0byB1cGRhdGUgdGhlIGNvbXBvbmVudCBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9IG5vZGUgLSBub2RlIHdoZXJlIHdlIHdpbGwgYmluZCB0aGUgZXhwcmVzc2lvbnNcbiAqIEBwYXJhbSAgIHtBcnJheX0gYXR0cmlidXRlcyAtIGxpc3Qgb2YgYXR0cmlidXRlIGJpbmRpbmdzXG4gKiBAcmV0dXJucyB7VGVtcGxhdGVDaHVua30gLSB0ZW1wbGF0ZSBiaW5kaW5ncyBvYmplY3RcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVBdHRyaWJ1dGVCaW5kaW5ncyhub2RlLCBhdHRyaWJ1dGVzKSB7XG4gIGlmIChhdHRyaWJ1dGVzID09PSB2b2lkIDApIHtcbiAgICBhdHRyaWJ1dGVzID0gW107XG4gIH1cblxuICBjb25zdCBleHByZXNzaW9ucyA9IGF0dHJpYnV0ZXMubWFwKGEgPT4gY3JlYXRlJDIobm9kZSwgYSkpO1xuICBjb25zdCBiaW5kaW5nID0ge307XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGJpbmRpbmcsIE9iamVjdC5hc3NpZ24oe1xuICAgIGV4cHJlc3Npb25zXG4gIH0sIGNyZWF0ZUNvcmVBUElNZXRob2RzKG1ldGhvZCA9PiBzY29wZSA9PiB7XG4gICAgZXhwcmVzc2lvbnMuZm9yRWFjaChlID0+IGVbbWV0aG9kXShzY29wZSkpO1xuICAgIHJldHVybiBiaW5kaW5nO1xuICB9KSkpO1xufVxuLyoqXG4gKiBDcmVhdGUgdGhlIHN1YmNvbXBvbmVudHMgdGhhdCBjYW4gYmUgaW5jbHVkZWQgaW5zaWRlIGEgdGFnIGluIHJ1bnRpbWVcbiAqIEBwYXJhbSAgIHtPYmplY3R9IGNvbXBvbmVudHMgLSBjb21wb25lbnRzIGltcG9ydGVkIGluIHJ1bnRpbWVcbiAqIEByZXR1cm5zIHtPYmplY3R9IGFsbCB0aGUgY29tcG9uZW50cyB0cmFuc2Zvcm1lZCBpbnRvIFJpb3QuQ29tcG9uZW50IGZhY3RvcnkgZnVuY3Rpb25zXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVTdWJjb21wb25lbnRzKGNvbXBvbmVudHMpIHtcbiAgaWYgKGNvbXBvbmVudHMgPT09IHZvaWQgMCkge1xuICAgIGNvbXBvbmVudHMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhjYWxsT3JBc3NpZ24oY29tcG9uZW50cykpLnJlZHVjZSgoYWNjLCBfcmVmNSkgPT4ge1xuICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmNTtcbiAgICBhY2NbY2FtZWxUb0Rhc2hDYXNlKGtleSldID0gY3JlYXRlQ29tcG9uZW50KHZhbHVlKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG4vKipcbiAqIFJ1biB0aGUgY29tcG9uZW50IGluc3RhbmNlIHRocm91Z2ggYWxsIHRoZSBwbHVnaW5zIHNldCBieSB0aGUgdXNlclxuICogQHBhcmFtICAge09iamVjdH0gY29tcG9uZW50IC0gY29tcG9uZW50IGluc3RhbmNlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgY29tcG9uZW50IGVuaGFuY2VkIGJ5IHRoZSBwbHVnaW5zXG4gKi9cblxuXG5mdW5jdGlvbiBydW5QbHVnaW5zKGNvbXBvbmVudCkge1xuICByZXR1cm4gWy4uLlBMVUdJTlNfU0VUXS5yZWR1Y2UoKGMsIGZuKSA9PiBmbihjKSB8fCBjLCBjb21wb25lbnQpO1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBjb21wb25lbnQgY3VycmVudCBzdGF0ZSBtZXJnaW5nIGl0IHdpdGggaXRzIHByZXZpb3VzIHN0YXRlXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBvbGRTdGF0ZSAtIHByZXZpb3VzIHN0YXRlIG9iamVjdFxuICogQHBhcmFtICAge09iamVjdH0gbmV3U3RhdGUgLSBuZXcgc3RhdGUgZ2l2ZW50IHRvIHRoZSBgdXBkYXRlYCBjYWxsXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXcgb2JqZWN0IHN0YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBjb21wdXRlU3RhdGUob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvbGRTdGF0ZSwgY2FsbE9yQXNzaWduKG5ld1N0YXRlKSk7XG59XG4vKipcbiAqIEFkZCBldmVudHVhbGx5IHRoZSBcImlzXCIgYXR0cmlidXRlIHRvIGxpbmsgdGhpcyBET00gbm9kZSB0byBpdHMgY3NzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gdGFyZ2V0IHJvb3Qgbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSBjb21wb25lbnQgbW91bnRlZFxuICogQHJldHVybnMge3VuZGVmaW5lZH0gaXQncyBhIHZvaWQgZnVuY3Rpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZENzc0hvb2soZWxlbWVudCwgbmFtZSkge1xuICBpZiAoZ2V0TmFtZShlbGVtZW50KSAhPT0gbmFtZSkge1xuICAgIHNldChlbGVtZW50LCBJU19ESVJFQ1RJVkUsIG5hbWUpO1xuICB9XG59XG4vKipcbiAqIENvbXBvbmVudCBjcmVhdGlvbiBmYWN0b3J5IGZ1bmN0aW9uIHRoYXQgd2lsbCBlbmhhbmNlIHRoZSB1c2VyIHByb3ZpZGVkIEFQSVxuICogQHBhcmFtICAge09iamVjdH0gY29tcG9uZW50IC0gYSBjb21wb25lbnQgaW1wbGVtZW50YXRpb24gcHJldmlvdXNseSBkZWZpbmVkXG4gKiBAcGFyYW0gICB7QXJyYXl9IG9wdGlvbnMuc2xvdHMgLSBjb21wb25lbnQgc2xvdHMgZ2VuZXJhdGVkIHZpYSByaW90IGNvbXBpbGVyXG4gKiBAcGFyYW0gICB7QXJyYXl9IG9wdGlvbnMuYXR0cmlidXRlcyAtIGF0dHJpYnV0ZSBleHByZXNzaW9ucyBnZW5lcmF0ZWQgdmlhIHJpb3QgY29tcGlsZXJcbiAqIEByZXR1cm5zIHtSaW90LkNvbXBvbmVudH0gYSByaW90IGNvbXBvbmVudCBpbnN0YW5jZVxuICovXG5cblxuZnVuY3Rpb24gZW5oYW5jZUNvbXBvbmVudEFQSShjb21wb25lbnQsIF9yZWY2KSB7XG4gIGxldCB7XG4gICAgc2xvdHMsXG4gICAgYXR0cmlidXRlcyxcbiAgICBwcm9wc1xuICB9ID0gX3JlZjY7XG4gIHJldHVybiBhdXRvYmluZE1ldGhvZHMocnVuUGx1Z2lucyhkZWZpbmVQcm9wZXJ0aWVzKE9iamVjdC5jcmVhdGUoY29tcG9uZW50KSwge1xuICAgIG1vdW50KGVsZW1lbnQsIHN0YXRlLCBwYXJlbnRTY29wZSkge1xuICAgICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgc3RhdGUgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tBVFRSSUJVVEVTX0tFWV9TWU1CT0xdID0gY3JlYXRlQXR0cmlidXRlQmluZGluZ3MoZWxlbWVudCwgYXR0cmlidXRlcykubW91bnQocGFyZW50U2NvcGUpO1xuICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgUFJPUFNfS0VZLCBPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oe30sIGV2YWx1YXRlSW5pdGlhbFByb3BzKGVsZW1lbnQsIHByb3BzKSwgZXZhbHVhdGVBdHRyaWJ1dGVFeHByZXNzaW9ucyh0aGlzW0FUVFJJQlVURVNfS0VZX1NZTUJPTF0uZXhwcmVzc2lvbnMpKSkpO1xuICAgICAgdGhpc1tTVEFURV9LRVldID0gY29tcHV0ZVN0YXRlKHRoaXNbU1RBVEVfS0VZXSwgc3RhdGUpO1xuICAgICAgdGhpc1tURU1QTEFURV9LRVlfU1lNQk9MXSA9IHRoaXMudGVtcGxhdGUuY3JlYXRlRE9NKGVsZW1lbnQpLmNsb25lKCk7IC8vIGxpbmsgdGhpcyBvYmplY3QgdG8gdGhlIERPTSBub2RlXG5cbiAgICAgIGJpbmRET01Ob2RlVG9Db21wb25lbnRPYmplY3QoZWxlbWVudCwgdGhpcyk7IC8vIGFkZCBldmVudHVhbGx5IHRoZSAnaXMnIGF0dHJpYnV0ZVxuXG4gICAgICBjb21wb25lbnQubmFtZSAmJiBhZGRDc3NIb29rKGVsZW1lbnQsIGNvbXBvbmVudC5uYW1lKTsgLy8gZGVmaW5lIHRoZSByb290IGVsZW1lbnRcblxuICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgUk9PVF9LRVksIGVsZW1lbnQpOyAvLyBkZWZpbmUgdGhlIHNsb3RzIGFycmF5XG5cbiAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsIFNMT1RTX0tFWSwgc2xvdHMpOyAvLyBiZWZvcmUgbW91bnQgbGlmZWN5Y2xlIGV2ZW50XG5cbiAgICAgIHRoaXNbT05fQkVGT1JFX01PVU5UX0tFWV0odGhpc1tQUk9QU19LRVldLCB0aGlzW1NUQVRFX0tFWV0pO1xuICAgICAgdGhpc1tQQVJFTlRfS0VZX1NZTUJPTF0gPSBwYXJlbnRTY29wZTsgLy8gbW91bnQgdGhlIHRlbXBsYXRlXG5cbiAgICAgIHRoaXNbVEVNUExBVEVfS0VZX1NZTUJPTF0ubW91bnQoZWxlbWVudCwgdGhpcywgcGFyZW50U2NvcGUpO1xuICAgICAgdGhpc1tPTl9NT1VOVEVEX0tFWV0odGhpc1tQUk9QU19LRVldLCB0aGlzW1NUQVRFX0tFWV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHVwZGF0ZShzdGF0ZSwgcGFyZW50U2NvcGUpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHN0YXRlID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnRTY29wZSkge1xuICAgICAgICB0aGlzW1BBUkVOVF9LRVlfU1lNQk9MXSA9IHBhcmVudFNjb3BlO1xuICAgICAgICB0aGlzW0FUVFJJQlVURVNfS0VZX1NZTUJPTF0udXBkYXRlKHBhcmVudFNjb3BlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3UHJvcHMgPSBldmFsdWF0ZUF0dHJpYnV0ZUV4cHJlc3Npb25zKHRoaXNbQVRUUklCVVRFU19LRVlfU1lNQk9MXS5leHByZXNzaW9ucyk7XG4gICAgICBpZiAodGhpc1tTSE9VTERfVVBEQVRFX0tFWV0obmV3UHJvcHMsIHRoaXNbUFJPUFNfS0VZXSkgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBQUk9QU19LRVksIE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgdGhpc1tQUk9QU19LRVldLCBuZXdQcm9wcykpKTtcbiAgICAgIHRoaXNbU1RBVEVfS0VZXSA9IGNvbXB1dGVTdGF0ZSh0aGlzW1NUQVRFX0tFWV0sIHN0YXRlKTtcbiAgICAgIHRoaXNbT05fQkVGT1JFX1VQREFURV9LRVldKHRoaXNbUFJPUFNfS0VZXSwgdGhpc1tTVEFURV9LRVldKTtcbiAgICAgIHRoaXNbVEVNUExBVEVfS0VZX1NZTUJPTF0udXBkYXRlKHRoaXMsIHRoaXNbUEFSRU5UX0tFWV9TWU1CT0xdKTtcbiAgICAgIHRoaXNbT05fVVBEQVRFRF9LRVldKHRoaXNbUFJPUFNfS0VZXSwgdGhpc1tTVEFURV9LRVldKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB1bm1vdW50KHByZXNlcnZlUm9vdCkge1xuICAgICAgdGhpc1tPTl9CRUZPUkVfVU5NT1VOVF9LRVldKHRoaXNbUFJPUFNfS0VZXSwgdGhpc1tTVEFURV9LRVldKTtcbiAgICAgIHRoaXNbQVRUUklCVVRFU19LRVlfU1lNQk9MXS51bm1vdW50KCk7IC8vIGlmIHRoZSBwcmVzZXJ2ZVJvb3QgaXMgbnVsbCB0aGUgdGVtcGxhdGUgaHRtbCB3aWxsIGJlIGxlZnQgdW50b3VjaGVkXG4gICAgICAvLyBpbiB0aGF0IGNhc2UgdGhlIERPTSBjbGVhbnVwIHdpbGwgaGFwcGVuIGRpZmZlcmVudGx5IGZyb20gYSBwYXJlbnQgbm9kZVxuXG4gICAgICB0aGlzW1RFTVBMQVRFX0tFWV9TWU1CT0xdLnVubW91bnQodGhpcywgdGhpc1tQQVJFTlRfS0VZX1NZTUJPTF0sIHByZXNlcnZlUm9vdCA9PT0gbnVsbCA/IG51bGwgOiAhcHJlc2VydmVSb290KTtcbiAgICAgIHRoaXNbT05fVU5NT1VOVEVEX0tFWV0odGhpc1tQUk9QU19LRVldLCB0aGlzW1NUQVRFX0tFWV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gIH0pKSwgT2JqZWN0LmtleXMoY29tcG9uZW50KS5maWx0ZXIocHJvcCA9PiBpc0Z1bmN0aW9uKGNvbXBvbmVudFtwcm9wXSkpKTtcbn1cbi8qKlxuICogQ29tcG9uZW50IGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uIHN0YXJ0aW5nIGZyb20gYSBET00gbm9kZVxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byB1cGdyYWRlXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBpbml0aWFsUHJvcHMgLSBpbml0aWFsIGNvbXBvbmVudCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBjb21wb25lbnROYW1lIC0gY29tcG9uZW50IGlkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhIG5ldyBjb21wb25lbnQgaW5zdGFuY2UgYm91bmQgdG8gYSBET00gbm9kZVxuICovXG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50KGVsZW1lbnQsIGluaXRpYWxQcm9wcywgY29tcG9uZW50TmFtZSkge1xuICBjb25zdCBuYW1lID0gY29tcG9uZW50TmFtZSB8fCBnZXROYW1lKGVsZW1lbnQpO1xuICBpZiAoIUNPTVBPTkVOVFNfSU1QTEVNRU5UQVRJT05fTUFQLmhhcyhuYW1lKSkgcGFuaWMoYFRoZSBjb21wb25lbnQgbmFtZWQgXCIke25hbWV9XCIgd2FzIG5ldmVyIHJlZ2lzdGVyZWRgKTtcbiAgY29uc3QgY29tcG9uZW50ID0gQ09NUE9ORU5UU19JTVBMRU1FTlRBVElPTl9NQVAuZ2V0KG5hbWUpKHtcbiAgICBwcm9wczogaW5pdGlhbFByb3BzXG4gIH0pO1xuICByZXR1cm4gY29tcG9uZW50Lm1vdW50KGVsZW1lbnQpO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gY29tcG9zZSBidXQgcGVyZm9ybXMgZnJvbSBsZWZ0LXRvLXJpZ2h0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uLjxici8+XG4gKiB7QGxpbmsgaHR0cHM6Ly8zMHNlY29uZHNvZmNvZGUub3JnL2Z1bmN0aW9uI2NvbXBvc2VyaWdodCBzZWUgYWxzb31cbiAqIEBwYXJhbSAgIHsuLi5bZnVuY3Rpb25dfSBmbnMpIC0gbGlzdCBvZiB1bmFyeSBmdW5jdGlvblxuICogQHJldHVybnMgeyp9IHJlc3VsdCBvZiB0aGUgY29tcHV0YXRpb25cbiAqL1xuLyoqXG4gKiBQZXJmb3JtcyByaWdodC10by1sZWZ0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uLjxici8+XG4gKiBVc2UgQXJyYXkucHJvdG90eXBlLnJlZHVjZSgpIHRvIHBlcmZvcm0gcmlnaHQtdG8tbGVmdCBmdW5jdGlvbiBjb21wb3NpdGlvbi48YnIvPlxuICogVGhlIGxhc3QgKHJpZ2h0bW9zdCkgZnVuY3Rpb24gY2FuIGFjY2VwdCBvbmUgb3IgbW9yZSBhcmd1bWVudHM7IHRoZSByZW1haW5pbmcgZnVuY3Rpb25zIG11c3QgYmUgdW5hcnkuPGJyLz5cbiAqIHtAbGluayBodHRwczovLzMwc2Vjb25kc29mY29kZS5vcmcvZnVuY3Rpb24jY29tcG9zZSBvcmlnaW5hbCBzb3VyY2UgY29kZX1cbiAqIEBwYXJhbSAgIHsuLi5bZnVuY3Rpb25dfSBmbnMpIC0gbGlzdCBvZiB1bmFyeSBmdW5jdGlvblxuICogQHJldHVybnMgeyp9IHJlc3VsdCBvZiB0aGUgY29tcHV0YXRpb25cbiAqL1xuXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZucyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIGZuc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgcmV0dXJuIGZucy5yZWR1Y2UoKGYsIGcpID0+IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZihnKC4uLmFyZ3VtZW50cykpO1xuICB9KTtcbn1cblxuY29uc3Qge1xuICBET01fQ09NUE9ORU5UX0lOU1RBTkNFX1BST1BFUlRZOiBET01fQ09NUE9ORU5UX0lOU1RBTkNFX1BST1BFUlRZJDEsXG4gIENPTVBPTkVOVFNfSU1QTEVNRU5UQVRJT05fTUFQOiBDT01QT05FTlRTX0lNUExFTUVOVEFUSU9OX01BUCQxLFxuICBQTFVHSU5TX1NFVDogUExVR0lOU19TRVQkMVxufSA9IGdsb2JhbHM7XG4vKipcbiAqIFJpb3QgcHVibGljIGFwaVxuICovXG5cbi8qKlxuICogUmVnaXN0ZXIgYSBjdXN0b20gdGFnIGJ5IG5hbWVcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWUgLSBjb21wb25lbnQgbmFtZVxuICogQHBhcmFtICAge09iamVjdH0gaW1wbGVtZW50YXRpb24gLSB0YWcgaW1wbGVtZW50YXRpb25cbiAqIEByZXR1cm5zIHtNYXB9IG1hcCBjb250YWluaW5nIGFsbCB0aGUgY29tcG9uZW50cyBpbXBsZW1lbnRhdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiByZWdpc3RlcihuYW1lLCBfcmVmKSB7XG4gIGxldCB7XG4gICAgY3NzLFxuICAgIHRlbXBsYXRlLFxuICAgIGV4cG9ydHNcbiAgfSA9IF9yZWY7XG4gIGlmIChDT01QT05FTlRTX0lNUExFTUVOVEFUSU9OX01BUCQxLmhhcyhuYW1lKSkgcGFuaWMoYFRoZSBjb21wb25lbnQgXCIke25hbWV9XCIgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZGApO1xuICBDT01QT05FTlRTX0lNUExFTUVOVEFUSU9OX01BUCQxLnNldChuYW1lLCBjcmVhdGVDb21wb25lbnQoe1xuICAgIG5hbWUsXG4gICAgY3NzLFxuICAgIHRlbXBsYXRlLFxuICAgIGV4cG9ydHNcbiAgfSkpO1xuICByZXR1cm4gQ09NUE9ORU5UU19JTVBMRU1FTlRBVElPTl9NQVAkMTtcbn1cbi8qKlxuICogVW5yZWdpc3RlciBhIHJpb3Qgd2ViIGNvbXBvbmVudFxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZSAtIGNvbXBvbmVudCBuYW1lXG4gKiBAcmV0dXJucyB7TWFwfSBtYXAgY29udGFpbmluZyBhbGwgdGhlIGNvbXBvbmVudHMgaW1wbGVtZW50YXRpb25zXG4gKi9cblxuZnVuY3Rpb24gdW5yZWdpc3RlcihuYW1lKSB7XG4gIGlmICghQ09NUE9ORU5UU19JTVBMRU1FTlRBVElPTl9NQVAkMS5oYXMobmFtZSkpIHBhbmljKGBUaGUgY29tcG9uZW50IFwiJHtuYW1lfVwiIHdhcyBuZXZlciByZWdpc3RlcmVkYCk7XG4gIENPTVBPTkVOVFNfSU1QTEVNRU5UQVRJT05fTUFQJDEuZGVsZXRlKG5hbWUpO1xuICBjc3NNYW5hZ2VyLnJlbW92ZShuYW1lKTtcbiAgcmV0dXJuIENPTVBPTkVOVFNfSU1QTEVNRU5UQVRJT05fTUFQJDE7XG59XG4vKipcbiAqIE1vdW50aW5nIGZ1bmN0aW9uIHRoYXQgd2lsbCB3b3JrIG9ubHkgZm9yIHRoZSBjb21wb25lbnRzIHRoYXQgd2VyZSBnbG9iYWxseSByZWdpc3RlcmVkXG4gKiBAcGFyYW0gICB7c3RyaW5nfEhUTUxFbGVtZW50fSBzZWxlY3RvciAtIHF1ZXJ5IGZvciB0aGUgc2VsZWN0aW9uIG9yIGEgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSAgIHtPYmplY3R9IGluaXRpYWxQcm9wcyAtIHRoZSBpbml0aWFsIGNvbXBvbmVudCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lIC0gb3B0aW9uYWwgY29tcG9uZW50IG5hbWVcbiAqIEByZXR1cm5zIHtBcnJheX0gbGlzdCBvZiBub2RlcyB1cGdyYWRlZFxuICovXG5cbmZ1bmN0aW9uIG1vdW50KHNlbGVjdG9yLCBpbml0aWFsUHJvcHMsIG5hbWUpIHtcbiAgcmV0dXJuICQoc2VsZWN0b3IpLm1hcChlbGVtZW50ID0+IG1vdW50Q29tcG9uZW50KGVsZW1lbnQsIGluaXRpYWxQcm9wcywgbmFtZSkpO1xufVxuLyoqXG4gKiBTd2VldCB1bm1vdW50aW5nIGhlbHBlciBmdW5jdGlvbiBmb3IgdGhlIERPTSBub2RlIG1vdW50ZWQgbWFudWFsbHkgYnkgdGhlIHVzZXJcbiAqIEBwYXJhbSAgIHtzdHJpbmd8SFRNTEVsZW1lbnR9IHNlbGVjdG9yIC0gcXVlcnkgZm9yIHRoZSBzZWxlY3Rpb24gb3IgYSBET00gZWxlbWVudFxuICogQHBhcmFtICAge2Jvb2xlYW58bnVsbH0ga2VlcFJvb3RFbGVtZW50IC0gaWYgdHJ1ZSBrZWVwIHRoZSByb290IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtBcnJheX0gbGlzdCBvZiBub2RlcyB1bm1vdW50ZWRcbiAqL1xuXG5mdW5jdGlvbiB1bm1vdW50KHNlbGVjdG9yLCBrZWVwUm9vdEVsZW1lbnQpIHtcbiAgcmV0dXJuICQoc2VsZWN0b3IpLm1hcChlbGVtZW50ID0+IHtcbiAgICBpZiAoZWxlbWVudFtET01fQ09NUE9ORU5UX0lOU1RBTkNFX1BST1BFUlRZJDFdKSB7XG4gICAgICBlbGVtZW50W0RPTV9DT01QT05FTlRfSU5TVEFOQ0VfUFJPUEVSVFkkMV0udW5tb3VudChrZWVwUm9vdEVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9KTtcbn1cbi8qKlxuICogRGVmaW5lIGEgcmlvdCBwbHVnaW5cbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gcGx1Z2luIC0gZnVuY3Rpb24gdGhhdCB3aWxsIHJlY2VpdmUgYWxsIHRoZSBjb21wb25lbnRzIGNyZWF0ZWRcbiAqIEByZXR1cm5zIHtTZXR9IHRoZSBzZXQgY29udGFpbmluZyBhbGwgdGhlIHBsdWdpbnMgaW5zdGFsbGVkXG4gKi9cblxuZnVuY3Rpb24gaW5zdGFsbChwbHVnaW4pIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKHBsdWdpbikpIHBhbmljKCdQbHVnaW5zIG11c3QgYmUgb2YgdHlwZSBmdW5jdGlvbicpO1xuICBpZiAoUExVR0lOU19TRVQkMS5oYXMocGx1Z2luKSkgcGFuaWMoJ1RoaXMgcGx1Z2luIHdhcyBhbHJlYWR5IGluc3RhbGxlZCcpO1xuICBQTFVHSU5TX1NFVCQxLmFkZChwbHVnaW4pO1xuICByZXR1cm4gUExVR0lOU19TRVQkMTtcbn1cbi8qKlxuICogVW5pbnN0YWxsIGEgcmlvdCBwbHVnaW5cbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gcGx1Z2luIC0gcGx1Z2luIHByZXZpb3VzbHkgaW5zdGFsbGVkXG4gKiBAcmV0dXJucyB7U2V0fSB0aGUgc2V0IGNvbnRhaW5pbmcgYWxsIHRoZSBwbHVnaW5zIGluc3RhbGxlZFxuICovXG5cbmZ1bmN0aW9uIHVuaW5zdGFsbChwbHVnaW4pIHtcbiAgaWYgKCFQTFVHSU5TX1NFVCQxLmhhcyhwbHVnaW4pKSBwYW5pYygnVGhpcyBwbHVnaW4gd2FzIG5ldmVyIGluc3RhbGxlZCcpO1xuICBQTFVHSU5TX1NFVCQxLmRlbGV0ZShwbHVnaW4pO1xuICByZXR1cm4gUExVR0lOU19TRVQkMTtcbn1cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBjcmVhdGUgY29tcG9uZW50IHdpdGhvdXQgcmVseWluZyBvbiB0aGUgcmVnaXN0ZXJlZCBvbmVzXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBpbXBsZW1lbnRhdGlvbiAtIGNvbXBvbmVudCBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybnMge0Z1bmN0aW9ufSBmdW5jdGlvbiB0aGF0IHdpbGwgYWxsb3cgeW91IHRvIG1vdW50IGEgcmlvdCBjb21wb25lbnQgb24gYSBET00gbm9kZVxuICovXG5cbmZ1bmN0aW9uIGNvbXBvbmVudChpbXBsZW1lbnRhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGVsLCBwcm9wcywgX3RlbXApIHtcbiAgICBsZXQge1xuICAgICAgc2xvdHMsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgcGFyZW50U2NvcGVcbiAgICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gICAgcmV0dXJuIGNvbXBvc2UoYyA9PiBjLm1vdW50KGVsLCBwYXJlbnRTY29wZSksIGMgPT4gYyh7XG4gICAgICBwcm9wcyxcbiAgICAgIHNsb3RzLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH0pLCBjcmVhdGVDb21wb25lbnQpKGltcGxlbWVudGF0aW9uKTtcbiAgfTtcbn1cbi8qKlxuICogTGlmdCBhIHJpb3QgY29tcG9uZW50IEludGVyZmFjZSBpbnRvIGEgcHVyZSByaW90IG9iamVjdFxuICogQHBhcmFtICAge0Z1bmN0aW9ufSBmdW5jIC0gUmlvdFB1cmVDb21wb25lbnQgZmFjdG9yeSBmdW5jdGlvblxuICogQHJldHVybnMge0Z1bmN0aW9ufSB0aGUgbGlmdGVkIG9yaWdpbmFsIGZ1bmN0aW9uIHJlY2VpdmVkIGFzIGFyZ3VtZW50XG4gKi9cblxuZnVuY3Rpb24gcHVyZShmdW5jKSB7XG4gIGlmICghaXNGdW5jdGlvbihmdW5jKSkgcGFuaWMoJ3Jpb3QucHVyZSBhY2NlcHRzIG9ubHkgYXJndW1lbnRzIG9mIHR5cGUgXCJmdW5jdGlvblwiJyk7XG4gIGZ1bmNbSVNfUFVSRV9TWU1CT0xdID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmM7XG59XG4vKiogQHR5cGUge3N0cmluZ30gY3VycmVudCByaW90IHZlcnNpb24gKi9cblxuY29uc3QgdmVyc2lvbiA9ICd2NS4wLjAnOyAvLyBleHBvc2Ugc29tZSBpbnRlcm5hbCBzdHVmZiB0aGF0IG1pZ2h0IGJlIHVzZWQgZnJvbSBleHRlcm5hbCB0b29sc1xuXG5jb25zdCBfXyA9IHtcbiAgY3NzTWFuYWdlcixcbiAgRE9NQmluZGluZ3MsXG4gIGNyZWF0ZUNvbXBvbmVudCxcbiAgZGVmaW5lQ29tcG9uZW50LFxuICBnbG9iYWxzXG59O1xuXG5leHBvcnQgeyBfXywgY29tcG9uZW50LCBpbnN0YWxsLCBtb3VudCwgcHVyZSwgcmVnaXN0ZXIsIHVuaW5zdGFsbCwgdW5tb3VudCwgdW5yZWdpc3RlciwgdmVyc2lvbiB9O1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG4vLyBwcm90b3R5cGUgY2xhc3MgZm9yIGhhc2ggZnVuY3Rpb25zXG5mdW5jdGlvbiBIYXNoIChibG9ja1NpemUsIGZpbmFsU2l6ZSkge1xuICB0aGlzLl9ibG9jayA9IEJ1ZmZlci5hbGxvYyhibG9ja1NpemUpXG4gIHRoaXMuX2ZpbmFsU2l6ZSA9IGZpbmFsU2l6ZVxuICB0aGlzLl9ibG9ja1NpemUgPSBibG9ja1NpemVcbiAgdGhpcy5fbGVuID0gMFxufVxuXG5IYXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmMgPSBlbmMgfHwgJ3V0ZjgnXG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuYylcbiAgfVxuXG4gIHZhciBibG9jayA9IHRoaXMuX2Jsb2NrXG4gIHZhciBibG9ja1NpemUgPSB0aGlzLl9ibG9ja1NpemVcbiAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoXG4gIHZhciBhY2N1bSA9IHRoaXMuX2xlblxuXG4gIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGxlbmd0aDspIHtcbiAgICB2YXIgYXNzaWduZWQgPSBhY2N1bSAlIGJsb2NrU2l6ZVxuICAgIHZhciByZW1haW5kZXIgPSBNYXRoLm1pbihsZW5ndGggLSBvZmZzZXQsIGJsb2NrU2l6ZSAtIGFzc2lnbmVkKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1haW5kZXI7IGkrKykge1xuICAgICAgYmxvY2tbYXNzaWduZWQgKyBpXSA9IGRhdGFbb2Zmc2V0ICsgaV1cbiAgICB9XG5cbiAgICBhY2N1bSArPSByZW1haW5kZXJcbiAgICBvZmZzZXQgKz0gcmVtYWluZGVyXG5cbiAgICBpZiAoKGFjY3VtICUgYmxvY2tTaXplKSA9PT0gMCkge1xuICAgICAgdGhpcy5fdXBkYXRlKGJsb2NrKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2xlbiArPSBsZW5ndGhcbiAgcmV0dXJuIHRoaXNcbn1cblxuSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICB2YXIgcmVtID0gdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplXG5cbiAgdGhpcy5fYmxvY2tbcmVtXSA9IDB4ODBcblxuICAvLyB6ZXJvIChyZW0gKyAxKSB0cmFpbGluZyBiaXRzLCB3aGVyZSAocmVtICsgMSkgaXMgdGhlIHNtYWxsZXN0XG4gIC8vIG5vbi1uZWdhdGl2ZSBzb2x1dGlvbiB0byB0aGUgZXF1YXRpb24gKGxlbmd0aCArIDEgKyAocmVtICsgMSkpID09PSBmaW5hbFNpemUgbW9kIGJsb2NrU2l6ZVxuICB0aGlzLl9ibG9jay5maWxsKDAsIHJlbSArIDEpXG5cbiAgaWYgKHJlbSA+PSB0aGlzLl9maW5hbFNpemUpIHtcbiAgICB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spXG4gICAgdGhpcy5fYmxvY2suZmlsbCgwKVxuICB9XG5cbiAgdmFyIGJpdHMgPSB0aGlzLl9sZW4gKiA4XG5cbiAgLy8gdWludDMyXG4gIGlmIChiaXRzIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkJFKGJpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDQpXG5cbiAgLy8gdWludDY0XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxvd0JpdHMgPSAoYml0cyAmIDB4ZmZmZmZmZmYpID4+PiAwXG4gICAgdmFyIGhpZ2hCaXRzID0gKGJpdHMgLSBsb3dCaXRzKSAvIDB4MTAwMDAwMDAwXG5cbiAgICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkJFKGhpZ2hCaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA4KVxuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUobG93Qml0cywgdGhpcy5fYmxvY2tTaXplIC0gNClcbiAgfVxuXG4gIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcbiAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoKClcblxuICByZXR1cm4gZW5jID8gaGFzaC50b1N0cmluZyhlbmMpIDogaGFzaFxufVxuXG5IYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ191cGRhdGUgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzcycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaFxuIiwiLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgSyA9IFtcbiAgMHg0MjhBMkY5OCwgMHg3MTM3NDQ5MSwgMHhCNUMwRkJDRiwgMHhFOUI1REJBNSxcbiAgMHgzOTU2QzI1QiwgMHg1OUYxMTFGMSwgMHg5MjNGODJBNCwgMHhBQjFDNUVENSxcbiAgMHhEODA3QUE5OCwgMHgxMjgzNUIwMSwgMHgyNDMxODVCRSwgMHg1NTBDN0RDMyxcbiAgMHg3MkJFNUQ3NCwgMHg4MERFQjFGRSwgMHg5QkRDMDZBNywgMHhDMTlCRjE3NCxcbiAgMHhFNDlCNjlDMSwgMHhFRkJFNDc4NiwgMHgwRkMxOURDNiwgMHgyNDBDQTFDQyxcbiAgMHgyREU5MkM2RiwgMHg0QTc0ODRBQSwgMHg1Q0IwQTlEQywgMHg3NkY5ODhEQSxcbiAgMHg5ODNFNTE1MiwgMHhBODMxQzY2RCwgMHhCMDAzMjdDOCwgMHhCRjU5N0ZDNyxcbiAgMHhDNkUwMEJGMywgMHhENUE3OTE0NywgMHgwNkNBNjM1MSwgMHgxNDI5Mjk2NyxcbiAgMHgyN0I3MEE4NSwgMHgyRTFCMjEzOCwgMHg0RDJDNkRGQywgMHg1MzM4MEQxMyxcbiAgMHg2NTBBNzM1NCwgMHg3NjZBMEFCQiwgMHg4MUMyQzkyRSwgMHg5MjcyMkM4NSxcbiAgMHhBMkJGRThBMSwgMHhBODFBNjY0QiwgMHhDMjRCOEI3MCwgMHhDNzZDNTFBMyxcbiAgMHhEMTkyRTgxOSwgMHhENjk5MDYyNCwgMHhGNDBFMzU4NSwgMHgxMDZBQTA3MCxcbiAgMHgxOUE0QzExNiwgMHgxRTM3NkMwOCwgMHgyNzQ4Nzc0QywgMHgzNEIwQkNCNSxcbiAgMHgzOTFDMENCMywgMHg0RUQ4QUE0QSwgMHg1QjlDQ0E0RiwgMHg2ODJFNkZGMyxcbiAgMHg3NDhGODJFRSwgMHg3OEE1NjM2RiwgMHg4NEM4NzgxNCwgMHg4Q0M3MDIwOCxcbiAgMHg5MEJFRkZGQSwgMHhBNDUwNkNFQiwgMHhCRUY5QTNGNywgMHhDNjcxNzhGMlxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg2NClcblxuZnVuY3Rpb24gU2hhMjU2ICgpIHtcbiAgdGhpcy5pbml0KClcblxuICB0aGlzLl93ID0gVyAvLyBuZXcgQXJyYXkoNjQpXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMjU2LCBIYXNoKVxuXG5TaGEyNTYucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDZhMDllNjY3XG4gIHRoaXMuX2IgPSAweGJiNjdhZTg1XG4gIHRoaXMuX2MgPSAweDNjNmVmMzcyXG4gIHRoaXMuX2QgPSAweGE1NGZmNTNhXG4gIHRoaXMuX2UgPSAweDUxMGU1MjdmXG4gIHRoaXMuX2YgPSAweDliMDU2ODhjXG4gIHRoaXMuX2cgPSAweDFmODNkOWFiXG4gIHRoaXMuX2ggPSAweDViZTBjZDE5XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gY2ggKHgsIHksIHopIHtcbiAgcmV0dXJuIHogXiAoeCAmICh5IF4geikpXG59XG5cbmZ1bmN0aW9uIG1haiAoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSB8ICh6ICYgKHggfCB5KSlcbn1cblxuZnVuY3Rpb24gc2lnbWEwICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gMiB8IHggPDwgMzApIF4gKHggPj4+IDEzIHwgeCA8PCAxOSkgXiAoeCA+Pj4gMjIgfCB4IDw8IDEwKVxufVxuXG5mdW5jdGlvbiBzaWdtYTEgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiA2IHwgeCA8PCAyNikgXiAoeCA+Pj4gMTEgfCB4IDw8IDIxKSBeICh4ID4+PiAyNSB8IHggPDwgNylcbn1cblxuZnVuY3Rpb24gZ2FtbWEwICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gNyB8IHggPDwgMjUpIF4gKHggPj4+IDE4IHwgeCA8PCAxNCkgXiAoeCA+Pj4gMylcbn1cblxuZnVuY3Rpb24gZ2FtbWExICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gMTcgfCB4IDw8IDE1KSBeICh4ID4+PiAxOSB8IHggPDwgMTMpIF4gKHggPj4+IDEwKVxufVxuXG5TaGEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcbiAgdmFyIGYgPSB0aGlzLl9mIHwgMFxuICB2YXIgZyA9IHRoaXMuX2cgfCAwXG4gIHZhciBoID0gdGhpcy5faCB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDY0OyArK2kpIFdbaV0gPSAoZ2FtbWExKFdbaSAtIDJdKSArIFdbaSAtIDddICsgZ2FtbWEwKFdbaSAtIDE1XSkgKyBXW2kgLSAxNl0pIHwgMFxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgNjQ7ICsraikge1xuICAgIHZhciBUMSA9IChoICsgc2lnbWExKGUpICsgY2goZSwgZiwgZykgKyBLW2pdICsgV1tqXSkgfCAwXG4gICAgdmFyIFQyID0gKHNpZ21hMChhKSArIG1haihhLCBiLCBjKSkgfCAwXG5cbiAgICBoID0gZ1xuICAgIGcgPSBmXG4gICAgZiA9IGVcbiAgICBlID0gKGQgKyBUMSkgfCAwXG4gICAgZCA9IGNcbiAgICBjID0gYlxuICAgIGIgPSBhXG4gICAgYSA9IChUMSArIFQyKSB8IDBcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbiAgdGhpcy5fZiA9IChmICsgdGhpcy5fZikgfCAwXG4gIHRoaXMuX2cgPSAoZyArIHRoaXMuX2cpIHwgMFxuICB0aGlzLl9oID0gKGggKyB0aGlzLl9oKSB8IDBcbn1cblxuU2hhMjU2LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMzIpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2gsIDI4KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjU2XG4iLCIvKiFcbiAqIFVBUGFyc2VyLmpzIHYwLjcuMjJcbiAqIExpZ2h0d2VpZ2h0IEphdmFTY3JpcHQtYmFzZWQgVXNlci1BZ2VudCBzdHJpbmcgcGFyc2VyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFpc2FsbWFuL3VhLXBhcnNlci1qc1xuICpcbiAqIENvcHlyaWdodCDCqSAyMDEyLTIwMTkgRmFpc2FsIFNhbG1hbiA8ZkBmYWlzYWxtYW4uY29tPlxuICogTGljZW5zZWQgdW5kZXIgTUlUIExpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24gKHdpbmRvdywgdW5kZWZpbmVkKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLy8vLy8vLy8vLy8vL1xuICAgIC8vIENvbnN0YW50c1xuICAgIC8vLy8vLy8vLy8vLy9cblxuXG4gICAgdmFyIExJQlZFUlNJT04gID0gJzAuNy4yMicsXG4gICAgICAgIEVNUFRZICAgICAgID0gJycsXG4gICAgICAgIFVOS05PV04gICAgID0gJz8nLFxuICAgICAgICBGVU5DX1RZUEUgICA9ICdmdW5jdGlvbicsXG4gICAgICAgIFVOREVGX1RZUEUgID0gJ3VuZGVmaW5lZCcsXG4gICAgICAgIE9CSl9UWVBFICAgID0gJ29iamVjdCcsXG4gICAgICAgIFNUUl9UWVBFICAgID0gJ3N0cmluZycsXG4gICAgICAgIE1BSk9SICAgICAgID0gJ21ham9yJywgLy8gZGVwcmVjYXRlZFxuICAgICAgICBNT0RFTCAgICAgICA9ICdtb2RlbCcsXG4gICAgICAgIE5BTUUgICAgICAgID0gJ25hbWUnLFxuICAgICAgICBUWVBFICAgICAgICA9ICd0eXBlJyxcbiAgICAgICAgVkVORE9SICAgICAgPSAndmVuZG9yJyxcbiAgICAgICAgVkVSU0lPTiAgICAgPSAndmVyc2lvbicsXG4gICAgICAgIEFSQ0hJVEVDVFVSRT0gJ2FyY2hpdGVjdHVyZScsXG4gICAgICAgIENPTlNPTEUgICAgID0gJ2NvbnNvbGUnLFxuICAgICAgICBNT0JJTEUgICAgICA9ICdtb2JpbGUnLFxuICAgICAgICBUQUJMRVQgICAgICA9ICd0YWJsZXQnLFxuICAgICAgICBTTUFSVFRWICAgICA9ICdzbWFydHR2JyxcbiAgICAgICAgV0VBUkFCTEUgICAgPSAnd2VhcmFibGUnLFxuICAgICAgICBFTUJFRERFRCAgICA9ICdlbWJlZGRlZCc7XG5cblxuICAgIC8vLy8vLy8vLy8vXG4gICAgLy8gSGVscGVyXG4gICAgLy8vLy8vLy8vL1xuXG5cbiAgICB2YXIgdXRpbCA9IHtcbiAgICAgICAgZXh0ZW5kIDogZnVuY3Rpb24gKHJlZ2V4ZXMsIGV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIHZhciBtZXJnZWRSZWdleGVzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHJlZ2V4ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uc1tpXSAmJiBleHRlbnNpb25zW2ldLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkUmVnZXhlc1tpXSA9IGV4dGVuc2lvbnNbaV0uY29uY2F0KHJlZ2V4ZXNbaV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFJlZ2V4ZXNbaV0gPSByZWdleGVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXJnZWRSZWdleGVzO1xuICAgICAgICB9LFxuICAgICAgICBoYXMgOiBmdW5jdGlvbiAoc3RyMSwgc3RyMikge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RyMSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjIudG9Mb3dlckNhc2UoKS5pbmRleE9mKHN0cjEudG9Mb3dlckNhc2UoKSkgIT09IC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb3dlcml6ZSA6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFqb3IgOiBmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZih2ZXJzaW9uKSA9PT0gU1RSX1RZUEUgPyB2ZXJzaW9uLnJlcGxhY2UoL1teXFxkXFwuXS9nLCcnKS5zcGxpdChcIi5cIilbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHRyaW0gOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gTWFwIGhlbHBlclxuICAgIC8vLy8vLy8vLy8vLy8vXG5cblxuICAgIHZhciBtYXBwZXIgPSB7XG5cbiAgICAgICAgcmd4IDogZnVuY3Rpb24gKHVhLCBhcnJheXMpIHtcblxuICAgICAgICAgICAgdmFyIGkgPSAwLCBqLCBrLCBwLCBxLCBtYXRjaGVzLCBtYXRjaDtcblxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCByZWdleGVzIG1hcHNcbiAgICAgICAgICAgIHdoaWxlIChpIDwgYXJyYXlzLmxlbmd0aCAmJiAhbWF0Y2hlcykge1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4ID0gYXJyYXlzW2ldLCAgICAgICAvLyBldmVuIHNlcXVlbmNlICgwLDIsNCwuLilcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMgPSBhcnJheXNbaSArIDFdOyAgIC8vIG9kZCBzZXF1ZW5jZSAoMSwzLDUsLi4pXG4gICAgICAgICAgICAgICAgaiA9IGsgPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gdHJ5IG1hdGNoaW5nIHVhc3RyaW5nIHdpdGggcmVnZXhlc1xuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgcmVnZXgubGVuZ3RoICYmICFtYXRjaGVzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IHJlZ2V4W2orK10uZXhlYyh1YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEhbWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwID0gMDsgcCA8IHByb3BzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaGVzWysra107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHByb3BzW3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGdpdmVuIHByb3BlcnR5IGlzIGFjdHVhbGx5IGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBxID09PSBPQkpfVFlQRSAmJiBxLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcVsxXSA9PSBGVU5DX1RZUEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ24gbW9kaWZpZWQgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gcVsxXS5jYWxsKHRoaXMsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzaWduIGdpdmVuIHZhbHVlLCBpZ25vcmUgcmVnZXggbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3FbMF1dID0gcVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB3aGV0aGVyIGZ1bmN0aW9uIG9yIHJlZ2V4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHFbMV0gPT09IEZVTkNfVFlQRSAmJiAhKHFbMV0uZXhlYyAmJiBxWzFdLnRlc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBmdW5jdGlvbiAodXN1YWxseSBzdHJpbmcgbWFwcGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcVswXV0gPSBtYXRjaCA/IHFbMV0uY2FsbCh0aGlzLCBtYXRjaCwgcVsyXSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbml0aXplIG1hdGNoIHVzaW5nIGdpdmVuIHJlZ2V4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1txWzBdXSA9IG1hdGNoID8gbWF0Y2gucmVwbGFjZShxWzFdLCBxWzJdKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxLmxlbmd0aCA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1txWzBdXSA9IG1hdGNoID8gcVszXS5jYWxsKHRoaXMsIG1hdGNoLnJlcGxhY2UocVsxXSwgcVsyXSkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1txXSA9IG1hdGNoID8gbWF0Y2ggOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzdHIgOiBmdW5jdGlvbiAoc3RyLCBtYXApIHtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBtYXApIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBhcnJheVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWFwW2ldID09PSBPQkpfVFlQRSAmJiBtYXBbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcFtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWwuaGFzKG1hcFtpXVtqXSwgc3RyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaSA9PT0gVU5LTk9XTikgPyB1bmRlZmluZWQgOiBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmhhcyhtYXBbaV0sIHN0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChpID09PSBVTktOT1dOKSA/IHVuZGVmaW5lZCA6IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFN0cmluZyBtYXBcbiAgICAvLy8vLy8vLy8vLy8vL1xuXG5cbiAgICB2YXIgbWFwcyA9IHtcblxuICAgICAgICBicm93c2VyIDoge1xuICAgICAgICAgICAgb2xkc2FmYXJpIDoge1xuICAgICAgICAgICAgICAgIHZlcnNpb24gOiB7XG4gICAgICAgICAgICAgICAgICAgICcxLjAnICAgOiAnLzgnLFxuICAgICAgICAgICAgICAgICAgICAnMS4yJyAgIDogJy8xJyxcbiAgICAgICAgICAgICAgICAgICAgJzEuMycgICA6ICcvMycsXG4gICAgICAgICAgICAgICAgICAgICcyLjAnICAgOiAnLzQxMicsXG4gICAgICAgICAgICAgICAgICAgICcyLjAuMicgOiAnLzQxNicsXG4gICAgICAgICAgICAgICAgICAgICcyLjAuMycgOiAnLzQxNycsXG4gICAgICAgICAgICAgICAgICAgICcyLjAuNCcgOiAnLzQxOScsXG4gICAgICAgICAgICAgICAgICAgICc/JyAgICAgOiAnLydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV2aWNlIDoge1xuICAgICAgICAgICAgYW1hem9uIDoge1xuICAgICAgICAgICAgICAgIG1vZGVsIDoge1xuICAgICAgICAgICAgICAgICAgICAnRmlyZSBQaG9uZScgOiBbJ1NEJywgJ0tGJ11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3ByaW50IDoge1xuICAgICAgICAgICAgICAgIG1vZGVsIDoge1xuICAgICAgICAgICAgICAgICAgICAnRXZvIFNoaWZ0IDRHJyA6ICc3MzczS1QnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2ZW5kb3IgOiB7XG4gICAgICAgICAgICAgICAgICAgICdIVEMnICAgICAgIDogJ0FQQScsXG4gICAgICAgICAgICAgICAgICAgICdTcHJpbnQnICAgIDogJ1NwcmludCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3MgOiB7XG4gICAgICAgICAgICB3aW5kb3dzIDoge1xuICAgICAgICAgICAgICAgIHZlcnNpb24gOiB7XG4gICAgICAgICAgICAgICAgICAgICdNRScgICAgICAgIDogJzQuOTAnLFxuICAgICAgICAgICAgICAgICAgICAnTlQgMy4xMScgICA6ICdOVDMuNTEnLFxuICAgICAgICAgICAgICAgICAgICAnTlQgNC4wJyAgICA6ICdOVDQuMCcsXG4gICAgICAgICAgICAgICAgICAgICcyMDAwJyAgICAgIDogJ05UIDUuMCcsXG4gICAgICAgICAgICAgICAgICAgICdYUCcgICAgICAgIDogWydOVCA1LjEnLCAnTlQgNS4yJ10sXG4gICAgICAgICAgICAgICAgICAgICdWaXN0YScgICAgIDogJ05UIDYuMCcsXG4gICAgICAgICAgICAgICAgICAgICc3JyAgICAgICAgIDogJ05UIDYuMScsXG4gICAgICAgICAgICAgICAgICAgICc4JyAgICAgICAgIDogJ05UIDYuMicsXG4gICAgICAgICAgICAgICAgICAgICc4LjEnICAgICAgIDogJ05UIDYuMycsXG4gICAgICAgICAgICAgICAgICAgICcxMCcgICAgICAgIDogWydOVCA2LjQnLCAnTlQgMTAuMCddLFxuICAgICAgICAgICAgICAgICAgICAnUlQnICAgICAgICA6ICdBUk0nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBSZWdleCBtYXBcbiAgICAvLy8vLy8vLy8vLy8vXG5cblxuICAgIHZhciByZWdleGVzID0ge1xuXG4gICAgICAgIGJyb3dzZXIgOiBbW1xuXG4gICAgICAgICAgICAvLyBQcmVzdG8gYmFzZWRcbiAgICAgICAgICAgIC8ob3BlcmFcXHNtaW5pKVxcLyhbXFx3XFwuLV0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIE1pbmlcbiAgICAgICAgICAgIC8ob3BlcmFcXHNbbW9iaWxldGFiXSspLit2ZXJzaW9uXFwvKFtcXHdcXC4tXSspL2ksICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIE1vYmkvVGFibGV0XG4gICAgICAgICAgICAvKG9wZXJhKS4rdmVyc2lvblxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhID4gOS44MFxuICAgICAgICAgICAgLyhvcGVyYSlbXFwvXFxzXSsoW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgPCA5LjgwXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhvcGlvcylbXFwvXFxzXSsoW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgbWluaSBvbiBpcGhvbmUgPj0gOC4wXG4gICAgICAgICAgICBdLCBbW05BTUUsICdPcGVyYSBNaW5pJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC9cXHMob3ByKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIFdlYmtpdFxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnT3BlcmEnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLy8gTWl4ZWRcbiAgICAgICAgICAgIC8oa2luZGxlKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2luZGxlXG4gICAgICAgICAgICAvKGx1bmFzY2FwZXxtYXh0aG9ufG5ldGZyb250fGphc21pbmV8YmxhemVyKVtcXC9cXHNdPyhbXFx3XFwuXSopL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEx1bmFzY2FwZS9NYXh0aG9uL05ldGZyb250L0phc21pbmUvQmxhemVyXG4gICAgICAgICAgICAvLyBUcmlkZW50IGJhc2VkXG4gICAgICAgICAgICAvKGF2YW50XFxzfGllbW9iaWxlfHNsaW0pKD86YnJvd3Nlcik/W1xcL1xcc10/KFtcXHdcXC5dKikvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZhbnQvSUVNb2JpbGUvU2xpbUJyb3dzZXJcbiAgICAgICAgICAgIC8oYmlkdWJyb3dzZXJ8YmFpZHVicm93c2VyKVtcXC9cXHNdPyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgIC8vIEJhaWR1IEJyb3dzZXJcbiAgICAgICAgICAgIC8oPzptc3xcXCgpKGllKVxccyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyXG5cbiAgICAgICAgICAgIC8vIFdlYmtpdC9LSFRNTCBiYXNlZFxuICAgICAgICAgICAgLyhyZWtvbnEpXFwvKFtcXHdcXC5dKikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWtvbnFcbiAgICAgICAgICAgIC8oY2hyb21pdW18ZmxvY2t8cm9ja21lbHR8bWlkb3JpfGVwaXBoYW55fHNpbGt8c2t5ZmlyZXxvdmlicm93c2VyfGJvbHR8aXJvbnx2aXZhbGRpfGlyaWRpdW18cGhhbnRvbWpzfGJvd3NlcnxxdWFya3xxdXB6aWxsYXxmYWxrb24pXFwvKFtcXHdcXC4tXSspL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21pdW0vRmxvY2svUm9ja01lbHQvTWlkb3JpL0VwaXBoYW55L1NpbGsvU2t5ZmlyZS9Cb2x0L0lyb24vSXJpZGl1bS9QaGFudG9tSlMvQm93c2VyL1F1cFppbGxhL0ZhbGtvblxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oa29ucXVlcm9yKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS29ucXVlcm9yXG4gICAgICAgICAgICBdLCBbW05BTUUsICdLb25xdWVyb3InXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyh0cmlkZW50KS4rcnZbOlxcc10oW1xcd1xcLl0rKS4rbGlrZVxcc2dlY2tvL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUxMVxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnSUUnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhlZGdlfGVkZ2lvc3xlZGdhfGVkZylcXC8oKFxcZCspP1tcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWljcm9zb2Z0IEVkZ2VcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0VkZ2UnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyh5YWJyb3dzZXIpXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBZYW5kZXhcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1lhbmRleCddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKEF2YXN0KVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF2YXN0IFNlY3VyZSBCcm93c2VyXG4gICAgICAgICAgICBdLCBbW05BTUUsICdBdmFzdCBTZWN1cmUgQnJvd3NlciddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKEFWRylcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFWRyBTZWN1cmUgQnJvd3NlclxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnQVZHIFNlY3VyZSBCcm93c2VyJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8ocHVmZmluKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVmZmluXG4gICAgICAgICAgICBdLCBbW05BTUUsICdQdWZmaW4nXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhmb2N1cylcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IEZvY3VzXG4gICAgICAgICAgICBdLCBbW05BTUUsICdGaXJlZm94IEZvY3VzJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8ob3B0KVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEgVG91Y2hcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ09wZXJhIFRvdWNoJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oKD86W1xcc1xcL10pdWM/XFxzP2Jyb3dzZXJ8KD86anVjLispdWN3ZWIpW1xcL1xcc10/KFtcXHdcXC5dKykvaSAgICAgICAgIC8vIFVDQnJvd3NlclxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnVUNCcm93c2VyJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oY29tb2RvX2RyYWdvbilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tb2RvIERyYWdvblxuICAgICAgICAgICAgXSwgW1tOQU1FLCAvXy9nLCAnICddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKHdpbmRvd3N3ZWNoYXQgcWJjb3JlKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlQ2hhdCBEZXNrdG9wIGZvciBXaW5kb3dzIEJ1aWx0LWluIEJyb3dzZXJcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1dlQ2hhdChXaW4pIERlc2t0b3AnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhtaWNyb21lc3NlbmdlcilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZUNoYXRcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1dlQ2hhdCddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKGJyYXZlKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJyYXZlIGJyb3dzZXJcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0JyYXZlJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8ocXFicm93c2VybGl0ZSlcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUVFCcm93c2VyTGl0ZVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oUVEpXFwvKFtcXGRcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUVEsIGFrYSBTaG91UVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC9tPyhxcWJyb3dzZXIpW1xcL1xcc10/KFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFFRQnJvd3NlclxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oYmFpZHVib3hhcHApW1xcL1xcc10/KFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhaWR1IEFwcFxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oMjM0NUV4cGxvcmVyKVtcXC9cXHNdPyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIzNDUgQnJvd3NlclxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8oTWV0YVNyKVtcXC9cXHNdPyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvdUdvdUJyb3dzZXJcbiAgICAgICAgICAgIF0sIFtOQU1FXSwgW1xuXG4gICAgICAgICAgICAvKExCQlJPV1NFUikvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpZUJhbyBCcm93c2VyXG4gICAgICAgICAgICBdLCBbTkFNRV0sIFtcblxuICAgICAgICAgICAgL3hpYW9taVxcL21pdWlicm93c2VyXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTUlVSSBCcm93c2VyXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdNSVVJIEJyb3dzZXInXV0sIFtcblxuICAgICAgICAgICAgLztmYmF2XFwvKFtcXHdcXC5dKyk7L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWNlYm9vayBBcHAgZm9yIGlPUyAmIEFuZHJvaWRcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0ZhY2Vib29rJ11dLCBbXG5cbiAgICAgICAgICAgIC9zYWZhcmlcXHMobGluZSlcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpbmUgQXBwIGZvciBpT1NcbiAgICAgICAgICAgIC9hbmRyb2lkLisobGluZSlcXC8oW1xcd1xcLl0rKVxcL2lhYi9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpbmUgQXBwIGZvciBBbmRyb2lkXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgL2hlYWRsZXNzY2hyb21lKD86XFwvKFtcXHdcXC5dKyl8XFxzKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lIEhlYWRsZXNzXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdDaHJvbWUgSGVhZGxlc3MnXV0sIFtcblxuICAgICAgICAgICAgL1xcc3d2XFwpLisoY2hyb21lKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9tZSBXZWJWaWV3XG4gICAgICAgICAgICBdLCBbW05BTUUsIC8oLispLywgJyQxIFdlYlZpZXcnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLygoPzpvY3VsdXN8c2Ftc3VuZylicm93c2VyKVxcLyhbXFx3XFwuXSspL2lcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgLyguKyg/Omd8dXMpKSguKykvLCAnJDEgJDInXSwgVkVSU0lPTl0sIFsgICAgICAgICAgICAgICAgLy8gT2N1bHVzIC8gU2Ftc3VuZyBCcm93c2VyXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLit2ZXJzaW9uXFwvKFtcXHdcXC5dKylcXHMrKD86bW9iaWxlXFxzP3NhZmFyaXxzYWZhcmkpKi9pICAgICAgICAvLyBBbmRyb2lkIEJyb3dzZXJcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0FuZHJvaWQgQnJvd3NlciddXSwgW1xuXG4gICAgICAgICAgICAvKHNhaWxmaXNoYnJvd3NlcilcXC8oW1xcd1xcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhaWxmaXNoIEJyb3dzZXJcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1NhaWxmaXNoIEJyb3dzZXInXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhjaHJvbWV8b21uaXdlYnxhcm9yYXxbdGl6ZW5va2FdezV9XFxzP2Jyb3dzZXIpXFwvdj8oW1xcd1xcLl0rKS9pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9tZS9PbW5pV2ViL0Fyb3JhL1RpemVuL05va2lhXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLyhkb2xmaW4pXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb2xwaGluXG4gICAgICAgICAgICBdLCBbW05BTUUsICdEb2xwaGluJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8ocWlodXxxaGJyb3dzZXJ8cWlob29icm93c2VyfDM2MGJyb3dzZXIpL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMzYwXG4gICAgICAgICAgICBdLCBbW05BTUUsICczNjAgQnJvd3NlciddXSwgW1xuXG4gICAgICAgICAgICAvKCg/OmFuZHJvaWQuKyljcm1vfGNyaW9zKVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9tZSBmb3IgQW5kcm9pZC9pT1NcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ0Nocm9tZSddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKGNvYXN0KVxcLyhbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIENvYXN0XG4gICAgICAgICAgICBdLCBbW05BTUUsICdPcGVyYSBDb2FzdCddLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvZnhpb3NcXC8oW1xcd1xcLi1dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggZm9yIGlPU1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIFtOQU1FLCAnRmlyZWZveCddXSwgW1xuXG4gICAgICAgICAgICAvdmVyc2lvblxcLyhbXFx3XFwuXSspLis/bW9iaWxlXFwvXFx3K1xccyhzYWZhcmkpL2kgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vYmlsZSBTYWZhcmlcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ01vYmlsZSBTYWZhcmknXV0sIFtcblxuICAgICAgICAgICAgL3ZlcnNpb25cXC8oW1xcd1xcLl0rKS4rPyhtb2JpbGVcXHM/c2FmYXJpfHNhZmFyaSkvaSAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpICYgU2FmYXJpIE1vYmlsZVxuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIE5BTUVdLCBbXG5cbiAgICAgICAgICAgIC93ZWJraXQuKz8oZ3NhKVxcLyhbXFx3XFwuXSspLis/KG1vYmlsZVxccz9zYWZhcml8c2FmYXJpKShcXC9bXFx3XFwuXSspL2kgIC8vIEdvb2dsZSBTZWFyY2ggQXBwbGlhbmNlIG9uIGlPU1xuICAgICAgICAgICAgXSwgW1tOQU1FLCAnR1NBJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC93ZWJraXQuKz8obW9iaWxlXFxzP3NhZmFyaXxzYWZhcmkpKFxcL1tcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8IDMuMFxuICAgICAgICAgICAgXSwgW05BTUUsIFtWRVJTSU9OLCBtYXBwZXIuc3RyLCBtYXBzLmJyb3dzZXIub2xkc2FmYXJpLnZlcnNpb25dXSwgW1xuXG4gICAgICAgICAgICAvKHdlYmtpdHxraHRtbClcXC8oW1xcd1xcLl0rKS9pXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLy8gR2Vja28gYmFzZWRcbiAgICAgICAgICAgIC8obmF2aWdhdG9yfG5ldHNjYXBlKVxcLyhbXFx3XFwuLV0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV0c2NhcGVcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ05ldHNjYXBlJ10sIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvKHN3aWZ0Zm94KS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3aWZ0Zm94XG4gICAgICAgICAgICAvKGljZWRyYWdvbnxpY2V3ZWFzZWx8Y2FtaW5vfGNoaW1lcmF8ZmVubmVjfG1hZW1vXFxzYnJvd3NlcnxtaW5pbW98Y29ua2Vyb3IpW1xcL1xcc10/KFtcXHdcXC5cXCtdKykvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWNlRHJhZ29uL0ljZXdlYXNlbC9DYW1pbm8vQ2hpbWVyYS9GZW5uZWMvTWFlbW8vTWluaW1vL0Nvbmtlcm9yXG4gICAgICAgICAgICAvKGZpcmVmb3h8c2VhbW9ua2V5fGstbWVsZW9ufGljZWNhdHxpY2VhcGV8ZmlyZWJpcmR8cGhvZW5peHxwYWxlbW9vbnxiYXNpbGlza3x3YXRlcmZveClcXC8oW1xcd1xcLi1dKykkL2ksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveC9TZWFNb25rZXkvSy1NZWxlb24vSWNlQ2F0L0ljZUFwZS9GaXJlYmlyZC9QaG9lbml4XG4gICAgICAgICAgICAvKG1vemlsbGEpXFwvKFtcXHdcXC5dKykuK3J2XFw6LitnZWNrb1xcL1xcZCsvaSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vemlsbGFcblxuICAgICAgICAgICAgLy8gT3RoZXJcbiAgICAgICAgICAgIC8ocG9sYXJpc3xseW54fGRpbGxvfGljYWJ8ZG9yaXN8YW1heWF8dzNtfG5ldHN1cmZ8c2xlaXBuaXIpW1xcL1xcc10/KFtcXHdcXC5dKykvaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9sYXJpcy9MeW54L0RpbGxvL2lDYWIvRG9yaXMvQW1heWEvdzNtL05ldFN1cmYvU2xlaXBuaXJcbiAgICAgICAgICAgIC8obGlua3MpXFxzXFwoKFtcXHdcXC5dKykvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpbmtzXG4gICAgICAgICAgICAvKGdvYnJvd3NlcilcXC8/KFtcXHdcXC5dKikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvQnJvd3NlclxuICAgICAgICAgICAgLyhpY2VcXHM/YnJvd3NlcilcXC92PyhbXFx3XFwuX10rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUNFIEJyb3dzZXJcbiAgICAgICAgICAgIC8obW9zYWljKVtcXC9cXHNdKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vc2FpY1xuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dXG4gICAgICAgIF0sXG5cbiAgICAgICAgY3B1IDogW1tcblxuICAgICAgICAgICAgLyg/OihhbWR8eCg/Oig/Ojg2fDY0KVtfLV0pP3x3b3d8d2luKTY0KVs7XFwpXS9pICAgICAgICAgICAgICAgICAgICAgLy8gQU1ENjRcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnYW1kNjQnXV0sIFtcblxuICAgICAgICAgICAgLyhpYTMyKD89OykpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJQTMyIChxdWlja3RpbWUpXG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgdXRpbC5sb3dlcml6ZV1dLCBbXG5cbiAgICAgICAgICAgIC8oKD86aVszNDZdfHgpODYpWztcXCldL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElBMzJcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnaWEzMiddXSwgW1xuXG4gICAgICAgICAgICAvLyBQb2NrZXRQQyBtaXN0YWtlbmx5IGlkZW50aWZpZWQgYXMgUG93ZXJQQ1xuICAgICAgICAgICAgL3dpbmRvd3NcXHMoY2V8bW9iaWxlKTtcXHNwcGM7L2lcbiAgICAgICAgICAgIF0sIFtbQVJDSElURUNUVVJFLCAnYXJtJ11dLCBbXG5cbiAgICAgICAgICAgIC8oKD86cHBjfHBvd2VycGMpKD86NjQpPykoPzpcXHNtYWN8O3xcXCkpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3dlclBDXG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgL293ZXIvLCAnJywgdXRpbC5sb3dlcml6ZV1dLCBbXG5cbiAgICAgICAgICAgIC8oc3VuNFxcdylbO1xcKV0vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTUEFSQ1xuICAgICAgICAgICAgXSwgW1tBUkNISVRFQ1RVUkUsICdzcGFyYyddXSwgW1xuXG4gICAgICAgICAgICAvKCg/OmF2cjMyfGlhNjQoPz07KSl8NjhrKD89XFwpKXxhcm0oPzo2NHwoPz12XFxkK1s7bF0pKXwoPz1hdG1lbFxccylhdnJ8KD86aXJpeHxtaXBzfHNwYXJjKSg/OjY0KT8oPz07KXxwYS1yaXNjKS9pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElBNjQsIDY4SywgQVJNLzY0LCBBVlIvMzIsIElSSVgvNjQsIE1JUFMvNjQsIFNQQVJDLzY0LCBQQS1SSVNDXG4gICAgICAgICAgICBdLCBbW0FSQ0hJVEVDVFVSRSwgdXRpbC5sb3dlcml6ZV1dXG4gICAgICAgIF0sXG5cbiAgICAgICAgZGV2aWNlIDogW1tcblxuICAgICAgICAgICAgL1xcKChpcGFkfHBsYXlib29rKTtbXFx3XFxzXFwpLDstXSsocmltfGFwcGxlKS9pICAgICAgICAgICAgICAgICAgICAgICAgLy8gaVBhZC9QbGF5Qm9va1xuICAgICAgICAgICAgXSwgW01PREVMLCBWRU5ET1IsIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYXBwbGVjb3JlbWVkaWFcXC9bXFx3XFwuXSsgXFwoKGlwYWQpLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpUGFkXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBcHBsZSddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgLyhhcHBsZVxcc3swLDF9dHYpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbGUgVFZcbiAgICAgICAgICAgIF0sIFtbTU9ERUwsICdBcHBsZSBUViddLCBbVkVORE9SLCAnQXBwbGUnXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuXG4gICAgICAgICAgICAvKGFyY2hvcylcXHMoZ2FtZXBhZDI/KS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcmNob3NcbiAgICAgICAgICAgIC8oaHApLisodG91Y2hwYWQpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFAgVG91Y2hQYWRcbiAgICAgICAgICAgIC8oaHApLisodGFibGV0KS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFAgVGFibGV0XG4gICAgICAgICAgICAvKGtpbmRsZSlcXC8oW1xcd1xcLl0rKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtpbmRsZVxuICAgICAgICAgICAgL1xccyhub29rKVtcXHdcXHNdK2J1aWxkXFwvKFxcdyspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vb2tcbiAgICAgICAgICAgIC8oZGVsbClcXHMoc3RyZWFba3ByXFxzXFxkXSpbXFxka29dKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGwgU3RyZWFrXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC8oa2ZbQS16XSspXFxzYnVpbGRcXC8uK3NpbGtcXC8vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2luZGxlIEZpcmUgSERcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0FtYXpvbiddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8oc2R8a2YpWzAzNDloaWpvcnN0dXddK1xcc2J1aWxkXFwvLitzaWxrXFwvL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZSBQaG9uZVxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgbWFwcGVyLnN0ciwgbWFwcy5kZXZpY2UuYW1hem9uLm1vZGVsXSwgW1ZFTkRPUiwgJ0FtYXpvbiddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9hbmRyb2lkLithZnQoW2Jtc10pXFxzYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgVFZcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0FtYXpvbiddLCBbVFlQRSwgU01BUlRUVl1dLCBbXG5cbiAgICAgICAgICAgIC9cXCgoaXBbaG9uZWR8XFxzXFx3Kl0rKTsuKyhhcHBsZSkvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaVBvZC9pUGhvbmVcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgVkVORE9SLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9cXCgoaXBbaG9uZWR8XFxzXFx3Kl0rKTsvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaVBvZC9pUGhvbmVcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0FwcGxlJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvKGJsYWNrYmVycnkpW1xccy1dPyhcXHcrKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2tCZXJyeVxuICAgICAgICAgICAgLyhibGFja2JlcnJ5fGJlbnF8cGFsbSg/PVxcLSl8c29ueWVyaWNzc29ufGFjZXJ8YXN1c3xkZWxsfG1laXp1fG1vdG9yb2xhfHBvbHl0cm9uKVtcXHNfLV0/KFtcXHctXSopL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJlblEvUGFsbS9Tb255LUVyaWNzc29uL0FjZXIvQXN1cy9EZWxsL01laXp1L01vdG9yb2xhL1BvbHl0cm9uXG4gICAgICAgICAgICAvKGhwKVxccyhbXFx3XFxzXStcXHcpL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIUCBpUEFRXG4gICAgICAgICAgICAvKGFzdXMpLT8oXFx3KykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3VzXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvXFwoYmIxMDtcXHMoXFx3KykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrQmVycnkgMTBcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0JsYWNrQmVycnknXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzdXMgVGFibGV0c1xuICAgICAgICAgICAgL2FuZHJvaWQuKyh0cmFuc2ZvW3ByaW1lXFxzXXs0LDEwfVxcc1xcdyt8ZWVlcGN8c2xpZGVyXFxzXFx3K3xuZXh1cyA3fHBhZGZvbmV8cDAwYykvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQXN1cyddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgLyhzb255KVxccyh0YWJsZXRcXHNbcHNdKVxcc2J1aWxkXFwvL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbnlcbiAgICAgICAgICAgIC8oc29ueSk/KD86c2dwLispXFxzYnVpbGRcXC8vaVxuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdTb255J10sIFtNT0RFTCwgJ1hwZXJpYSBUYWJsZXQnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvYW5kcm9pZC4rXFxzKFtjLWddXFxkezR9fHNvWy1sXVxcdyspKD89XFxzYnVpbGRcXC98XFwpLitjaHJvbWVcXC8oPyFbMS02XXswLDF9XFxkXFwuKSkvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnU29ueSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgL1xccyhvdXlhKVxccy9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE91eWFcbiAgICAgICAgICAgIC8obmludGVuZG8pXFxzKFt3aWRzM3VdKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5pbnRlbmRvXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIENPTlNPTEVdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rO1xccyhzaGllbGQpXFxzYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTnZpZGlhXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdOdmlkaWEnXSwgW1RZUEUsIENPTlNPTEVdXSwgW1xuXG4gICAgICAgICAgICAvKHBsYXlzdGF0aW9uXFxzWzM0cG9ydGFibGV2aV0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQbGF5c3RhdGlvblxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnU29ueSddLCBbVFlQRSwgQ09OU09MRV1dLCBbXG5cbiAgICAgICAgICAgIC8oc3ByaW50XFxzKFxcdyspKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcHJpbnQgUGhvbmVzXG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgbWFwcGVyLnN0ciwgbWFwcy5kZXZpY2Uuc3ByaW50LnZlbmRvcl0sIFtNT0RFTCwgbWFwcGVyLnN0ciwgbWFwcy5kZXZpY2Uuc3ByaW50Lm1vZGVsXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8oaHRjKVs7X1xccy1dKyhbXFx3XFxzXSsoPz1cXCl8XFxzYnVpbGQpfFxcdyspL2ksICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFRDXG4gICAgICAgICAgICAvKHp0ZSktKFxcdyopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBaVEVcbiAgICAgICAgICAgIC8oYWxjYXRlbHxnZWVrc3Bob25lfG5leGlhbnxwYW5hc29uaWN8KD89O1xccylzb255KVtfXFxzLV0/KFtcXHctXSopL2lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxjYXRlbC9HZWVrc1Bob25lL05leGlhbi9QYW5hc29uaWMvU29ueVxuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgW01PREVMLCAvXy9nLCAnICddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLyhuZXh1c1xcczkpL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSFRDIE5leHVzIDlcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0hUQyddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2RcXC9odWF3ZWkoW1xcd1xccy1dKylbO1xcKV0vaSxcbiAgICAgICAgICAgIC8obmV4dXNcXHM2cHx2b2ctbDI5fGFuZS1seDF8ZW1sLWwyOXxlbGUtbDI5KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSHVhd2VpXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdIdWF3ZWknXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLisoYmFoMj8tYT9bbHddXFxkezJ9KS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEh1YXdlaSBNZWRpYVBhZFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnSHVhd2VpJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvKG1pY3Jvc29mdCk7XFxzKGx1bWlhW1xcc1xcd10rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBMdW1pYVxuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvW1xcc1xcKDtdKHhib3goPzpcXHNvbmUpPylbXFxzXFwpO10vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWljcm9zb2Z0IFhib3hcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ01pY3Jvc29mdCddLCBbVFlQRSwgQ09OU09MRV1dLCBbXG4gICAgICAgICAgICAvKGtpblxcLltvbmV0d117M30pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaWNyb3NvZnQgS2luXG4gICAgICAgICAgICBdLCBbW01PREVMLCAvXFwuL2csICcgJ10sIFtWRU5ET1IsICdNaWNyb3NvZnQnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW90b3JvbGFcbiAgICAgICAgICAgIC9cXHMobWlsZXN0b25lfGRyb2lkKD86WzItNHhdfFxccyg/OmJpb25pY3x4Mnxwcm98cmF6cikpPzo/KFxcczRnKT8pW1xcd1xcc10rYnVpbGRcXC8vaSxcbiAgICAgICAgICAgIC9tb3RbXFxzLV0/KFxcdyopL2ksXG4gICAgICAgICAgICAvKFhUXFxkezMsNH0pIGJ1aWxkXFwvL2ksXG4gICAgICAgICAgICAvKG5leHVzXFxzNikvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTW90b3JvbGEnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG4gICAgICAgICAgICAvYW5kcm9pZC4rXFxzKG16NjBcXGR8eG9vbVtcXHMyXXswLDJ9KVxcc2J1aWxkXFwvL2lcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ01vdG9yb2xhJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvaGJidHZcXC9cXGQrXFwuXFxkK1xcLlxcZCtcXHMrXFwoW1xcd1xcc10qO1xccyooXFx3W147XSopOyhbXjtdKikvaSAgICAgICAgICAgIC8vIEhiYlRWIGRldmljZXNcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCB1dGlsLnRyaW1dLCBbTU9ERUwsIHV0aWwudHJpbV0sIFtUWVBFLCBTTUFSVFRWXV0sIFtcblxuICAgICAgICAgICAgL2hiYnR2LittYXBsZTsoXFxkKykvaVxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgL14vLCAnU21hcnRUViddLCBbVkVORE9SLCAnU2Ftc3VuZyddLCBbVFlQRSwgU01BUlRUVl1dLCBbXG5cbiAgICAgICAgICAgIC9cXChkdHZbXFwpO10uKyhhcXVvcykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGFycFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnU2hhcnAnXSwgW1RZUEUsIFNNQVJUVFZdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rKChzY2gtaVs4OV0wXFxkfHNody1tMzgwc3xndC1wXFxkezR9fGd0LW5cXGQrfHNnaC10OFs1Nl05fG5leHVzIDEwKSkvaSxcbiAgICAgICAgICAgIC8oKFNNLVRcXHcrKSkvaVxuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdTYW1zdW5nJ10sIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFsgICAgICAgICAgICAgICAgICAvLyBTYW1zdW5nXG4gICAgICAgICAgICAvc21hcnQtdHYuKyhzYW1zdW5nKS9pXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBbVFlQRSwgU01BUlRUVl0sIE1PREVMXSwgW1xuICAgICAgICAgICAgLygoc1tjZ3BdaC1cXHcrfGd0LVxcdyt8Z2FsYXh5XFxzbmV4dXN8c20tXFx3W1xcd1xcZF0rKSkvaSxcbiAgICAgICAgICAgIC8oc2FtW3N1bmddKilbXFxzLV0qKFxcdystP1tcXHctXSopL2ksXG4gICAgICAgICAgICAvc2VjLSgoc2doXFx3KykpL2lcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnU2Ftc3VuZyddLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC9zaWUtKFxcdyopL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpZW1lbnNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1NpZW1lbnMnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8obWFlbW98bm9raWEpLioobjkwMHxsdW1pYVxcc1xcZCspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb2tpYVxuICAgICAgICAgICAgLyhub2tpYSlbXFxzXy1dPyhbXFx3LV0qKS9pXG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ05va2lhJ10sIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWRbeFxcZFxcLlxccztdK1xccyhbYWJdWzEtN11cXC0/WzAxNzhhXVxcZFxcZD8pL2kgICAgICAgICAgICAgICAgICAgLy8gQWNlclxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnQWNlciddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuKyhbdmxda1xcLT9cXGR7M30pXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMRyBUYWJsZXRcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0xHJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuICAgICAgICAgICAgL2FuZHJvaWRcXHMzXFwuW1xcc1xcdzstXXsxMH0obGc/KS0oWzA2Y3Y5XXszLDR9KS9pICAgICAgICAgICAgICAgICAgICAgLy8gTEcgVGFibGV0XG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ0xHJ10sIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC8obGcpIG5ldGNhc3RcXC50di9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExHIFNtYXJ0VFZcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgU01BUlRUVl1dLCBbXG4gICAgICAgICAgICAvKG5leHVzXFxzWzQ1XSkvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMR1xuICAgICAgICAgICAgL2xnW2U7XFxzXFwvLV0rKFxcdyopL2ksXG4gICAgICAgICAgICAvYW5kcm9pZC4rbGcoXFwtP1tcXGRcXHddKylcXHMrYnVpbGQvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTEcnXSwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC8obGVub3ZvKVxccz8ocyg/OjUwMDB8NjAwMCkoPzpbXFx3LV0rKXx0YWIoPzpbXFxzXFx3XSspKS9pICAgICAgICAgICAgIC8vIExlbm92byB0YWJsZXRzXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvYW5kcm9pZC4rKGlkZWF0YWJbYS16MC05XFwtXFxzXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVub3ZvXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdMZW5vdm8nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG4gICAgICAgICAgICAvKGxlbm92bylbX1xccy1dPyhbXFx3LV0rKS9pXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbXG5cbiAgICAgICAgICAgIC9saW51eDsuKygoam9sbGEpKTsvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSm9sbGFcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgLygocGViYmxlKSlhcHBcXC9bXFxkXFwuXStcXHMvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGViYmxlXG4gICAgICAgICAgICBdLCBbVkVORE9SLCBNT0RFTCwgW1RZUEUsIFdFQVJBQkxFXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuKztcXHMob3BwbylcXHM/KFtcXHdcXHNdKylcXHNidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9QUE9cbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgL2Nya2V5L2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgQ2hyb21lY2FzdFxuICAgICAgICAgICAgXSwgW1tNT0RFTCwgJ0Nocm9tZWNhc3QnXSwgW1ZFTkRPUiwgJ0dvb2dsZSddLCBbVFlQRSwgU01BUlRUVl1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKGdsYXNzKVxcc1xcZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29vZ2xlIEdsYXNzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdHb29nbGUnXSwgW1RZUEUsIFdFQVJBQkxFXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuKztcXHMocGl4ZWwgYylbXFxzKV0vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvb2dsZSBQaXhlbCBDXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdHb29nbGUnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKHBpeGVsKCBbMjNdKT8oIHhsKT8pW1xccyldL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb29nbGUgUGl4ZWxcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0dvb2dsZSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuKztcXHMoXFx3KylcXHMrYnVpbGRcXC9obVxcMS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFhpYW9taSBIb25nbWkgJ251bWVyaWMnIG1vZGVsc1xuICAgICAgICAgICAgL2FuZHJvaWQuKyhobVtcXHNcXC1fXSpub3RlP1tcXHNfXSooPzpcXGRcXHcpPylcXHMrYnVpbGQvaSwgICAgICAgICAgICAgICAvLyBYaWFvbWkgSG9uZ21pXG4gICAgICAgICAgICAvYW5kcm9pZC4rKG1pW1xcc1xcLV9dKig/OmFcXGR8b25lfG9uZVtcXHNfXXBsdXN8bm90ZSBsdGUpP1tcXHNfXSooPzpcXGQ/XFx3PylbXFxzX10qKD86cGx1cyk/KVxccytidWlsZC9pLCAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWGlhb21pIE1pXG4gICAgICAgICAgICAvYW5kcm9pZC4rKHJlZG1pW1xcc1xcLV9dKig/Om5vdGUpPyg/OltcXHNfXT9bXFx3XFxzXSspKVxccytidWlsZC9pICAgICAgIC8vIFJlZG1pIFBob25lc1xuICAgICAgICAgICAgXSwgW1tNT0RFTCwgL18vZywgJyAnXSwgW1ZFTkRPUiwgJ1hpYW9taSddLCBbVFlQRSwgTU9CSUxFXV0sIFtcbiAgICAgICAgICAgIC9hbmRyb2lkLisobWlbXFxzXFwtX10qKD86cGFkKSg/OltcXHNfXT9bXFx3XFxzXSspKVxccytidWlsZC9pICAgICAgICAgICAgLy8gTWkgUGFkIHRhYmxldHNcbiAgICAgICAgICAgIF0sW1tNT0RFTCwgL18vZywgJyAnXSwgW1ZFTkRPUiwgJ1hpYW9taSddLCBbVFlQRSwgVEFCTEVUXV0sIFtcbiAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKG1bMS01XVxcc25vdGUpXFxzYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWVpenVcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ01laXp1J10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuICAgICAgICAgICAgLyhteiktKFtcXHctXXsyLH0pL2lcbiAgICAgICAgICAgIF0sIFtbVkVORE9SLCAnTWVpenUnXSwgTU9ERUwsIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rYTAwMCgxKVxccytidWlsZC9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmVQbHVzXG4gICAgICAgICAgICAvYW5kcm9pZC4rb25lcGx1c1xccyhhXFxkezR9KVtcXHMpXS9pXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdPbmVQbHVzJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihSQ1RbXFxkXFx3XSspXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUkNBIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1JDQSddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXFxzXSsoVmVudWVbXFxkXFxzXXsyLDd9KVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGwgVmVudWUgVGFibGV0c1xuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnRGVsbCddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooUVtUfE1dW1xcZFxcd10rKVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZlcml6b24gVGFibGV0XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdWZXJpem9uJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKyhCYXJuZXNbJlxcc10rTm9ibGVcXHMrfEJOW1JUXSkoVj8uKilcXHMrYnVpbGQvaSAgICAgLy8gQmFybmVzICYgTm9ibGUgVGFibGV0XG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ0Jhcm5lcyAmIE5vYmxlJ10sIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccysoVE1cXGR7M30uKlxcYilcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhcm5lcyAmIE5vYmxlIFRhYmxldFxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnTnVWaXNpb24nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLis7XFxzKGs4OClcXHNidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBaVEUgSyBTZXJpZXMgVGFibGV0XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdaVEUnXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKGdlblxcZHszfSlcXHMrYnVpbGQuKjQ5aC9pICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3aXNzIEdFTiBNb2JpbGVcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ1N3aXNzJ10sIFtUWVBFLCBNT0JJTEVdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKih6dXJcXGR7M30pXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTd2lzcyBaVVIgVGFibGV0XG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdTd2lzcyddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooKFpla2kpP1RCLipcXGIpXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWmVraSBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdaZWtpJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvKGFuZHJvaWQpLitbO1xcL11cXHMrKFtZUl1cXGR7Mn0pXFxzK2J1aWxkL2ksXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKyhEcmFnb25bXFwtXFxzXStUb3VjaFxccyt8RFQpKFxcd3s1fSlcXHNidWlsZC9pICAgICAgICAvLyBEcmFnb24gVG91Y2ggVGFibGV0XG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ0RyYWdvbiBUb3VjaCddLCBNT0RFTCwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKE5TLT9cXHd7MCw5fSlcXHNidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2lnbmlhIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0luc2lnbmlhJ10sIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKigoTlh8TmV4dCktP1xcd3swLDl9KVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAvLyBOZXh0Qm9vayBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdOZXh0Qm9vayddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooWHRyZW1lXFxfKT8oVigxWzA0NV18MlswMTVdfDMwfDQwfDYwfDdbMDVdfDkwKSlcXHMrYnVpbGQvaVxuICAgICAgICAgICAgXSwgW1tWRU5ET1IsICdWb2ljZSddLCBNT0RFTCwgW1RZUEUsIE1PQklMRV1dLCBbICAgICAgICAgICAgICAgICAgICAvLyBWb2ljZSBYdHJlbWUgUGhvbmVzXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKExWVEVMXFwtKT8oVjFbMTJdKVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgLy8gTHZUZWwgUGhvbmVzXG4gICAgICAgICAgICBdLCBbW1ZFTkRPUiwgJ0x2VGVsJ10sIE1PREVMLCBbVFlQRSwgTU9CSUxFXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuKztcXHMoUEgtMSlcXHMvaVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnRXNzZW50aWFsJ10sIFtUWVBFLCBNT0JJTEVdXSwgWyAgICAgICAgICAgICAgICAvLyBFc3NlbnRpYWwgUEgtMVxuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihWKDEwME1EfDcwME5BfDcwMTF8OTE3RykuKlxcYilcXHMrYnVpbGQvaSAgICAgICAgICAvLyBFbnZpemVuIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ0Vudml6ZW4nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLitbO1xcL11cXHMqKExlW1xcc1xcLV0rUGFuKVtcXHNcXC1dKyhcXHd7MSw5fSlcXHMrYnVpbGQvaSAgICAgICAgICAvLyBMZSBQYW4gVGFibGV0c1xuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvYW5kcm9pZC4rWztcXC9dXFxzKihUcmlvW1xcc1xcLV0qLiopXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFjaFNwZWVkIFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtNT0RFTCwgW1ZFTkRPUiwgJ01hY2hTcGVlZCddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccyooVHJpbml0eSlbXFwtXFxzXSooVFxcZHszfSlcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAvLyBUcmluaXR5IFRhYmxldHNcbiAgICAgICAgICAgIF0sIFtWRU5ET1IsIE1PREVMLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuK1s7XFwvXVxccypUVV8oMTQ5MSlcXHMrYnVpbGQvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3RvciBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdSb3RvciddLCBbVFlQRSwgVEFCTEVUXV0sIFtcblxuICAgICAgICAgICAgL2FuZHJvaWQuKyhLUyguKykpXFxzK2J1aWxkL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW1hem9uIEtpbmRsZSBUYWJsZXRzXG4gICAgICAgICAgICBdLCBbTU9ERUwsIFtWRU5ET1IsICdBbWF6b24nXSwgW1RZUEUsIFRBQkxFVF1dLCBbXG5cbiAgICAgICAgICAgIC9hbmRyb2lkLisoR2lnYXNldClbXFxzXFwtXSsoUVxcd3sxLDl9KVxccytidWlsZC9pICAgICAgICAgICAgICAgICAgICAgIC8vIEdpZ2FzZXQgVGFibGV0c1xuICAgICAgICAgICAgXSwgW1ZFTkRPUiwgTU9ERUwsIFtUWVBFLCBUQUJMRVRdXSwgW1xuXG4gICAgICAgICAgICAvXFxzKHRhYmxldHx0YWIpWztcXC9dL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5pZGVudGlmaWFibGUgVGFibGV0XG4gICAgICAgICAgICAvXFxzKG1vYmlsZSkoPzpbO1xcL118XFxzc2FmYXJpKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuaWRlbnRpZmlhYmxlIE1vYmlsZVxuICAgICAgICAgICAgXSwgW1tUWVBFLCB1dGlsLmxvd2VyaXplXSwgVkVORE9SLCBNT0RFTF0sIFtcblxuICAgICAgICAgICAgL1tcXHNcXC9cXChdKHNtYXJ0LT90dilbO1xcKV0vaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU21hcnRUVlxuICAgICAgICAgICAgXSwgW1tUWVBFLCBTTUFSVFRWXV0sIFtcblxuICAgICAgICAgICAgLyhhbmRyb2lkW1xcd1xcLlxcc1xcLV17MCw5fSk7LitidWlsZC9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJpYyBBbmRyb2lkIERldmljZVxuICAgICAgICAgICAgXSwgW01PREVMLCBbVkVORE9SLCAnR2VuZXJpYyddXVxuICAgICAgICBdLFxuXG4gICAgICAgIGVuZ2luZSA6IFtbXG5cbiAgICAgICAgICAgIC93aW5kb3dzLitcXHNlZGdlXFwvKFtcXHdcXC5dKykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVkZ2VIVE1MXG4gICAgICAgICAgICBdLCBbVkVSU0lPTiwgW05BTUUsICdFZGdlSFRNTCddXSwgW1xuXG4gICAgICAgICAgICAvd2Via2l0XFwvNTM3XFwuMzYuK2Nocm9tZVxcLyg/ITI3KShbXFx3XFwuXSspL2kgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxpbmtcbiAgICAgICAgICAgIF0sIFtWRVJTSU9OLCBbTkFNRSwgJ0JsaW5rJ11dLCBbXG5cbiAgICAgICAgICAgIC8ocHJlc3RvKVxcLyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlc3RvXG4gICAgICAgICAgICAvKHdlYmtpdHx0cmlkZW50fG5ldGZyb250fG5ldHN1cmZ8YW1heWF8bHlueHx3M218Z29hbm5hKVxcLyhbXFx3XFwuXSspL2ksICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2ViS2l0L1RyaWRlbnQvTmV0RnJvbnQvTmV0U3VyZi9BbWF5YS9MeW54L3czbS9Hb2FubmFcbiAgICAgICAgICAgIC8oa2h0bWx8dGFzbWFufGxpbmtzKVtcXC9cXHNdXFwoPyhbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLSFRNTC9UYXNtYW4vTGlua3NcbiAgICAgICAgICAgIC8oaWNhYilbXFwvXFxzXShbMjNdXFwuW1xcZFxcLl0rKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpQ2FiXG4gICAgICAgICAgICBdLCBbTkFNRSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgL3J2XFw6KFtcXHdcXC5dezEsOX0pLisoZ2Vja28pL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZWNrb1xuICAgICAgICAgICAgXSwgW1ZFUlNJT04sIE5BTUVdXG4gICAgICAgIF0sXG5cbiAgICAgICAgb3MgOiBbW1xuXG4gICAgICAgICAgICAvLyBXaW5kb3dzIGJhc2VkXG4gICAgICAgICAgICAvbWljcm9zb2Z0XFxzKHdpbmRvd3MpXFxzKHZpc3RhfHhwKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2luZG93cyAoaVR1bmVzKVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLCBbXG4gICAgICAgICAgICAvKHdpbmRvd3MpXFxzbnRcXHM2XFwuMjtcXHMoYXJtKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaW5kb3dzIFJUXG4gICAgICAgICAgICAvKHdpbmRvd3NcXHNwaG9uZSg/Olxcc29zKSopW1xcc1xcL10/KFtcXGRcXC5cXHNcXHddKikvaSwgICAgICAgICAgICAgICAgICAgLy8gV2luZG93cyBQaG9uZVxuICAgICAgICAgICAgLyh3aW5kb3dzXFxzbW9iaWxlfHdpbmRvd3MpW1xcc1xcL10/KFtudGNlXFxkXFwuXFxzXStcXHcpL2lcbiAgICAgICAgICAgIF0sIFtOQU1FLCBbVkVSU0lPTiwgbWFwcGVyLnN0ciwgbWFwcy5vcy53aW5kb3dzLnZlcnNpb25dXSwgW1xuICAgICAgICAgICAgLyh3aW4oPz0zfDl8bil8d2luXFxzOXhcXHMpKFtudFxcZFxcLl0rKS9pXG4gICAgICAgICAgICBdLCBbW05BTUUsICdXaW5kb3dzJ10sIFtWRVJTSU9OLCBtYXBwZXIuc3RyLCBtYXBzLm9zLndpbmRvd3MudmVyc2lvbl1dLCBbXG5cbiAgICAgICAgICAgIC8vIE1vYmlsZS9FbWJlZGRlZCBPU1xuICAgICAgICAgICAgL1xcKChiYikoMTApOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2tCZXJyeSAxMFxuICAgICAgICAgICAgXSwgW1tOQU1FLCAnQmxhY2tCZXJyeSddLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgLyhibGFja2JlcnJ5KVxcdypcXC8/KFtcXHdcXC5dKikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2tiZXJyeVxuICAgICAgICAgICAgLyh0aXplbnxrYWlvcylbXFwvXFxzXShbXFx3XFwuXSspL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGl6ZW4vS2FpT1NcbiAgICAgICAgICAgIC8oYW5kcm9pZHx3ZWJvc3xwYWxtXFxzb3N8cW54fGJhZGF8cmltXFxzdGFibGV0XFxzb3N8bWVlZ298c2FpbGZpc2h8Y29udGlraSlbXFwvXFxzLV0/KFtcXHdcXC5dKikvaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbmRyb2lkL1dlYk9TL1BhbG0vUU5YL0JhZGEvUklNL01lZUdvL0NvbnRpa2kvU2FpbGZpc2ggT1NcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuICAgICAgICAgICAgLyhzeW1iaWFuXFxzP29zfHN5bWJvc3xzNjAoPz07KSlbXFwvXFxzLV0/KFtcXHdcXC5dKikvaSAgICAgICAgICAgICAgICAgIC8vIFN5bWJpYW5cbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1N5bWJpYW4nXSwgVkVSU0lPTl0sIFtcbiAgICAgICAgICAgIC9cXCgoc2VyaWVzNDApOy9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlcmllcyA0MFxuICAgICAgICAgICAgXSwgW05BTUVdLCBbXG4gICAgICAgICAgICAvbW96aWxsYS4rXFwobW9iaWxlOy4rZ2Vja28uK2ZpcmVmb3gvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IE9TXG4gICAgICAgICAgICBdLCBbW05BTUUsICdGaXJlZm94IE9TJ10sIFZFUlNJT05dLCBbXG5cbiAgICAgICAgICAgIC8vIENvbnNvbGVcbiAgICAgICAgICAgIC8obmludGVuZG98cGxheXN0YXRpb24pXFxzKFt3aWRzMzRwb3J0YWJsZXZ1XSspL2ksICAgICAgICAgICAgICAgICAgIC8vIE5pbnRlbmRvL1BsYXlzdGF0aW9uXG5cbiAgICAgICAgICAgIC8vIEdOVS9MaW51eCBiYXNlZFxuICAgICAgICAgICAgLyhtaW50KVtcXC9cXHNcXChdPyhcXHcqKS9pLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWludFxuICAgICAgICAgICAgLyhtYWdlaWF8dmVjdG9ybGludXgpWztcXHNdL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFnZWlhL1ZlY3RvckxpbnV4XG4gICAgICAgICAgICAvKGpvbGl8W2t4bG5dP3VidW50dXxkZWJpYW58c3VzZXxvcGVuc3VzZXxnZW50b298KD89XFxzKWFyY2h8c2xhY2t3YXJlfGZlZG9yYXxtYW5kcml2YXxjZW50b3N8cGNsaW51eG9zfHJlZGhhdHx6ZW53YWxrfGxpbnB1cylbXFwvXFxzLV0/KD8hY2hyb20pKFtcXHdcXC4tXSopL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEpvbGkvVWJ1bnR1L0RlYmlhbi9TVVNFL0dlbnRvby9BcmNoL1NsYWNrd2FyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGZWRvcmEvTWFuZHJpdmEvQ2VudE9TL1BDTGludXhPUy9SZWRIYXQvWmVud2Fsay9MaW5wdXNcbiAgICAgICAgICAgIC8oaHVyZHxsaW51eClcXHM/KFtcXHdcXC5dKikvaSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSHVyZC9MaW51eFxuICAgICAgICAgICAgLyhnbnUpXFxzPyhbXFx3XFwuXSopL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHTlVcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSwgW1xuXG4gICAgICAgICAgICAvKGNyb3MpXFxzW1xcd10rXFxzKFtcXHdcXC5dK1xcdykvaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENocm9taXVtIE9TXG4gICAgICAgICAgICBdLCBbW05BTUUsICdDaHJvbWl1bSBPUyddLCBWRVJTSU9OXSxbXG5cbiAgICAgICAgICAgIC8vIFNvbGFyaXNcbiAgICAgICAgICAgIC8oc3Vub3MpXFxzPyhbXFx3XFwuXFxkXSopL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbGFyaXNcbiAgICAgICAgICAgIF0sIFtbTkFNRSwgJ1NvbGFyaXMnXSwgVkVSU0lPTl0sIFtcblxuICAgICAgICAgICAgLy8gQlNEIGJhc2VkXG4gICAgICAgICAgICAvXFxzKFtmcmVudG9wYy1dezAsNH1ic2R8ZHJhZ29uZmx5KVxccz8oW1xcd1xcLl0qKS9pICAgICAgICAgICAgICAgICAgICAvLyBGcmVlQlNEL05ldEJTRC9PcGVuQlNEL1BDLUJTRC9EcmFnb25GbHlcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXSxbXG5cbiAgICAgICAgICAgIC8oaGFpa3UpXFxzKFxcdyspL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYWlrdVxuICAgICAgICAgICAgXSwgW05BTUUsIFZFUlNJT05dLFtcblxuICAgICAgICAgICAgL2NmbmV0d29ya1xcLy4rZGFyd2luL2ksXG4gICAgICAgICAgICAvaXBbaG9uZWFkXXsyLDR9KD86Lipvc1xccyhbXFx3XSspXFxzbGlrZVxcc21hY3w7XFxzb3BlcmEpL2kgICAgICAgICAgICAgLy8gaU9TXG4gICAgICAgICAgICBdLCBbW1ZFUlNJT04sIC9fL2csICcuJ10sIFtOQU1FLCAnaU9TJ11dLCBbXG5cbiAgICAgICAgICAgIC8obWFjXFxzb3NcXHN4KVxccz8oW1xcd1xcc1xcLl0qKS9pLFxuICAgICAgICAgICAgLyhtYWNpbnRvc2h8bWFjKD89X3Bvd2VycGMpXFxzKS9pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFjIE9TXG4gICAgICAgICAgICBdLCBbW05BTUUsICdNYWMgT1MnXSwgW1ZFUlNJT04sIC9fL2csICcuJ11dLCBbXG5cbiAgICAgICAgICAgIC8vIE90aGVyXG4gICAgICAgICAgICAvKCg/Om9wZW4pP3NvbGFyaXMpW1xcL1xccy1dPyhbXFx3XFwuXSopL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb2xhcmlzXG4gICAgICAgICAgICAvKGFpeClcXHMoKFxcZCkoPz1cXC58XFwpfFxccylbXFx3XFwuXSkqL2ksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBSVhcbiAgICAgICAgICAgIC8ocGxhblxcczl8bWluaXh8YmVvc3xvc1xcLzJ8YW1pZ2Fvc3xtb3JwaG9zfHJpc2NcXHNvc3xvcGVudm1zfGZ1Y2hzaWEpL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYW45L01pbml4L0JlT1MvT1MyL0FtaWdhT1MvTW9ycGhPUy9SSVNDT1MvT3BlblZNUy9GdWNoc2lhXG4gICAgICAgICAgICAvKHVuaXgpXFxzPyhbXFx3XFwuXSopL2kgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVOSVhcbiAgICAgICAgICAgIF0sIFtOQU1FLCBWRVJTSU9OXVxuICAgICAgICBdXG4gICAgfTtcblxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBDb25zdHJ1Y3RvclxuICAgIC8vLy8vLy8vLy8vLy8vLy9cbiAgICB2YXIgVUFQYXJzZXIgPSBmdW5jdGlvbiAodWFzdHJpbmcsIGV4dGVuc2lvbnMpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHVhc3RyaW5nID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucyA9IHVhc3RyaW5nO1xuICAgICAgICAgICAgdWFzdHJpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVUFQYXJzZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVBUGFyc2VyKHVhc3RyaW5nLCBleHRlbnNpb25zKS5nZXRSZXN1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1YSA9IHVhc3RyaW5nIHx8ICgod2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpID8gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQgOiBFTVBUWSk7XG4gICAgICAgIHZhciByZ3htYXAgPSBleHRlbnNpb25zID8gdXRpbC5leHRlbmQocmVnZXhlcywgZXh0ZW5zaW9ucykgOiByZWdleGVzO1xuXG4gICAgICAgIHRoaXMuZ2V0QnJvd3NlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBicm93c2VyID0geyBuYW1lOiB1bmRlZmluZWQsIHZlcnNpb246IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgbWFwcGVyLnJneC5jYWxsKGJyb3dzZXIsIHVhLCByZ3htYXAuYnJvd3Nlcik7XG4gICAgICAgICAgICBicm93c2VyLm1ham9yID0gdXRpbC5tYWpvcihicm93c2VyLnZlcnNpb24pOyAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICByZXR1cm4gYnJvd3NlcjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRDUFUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY3B1ID0geyBhcmNoaXRlY3R1cmU6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgbWFwcGVyLnJneC5jYWxsKGNwdSwgdWEsIHJneG1hcC5jcHUpO1xuICAgICAgICAgICAgcmV0dXJuIGNwdTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXREZXZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGV2aWNlID0geyB2ZW5kb3I6IHVuZGVmaW5lZCwgbW9kZWw6IHVuZGVmaW5lZCwgdHlwZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICBtYXBwZXIucmd4LmNhbGwoZGV2aWNlLCB1YSwgcmd4bWFwLmRldmljZSk7XG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEVuZ2luZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlbmdpbmUgPSB7IG5hbWU6IHVuZGVmaW5lZCwgdmVyc2lvbjogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICBtYXBwZXIucmd4LmNhbGwoZW5naW5lLCB1YSwgcmd4bWFwLmVuZ2luZSk7XG4gICAgICAgICAgICByZXR1cm4gZW5naW5lO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE9TID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9zID0geyBuYW1lOiB1bmRlZmluZWQsIHZlcnNpb246IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgbWFwcGVyLnJneC5jYWxsKG9zLCB1YSwgcmd4bWFwLm9zKTtcbiAgICAgICAgICAgIHJldHVybiBvcztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVhICAgICAgOiB0aGlzLmdldFVBKCksXG4gICAgICAgICAgICAgICAgYnJvd3NlciA6IHRoaXMuZ2V0QnJvd3NlcigpLFxuICAgICAgICAgICAgICAgIGVuZ2luZSAgOiB0aGlzLmdldEVuZ2luZSgpLFxuICAgICAgICAgICAgICAgIG9zICAgICAgOiB0aGlzLmdldE9TKCksXG4gICAgICAgICAgICAgICAgZGV2aWNlICA6IHRoaXMuZ2V0RGV2aWNlKCksXG4gICAgICAgICAgICAgICAgY3B1ICAgICA6IHRoaXMuZ2V0Q1BVKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0VUEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdWE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0VUEgPSBmdW5jdGlvbiAodWFzdHJpbmcpIHtcbiAgICAgICAgICAgIHVhID0gdWFzdHJpbmc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFVBUGFyc2VyLlZFUlNJT04gPSBMSUJWRVJTSU9OO1xuICAgIFVBUGFyc2VyLkJST1dTRVIgPSB7XG4gICAgICAgIE5BTUUgICAgOiBOQU1FLFxuICAgICAgICBNQUpPUiAgIDogTUFKT1IsIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgVkVSU0lPTiA6IFZFUlNJT05cbiAgICB9O1xuICAgIFVBUGFyc2VyLkNQVSA9IHtcbiAgICAgICAgQVJDSElURUNUVVJFIDogQVJDSElURUNUVVJFXG4gICAgfTtcbiAgICBVQVBhcnNlci5ERVZJQ0UgPSB7XG4gICAgICAgIE1PREVMICAgOiBNT0RFTCxcbiAgICAgICAgVkVORE9SICA6IFZFTkRPUixcbiAgICAgICAgVFlQRSAgICA6IFRZUEUsXG4gICAgICAgIENPTlNPTEUgOiBDT05TT0xFLFxuICAgICAgICBNT0JJTEUgIDogTU9CSUxFLFxuICAgICAgICBTTUFSVFRWIDogU01BUlRUVixcbiAgICAgICAgVEFCTEVUICA6IFRBQkxFVCxcbiAgICAgICAgV0VBUkFCTEU6IFdFQVJBQkxFLFxuICAgICAgICBFTUJFRERFRDogRU1CRURERURcbiAgICB9O1xuICAgIFVBUGFyc2VyLkVOR0lORSA9IHtcbiAgICAgICAgTkFNRSAgICA6IE5BTUUsXG4gICAgICAgIFZFUlNJT04gOiBWRVJTSU9OXG4gICAgfTtcbiAgICBVQVBhcnNlci5PUyA9IHtcbiAgICAgICAgTkFNRSAgICA6IE5BTUUsXG4gICAgICAgIFZFUlNJT04gOiBWRVJTSU9OXG4gICAgfTtcblxuICAgIC8vLy8vLy8vLy8vXG4gICAgLy8gRXhwb3J0XG4gICAgLy8vLy8vLy8vL1xuXG5cbiAgICAvLyBjaGVjayBqcyBlbnZpcm9ubWVudFxuICAgIGlmICh0eXBlb2YoZXhwb3J0cykgIT09IFVOREVGX1RZUEUpIHtcbiAgICAgICAgLy8gbm9kZWpzIGVudlxuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gVU5ERUZfVFlQRSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVUFQYXJzZXI7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0cy5VQVBhcnNlciA9IFVBUGFyc2VyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlcXVpcmVqcyBlbnYgKG9wdGlvbmFsKVxuICAgICAgICBpZiAodHlwZW9mKGRlZmluZSkgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVUFQYXJzZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cpIHtcbiAgICAgICAgICAgIC8vIGJyb3dzZXIgZW52XG4gICAgICAgICAgICB3aW5kb3cuVUFQYXJzZXIgPSBVQVBhcnNlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGpRdWVyeS9aZXB0byBzcGVjaWZpYyAob3B0aW9uYWwpXG4gICAgLy8gTm90ZTpcbiAgICAvLyAgIEluIEFNRCBlbnYgdGhlIGdsb2JhbCBzY29wZSBzaG91bGQgYmUga2VwdCBjbGVhbiwgYnV0IGpRdWVyeSBpcyBhbiBleGNlcHRpb24uXG4gICAgLy8gICBqUXVlcnkgYWx3YXlzIGV4cG9ydHMgdG8gZ2xvYmFsIHNjb3BlLCB1bmxlc3MgalF1ZXJ5Lm5vQ29uZmxpY3QodHJ1ZSkgaXMgdXNlZCxcbiAgICAvLyAgIGFuZCB3ZSBzaG91bGQgY2F0Y2ggdGhhdC5cbiAgICB2YXIgJCA9IHdpbmRvdyAmJiAod2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG8pO1xuICAgIGlmICgkICYmICEkLnVhKSB7XG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgVUFQYXJzZXIoKTtcbiAgICAgICAgJC51YSA9IHBhcnNlci5nZXRSZXN1bHQoKTtcbiAgICAgICAgJC51YS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VyLmdldFVBKCk7XG4gICAgICAgIH07XG4gICAgICAgICQudWEuc2V0ID0gZnVuY3Rpb24gKHVhc3RyaW5nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc2V0VUEodWFzdHJpbmcpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlci5nZXRSZXN1bHQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgJC51YVtwcm9wXSA9IHJlc3VsdFtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbn0pKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnID8gd2luZG93IDogdGhpcyk7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHRpZihfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdKSB7XG5cdFx0cmV0dXJuIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0uZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IG1vZHVsZVsnZGVmYXVsdCddIDpcblx0XHQoKSA9PiBtb2R1bGU7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwidmFyIHNjcmlwdFVybDtcbmlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmcuaW1wb3J0U2NyaXB0cykgc2NyaXB0VXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmxvY2F0aW9uICsgXCJcIjtcbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5kb2N1bWVudDtcbmlmICghc2NyaXB0VXJsICYmIGRvY3VtZW50KSB7XG5cdGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KVxuXHRcdHNjcmlwdFVybCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjXG5cdGlmICghc2NyaXB0VXJsKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRpZihzY3JpcHRzLmxlbmd0aCkgc2NyaXB0VXJsID0gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdLnNyY1xuXHR9XG59XG4vLyBXaGVuIHN1cHBvcnRpbmcgYnJvd3NlcnMgd2hlcmUgYW4gYXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCB5b3UgbXVzdCBzcGVjaWZ5IGFuIG91dHB1dC5wdWJsaWNQYXRoIG1hbnVhbGx5IHZpYSBjb25maWd1cmF0aW9uXG4vLyBvciBwYXNzIGFuIGVtcHR5IHN0cmluZyAoXCJcIikgYW5kIHNldCB0aGUgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gdmFyaWFibGUgZnJvbSB5b3VyIGNvZGUgdG8gdXNlIHlvdXIgb3duIGxvZ2ljLlxuaWYgKCFzY3JpcHRVcmwpIHRocm93IG5ldyBFcnJvcihcIkF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuc2NyaXB0VXJsID0gc2NyaXB0VXJsLnJlcGxhY2UoLyMuKiQvLCBcIlwiKS5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKS5yZXBsYWNlKC9cXC9bXlxcL10rJC8sIFwiL1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18ucCA9IHNjcmlwdFVybDsiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZVxuX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2luZGV4LmpzXCIpO1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgdXNlZCAnZXhwb3J0cycgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuIl0sInNvdXJjZVJvb3QiOiIifQ==